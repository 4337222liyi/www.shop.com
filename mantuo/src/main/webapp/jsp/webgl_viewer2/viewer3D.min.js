
var IS_CONCAT_BUILD = !0
  , BUILD_LMV_WORKER_URL = "lmvworker.min.js"
  , LMV_WORKER_URL = BUILD_LMV_WORKER_URL
  , ENABLE_DEBUG = !1
  , ENABLE_TRACE = !1
  , ENABLE_INLINE_WORKER = !0
  , TeratekNamespace = function(f) {
    var h = "undefined" !== typeof window && null  !== window ? window : self;
    f = f.split(".");
    for (var g = 0; g < f.length; ++g)
        h[f[g]] = h[f[g]] || {},
        h = h[f[g]];
    return h
}
;
TeratekNamespace("Teratek.Viewing.Private");
TeratekNamespace("Teratek.Viewing.Extensions");
TeratekNamespace("Teratek.Viewing.Shaders");
TeratekNamespace("Teratek.Viewing.UI");
var _isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
"undefined" !== typeof window && _isIE11 && function() {
    function f(f, g) {
        g = g || {
            bubbles: !1,
            cancelable: !1,
            detail: void 0
        };
        var d = document.createEvent("CustomEvent");
        d.initCustomEvent(f, g.bubbles, g.cancelable, g.detail);
        return d
    }
    f.prototype = window.CustomEvent.prototype;
    window.CustomEvent = f
}
();
ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function(f, h) {
    !h || h > this.byteLength ? h = this.byteLength : 0 > h && (h = this.byteLength + h,
    0 > h && (h = 0));
    0 > f && (f = this.byteLength + f,
    0 > f && (f = 0));
    if (h <= f)
        return new ArrayBuffer;
    for (var g = h - f, d = new Uint8Array(this,f,g), c = new Uint8Array(g), a = 0; a < g; a++)
        c[a] = d[a];
    return c.buffer
}
);
"undefined" !== typeof window && (window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder);
function launchFullscreen(f, h) {
    f.requestFullscreen ? f.requestFullscreen(h) : f.mozRequestFullScreen ? f.mozRequestFullScreen(h) : f.webkitRequestFullscreen ? f.webkitRequestFullscreen(h) : f.msRequestFullscreen && f.msRequestFullscreen(h)
}
function exitFullscreen() {
    document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen()
}
function inFullscreen() {
    return document.fullscreenEnabled || document.mozFullScreenElement || document.webkitIsFullScreen || document.msFullscreenElement ? !0 : !1
}
function fullscreenElement() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement
}
function isFullscreenAvailable(f) {
    return f.requestFullscreen || f.mozRequestFullScreen || f.webkitRequestFullscreen || f.msRequestFullscreen
}
function getAndroidVersion(f) {
    f = f || navigator.userAgent;
    return (f = f.match(/Android\s([0-9\.]*)/)) ? f[1] : !1
}
function isTouchDevice() {
    return "ontouchstart" in window
}
function isIOSDevice() {
    return /ip(ad|hone|od)/.test(navigator.userAgent.toLowerCase())
}
function isAndroidDevice() {
    return -1 !== navigator.userAgent.toLowerCase().indexOf("android")
}
function isMobileDevice() {
    return isIOSDevice() || isAndroidDevice()
}
function detectWebGL() {
    if (window.WebGLRenderingContext) {
        for (var f = document.createElement("canvas"), h = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"], g = !1, d = 0; 4 > d; d++)
            try {
                if ((g = f.getContext(h[d])) && "function" === typeof g.getParameter)
                    return 1
            } catch (c) {}
        return 0
    }
    return -1
}
function touchStartToClick(f) {
    f.preventDefault();
    f.stopPropagation();
    f.target.click()
}
(function() {
    var f = "undefined" !== typeof window && null  !== window ? window : self;
    f.performance || (f.performance = Date)
}
)();
"undefined" !== typeof window && !function(f, h, g, d) {
    function c(a, b, c) {
        return setTimeout(m(a, c), b)
    }
    function a(a, c, d) {
        return Array.isArray(a) ? (b(a, d[c], d),
        !0) : !1
    }
    function b(a, b, c) {
        var f;
        if (a)
            if (a.forEach)
                a.forEach(b, c);
            else if (a.length !== d)
                for (f = 0; f < a.length; )
                    b.call(c, a[f], f, a),
                    f++;
            else
                for (f in a)
                    a.hasOwnProperty(f) && b.call(c, a[f], f, a)
    }
    function k(a, b, c) {
        for (var f = Object.keys(b), g = 0; g < f.length; )
            (!c || c && a[f[g]] === d) && (a[f[g]] = b[f[g]]),
            g++;
        return a
    }
    function l(a, b) {
        return k(a, b, !0)
    }
    function n(a, b, c) {
        var d = 
        b.prototype;
        b = a.prototype = Object.create(d);
        b.constructor = a;
        b._super = d;
        c && k(b, c)
    }
    function m(a, b) {
        return function() {
            return a.apply(b, arguments)
        }
    }
    function q(a, b) {
        return typeof a == ja ? a.apply(b ? b[0] || d : d, b) : a
    }
    function r(a, c, d) {
        b(C(c), function(b) {
            a.addEventListener(b, d, !1)
        }
        )
    }
    function t(a, c, d) {
        b(C(c), function(b) {
            a.removeEventListener(b, d, !1)
        }
        )
    }
    function w(a, b) {
        for (; a; ) {
            if (a == b)
                return !0;
            a = a.parentNode
        }
        return !1
    }
    function C(a) {
        return a.trim().split(/\s+/g)
    }
    function E(a, b, c) {
        if (a.indexOf && !c)
            return a.indexOf(b);
        for (var d = 0; d < a.length; ) {
            if (c && a[d][c] == b || !c && a[d] === b)
                return d;
            d++
        }
        return -1
    }
    function G(a) {
        return Array.prototype.slice.call(a, 0)
    }
    function B(a, b, c) {
        for (var d = [], f = [], g = 0; g < a.length; ) {
            var k = b ? a[g][b] : a[g];
            0 > E(f, k) && d.push(a[g]);
            f[g] = k;
            g++
        }
        return c && (d = b ? d.sort(function(a, c) {
            return a[b] > c[b]
        }
        ) : d.sort()),
        d
    }
    function v(a, b) {
        for (var c, f, g = b[0].toUpperCase() + b.slice(1), k = 0; k < xa.length; ) {
            if (c = xa[k],
            f = c ? c + g : b,
            f in a)
                return f;
            k++
        }
        return d
    }
    function D(a) {
        a = a.ownerDocument;
        return a.defaultView || a.parentWindow
    }
    function z(a, b) {
        var c = this;
        this.manager = a;
        this.callback = b;
        this.element = a.element;
        this.target = a.options.inputTarget;
        this.domHandler = function(b) {
            q(a.options.enable, [a]) && c.handler(b)
        }
        ;
        this.init()
    }
    function H(a) {
        var b = a.options.inputClass;
        return new (b ? b : Ma ? S : Ea ? P : Na ? Z : M)(a,I)
    }
    function I(a, b, c) {
        var f = c.pointers.length
          , g = c.changedPointers.length
          , k = b & la && 0 === f - g
          , f = b & (oa | pa) && 0 === f - g;
        c.isFirst = !!k;
        c.isFinal = !!f;
        k && (a.session = {});
        c.eventType = b;
        b = a.session;
        k = c.pointers;
        f = k.length;
        b.firstInput || (b.firstInput = 
        J(c));
        1 < f && !b.firstMultiple ? b.firstMultiple = J(c) : 1 === f && (b.firstMultiple = !1);
        var g = b.firstInput
          , h = (f = b.firstMultiple) ? f.center : g.center
          , l = c.center = L(k);
        c.timeStamp = qa();
        c.deltaTime = c.timeStamp - g.timeStamp;
        c.angle = K(h, l);
        c.distance = N(h, l);
        var g = c.center
          , h = b.offsetDelta || {}
          , l = b.prevDelta || {}
          , n = b.prevInput || {};
        (c.eventType === la || n.eventType === oa) && (l = b.prevDelta = {
            x: n.deltaX || 0,
            y: n.deltaY || 0
        },
        h = b.offsetDelta = {
            x: g.x,
            y: g.y
        });
        c.deltaX = l.x + (g.x - h.x);
        c.deltaY = l.y + (g.y - h.y);
        c.offsetDirection = F(c.deltaX, c.deltaY);
        f ? (g = f.pointers,
        g = N(k[0], k[1], Ka) / N(g[0], g[1], Ka)) : g = 1;
        c.scale = g;
        f ? (f = f.pointers,
        k = K(k[1], k[0], Ka) - K(f[1], f[0], Ka)) : k = 0;
        c.rotation = k;
        l = b.lastInterval || c;
        k = c.timeStamp - l.timeStamp;
        c.eventType != pa && (k > ya || l.velocity === d) ? (g = l.deltaX - c.deltaX,
        l = l.deltaY - c.deltaY,
        h = {
            x: g / k || 0,
            y: l / k || 0
        },
        k = h.x,
        f = h.y,
        h = ha(h.x) > ha(h.y) ? h.x : h.y,
        g = F(g, l),
        b.lastInterval = c) : (h = l.velocity,
        k = l.velocityX,
        f = l.velocityY,
        g = l.direction);
        c.velocity = h;
        c.velocityX = k;
        c.velocityY = f;
        c.direction = g;
        b = a.element;
        w(c.srcEvent.target, b) && (b = c.srcEvent.target);
        c.target = b;
        a.emit("hammer.input", c);
        a.recognize(c);
        a.session.prevInput = c
    }
    function J(a) {
        for (var b = [], c = 0; c < a.pointers.length; )
            b[c] = {
                clientX: za(a.pointers[c].clientX),
                clientY: za(a.pointers[c].clientY)
            },
            c++;
        return {
            timeStamp: qa(),
            pointers: b,
            center: L(b),
            deltaX: a.deltaX,
            deltaY: a.deltaY
        }
    }
    function L(a) {
        var b = a.length;
        if (1 === b)
            return {
                x: za(a[0].clientX),
                y: za(a[0].clientY)
            };
        for (var c = 0, d = 0, f = 0; b > f; )
            c += a[f].clientX,
            d += a[f].clientY,
            f++;
        return {
            x: za(c / b),
            y: za(d / b)
        }
    }
    function F(a, b) {
        return a === b ? Fa : ha(a) >= ha(b) ? 0 < 
        a ? sa : va : 0 < b ? Oa : Pa
    }
    function N(a, b, c) {
        c || (c = Sa);
        var d = b[c[0]] - a[c[0]];
        a = b[c[1]] - a[c[1]];
        return Math.sqrt(d * d + a * a)
    }
    function K(a, b, c) {
        c || (c = Sa);
        return 180 * Math.atan2(b[c[1]] - a[c[1]], b[c[0]] - a[c[0]]) / Math.PI
    }
    function M() {
        this.evEl = tb;
        this.evWin = Aa;
        this.allow = !0;
        this.pressed = !1;
        z.apply(this, arguments)
    }
    function S() {
        this.evEl = db;
        this.evWin = Xa;
        z.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = []
    }
    function ba() {
        this.evTarget = ub;
        this.evWin = eb;
        this.started = !1;
        z.apply(this, arguments)
    }
    function P() {
        this.evTarget = 
        ab;
        this.targetIds = {};
        z.apply(this, arguments)
    }
    function aa(a, b) {
        var c = G(a.touches)
          , d = this.targetIds;
        if (b & (la | ta) && 1 === c.length)
            return d[c[0].identifier] = !0,
            [c, c];
        var f, g = G(a.changedTouches), k = [], h = this.target;
        if (f = c.filter(function(a) {
            return w(a.target, h)
        }
        ),
        b === la)
            for (c = 0; c < f.length; )
                d[f[c].identifier] = !0,
                c++;
        for (c = 0; c < g.length; )
            d[g[c].identifier] && k.push(g[c]),
            b & (oa | pa) && delete d[g[c].identifier],
            c++;
        return k.length ? [B(f.concat(k), "identifier", !0), k] : void 0
    }
    function Z() {
        z.apply(this, arguments);
        var a = 
        m(this.handler, this);
        this.touch = new P(this.manager,a);
        this.mouse = new M(this.manager,a)
    }
    function V(a, b) {
        this.manager = a;
        this.set(b)
    }
    function ea(a) {
        if (-1 < a.indexOf(Va))
            return Va;
        var b = -1 < a.indexOf(Ta)
          , c = -1 < a.indexOf(Qa);
        return b && c ? Ta + " " + Qa : b || c ? b ? Ta : Qa : -1 < a.indexOf(bb) ? bb : Ya
    }
    function X(a) {
        this.id = La++;
        this.manager = null ;
        this.options = l(a || {}, this.defaults);
        a = this.options.enable;
        this.options.enable = a === d ? !0 : a;
        this.state = Za;
        this.simultaneous = {};
        this.requireFail = []
    }
    function R(a) {
        return a == Pa ? "down" : a == 
        Oa ? "up" : a == sa ? "left" : a == va ? "right" : ""
    }
    function T(a, b) {
        var c = b.manager;
        return c ? c.get(a) : a
    }
    function O() {
        X.apply(this, arguments)
    }
    function ca() {
        O.apply(this, arguments);
        this.pY = this.pX = null 
    }
    function ia() {
        O.apply(this, arguments)
    }
    function fa() {
        X.apply(this, arguments);
        this._input = this._timer = null 
    }
    function W() {
        O.apply(this, arguments)
    }
    function ga() {
        O.apply(this, arguments)
    }
    function da() {
        X.apply(this, arguments);
        this.pCenter = this.pTime = !1;
        this._input = this._timer = null ;
        this.count = 0
    }
    function na(a, b) {
        b = b || {};
        var c = 
        b.recognizers;
        return b.recognizers = c === d ? na.defaults.preset : c,
        new Y(a,b)
    }
    function Y(a, c) {
        c = c || {};
        this.options = l(c, na.defaults);
        this.options.inputTarget = this.options.inputTarget || a;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = a;
        this.input = H(this);
        this.touchAction = new V(this,this.options.touchAction);
        Ia(this, !0);
        b(c.recognizers, function(a) {
            var b = this.add(new a[0](a[1]));
            a[2] && b.recognizeWith(a[2]);
            a[3] && b.requireFailure(a[3])
        }
        , this)
    }
    function Ia(a, c) {
        var d = a.element;
        b(a.options.cssProps, 
        function(a, b) {
            d.style[v(d.style, b)] = c ? a : ""
        }
        )
    }
    function Ha(a, b) {
        var c = h.createEvent("Event");
        c.initEvent(a, !0, !0);
        c.gesture = b;
        b.target.dispatchEvent(c)
    }
    var xa = " webkit moz MS ms o".split(" ")
      , ka = h.createElement("div")
      , ja = "function"
      , za = Math.round
      , ha = Math.abs
      , qa = Date.now
      , La = 1
      , Ja = /mobile|tablet|ip(ad|hone|od)|android/i
      , Na = "ontouchstart" in f
      , Ma = v(f, "PointerEvent") !== d
      , Ea = Na && Ja.test(navigator.userAgent)
      , ya = 25
      , la = 1
      , ta = 2
      , oa = 4
      , pa = 8
      , Fa = 1
      , sa = 2
      , va = 4
      , Oa = 8
      , Pa = 16
      , A = sa | va
      , Da = Oa | Pa
      , Ja = A | Da
      , Sa = ["x", "y"]
      , Ka = ["clientX", 
    "clientY"];
    z.prototype = {
        handler: function() {},
        init: function() {
            this.evEl && r(this.element, this.evEl, this.domHandler);
            this.evTarget && r(this.target, this.evTarget, this.domHandler);
            this.evWin && r(D(this.element), this.evWin, this.domHandler)
        },
        destroy: function() {
            this.evEl && t(this.element, this.evEl, this.domHandler);
            this.evTarget && t(this.target, this.evTarget, this.domHandler);
            this.evWin && t(D(this.element), this.evWin, this.domHandler)
        }
    };
    var $a = {
        mousedown: la,
        mousemove: ta,
        mouseup: oa
    }
      , tb = "mousedown"
      , Aa = "mousemove mouseup";
    n(M, z, {
        handler: function(a) {
            var b = $a[a.type];
            b & la && 0 === a.button && (this.pressed = !0);
            b & ta && 1 !== a.which && (b = oa);
            this.pressed && this.allow && (b & oa && (this.pressed = !1),
            this.callback(this.manager, b, {
                pointers: [a],
                changedPointers: [a],
                pointerType: "mouse",
                srcEvent: a
            }))
        }
    });
    var ma = {
        pointerdown: la,
        pointermove: ta,
        pointerup: oa,
        pointercancel: pa,
        pointerout: pa
    }
      , Wa = {
        2: "touch",
        3: "pen",
        4: "mouse",
        5: "kinect"
    }
      , db = "pointerdown"
      , Xa = "pointermove pointerup pointercancel";
    f.MSPointerEvent && (db = "MSPointerDown",
    Xa = "MSPointerMove MSPointerUp MSPointerCancel");
    n(S, z, {
        handler: function(a) {
            var b = this.store
              , c = !1
              , d = a.type.toLowerCase().replace("ms", "")
              , d = ma[d]
              , f = Wa[a.pointerType] || a.pointerType
              , g = "touch" == f
              , k = E(b, a.pointerId, "pointerId");
            d & la && (0 === a.button || g) ? 0 > k && (b.push(a),
            k = b.length - 1) : d & (oa | pa) && (c = !0);
            0 > k || (b[k] = a,
            this.callback(this.manager, d, {
                pointers: b,
                changedPointers: [a],
                pointerType: f,
                srcEvent: a
            }),
            c && b.splice(k, 1))
        }
    });
    var fb = {
        touchstart: la,
        touchmove: ta,
        touchend: oa,
        touchcancel: pa
    }
      , ub = "touchstart"
      , eb = "touchstart touchmove touchend touchcancel";
    n(ba, 
    z, {
        handler: function(a) {
            var b = fb[a.type];
            if (b === la && (this.started = !0),
            this.started) {
                var c, d = G(a.touches);
                c = G(a.changedTouches);
                c = (b & (oa | pa) && (d = B(d.concat(c), "identifier", !0)),
                [d, c]);
                b & (oa | pa) && 0 === c[0].length - c[1].length && (this.started = !1);
                this.callback(this.manager, b, {
                    pointers: c[0],
                    changedPointers: c[1],
                    pointerType: "touch",
                    srcEvent: a
                })
            }
        }
    });
    var kb = {
        touchstart: la,
        touchmove: ta,
        touchend: oa,
        touchcancel: pa
    }
      , ab = "touchstart touchmove touchend touchcancel";
    n(P, z, {
        handler: function(a) {
            var b = kb[a.type]
              , c = aa.call(this, 
            a, b);
            c && this.callback(this.manager, b, {
                pointers: c[0],
                changedPointers: c[1],
                pointerType: "touch",
                srcEvent: a
            })
        }
    });
    n(Z, z, {
        handler: function(a, b, c) {
            var d = "mouse" == c.pointerType;
            if ("touch" == c.pointerType)
                this.mouse.allow = !1;
            else if (d && !this.mouse.allow)
                return;
            b & (oa | pa) && (this.mouse.allow = !0);
            this.callback(a, b, c)
        },
        destroy: function() {
            this.touch.destroy();
            this.mouse.destroy()
        }
    });
    var gb = v(ka.style, "touchAction")
      , hb = gb !== d
      , Ya = "auto"
      , bb = "manipulation"
      , Va = "none"
      , Ta = "pan-x"
      , Qa = "pan-y";
    V.prototype = {
        set: function(a) {
            "compute" == 
            a && (a = this.compute());
            hb && (this.manager.element.style[gb] = a);
            this.actions = a.toLowerCase().trim()
        },
        update: function() {
            this.set(this.manager.options.touchAction)
        },
        compute: function() {
            var a = [];
            return b(this.manager.recognizers, function(b) {
                q(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()))
            }
            ),
            ea(a.join(" "))
        },
        preventDefaults: function(a) {
            if (!hb) {
                var b = a.srcEvent;
                a = a.offsetDirection;
                if (this.manager.session.prevented)
                    return void b.preventDefault();
                var c = this.actions
                  , d = -1 < c.indexOf(Va)
                  , f = -1 < c.indexOf(Qa)
                  , 
                c = -1 < c.indexOf(Ta);
                return d || f && a & A || c && a & Da ? this.preventSrc(b) : void 0
            }
        },
        preventSrc: function(a) {
            this.manager.session.prevented = !0;
            a.preventDefault()
        }
    };
    var Za = 1;
    X.prototype = {
        defaults: {},
        set: function(a) {
            return k(this.options, a),
            this.manager && this.manager.touchAction.update(),
            this
        },
        recognizeWith: function(b) {
            if (a(b, "recognizeWith", this))
                return this;
            var c = this.simultaneous;
            return b = T(b, this),
            c[b.id] || (c[b.id] = b,
            b.recognizeWith(this)),
            this
        },
        dropRecognizeWith: function(b) {
            return a(b, "dropRecognizeWith", this) ? 
            this : (b = T(b, this),
            delete this.simultaneous[b.id],
            this)
        },
        requireFailure: function(b) {
            if (a(b, "requireFailure", this))
                return this;
            var c = this.requireFail;
            return b = T(b, this),
            -1 === E(c, b) && (c.push(b),
            b.requireFailure(this)),
            this
        },
        dropRequireFailure: function(b) {
            if (a(b, "dropRequireFailure", this))
                return this;
            b = T(b, this);
            b = E(this.requireFail, b);
            return -1 < b && this.requireFail.splice(b, 1),
            this
        },
        hasRequireFailures: function() {
            return 0 < this.requireFail.length
        },
        canRecognizeWith: function(a) {
            return !!this.simultaneous[a.id]
        },
        emit: function(a) {
            function b(f) {
                c.manager.emit(c.options.event + (f ? d & 16 ? "cancel" : d & 8 ? "end" : d & 4 ? "move" : d & 2 ? "start" : "" : ""), a)
            }
            var c = this
              , d = this.state;
            8 > d && b(!0);
            b();
            8 <= d && b(!0)
        },
        tryEmit: function(a) {
            return this.canEmit() ? this.emit(a) : void (this.state = 32)
        },
        canEmit: function() {
            for (var a = 0; a < this.requireFail.length; ) {
                if (!(this.requireFail[a].state & (32 | Za)))
                    return !1;
                a++
            }
            return !0
        },
        recognize: function(a) {
            a = k({}, a);
            return q(this.options.enable, [this, a]) ? (this.state & 56 && (this.state = Za),
            this.state = this.process(a),
            void (this.state & 30 && this.tryEmit(a))) : (this.reset(),
            void (this.state = 32))
        },
        process: function() {},
        getTouchAction: function() {},
        reset: function() {}
    };
    n(O, X, {
        defaults: {
            pointers: 1
        },
        attrTest: function(a) {
            var b = this.options.pointers;
            return 0 === b || a.pointers.length === b
        },
        process: function(a) {
            var b = this.state
              , c = a.eventType
              , d = b & 6;
            a = this.attrTest(a);
            return d && (c & pa || !a) ? b | 16 : d || a ? c & oa ? b | 8 : b & 2 ? b | 4 : 2 : 32
        }
    });
    n(ca, O, {
        defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: Ja
        },
        getTouchAction: function() {
            var a = this.options.direction
              , 
            b = [];
            return a & A && b.push(Qa),
            a & Da && b.push(Ta),
            b
        },
        directionTest: function(a) {
            var b = this.options
              , c = !0
              , d = a.distance
              , f = a.direction
              , g = a.deltaX
              , k = a.deltaY;
            return f & b.direction || (b.direction & A ? (f = 0 === g ? Fa : 0 > g ? sa : va,
            c = g != this.pX,
            d = Math.abs(a.deltaX)) : (f = 0 === k ? Fa : 0 > k ? Oa : Pa,
            c = k != this.pY,
            d = Math.abs(a.deltaY))),
            a.direction = f,
            c && d > b.threshold && f & b.direction
        },
        attrTest: function(a) {
            return O.prototype.attrTest.call(this, a) && (this.state & 2 || !(this.state & 2) && this.directionTest(a))
        },
        emit: function(a) {
            this.pX = a.deltaX;
            this.pY = 
            a.deltaY;
            var b = R(a.direction);
            b && this.manager.emit(this.options.event + b, a);
            this._super.emit.call(this, a)
        }
    });
    n(ia, O, {
        defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [Va]
        },
        attrTest: function(a) {
            return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & 2)
        },
        emit: function(a) {
            (this._super.emit.call(this, a),
            1 !== a.scale) && this.manager.emit(this.options.event + (1 > a.scale ? "in" : "out"), a)
        }
    });
    n(fa, X, {
        defaults: {
            event: "press",
            pointers: 1,
            time: 500,
            threshold: 5
        },
        getTouchAction: function() {
            return [Ya]
        },
        process: function(a) {
            var b = this.options
              , d = a.pointers.length === b.pointers
              , f = a.distance < b.threshold
              , g = a.deltaTime > b.time;
            if (this._input = a,
            !f || !d || a.eventType & (oa | pa) && !g)
                this.reset();
            else if (a.eventType & la)
                this.reset(),
                this._timer = c(function() {
                    this.state = 8;
                    this.tryEmit()
                }
                , b.time, this);
            else if (a.eventType & oa)
                return 8;
            return 32
        },
        reset: function() {
            clearTimeout(this._timer)
        },
        emit: function(a) {
            8 === this.state && (a && a.eventType & oa ? this.manager.emit(this.options.event + 
            "up", a) : (this._input.timeStamp = qa(),
            this.manager.emit(this.options.event, this._input)))
        }
    });
    n(W, O, {
        defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [Va]
        },
        attrTest: function(a) {
            return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & 2)
        }
    });
    n(ga, O, {
        defaults: {
            event: "swipe",
            threshold: 10,
            velocity: .65,
            direction: A | Da,
            pointers: 1
        },
        getTouchAction: function() {
            return ca.prototype.getTouchAction.call(this)
        },
        attrTest: function(a) {
            var b, c = this.options.direction;
            return c & (A | Da) ? b = a.velocity : c & A ? b = a.velocityX : c & Da && (b = a.velocityY),
            this._super.attrTest.call(this, a) && c & a.direction && a.distance > this.options.threshold && ha(b) > this.options.velocity && a.eventType & oa
        },
        emit: function(a) {
            var b = R(a.direction);
            b && this.manager.emit(this.options.event + b, a);
            this.manager.emit(this.options.event, a)
        }
    });
    n(da, X, {
        defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 2,
            posThreshold: 10
        },
        getTouchAction: function() {
            return [bb]
        },
        process: function(a) {
            var b = this.options
              , 
            d = a.pointers.length === b.pointers
              , f = a.distance < b.threshold
              , g = a.deltaTime < b.time;
            if (this.reset(),
            a.eventType & la && 0 === this.count)
                return this.failTimeout();
            if (f && g && d) {
                if (a.eventType != oa)
                    return this.failTimeout();
                d = this.pTime ? a.timeStamp - this.pTime < b.interval : !0;
                f = !this.pCenter || N(this.pCenter, a.center) < b.posThreshold;
                this.pTime = a.timeStamp;
                this.pCenter = a.center;
                f && d ? this.count += 1 : this.count = 1;
                this._input = a;
                if (0 === this.count % b.taps)
                    return this.hasRequireFailures() ? (this._timer = c(function() {
                        this.state = 
                        8;
                        this.tryEmit()
                    }
                    , b.interval, this),
                    2) : 8
            }
            return 32
        },
        failTimeout: function() {
            return this._timer = c(function() {
                this.state = 32
            }
            , this.options.interval, this),
            32
        },
        reset: function() {
            clearTimeout(this._timer)
        },
        emit: function() {
            8 == this.state && (this._input.tapCount = this.count,
            this.manager.emit(this.options.event, this._input))
        }
    });
    na.VERSION = "2.0.4";
    na.defaults = {
        domEvents: !1,
        touchAction: "compute",
        enable: !0,
        inputTarget: null ,
        inputClass: null ,
        preset: [[W, {
            enable: !1
        }], [ia, {
            enable: !1
        }, ["rotate"]], [ga, {
            direction: A
        }], [ca, {
            direction: A
        }, 
        ["swipe"]], [da], [da, {
            event: "doubletap",
            taps: 2
        }, ["tap"]], [fa]],
        cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    Y.prototype = {
        set: function(a) {
            return k(this.options, a),
            a.touchAction && this.touchAction.update(),
            a.inputTarget && (this.input.destroy(),
            this.input.target = a.inputTarget,
            this.input.init()),
            this
        },
        stop: function(a) {
            this.session.stopped = a ? 2 : 1
        },
        recognize: function(a) {
            var b = this.session;
            if (!b.stopped) {
                this.touchAction.preventDefaults(a);
                var c, d = this.recognizers, f = b.curRecognizer;
                (!f || f && f.state & 8) && (f = b.curRecognizer = null );
                for (var g = 0; g < d.length; )
                    c = d[g],
                    2 === b.stopped || f && c != f && !c.canRecognizeWith(f) ? c.reset() : c.recognize(a),
                    !f && c.state & 14 && (f = b.curRecognizer = c),
                    g++
            }
        },
        get: function(a) {
            if (a instanceof X)
                return a;
            for (var b = this.recognizers, c = 0; c < b.length; c++)
                if (b[c].options.event == a)
                    return b[c];
            return null 
        },
        add: function(b) {
            if (a(b, "add", this))
                return this;
            var c = this.get(b.options.event);
            return c && this.remove(c),
            this.recognizers.push(b),
            b.manager = this,
            this.touchAction.update(),
            b
        },
        remove: function(b) {
            if (a(b, "remove", this))
                return this;
            var c = this.recognizers;
            return b = this.get(b),
            c.splice(E(c, b), 1),
            this.touchAction.update(),
            this
        },
        on: function(a, c) {
            var d = this.handlers;
            return b(C(a), function(a) {
                d[a] = d[a] || [];
                d[a].push(c)
            }
            ),
            this
        },
        off: function(a, c) {
            var d = this.handlers;
            return b(C(a), function(a) {
                c ? d[a].splice(E(d[a], c), 1) : delete d[a]
            }
            ),
            this
        },
        emit: function(a, b) {
            this.options.domEvents && Ha(a, b);
            var c = this.handlers[a] && this.handlers[a].slice();
            if (c && c.length) {
                b.type = a;
                b.preventDefault = function() {
                    b.srcEvent.preventDefault()
                }
                ;
                for (var d = 0; d < c.length; )
                    c[d](b),
                    d++
            }
        },
        destroy: function() {
            this.element && Ia(this, !1);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null 
        }
    };
    k(na, {
        INPUT_START: la,
        INPUT_MOVE: ta,
        INPUT_END: oa,
        INPUT_CANCEL: pa,
        STATE_POSSIBLE: Za,
        STATE_BEGAN: 2,
        STATE_CHANGED: 4,
        STATE_ENDED: 8,
        STATE_RECOGNIZED: 8,
        STATE_CANCELLED: 16,
        STATE_FAILED: 32,
        DIRECTION_NONE: Fa,
        DIRECTION_LEFT: sa,
        DIRECTION_RIGHT: va,
        DIRECTION_UP: Oa,
        DIRECTION_DOWN: Pa,
        DIRECTION_HORIZONTAL: A,
        DIRECTION_VERTICAL: Da,
        DIRECTION_ALL: Ja,
        Manager: Y,
        Input: z,
        TouchAction: V,
        TouchInput: P,
        MouseInput: M,
        PointerEventInput: S,
        TouchMouseInput: Z,
        SingleTouchInput: ba,
        Recognizer: X,
        AttrRecognizer: O,
        Tap: da,
        Pan: ca,
        Swipe: ga,
        Pinch: ia,
        Rotate: W,
        Press: fa,
        on: r,
        off: t,
        each: b,
        merge: l,
        extend: k,
        inherit: n,
        bindFn: m,
        prefixed: v
    });
    f[g] = na
}
(window, document, "Hammer");
function init_three_dds_loader() {
    THREE.DDSLoader = function() {
        this._parser = THREE.DDSLoader.parse
    }
    ;
    THREE.DDSLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);
    THREE.DDSLoader.prototype.constructor = THREE.DDSLoader;
    THREE.DDSLoader.parse = function(f, h) {
        function g(a) {
            return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24)
        }
        function d(a, b, c, d) {
            var f = c * d * 4;
            a = new Uint8Array(a,b,f);
            for (var f = new Uint8Array(f), g = b = 0, k = 0; k < d; k++)
                for (var h = 0; h < c; h++) {
                    var l = a[g];
                    g++;
                    var n = a[g];
                    g++;
                    var m = a[g];
                    g++;
                    var q = a[g];
                    g++;
                    f[b] = m;
                    b++;
                    f[b] = n;
                    b++;
                    f[b] = l;
                    b++;
                    f[b] = q;
                    b++
                }
            return f
        }
        var c = {
            mipmaps: [],
            width: 0,
            height: 0,
            format: null ,
            mipmapCount: 1
        }
          , a = g("DXT1")
          , b = g("DXT3")
          , k = g("DXT5")
          , l = new Int32Array(f,0,31);
        if (542327876 !== l[0])
            return console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header."),
            c;
        if (!l[20] & 4)
            return console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code."),
            c;
        var n = l[21]
          , m = !1;
        switch (n) {
        case a:
            a = 8;
            c.format = THREE.RGB_S3TC_DXT1_Format;
            break;
        case b:
            a = 16;
            c.format = THREE.RGBA_S3TC_DXT3_Format;
            break;
        case k:
            a = 16;
            c.format = THREE.RGBA_S3TC_DXT5_Format;
            break;
        default:
            if (32 == l[22] && l[23] & 16711680 && l[24] & 65280 && l[25] & 255 && l[26] & 4278190080)
                m = !0,
                a = 64,
                c.format = THREE.RGBAFormat;
            else
                return console.error("THREE.DDSLoader.parse: Unsupported FourCC code ", String.fromCharCode(n & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255)),
                c
        }
        c.mipmapCount = 1;
        l[2] & 131072 && !1 !== h && (c.mipmapCount = Math.max(1, l[7]));
        c.isCubemap = l[28] & 512 ? !0 : !1;
        c.width = l[4];
        c.height = l[3];
        for (var l = 
        l[1] + 4, b = c.width, k = c.height, n = c.isCubemap ? 6 : 1, q = 0; q < n; q++) {
            for (var r = 0; r < c.mipmapCount; r++) {
                if (m)
                    var t = d(f, l, b, k)
                      , w = t.length;
                else
                    w = Math.max(4, b) / 4 * Math.max(4, k) / 4 * a,
                    t = new Uint8Array(f,l,w);
                c.mipmaps.push({
                    data: t,
                    width: b,
                    height: k
                });
                l += w;
                b = Math.max(.5 * b, 1);
                k = Math.max(.5 * k, 1)
            }
            b = c.width;
            k = c.height
        }
        return c
    }
}
!function(f) {
    var h;
    "undefined" != typeof window ? h = window : "undefined" != typeof global ? h = global : "undefined" != typeof self && (h = self);
    h.lmv_poly2tri = f()
}
(function() {
    return function h(g, d, c) {
        function a(k, n) {
            if (!d[k]) {
                if (!g[k]) {
                    var m = "function" == typeof require && require;
                    if (!n && m)
                        return m(k, !0);
                    if (b)
                        return b(k, !0);
                    throw Error("Cannot find module '" + k + "'");
                }
                m = d[k] = {
                    exports: {}
                };
                g[k][0].call(m.exports, function(b) {
                    var c = g[k][1][b];
                    return a(c ? c : b)
                }
                , m, m.exports, h, g, d, c)
            }
            return d[k].exports
        }
        for (var b = "function" == typeof require && 
        require, k = 0; k < c.length; k++)
            a(c[k]);
        return a
    }
    ({
        1: [function(h, g, d) {
            g.exports = {
                version: "1.3.5"
            }
        }
        , {}],
        2: [function(h, g, d) {
            h = function(c, a) {
                this.head_ = c;
                this.tail_ = a;
                this.search_node_ = c
            }
            ;
            h.prototype.head = function() {
                return this.head_
            }
            ;
            h.prototype.setHead = function(c) {
                this.head_ = c
            }
            ;
            h.prototype.tail = function() {
                return this.tail_
            }
            ;
            h.prototype.setTail = function(c) {
                this.tail_ = c
            }
            ;
            h.prototype.search = function() {
                return this.search_node_
            }
            ;
            h.prototype.setSearch = function(c) {
                this.search_node_ = c
            }
            ;
            h.prototype.findSearchNode = 
            function() {
                return this.search_node_
            }
            ;
            h.prototype.locateNode = function(c) {
                var a = this.search_node_;
                if (c < a.value)
                    for (; a = a.prev; ) {
                        if (c >= a.value)
                            return this.search_node_ = a
                    }
                else
                    for (; a = a.next; )
                        if (c < a.value)
                            return this.search_node_ = a.prev;
                return null 
            }
            ;
            h.prototype.locatePoint = function(c) {
                var a = c.x
                  , b = this.findSearchNode(a)
                  , d = b.point.x;
                if (a === d) {
                    if (c !== b.point)
                        if (c === b.prev.point)
                            b = b.prev;
                        else if (c === b.next.point)
                            b = b.next;
                        else
                            throw Error("poly2tri Invalid AdvancingFront.locatePoint() call");
                } else if (a < d)
                    for (; (b = 
                    b.prev) && c !== b.point; )
                        ;
                else
                    for (; (b = b.next) && c !== b.point; )
                        ;
                b && (this.search_node_ = b);
                return b
            }
            ;
            g.exports = h;
            g.exports.Node = function(c, a) {
                this.point = c;
                this.triangle = a || null ;
                this.prev = this.next = null ;
                this.value = c.x
            }
        }
        , {}],
        3: [function(h, g, d) {
            g.exports = function(c, a) {
                if (!c)
                    throw Error(a || "Assert Failed");
            }
        }
        , {}],
        4: [function(h, g, d) {
            var c = h("./xy")
              , a = function(a, c) {
                this.x = +a || 0;
                this.y = +c || 0;
                this._p2t_edge_list = null 
            }
            ;
            a.prototype.toString = function() {
                return c.toStringBase(this)
            }
            ;
            a.prototype.toJSON = function() {
                return {
                    x: this.x,
                    y: this.y
                }
            }
            ;
            a.prototype.clone = function() {
                return new a(this.x,this.y)
            }
            ;
            a.prototype.set_zero = function() {
                this.y = this.x = 0;
                return this
            }
            ;
            a.prototype.set = function(a, c) {
                this.x = +a || 0;
                this.y = +c || 0;
                return this
            }
            ;
            a.prototype.negate = function() {
                this.x = -this.x;
                this.y = -this.y;
                return this
            }
            ;
            a.prototype.add = function(a) {
                this.x += a.x;
                this.y += a.y;
                return this
            }
            ;
            a.prototype.sub = function(a) {
                this.x -= a.x;
                this.y -= a.y;
                return this
            }
            ;
            a.prototype.mul = function(a) {
                this.x *= a;
                this.y *= a;
                return this
            }
            ;
            a.prototype.length = function() {
                return Math.sqrt(this.x * 
                this.x + this.y * this.y)
            }
            ;
            a.prototype.normalize = function() {
                var a = this.length();
                this.x /= a;
                this.y /= a;
                return a
            }
            ;
            a.prototype.equals = function(a) {
                return this.x === a.x && this.y === a.y
            }
            ;
            a.negate = function(b) {
                return new a(-b.x,-b.y)
            }
            ;
            a.add = function(b, c) {
                return new a(b.x + c.x,b.y + c.y)
            }
            ;
            a.sub = function(b, c) {
                return new a(b.x - c.x,b.y - c.y)
            }
            ;
            a.mul = function(b, c) {
                return new a(b * c.x,b * c.y)
            }
            ;
            a.cross = function(b, c) {
                return "number" === typeof b ? "number" === typeof c ? b * c : new a(-b * c.y,b * c.x) : "number" === typeof c ? new a(c * b.y,-c * b.x) : b.x * 
                c.y - b.y * c.x
            }
            ;
            a.toString = c.toString;
            a.compare = c.compare;
            a.cmp = c.compare;
            a.equals = c.equals;
            a.dot = function(a, c) {
                return a.x * c.x + a.y * c.y
            }
            ;
            g.exports = a
        }
        , {
            "./xy": 11
        }],
        5: [function(h, g, d) {
            var c = h("./xy");
            h = function(a, b) {
                this.name = "PointError";
                this.points = b = b || [];
                this.message = a || "Invalid Points!";
                for (var d = 0; d < b.length; d++)
                    this.message += " " + c.toString(b[d])
            }
            ;
            h.prototype = Error();
            h.prototype.constructor = h;
            g.exports = h
        }
        , {
            "./xy": 11
        }],
        6: [function(h, g, d) {
            (function(c) {
                var a = c.poly2tri;
                d.noConflict = function() {
                    c.poly2tri = 
                    a;
                    return d
                }
                ;
                d.VERSION = h("../dist/version.json").version;
                d.PointError = h("./pointerror");
                d.Point = h("./point");
                d.Triangle = h("./triangle");
                d.SweepContext = h("./sweepcontext");
                var b = h("./sweep");
                d.triangulate = b.triangulate;
                d.sweep = {
                    Triangulate: b.triangulate
                }
            }
            ).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }
        , {
            "../dist/version.json": 1,
            "./point": 4,
            "./pointerror": 5,
            "./sweep": 7,
            "./sweepcontext": 8,
            "./triangle": 9
        }],
        7: [function(h, g, d) {
            function c(b, d, g, k, h) {
                if (!a(k, d, g)) {
                    var l = k.pointCCW(h)
                      , 
                    n = L(g, l, d);
                    if (n === J.COLLINEAR)
                        throw new D("poly2tri EdgeEvent: Collinear not supported!",[g, l, d]);
                    var l = k.pointCW(h)
                      , m = L(g, l, d);
                    if (m === J.COLLINEAR)
                        throw new D("poly2tri EdgeEvent: Collinear not supported!",[g, l, d]);
                    n === m ? (k = n === J.CW ? k.neighborCCW(h) : k.neighborCW(h),
                    c(b, d, g, k, h)) : E(b, d, g, k, h)
                }
            }
            function a(a, b, c) {
                var d = a.edgeIndex(b, c);
                return -1 !== d ? (a.markConstrainedEdgeByIndex(d),
                (a = a.getNeighbor(d)) && a.markConstrainedEdgeByPoints(b, c),
                !0) : !1
            }
            function b(a, b) {
                var c = new z(b.prev.point,b.point,b.next.point);
                c.markNeighbor(b.prev.triangle);
                c.markNeighbor(b.triangle);
                a.addToMap(c);
                b.prev.next = b.next;
                b.next.prev = b.prev;
                k(a, c) || a.mapTriangleToNodes(c)
            }
            function k(a, b) {
                for (var c = 0; 3 > c; ++c)
                    if (!b.delaunay_edge[c]) {
                        var d = b.getNeighbor(c);
                        if (d) {
                            var g = b.getPoint(c)
                              , h = d.oppositePoint(b, g)
                              , n = d.index(h);
                            if (d.constrained_edge[n] || d.delaunay_edge[n])
                                b.constrained_edge[c] = d.constrained_edge[n];
                            else {
                                var m;
                                var q = b.pointCCW(g)
                                  , r = b.pointCW(g);
                                m = g.x - h.x;
                                var B = g.y - h.y
                                  , t = q.x - h.x
                                  , q = q.y - h.y
                                  , z = m * q - t * B;
                                if (0 >= z)
                                    m = !1;
                                else {
                                    var v = 
                                    r.x - h.x
                                      , r = r.y - h.y
                                      , w = v * B - m * r;
                                    m = 0 >= w ? !1 : 0 < (m * m + B * B) * (t * r - v * q) + (t * t + q * q) * w + (v * v + r * r) * z
                                }
                                if (m)
                                    return b.delaunay_edge[c] = !0,
                                    d.delaunay_edge[n] = !0,
                                    l(b, g, d, h),
                                    (g = !k(a, b)) && a.mapTriangleToNodes(b),
                                    (g = !k(a, d)) && a.mapTriangleToNodes(d),
                                    b.delaunay_edge[c] = !1,
                                    d.delaunay_edge[n] = !1,
                                    !0
                            }
                        }
                    }
                return !1
            }
            function l(a, b, c, d) {
                var g, k, h, l;
                g = a.neighborCCW(b);
                k = a.neighborCW(b);
                h = c.neighborCCW(d);
                l = c.neighborCW(d);
                var n, m, q, r;
                n = a.getConstrainedEdgeCCW(b);
                m = a.getConstrainedEdgeCW(b);
                q = c.getConstrainedEdgeCCW(d);
                r = c.getConstrainedEdgeCW(d);
                var B, t, z, v;
                B = a.getDelaunayEdgeCCW(b);
                t = a.getDelaunayEdgeCW(b);
                z = c.getDelaunayEdgeCCW(d);
                v = c.getDelaunayEdgeCW(d);
                a.legalize(b, d);
                c.legalize(d, b);
                c.setDelaunayEdgeCCW(b, B);
                a.setDelaunayEdgeCW(b, t);
                a.setDelaunayEdgeCCW(d, z);
                c.setDelaunayEdgeCW(d, v);
                c.setConstrainedEdgeCCW(b, n);
                a.setConstrainedEdgeCW(b, m);
                a.setConstrainedEdgeCCW(d, q);
                c.setConstrainedEdgeCW(d, r);
                a.clearNeighbors();
                c.clearNeighbors();
                g && c.markNeighbor(g);
                k && a.markNeighbor(k);
                h && a.markNeighbor(h);
                l && c.markNeighbor(l);
                a.markNeighbor(c)
            }
            function n(a, c) {
                var d;
                d = a.basin.width > (a.basin.left_highest ? a.basin.left_node.point.y - c.point.y : a.basin.right_node.point.y - c.point.y) ? !0 : !1;
                if (!d && (b(a, c),
                c.prev !== a.basin.left_node || c.next !== a.basin.right_node)) {
                    if (c.prev === a.basin.left_node) {
                        d = L(c.point, c.next.point, c.next.next.point);
                        if (d === J.CW)
                            return;
                        c = c.next
                    } else if (c.next === a.basin.right_node) {
                        d = L(c.point, c.prev.point, c.prev.prev.point);
                        if (d === J.CCW)
                            return;
                        c = c.prev
                    } else
                        c = c.prev.point.y < c.next.point.y ? c.prev : c.next;
                    n(a, c)
                }
            }
            function m(a, b, c) {
                c.point.x < 
                b.p.x && (L(c.point, c.next.point, c.next.next.point) === J.CCW ? q(a, b, c) : (r(a, b, c),
                m(a, b, c)))
            }
            function q(a, c, d) {
                b(a, d.next);
                d.next.point !== c.p && L(c.q, d.next.point, c.p) === J.CCW && L(d.point, d.next.point, d.next.next.point) === J.CCW && q(a, c, d)
            }
            function r(a, b, c) {
                L(c.next.point, c.next.next.point, c.next.next.next.point) === J.CCW ? q(a, b, c.next) : L(b.q, c.next.next.point, b.p) === J.CCW && r(a, b, c.next)
            }
            function t(a, b, c) {
                c.point.x > b.p.x && (L(c.point, c.prev.point, c.prev.prev.point) === J.CW ? C(a, b, c) : (w(a, b, c),
                t(a, b, c)))
            }
            function w(a, 
            b, c) {
                L(c.prev.point, c.prev.prev.point, c.prev.prev.prev.point) === J.CW ? C(a, b, c.prev) : L(b.q, c.prev.prev.point, b.p) === J.CW && w(a, b, c.prev)
            }
            function C(a, c, d) {
                b(a, d.prev);
                d.prev.point !== c.p && L(c.q, d.prev.point, c.p) === J.CW && L(d.point, d.prev.point, d.prev.prev.point) === J.CW && C(a, c, d)
            }
            function E(a, b, d, g, h) {
                var n = g.neighborAcross(h);
                v(n, "FLIP failed due to missing triangle!");
                var m = n.oppositePoint(g, h);
                if (g.getConstrainedEdgeAcross(h))
                    throw a = g.index(h),
                    new D("poly2tri Intersecting Constraints",[h, m, g.getPoint((a + 
                    1) % 3), g.getPoint((a + 2) % 3)]);
                if (F(h, g.pointCCW(h), g.pointCW(h), m))
                    if (l(g, h, n, m),
                    a.mapTriangleToNodes(g),
                    a.mapTriangleToNodes(n),
                    h === d && m === b)
                        d === a.edge_event.constrained_edge.q && b === a.edge_event.constrained_edge.p && (g.markConstrainedEdgeByPoints(b, d),
                        n.markConstrainedEdgeByPoints(b, d),
                        k(a, g),
                        k(a, n));
                    else {
                        var q = L(d, m, b);
                        q === J.CCW ? (m = n.edgeIndex(h, m),
                        n.delaunay_edge[m] = !0,
                        k(a, n),
                        n.clearDelaunayEdges()) : (m = g.edgeIndex(h, m),
                        g.delaunay_edge[m] = !0,
                        k(a, g),
                        g.clearDelaunayEdges(),
                        g = n);
                        E(a, b, d, g, h)
                    }
                else
                    m = G(b, 
                    d, n, m),
                    B(a, b, d, g, n, m),
                    c(a, b, d, g, h)
            }
            function G(a, b, c, d) {
                var g = L(b, d, a);
                if (g === J.CW)
                    return c.pointCCW(d);
                if (g === J.CCW)
                    return c.pointCW(d);
                throw new D("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!",[b, d, a]);
            }
            function B(a, b, c, d, g, k) {
                var h = g.neighborAcross(k);
                v(h, "FLIP failed due to missing triangle");
                g = h.oppositePoint(g, k);
                F(c, d.pointCCW(c), d.pointCW(c), g) ? E(a, c, g, h, g) : (g = G(b, c, h, g),
                B(a, b, c, d, h, g))
            }
            var v = h("./assert")
              , D = h("./pointerror")
              , z = h("./triangle")
              , H = h("./advancingfront").Node;
            h = h("./utils");
            var I = h.EPSILON
              , J = h.Orientation
              , L = h.orient2d
              , F = h.inScanArea
              , N = h.isAngleObtuse;
            d.triangulate = function(d) {
                d.initTriangulation();
                d.createAdvancingFront();
                var g, h = d.pointCount();
                for (g = 1; g < h; ++g) {
                    var l = d.getPoint(g), q;
                    q = d;
                    var r = l
                      , B = q.locateNode(r)
                      , w = void 0
                      , w = new z(r,B.point,B.next.point);
                    w.markNeighbor(B.triangle);
                    q.addToMap(w);
                    var C = new H(r);
                    C.next = B.next;
                    C.prev = B;
                    B.next.prev = C;
                    B.next = C;
                    k(q, w) || q.mapTriangleToNodes(w);
                    w = C;
                    r.x <= B.point.x + I && b(q, B);
                    for (r = w.next; r.next && !N(r.point, r.next.point, 
                    r.prev.point); )
                        b(q, r),
                        r = r.next;
                    for (r = w.prev; r.prev && !N(r.point, r.next.point, r.prev.point); )
                        b(q, r),
                        r = r.prev;
                    if (w.next && w.next.next && (r = w.point.x - w.next.next.point.x,
                    B = w.point.y - w.next.next.point.y,
                    v(0 <= B, "unordered y"),
                    0 <= r || Math.abs(r) < B)) {
                        r = w;
                        L(r.point, r.next.point, r.next.next.point) === J.CCW ? q.basin.left_node = r.next.next : q.basin.left_node = r.next;
                        for (q.basin.bottom_node = q.basin.left_node; q.basin.bottom_node.next && q.basin.bottom_node.point.y >= q.basin.bottom_node.next.point.y; )
                            q.basin.bottom_node = q.basin.bottom_node.next;
                        if (q.basin.bottom_node !== q.basin.left_node) {
                            for (q.basin.right_node = q.basin.bottom_node; q.basin.right_node.next && q.basin.right_node.point.y < q.basin.right_node.next.point.y; )
                                q.basin.right_node = q.basin.right_node.next;
                            q.basin.right_node !== q.basin.bottom_node && (q.basin.width = q.basin.right_node.point.x - q.basin.left_node.point.x,
                            q.basin.left_highest = q.basin.left_node.point.y > q.basin.right_node.point.y,
                            n(q, q.basin.bottom_node))
                        }
                    }
                    q = w;
                    l = l._p2t_edge_list;
                    for (w = 0; l && w < l.length; ++w)
                        if (r = d,
                        B = l[w],
                        C = q,
                        r.edge_event.constrained_edge = 
                        B,
                        r.edge_event.right = B.p.x > B.q.x,
                        !a(C.triangle, B.p, B.q)) {
                            if (r.edge_event.right)
                                for (var D = r, G = B, E = C; E.next.point.x < G.p.x; )
                                    L(G.q, E.next.point, G.p) === J.CCW ? m(D, G, E) : E = E.next;
                            else
                                for (D = r,
                                G = B,
                                E = C; E.prev.point.x > G.p.x; )
                                    L(G.q, E.prev.point, G.p) === J.CW ? t(D, G, E) : E = E.prev;
                            c(r, B.p, B.q, C.triangle, B.q)
                        }
                }
                g = d.front().head().next.triangle;
                for (h = d.front().head().next.point; !g.getConstrainedEdgeCW(h); )
                    g = g.neighborCCW(h);
                d.meshClean(g)
            }
        }
        , {
            "./advancingfront": 2,
            "./assert": 3,
            "./pointerror": 5,
            "./triangle": 9,
            "./utils": 10
        }],
        8: [function(h, g, d) {
            var c = h("./pointerror")
              , a = h("./point")
              , b = h("./triangle")
              , k = h("./sweep")
              , l = h("./advancingfront")
              , n = l.Node
              , m = function(a, b) {
                this.p = a;
                this.q = b;
                if (a.y > b.y)
                    this.q = a,
                    this.p = b;
                else if (a.y === b.y)
                    if (a.x > b.x)
                        this.q = a,
                        this.p = b;
                    else if (a.x === b.x)
                        throw new c("poly2tri Invalid Edge constructor: repeated points!",[a]);
                this.q._p2t_edge_list || (this.q._p2t_edge_list = []);
                this.q._p2t_edge_list.push(this)
            }
              , q = function() {
                this.right_node = this.bottom_node = this.left_node = null ;
                this.width = 0;
                this.left_highest = 
                !1
            }
            ;
            q.prototype.clear = function() {
                this.right_node = this.bottom_node = this.left_node = null ;
                this.width = 0;
                this.left_highest = !1
            }
            ;
            var r = function() {
                this.constrained_edge = null ;
                this.right = !1
            }
            ;
            h = function(a, b) {
                b = b || {};
                this.triangles_ = [];
                this.map_ = [];
                this.points_ = b.cloneArrays ? a.slice(0) : a;
                this.edge_list = [];
                this.af_tail_ = this.af_middle_ = this.af_head_ = this.tail_ = this.head_ = this.front_ = this.pmin_ = this.pmax_ = null ;
                this.basin = new q;
                this.edge_event = new r;
                this.initEdges(this.points_)
            }
            ;
            h.prototype.addHole = function(a) {
                this.initEdges(a);
                var b, c = a.length;
                for (b = 0; b < c; b++)
                    this.points_.push(a[b]);
                return this
            }
            ;
            h.prototype.AddHole = h.prototype.addHole;
            h.prototype.addHoles = function(a) {
                var b, c = a.length;
                for (b = 0; b < c; b++)
                    this.initEdges(a[b]);
                this.points_ = this.points_.concat.apply(this.points_, a);
                return this
            }
            ;
            h.prototype.addPoint = function(a) {
                this.points_.push(a);
                return this
            }
            ;
            h.prototype.AddPoint = h.prototype.addPoint;
            h.prototype.addPoints = function(a) {
                this.points_ = this.points_.concat(a);
                return this
            }
            ;
            h.prototype.triangulate = function() {
                k.triangulate(this);
                return this
            }
            ;
            h.prototype.getBoundingBox = function() {
                return {
                    min: this.pmin_,
                    max: this.pmax_
                }
            }
            ;
            h.prototype.getTriangles = function() {
                return this.triangles_
            }
            ;
            h.prototype.GetTriangles = h.prototype.getTriangles;
            h.prototype.front = function() {
                return this.front_
            }
            ;
            h.prototype.pointCount = function() {
                return this.points_.length
            }
            ;
            h.prototype.head = function() {
                return this.head_
            }
            ;
            h.prototype.setHead = function(a) {
                this.head_ = a
            }
            ;
            h.prototype.tail = function() {
                return this.tail_
            }
            ;
            h.prototype.setTail = function(a) {
                this.tail_ = a
            }
            ;
            h.prototype.getMap = 
            function() {
                return this.map_
            }
            ;
            h.prototype.initTriangulation = function() {
                var b = this.points_[0].x, c = this.points_[0].x, d = this.points_[0].y, g = this.points_[0].y, k, h = this.points_.length;
                for (k = 1; k < h; k++) {
                    var l = this.points_[k];
                    l.x > b && (b = l.x);
                    l.x < c && (c = l.x);
                    l.y > d && (d = l.y);
                    l.y < g && (g = l.y)
                }
                this.pmin_ = new a(c,g);
                this.pmax_ = new a(b,d);
                k = .3 * (b - c);
                d = .3 * (d - g);
                this.head_ = new a(b + k,g - d);
                this.tail_ = new a(c - k,g - d);
                this.points_.sort(a.compare)
            }
            ;
            h.prototype.initEdges = function(a, b) {
                var c, d = a.length, g = b ? a.length - 1 : a.length;
                for (c = 0; c < g; ++c)
                    this.edge_list.push(new m(a[c],a[(c + 1) % d]))
            }
            ;
            h.prototype.getPoint = function(a) {
                return this.points_[a]
            }
            ;
            h.prototype.addToMap = function(a) {
                this.map_.push(a)
            }
            ;
            h.prototype.locateNode = function(a) {
                return this.front_.locateNode(a.x)
            }
            ;
            h.prototype.createAdvancingFront = function() {
                var a, c, d;
                d = new b(this.points_[0],this.tail_,this.head_);
                this.map_.push(d);
                a = new n(d.getPoint(1),d);
                c = new n(d.getPoint(0),d);
                d = new n(d.getPoint(2));
                this.front_ = new l(a,d);
                a.next = c;
                c.next = d;
                c.prev = a;
                d.prev = c
            }
            ;
            h.prototype.removeNode = 
            function(a) {}
            ;
            h.prototype.mapTriangleToNodes = function(a) {
                for (var b = 0; 3 > b; ++b)
                    if (!a.getNeighbor(b)) {
                        var c = this.front_.locatePoint(a.pointCW(a.getPoint(b)));
                        c && (c.triangle = a)
                    }
            }
            ;
            h.prototype.removeFromMap = function(a) {
                var b, c = this.map_, d = c.length;
                for (b = 0; b < d; b++)
                    if (c[b] === a) {
                        c.splice(b, 1);
                        break
                    }
            }
            ;
            h.prototype.meshClean = function(a) {
                a = [a];
                for (var b, c; b = a.pop(); )
                    if (!b.isInterior())
                        for (b.setInterior(!0),
                        this.triangles_.push(b),
                        c = 0; 3 > c; c++)
                            b.constrained_edge[c] || a.push(b.getNeighbor(c))
            }
            ;
            g.exports = h
        }
        , {
            "./advancingfront": 2,
            "./point": 4,
            "./pointerror": 5,
            "./sweep": 7,
            "./triangle": 9
        }],
        9: [function(h, g, d) {
            d = function(a, b, c) {
                this.points_ = [a, b, c];
                this.neighbors_ = [null , null , null ];
                this.interior_ = !1;
                this.constrained_edge = [!1, !1, !1];
                this.delaunay_edge = [!1, !1, !1]
            }
            ;
            var c = h("./xy").toString;
            d.prototype.toString = function() {
                return "[" + c(this.points_[0]) + c(this.points_[1]) + c(this.points_[2]) + "]"
            }
            ;
            d.prototype.getPoint = function(a) {
                return this.points_[a]
            }
            ;
            d.prototype.GetPoint = d.prototype.getPoint;
            d.prototype.getPoints = function() {
                return this.points_
            }
            ;
            d.prototype.getNeighbor = function(a) {
                return this.neighbors_[a]
            }
            ;
            d.prototype.containsPoint = function(a) {
                var b = this.points_;
                return a === b[0] || a === b[1] || a === b[2]
            }
            ;
            d.prototype.containsEdge = function(a) {
                return this.containsPoint(a.p) && this.containsPoint(a.q)
            }
            ;
            d.prototype.containsPoints = function(a, b) {
                return this.containsPoint(a) && this.containsPoint(b)
            }
            ;
            d.prototype.isInterior = function() {
                return this.interior_
            }
            ;
            d.prototype.setInterior = function(a) {
                this.interior_ = a;
                return this
            }
            ;
            d.prototype.markNeighborPointers = 
            function(a, b, c) {
                var d = this.points_;
                if (a === d[2] && b === d[1] || a === d[1] && b === d[2])
                    this.neighbors_[0] = c;
                else if (a === d[0] && b === d[2] || a === d[2] && b === d[0])
                    this.neighbors_[1] = c;
                else if (a === d[0] && b === d[1] || a === d[1] && b === d[0])
                    this.neighbors_[2] = c;
                else
                    throw Error("poly2tri Invalid Triangle.markNeighborPointers() call");
            }
            ;
            d.prototype.markNeighbor = function(a) {
                var b = this.points_;
                a.containsPoints(b[1], b[2]) ? (this.neighbors_[0] = a,
                a.markNeighborPointers(b[1], b[2], this)) : a.containsPoints(b[0], b[2]) ? (this.neighbors_[1] = 
                a,
                a.markNeighborPointers(b[0], b[2], this)) : a.containsPoints(b[0], b[1]) && (this.neighbors_[2] = a,
                a.markNeighborPointers(b[0], b[1], this))
            }
            ;
            d.prototype.clearNeighbors = function() {
                this.neighbors_[0] = null ;
                this.neighbors_[1] = null ;
                this.neighbors_[2] = null 
            }
            ;
            d.prototype.clearDelaunayEdges = function() {
                this.delaunay_edge[0] = !1;
                this.delaunay_edge[1] = !1;
                this.delaunay_edge[2] = !1
            }
            ;
            d.prototype.pointCW = function(a) {
                var b = this.points_;
                return a === b[0] ? b[2] : a === b[1] ? b[0] : a === b[2] ? b[1] : null 
            }
            ;
            d.prototype.pointCCW = function(a) {
                var b = 
                this.points_;
                return a === b[0] ? b[1] : a === b[1] ? b[2] : a === b[2] ? b[0] : null 
            }
            ;
            d.prototype.neighborCW = function(a) {
                return a === this.points_[0] ? this.neighbors_[1] : a === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0]
            }
            ;
            d.prototype.neighborCCW = function(a) {
                return a === this.points_[0] ? this.neighbors_[2] : a === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1]
            }
            ;
            d.prototype.getConstrainedEdgeCW = function(a) {
                return a === this.points_[0] ? this.constrained_edge[1] : a === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0]
            }
            ;
            d.prototype.getConstrainedEdgeCCW = function(a) {
                return a === this.points_[0] ? this.constrained_edge[2] : a === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1]
            }
            ;
            d.prototype.getConstrainedEdgeAcross = function(a) {
                return a === this.points_[0] ? this.constrained_edge[0] : a === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2]
            }
            ;
            d.prototype.setConstrainedEdgeCW = function(a, b) {
                a === this.points_[0] ? this.constrained_edge[1] = b : a === this.points_[1] ? this.constrained_edge[2] = b : this.constrained_edge[0] = 
                b
            }
            ;
            d.prototype.setConstrainedEdgeCCW = function(a, b) {
                a === this.points_[0] ? this.constrained_edge[2] = b : a === this.points_[1] ? this.constrained_edge[0] = b : this.constrained_edge[1] = b
            }
            ;
            d.prototype.getDelaunayEdgeCW = function(a) {
                return a === this.points_[0] ? this.delaunay_edge[1] : a === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0]
            }
            ;
            d.prototype.getDelaunayEdgeCCW = function(a) {
                return a === this.points_[0] ? this.delaunay_edge[2] : a === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1]
            }
            ;
            d.prototype.setDelaunayEdgeCW = 
            function(a, b) {
                a === this.points_[0] ? this.delaunay_edge[1] = b : a === this.points_[1] ? this.delaunay_edge[2] = b : this.delaunay_edge[0] = b
            }
            ;
            d.prototype.setDelaunayEdgeCCW = function(a, b) {
                a === this.points_[0] ? this.delaunay_edge[2] = b : a === this.points_[1] ? this.delaunay_edge[0] = b : this.delaunay_edge[1] = b
            }
            ;
            d.prototype.neighborAcross = function(a) {
                return a === this.points_[0] ? this.neighbors_[0] : a === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2]
            }
            ;
            d.prototype.oppositePoint = function(a, b) {
                var c = a.pointCW(b);
                return this.pointCW(c)
            }
            ;
            d.prototype.legalize = function(a, b) {
                var c = this.points_;
                if (a === c[0])
                    c[1] = c[0],
                    c[0] = c[2],
                    c[2] = b;
                else if (a === c[1])
                    c[2] = c[1],
                    c[1] = c[0],
                    c[0] = b;
                else if (a === c[2])
                    c[0] = c[2],
                    c[2] = c[1],
                    c[1] = b;
                else
                    throw Error("poly2tri Invalid Triangle.legalize() call");
            }
            ;
            d.prototype.index = function(a) {
                var b = this.points_;
                if (a === b[0])
                    return 0;
                if (a === b[1])
                    return 1;
                if (a === b[2])
                    return 2;
                throw Error("poly2tri Invalid Triangle.index() call");
            }
            ;
            d.prototype.edgeIndex = function(a, b) {
                var c = this.points_;
                if (a === c[0]) {
                    if (b === c[1])
                        return 2;
                    if (b === c[2])
                        return 1
                } else if (a === c[1]) {
                    if (b === c[2])
                        return 0;
                    if (b === c[0])
                        return 2
                } else if (a === c[2]) {
                    if (b === c[0])
                        return 1;
                    if (b === c[1])
                        return 0
                }
                return -1
            }
            ;
            d.prototype.markConstrainedEdgeByIndex = function(a) {
                this.constrained_edge[a] = !0
            }
            ;
            d.prototype.markConstrainedEdgeByEdge = function(a) {
                this.markConstrainedEdgeByPoints(a.p, a.q)
            }
            ;
            d.prototype.markConstrainedEdgeByPoints = function(a, b) {
                var c = this.points_;
                if (b === c[0] && a === c[1] || b === c[1] && a === c[0])
                    this.constrained_edge[2] = !0;
                else if (b === c[0] && a === c[2] || b === c[2] && 
                a === c[0])
                    this.constrained_edge[1] = !0;
                else if (b === c[1] && a === c[2] || b === c[2] && a === c[1])
                    this.constrained_edge[0] = !0
            }
            ;
            g.exports = d
        }
        , {
            "./xy": 11
        }],
        10: [function(h, g, d) {
            d.EPSILON = 1E-12;
            var c = {
                CW: 1,
                CCW: -1,
                COLLINEAR: 0
            };
            d.Orientation = c;
            d.orient2d = function(a, b, d) {
                a = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);
                return -1E-12 < a && 1E-12 > a ? c.COLLINEAR : 0 < a ? c.CCW : c.CW
            }
            ;
            d.inScanArea = function(a, b, c, d) {
                return -1E-12 <= (a.x - b.x) * (d.y - b.y) - (d.x - b.x) * (a.y - b.y) || 1E-12 >= (a.x - c.x) * (d.y - c.y) - (d.x - c.x) * (a.y - c.y) ? !1 : !0
            }
            ;
            d.isAngleObtuse = function(a, 
            b, c) {
                return 0 > (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y)
            }
        }
        , {}],
        11: [function(h, g, d) {
            function c(a) {
                return "(" + a.x + ";" + a.y + ")"
            }
            g.exports = {
                toString: function(a) {
                    var b = a.toString();
                    return "[object Object]" === b ? c(a) : b
                },
                toStringBase: c,
                compare: function(a, b) {
                    return a.y === b.y ? a.x - b.x : a.y - b.y
                },
                equals: function(a, b) {
                    return a.x === b.x && a.y === b.y
                }
            }
        }
        , {}]
    }, {}, [6])(6)
}
);
(function() {
    var f = Teratek.Viewing;
    f.EventDispatcher = function() {}
    ;
    f.EventDispatcher.prototype = {
        constructor: f.EventDispatcher,
        apply: function(h) {
            h.addEventListener = f.EventDispatcher.prototype.addEventListener;
            h.hasEventListener = f.EventDispatcher.prototype.hasEventListener;
            h.removeEventListener = f.EventDispatcher.prototype.removeEventListener;
            h.fireEvent = f.EventDispatcher.prototype.fireEvent;
            h.dispatchEvent = f.EventDispatcher.prototype.fireEvent
        },
        addEventListener: function(f, g) {
            void 0 === this.listeners && 
            (this.listeners = {});
            "undefined" == typeof this.listeners[f] && (this.listeners[f] = []);
            this.listeners[f].push(g)
        },
        hasEventListener: function(f, g) {
            if (void 0 === this.listeners)
                return !1;
            var d = this.listeners;
            return void 0 !== d[f] && -1 !== d[f].indexOf(g) ? !0 : !1
        },
        removeEventListener: function(f, g) {
            void 0 === this.listeners && (this.listeners = {});
            if (this.listeners[f] instanceof Array)
                for (var d = this.listeners[f], c = 0, a = d.length; c < a; c++)
                    if (d[c] === g) {
                        d.splice(c, 1);
                        break
                    }
        },
        fireEvent: function(f) {
            void 0 === this.listeners && (this.listeners = 
            {});
            "string" == typeof f && (f = {
                type: f
            });
            if (!f.target)
                try {
                    f.target = this
                } catch (g) {}
            if (!f.type)
                throw Error("event type unknown.");
            if (this.listeners[f.type] instanceof Array)
                for (var d = this.listeners[f.type].slice(), c = 0; c < d.length; c++)
                    d[c].call(this, f)
        }
    }
}
)();
Teratek.Viewing.FileLoader = function(f) {
    this.viewer = f
}
;
Teratek.Viewing.FileLoader.prototype.constructor = Teratek.Viewing.FileLoader;
Teratek.Viewing.FileLoader.prototype.loadFile = function(f, h, g, d) {
    return !1
}
;
(function() {
    Teratek.Viewing.FileLoaderManager = new function() {
        var f = {};
        return {
            registerFileLoader: function(h, g, d) {
                return f[h] ? !1 : (f[h] = {
                    loader: d,
                    extensions: g
                },
                !0)
            },
            getFileLoader: function(h) {
                return f[h] ? f[h].loader : null 
            },
            getFileLoaderForExtension: function(h) {
                h = h ? h.toLowerCase() : "";
                for (var g in f) {
                    var d = f[g];
                    if (d)
                        for (var c = 0; c < d.extensions.length; c++)
                            if (d.extensions[c].toLowerCase() === h)
                                return d.loader
                }
                return null 
            },
            unregisterFileLoader: function(h) {
                return f[h] ? (delete f[h],
                !0) : !1
            }
        }
    }
}
)();
(function() {
    function f(a) {
        for (var b = 0; b < c.length; ++b)
            document.addEventListener(c[b], a, !1)
    }
    function h(a) {
        for (var b = 0; b < c.length; ++b)
            document.removeEventListener(c[b], a, !1)
    }
    var g = Teratek.Viewing
      , d = Teratek.Viewing.Private
      , c = ["fullscreenchange", "mozfullscreenchange", "webkitfullscreenchange", "MSFullscreenChange"];
    g.ScreenMode = {
        kNormal: 0,
        kFullBrowser: 1,
        kFullScreen: 2
    };
    g.ScreenModeDelegate = function(a) {
        this.viewer = a;
        this.bindFullscreenEventListener = this.fullscreenEventListener.bind(this);
        this.getMode() === 
        g.ScreenMode.kFullScreen && f(this.bindFullscreenEventListener)
    }
    ;
    g.ScreenModeDelegate.prototype.uninitialize = function() {
        h(this.bindFullscreenEventListener);
        this.viewer = null 
    }
    ;
    g.ScreenModeDelegate.prototype.isModeSupported = function(a) {
        return !0
    }
    ;
    g.ScreenModeDelegate.prototype.setMode = function(a) {
        var b = this.getMode();
        return a !== b && this.isModeSupported(a) ? (this.doScreenModeChange(b, a),
        this.onScreenModeChanged(b, a),
        !0) : !1
    }
    ;
    g.ScreenModeDelegate.prototype.getMode = function() {
        throw "Implement getMode() in derived class";
    }
    ;
    g.ScreenModeDelegate.prototype.getNextMode = function() {
        var a = this.getMode(), b, c = g.ScreenMode;
        a === c.kNormal && this.isModeSupported(c.kFullBrowser) ? b = c.kFullBrowser : a === c.kNormal && this.isModeSupported(c.kFullScreen) ? b = c.kFullScreen : a === c.kFullBrowser && this.isModeSupported(c.kFullScreen) ? b = c.kFullScreen : a === c.kFullBrowser && this.isModeSupported(c.kNormal) ? b = c.kNormal : a === c.kFullScreen && this.isModeSupported(c.kNormal) ? b = c.kNormal : a === c.kFullScreen && this.isModeSupported(c.kFullBrowser) && (b = c.kFullBrowser);
        return b
    }
    ;
    g.ScreenModeDelegate.prototype.getEscapeMode = function() {
        return this.getMode() !== g.ScreenMode.kNormal ? g.ScreenMode.kNormal : void 0
    }
    ;
    g.ScreenModeDelegate.prototype.fullscreenEventListener = function() {
        if (inFullscreen())
            this.viewer.resize();
        else {
            var a = g.ScreenMode;
            this.doScreenModeChange(a.kFullScreen, a.kNormal);
            this.onScreenModeChanged(a.kFullScreen, a.kNormal)
        }
    }
    ;
    g.ScreenModeDelegate.prototype.doScreenModeChange = function(a, b) {
        throw "Implement doScreenModeChange() in derived class";
    }
    ;
    g.ScreenModeDelegate.prototype.onScreenModeChanged = 
    function(a, b) {
        a === g.ScreenMode.kFullScreen ? h(this.bindFullscreenEventListener) : b === g.ScreenMode.kFullScreen && f(this.bindFullscreenEventListener);
        this.viewer.resize();
        this.viewer.fireEvent({
            type: g.FULLSCREEN_MODE_EVENT,
            mode: b
        })
    }
    ;
    g.ApplicationScreenModeDelegate = function(a) {
        g.ScreenModeDelegate.call(this, a)
    }
    ;
    g.ApplicationScreenModeDelegate.prototype = Object.create(g.ScreenModeDelegate.prototype);
    g.ApplicationScreenModeDelegate.prototype.constructor = g.ApplicationScreenModeDelegate;
    g.ApplicationScreenModeDelegate.prototype.isModeSupported = 
    function(a) {
        return a !== g.ScreenMode.kFullBrowser
    }
    ;
    g.ApplicationScreenModeDelegate.prototype.getMode = function() {
        return inFullscreen() ? g.ScreenMode.kFullScreen : g.ScreenMode.kNormal
    }
    ;
    g.ApplicationScreenModeDelegate.prototype.doScreenModeChange = function(a, b) {
        var c = this.viewer.container;
        b === g.ScreenMode.kNormal ? (c.classList.remove("viewer-fill-browser"),
        exitFullscreen()) : b === g.ScreenMode.kFullScreen && (c.classList.add("viewer-fill-browser"),
        launchFullscreen(c))
    }
    ;
    g.NullScreenModeDelegate = function(a) {
        g.ScreenModeDelegate.call(this, 
        a)
    }
    ;
    g.NullScreenModeDelegate.prototype = Object.create(g.ScreenModeDelegate.prototype);
    g.NullScreenModeDelegate.prototype.constructor = g.ScreenModeDelegate;
    g.NullScreenModeDelegate.prototype.isModeSupported = function(a) {
        return !1
    }
    ;
    g.NullScreenModeDelegate.prototype.getMode = function() {
        return g.ScreenMode.kNormal
    }
    ;
    g.ScreenModeMixin = function() {}
    ;
    g.ScreenModeMixin.prototype = {
        setScreenModeDelegate: function(a) {
            this.screenModeDelegate && (this.screenModeDelegate.uninitialize(),
            this.screenModeDelegate = null );
            this.screenModeDelegateClass = 
            a ? a : null  === a ? g.NullScreenModeDelegate : g.ApplicationScreenModeDelegate
        },
        getScreenModeDelegate: function() {
            this.screenModeDelegate || (this.screenModeDelegate = new this.screenModeDelegateClass(this));
            return this.screenModeDelegate
        },
        isScreenModeSupported: function(a) {
            return this.getScreenModeDelegate().isModeSupported(a)
        },
        canChangeScreenMode: function() {
            return this.isScreenModeSupported(Teratek.Viewing.ScreenMode.kNormal)
        },
        setScreenMode: function(a) {
            var b = d.logger;
            b && b.log({
                category: "screen_mode",
                value: a
            });
            return this.getScreenModeDelegate().setMode(a)
        },
        getScreenMode: function() {
            return this.getScreenModeDelegate().getMode()
        },
        nextScreenMode: function() {
            var a = this.getScreenModeDelegate().getNextMode();
            return void 0 !== a ? this.setScreenMode(a) : !1
        },
        escapeScreenMode: function() {
            var a = this.getScreenModeDelegate().getEscapeMode();
            return void 0 !== a ? this.setScreenMode(a) : !1
        },
        apply: function(a) {
            var b = g.ScreenModeMixin.prototype;
            a.setScreenModeDelegate = b.setScreenModeDelegate;
            a.getScreenModeDelegate = b.getScreenModeDelegate;
            a.isScreenModeSupported = b.isScreenModeSupported;
            a.canChangeScreenMode = b.canChangeScreenMode;
            a.setScreenMode = b.setScreenMode;
            a.getScreenMode = b.getScreenMode;
            a.nextScreenMode = b.nextScreenMode;
            a.escapeScreenMode = b.escapeScreenMode
        }
    }
}
)();
(function() {
    var f = Teratek.Viewing
      , h = {
        METER: "m",
        CENTIMETER: "cm",
        MILLIMETER: "mm",
        FOOT: "ft",
        INCH: "in"
    };
    f.ModelUnits = h;
    var g = function(d) {
        this.myData = d;
        this.propWorker = this.sharedPath = null 
    }
    ;
    f.EventDispatcher.prototype.apply(g.prototype);
    g.prototype.constructor = g;
    g.prototype.setData = function(d) {
        this.myData = d
    }
    ;
    g.prototype.getData = function() {
        return this.myData
    }
    ;
    g.prototype.getRoot = function() {
        return this.is2d() ? (console.warn("Teratek.Viewing.Model.getRoot is not yet implemented for 2D"),
        null ) : this.myData && 
        this.myData.instanceTree ? this.myData.instanceTree.root : null 
    }
    ;
    g.prototype.getRootId = function() {
        return this.is2d() ? (console.warn("Teratek.Viewing.Model.getRootId is not yet implemented for 2D"),
        0) : this.myData && this.myData.instanceTree ? this.myData.instanceTree.getRootId() : 0
    }
    ;
    g.prototype.getBoundingBox = function() {
        return this.myData ? this.myData.bbox : null 
    }
    ;
    g.prototype.getUnitScale = function() {
        switch (this.is2d() ? this.getMetadata("page_dimensions", "model_units", null ) : this.getMetadata("distance unit", "value", 
        null )) {
        case "meter":
        case "m":
            return 1;
        case "foot":
        case "ft":
            return .3048;
        case "inch":
        case "in":
            return .0254;
        case "centimeter":
        case "cm":
            return .01;
        case "millimeter":
        case "mm":
            return .001;
        default:
            return 1
        }
    }
    ;
    g.prototype.getUnitString = function() {
        switch (this.is2d() ? this.getMetadata("page_dimensions", "page_units", null ) : this.getMetadata("distance unit", "value", null )) {
        case "meter":
        case "m":
            return h.METER;
        case "foot":
        case "ft":
            return h.FOOT;
        case "inch":
        case "in":
            return h.INCH;
        case "centimeter":
        case "cm":
            return h.CENTIMETER;
        case "millimeter":
        case "mm":
            return h.MILLIMETER;
        default:
            return null 
        }
    }
    ;
    g.prototype.getMetadata = function(d, c, a) {
        if (this.myData) {
            var b = this.myData.metadata;
            if (b && (d = b[d],
            void 0 !== d))
                if (c) {
                    if (c = d[c],
                    void 0 !== c)
                        return c
                } else
                    return d
        }
        return a
    }
    ;
    g.prototype.getDefaultCamera = function() {
        var d = this.myData;
        if (!d)
            return null ;
        var c = null 
          , a = d.cameras ? d.cameras.length : 0;
        if (0 < a) {
            var b = this.getMetadata("default camera", "index", null );
            if (null  !== b && d.cameras[b])
                c = d.cameras[b];
            else {
                for (b = 0; b < a; b++) {
                    var f = d.cameras[b];
                    if (f.isPerspective) {
                        c = f;
                        break
                    }
                }
                c || (c = d.cameras[0])
            }
        }
        return c
    }
    ;
    g.prototype.getUpVector = function() {
        return this.getMetadata("world up vector", "XYZ", null )
    }
    ;
    g.prototype.geomPolyCount = function() {
        return this.myData ? this.myData.geomPolyCount : null 
    }
    ;
    g.prototype.instancePolyCount = function() {
        return this.myData ? this.myData.instancePolyCount : null 
    }
    ;
    g.prototype.getLayersRoot = function() {
        return this.is2d() ? this.myData ? this.myData.layersRoot : null  : (console.warn("Teratek.Viewing.Model.getLayersRoot is not yet implemented for 3D"),
        null )
    }
    ;
    g.prototype.is2d = function() {
        return !(!this.myData || !this.myData.is2d)
    }
    ;
    g.prototype.isLoadDone = function() {
        return !(!this.myData || !this.myData.loadDone)
    }
    ;
    g.prototype.isObjectTreeCreated = function() {
        return !!this.myData.instanceTree
    }
    ;
    g.prototype.getProperties = function(d, c, a) {
        this.myData && this.myData.propWorker.getProperties(d, c, a)
    }
    ;
    g.prototype.getExternalIdMapping = function(d, c) {
        this.myData && this.myData.propWorker.getExternalIdMapping(d, c)
    }
    ;
    g.prototype.getObjectTree = function(d, c) {
        !this.myData && c ? c() : 
        this.myData.propWorker.getObjectTree(d, c)
    }
    ;
    g.prototype.search = function(d, c, a, b) {
        var f = this;
        this.isLoadDone() ? this.myData.propWorker.searchProperties(d, b, c, a) : this.getObjectTree(function() {
            f.myData.propWorker.searchProperties(d, b, c, a)
        }
        )
    }
    ;
    g.prototype.pageToModel = function(d, c, a) {
        var b = this.myData.metadata.page_dimensions
          , f = this.myData.viewports
          , g = new THREE.Vector3
          , h = new THREE.Vector3;
        g.x = d.x / b.page_width * b.logical_width + b.logical_offset_x;
        g.y = d.y / b.page_height * b.logical_height + b.logical_offset_y;
        g.z = 
        0;
        h.x = c.x / b.page_width * b.logical_width + b.logical_offset_x;
        h.y = c.y / b.page_height * b.logical_height + b.logical_offset_y;
        h.z = 0;
        var b = new THREE.Vector2
          , m = new THREE.Vector2;
        this.logicalToModel(g, h, b, m, f[a]);
        var q = d.distanceTo(c)
          , r = b.distanceTo(m);
        if (.01 > Math.abs(r - q)) {
            a = this.pointInClip(d, a);
            for (var t = b.clone(), w = m.clone(), C = 0; C < a.length && !(this.logicalToModel(g, h, b, m, f[a[C]]),
            r = b.distanceTo(m),
            .01 < Math.abs(r - q)); C++)
                ;
            C >= a.length && (b = t,
            m = w)
        }
        d.x = b.x;
        d.y = b.y;
        c.x = m.x;
        c.y = m.y
    }
    ;
    g.prototype.logicalToModel = function(d, 
    c, a, b, f) {
        if (f && f.transform) {
            for (var g = new THREE.Matrix4, h = 0; 16 > h; h++)
                g.elements[h] = f.transform[h];
            this.repairViewportMatrix(g);
            f = g.getInverse(g).elements;
            a.x = f[0] * d.x + f[4] * d.y + f[8] * d.z + f[12];
            a.y = f[1] * d.x + f[5] * d.y + f[9] * d.z + f[13];
            b.x = f[0] * c.x + f[4] * c.y + f[8] * c.z + f[12];
            b.y = f[1] * c.x + f[5] * c.y + f[9] * c.z + f[13]
        }
    }
    ;
    g.prototype.repairViewportMatrix = function(d) {
        d = d.elements;
        if (.001 > Math.abs(d[0]))
            if (.001 < Math.abs(d[4]))
                for (var c = 0; 4 > c; c++) {
                    var a = d[c];
                    d[c] = d[c + 4];
                    d[c + 4] = a
                }
            else
                for (c = 0; 4 > c; c++)
                    a = d[c],
                    d[c] = d[c + 8],
                    d[c + 8] = a;
        if (.001 > Math.abs(d[5]))
            for (c = 4; 8 > c; c++)
                a = d[c],
                d[c] = d[c + 4],
                d[c + 4] = a
    }
    ;
    g.prototype.pointInClip = function(d, c) {
        for (var a = this.myData.clips, b = [], f = 0; f < a.length; f++)
            if (f !== c) {
                for (var g = [], h = [], m = a[f].contourCounts, q = a[f].points, r = 0, t = [], w = 0; w < m.length; w++) {
                    for (var C = 0; C < m[w]; C++)
                        g.push(r),
                        r++;
                    h.push(g);
                    g = []
                }
                for (w = 0; w < q.length; w += 2)
                    t.push({
                        x: q[w],
                        y: q[w + 1]
                    });
                this.pointInPolygon(d.x, d.y, h, t) && b.push(f)
            }
        return b
    }
    ;
    g.prototype.pointInPolygon = function(d, c, a, b) {
        for (var f = !1, g = 0; g < a.length; g++)
            this.pointInContour(d, 
            c, a[g], b) && (f = !f);
        return f
    }
    ;
    g.prototype.pointInContour = function(d, c, a, b) {
        var f, g, h, m, q, r, t = !1;
        h = b[a[a.length - 1]].x;
        m = b[a[a.length - 1]].y;
        f = m >= c;
        for (var w = 0, C = a.length; w < C; ++w)
            q = b[a[w]].x,
            r = b[a[w]].y,
            g = r >= c,
            f != g && (r - c) * (h - q) >= (q - d) * (m - r) == g && (t = !t),
            f = g,
            h = q,
            m = r;
        return t
    }
    ;
    g.prototype.getTopoIndex = function(d) {
        if (this.myData && this.myData.fragments) {
            var c = this.myData.fragments.topoIndexes;
            if (c)
                return c[d]
        }
    }
    ;
    g.prototype.getTopology = function(d) {
        if (this.myData) {
            var c = this.myData.topology;
            if (c && (d = c[d]))
                return d
        }
    }
    ;
    g.prototype.hasTopology = function() {
        if (this.myData && this.myData.topology)
            return !0
    }
    ;
    g.prototype.getAttributeToIdMap = function(d, c) {
        var a = this;
        this.isLoadDone() ? this.myData.propWorker.attributeToIdMap(d, c) : this.getObjectTree(function() {
            a.myData.propWorker.attributeToIdMap(d, c)
        }
        )
    }
    ;
    f.Model = g
}
)();
TeratekNamespace("Teratek.Viewing.Private");
(function() {
    var f = Teratek.Viewing.Private;
    f.inWorkerThread = "undefined" !== typeof self && "undefined" === typeof window;
    f.ViewingService = {};
    f.ViewingService.generateUrl = function(h, g, d, c) {
        if (0 !== d.indexOf("urn:"))
            return d;
        h += "/";
        "items" !== g && (d = d.substr(4));
        return h = "bubbles" === g && 0 == f.env.indexOf("Teratek") ? h + d : h + (g + "/" + d)
    }
    ;
    f.ViewingService.get = function(h, g, d, c, a, b) {
        b = b ? b : {};
        d = f.ViewingService.generateUrl(h, g, d, b);
        b.queryParams && (d = d + "?" + b.queryParams);
        var k = new XMLHttpRequest;
        try {
            h = function(a) {
                200 === 
                k.status ? c(k.response ? k.response : k.responseText) : l(a)
            }
            ;
            var l = function(b) {
                a(k.status, k.statusText, {
                    url: d
                })
            }
              , n = b.hasOwnProperty("asynchronous") ? b.asynchronous : !0;
            k.open("GET", d, n);
            b.hasOwnProperty("responseType") && (k.responseType = b.responseType);
            k.withCredentials = !0;
            b.hasOwnProperty("withCredentials") && (k.withCredentials = b.withCredentials);
            if (b.headers)
                for (var m in b.headers)
                    k.setRequestHeader(m, b.headers[m]);
            n && (k.onload = h,
            k.onerror = l,
            k.ontimeout = l);
            k.send();
            f.inWorkerThread ? self.postMessage({
                assetRequest: [d, 
                b.headers, null ]
            }) : f.assets.push([d, b.headers, null ]);
            n || h(null )
        } catch (q) {
            a(k.status, k.statusText, {
                url: d,
                exception: q
            })
        }
    }
}
)();
var Xhr = function() {
    var f = function(f, g, d) {
        this.xhr = new XMLHttpRequest;
        this.errorHandler = f;
        this.success = !1;
        this.viewing_url = d;
        this.auth = g
    }
    ;
    f.prototype.generateUrl = function(f, g, d) {
        var c = f.indexOf("urn:");
        0 === c && this.viewing_url && ((d = d && d.feature ? d.feature : null ) ? "render" == d ? (f = f.substr(4),
        f = this.viewing_url + "/" + d + "/" + encodeURIComponent(f)) : "bubbles" == d ? (f = f.substr(4),
        f = this.viewing_url + "/" + d + "/" + encodeURIComponent(f)) : "comments" == d ? (f = f.substr(4),
        f = this.viewing_url + "/" + d + "/file/" + encodeURIComponent(f)) : 
        f = this.viewing_url + "/" + d + "/" + encodeURIComponent(f.substr(c)) : f = this.viewing_url + "/items/" + encodeURIComponent(f.substr(c)));
        g && (f = f + "?" + g);
        return f
    }
    ;
    f.prototype.addHeaders = function(f) {
        for (var g in f)
            this.xhr.setRequestHeader(g, f[g])
    }
    ;
    f.prototype.get = function(f, g, d, c, a, b, k) {
        f = this.generateUrl(f, b, {
            feature: a,
            oss_url: k
        });
        try {
            this.xhr.open("GET", f, !!c),
            this.xhr.responseType = d,
            this.success = !1,
            this.auth && (this.xhr.withCredentials = !0),
            c && (this.xhr.onload = c),
            this.addHeaders(g),
            this.xhr.send()
        } catch (l) {
            return this.errorHandler && 
            this.errorHandler.networkFailure(f, l),
            null 
        }
        this.errorCheck(f, 200);
        return this.xhr.response
    }
    ;
    f.prototype.post = function(f, g, d, c, a, b) {
        f = this.generateUrl(f, null , {
            feature: b
        });
        g["Content-Type"] || (g["Content-Type"] = "application/json");
        try {
            this.xhr.open("POST", f, !!a),
            this.xhr.responseType = c,
            this.success = !1,
            this.auth && (this.xhr.withCredentials = !0),
            a && (this.xhr.onload = a),
            this.addHeaders(g),
            this.xhr.send(d)
        } catch (k) {
            return this.errorHandler && this.errorHandler.networkFailure(f, k),
            null 
        }
        this.errorCheck(f, 200, 201);
        return this.xhr.response
    }
    ;
    f.prototype.getRange = function(f, g, d, c, a, b) {
        f = this.generateUrl(path);
        g.Range = "bytes=" + c + "-" + a;
        try {
            this.xhr.open("GET", f, !!b),
            this.xhr.responseType = d,
            this.success = !1,
            this.auth && (this.xhr.withCredentials = !0),
            b && (this.xhr.onload = b),
            this.addHeaders(g),
            this.xhr.send()
        } catch (k) {
            return this.errorHandler && this.errorHandler.networkFailure(f, k),
            null 
        }
        this.errorCheck(f, 206);
        return this.xhr.response
    }
    ;
    f.prototype.head = function(f) {
        f = this.generateUrl(path);
        try {
            this.xhr.open("GET", f, !1),
            this.success = 
            !1,
            this.auth && (this.xhr.withCredentials = !0),
            this.addHeaders([]),
            this.xhr.send()
        } catch (g) {
            return this.errorHandler && this.errorHandler.networkFailure(f, g),
            null 
        }
        this.errorCheck(f, 200);
        f = [];
        f["Accept-Ranges"] = this.xhr.getResponseHeader("Accept-Ranges");
        f["Content-Length"] = this.xhr.getResponseHeader("Content-Length");
        return f
    }
    ;
    f.prototype.errorCheck = function(f, g) {
        if (4 === this.xhr.readyState && this.xhr.status) {
            var d;
            for (d = 1; d < arguments.length && this.xhr.status !== arguments[d]; d++)
                ;
            d === arguments.length && this.errorHandler ? 
            this.errorHandler.unsuccessfulResponse(f, this.xhr.status, this.xhr.statusText) : this.success = !0
        } else
            this.success = !0
    }
    ;
    return f
}
()
  , XhrErrorHandler = function() {
    var f = function(f) {
        this.host = f;
        this.ignoreFileNotFound = !1
    }
    ;
    f.prototype.networkFailure = function(f, g) {
        this.host.raiseError(Teratek.Viewing.ErrorCodes.NETWORK_FAILURE, "Network failure", {
            url: f,
            exception: g.toString(),
            stack: g.stack
        })
    }
    ;
    f.prototype.unsuccessfulResponse = function(f, g, d) {
        403 == g ? this.host.raiseError(Teratek.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED, 
        "Access denied to remote resource", {
            url: f,
            httpStatus: g,
            httpStatusText: d
        }) : 404 == g ? this.ignoreFileNotFound || this.host.raiseError(Teratek.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND, "Remote resource not found", {
            url: f,
            httpStatus: g,
            httpStatusText: d
        }) : 500 <= g && 600 > g ? this.host.raiseError(Teratek.Viewing.ErrorCodes.NETWORK_SERVER_ERROR, "Server error when accessing resource", {
            url: f,
            httpStatus: g,
            httpStatusText: d
        }) : this.host.raiseError(Teratek.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE, "Unhandled response code from server", 
        {
            url: f,
            httpStatus: g,
            httpStatusText: d
        })
    }
    ;
    return f
}
();
if ("undefined" !== typeof window) {
    var trace = function(f) {
        "\n" == f[f.length - 1] && (f = f.substring(0, f.length - 1));
        console.log((performance.now() / 1E3).toFixed(3) + ": " + f)
    }
      , RTCPeerConnection = null 
      , getUserMedia = null 
      , attachMediaStream = null 
      , reattachMediaStream = null 
      , webrtcDetectedBrowser = null 
      , webrtcDetectedVersion = null ;
    if (navigator.mozGetUserMedia)
        webrtcDetectedBrowser = "firefox",
        webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]),
        RTCPeerConnection = mozRTCPeerConnection,
        RTCSessionDescription = 
        mozRTCSessionDescription,
        RTCIceCandidate = mozRTCIceCandidate,
        getUserMedia = navigator.mozGetUserMedia.bind(navigator),
        createIceServer = function(f, h, g) {
            var d = null 
              , c = f.split(":");
            0 === c[0].indexOf("stun") ? d = {
                url: f
            } : 0 !== c[0].indexOf("turn") || -1 === f.indexOf("transport=udp") && -1 !== f.indexOf("?transport") || (d = {
                url: f.split("?")[0],
                credential: g,
                username: h
            });
            return d
        }
        ,
        attachMediaStream = function(f, h) {
            console.log("Attaching media stream");
            f.mozSrcObject = h;
            f.play()
        }
        ,
        reattachMediaStream = function(f, h) {
            console.log("Reattaching media stream");
            f.mozSrcObject = h.mozSrcObject;
            f.play()
        }
        ,
        MediaStream.prototype.getVideoTracks = function() {
            return []
        }
        ,
        MediaStream.prototype.getAudioTracks = function() {
            return []
        }
        ;
    else if (navigator.webkitGetUserMedia) {
        var match = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)
          , webrtcDetectedBrowser = "chrome"
          , webrtcDetectedVersion = match ? parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2]) : 40;
        createIceServer = function(f, h, g) {
            var d = null 
              , c = f.split(":");
            0 === c[0].indexOf("stun") ? d = {
                url: f
            } : 0 === c[0].indexOf("turn") && 
            (28 > webrtcDetectedVersion ? (f = f.split("turn:"),
            d = {
                url: "turn:" + h + "@" + f[1],
                credential: g
            }) : d = {
                url: f,
                credential: g,
                username: h
            });
            return d
        }
        ;
        RTCPeerConnection = webkitRTCPeerConnection;
        getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
        attachMediaStream = function(f, h) {
            "undefined" !== typeof f.srcObject ? f.srcObject = h : "undefined" !== typeof f.mozSrcObject ? f.mozSrcObject = h : "undefined" !== typeof f.src ? f.src = URL.createObjectURL(h) : console.log("Error attaching stream to element.")
        }
        ;
        reattachMediaStream = function(f, 
        h) {
            f.src = h.src
        }
        ;
        webkitMediaStream.prototype.getVideoTracks || (webkitMediaStream.prototype.getVideoTracks = function() {
            return this.videoTracks
        }
        ,
        webkitMediaStream.prototype.getAudioTracks = function() {
            return this.audioTracks
        }
        );
        webkitRTCPeerConnection.prototype.getLocalStreams || (webkitRTCPeerConnection.prototype.getLocalStreams = function() {
            return this.localStreams
        }
        ,
        webkitRTCPeerConnection.prototype.getRemoteStreams = function() {
            return this.remoteStreams
        }
        )
    } else
        console.log("Browser does not appear to be WebRTC-capable")
}
(function() {
    function f(a, b) {
        function c() {
            return g.config.userName && g.config.userName.length ? g.config.userName : w ? w.slice(0, 5) : "Unknown"
        }
        function f(a) {
            switch (a.type) {
            case "txt":
                if (0 == a.msg.indexOf("/nick ")) {
                    var b = v.getUserById(a.from, a.roomId)
                      , d = a.msg.slice(6);
                    d.length && (b.name = d,
                    b.id == w && (d = Teratek.Viewing.i18n.translate("you"),
                    b.name += " (" + d + ")"));
                    v.dispatchEvent({
                        type: "userListChange",
                        data: a,
                        channelId: a.roomId
                    })
                }
                break;
            case "joinok":
                b = B[a.roomId];
                stderr("joined channel " + a.roomId);
                b.users = a.users && 
                a.users.length ? a.users : [];
                for (d = 0; d < b.users.length; d++)
                    b.users[d].name && b.users[d].name.length || (b.users[d].name = b.users[d].id.slice(0, 5));
                var d = c()
                  , g = Teratek.Viewing.i18n.translate("you")
                  , g = {
                    id: w,
                    name: d + " (" + g + ")",
                    isSelf: !0,
                    status: 0
                };
                b.userSet[w] || (b.users.push(g),
                b.userSet[w] = g);
                0 != g.id.indexOf(d) && v.sendChatMessage("/nick " + d, a.roomId);
                break;
            case "join_error":
                break;
            case "sessionId":
                stderr("Connect successful, your id is: " + a.id);
                w = a.id;
                break;
            case "joined":
                a.userStatus = "joined";
                a.user.name && a.user.name.length || 
                (a.user.name = a.user.id.slice(0, 5));
                a.roomId && ((b = B[a.roomId]) ? (b.users.push(a.user),
                stderr(a.user + " joined room " + a.roomId)) : stderr("Channel " + a.roomId + " does not exist for socket " + w));
                break;
            case "left":
                a.userStatus = "left";
                stderr(a.user + " left room " + a.room);
                for (b in B) {
                    for (var d = B[b].users, g = -1, h = 0; h < d.length; h++)
                        if (d[h].id == a.user) {
                            g = h;
                            break
                        }
                    -1 != g && d.splice(g, 1);
                    delete B[b].userSet[a.user]
                }
                break;
            case "camera":
            case "pointer":
                break;
            default:
                stderr(a)
            }
            v.dispatchEvent({
                type: r[a.type],
                data: a,
                channelId: a.roomId
            })
        }
        function h(a) {
            E < C.length ? (stderr("Connect failed, trying another server..."),
            t.disconnect(),
            t = null ,
            E++,
            v.connect(v.sessionID)) : v.dispatchEvent({
                type: "socketError",
                data: a
            })
        }
        function m(a) {
            v.dispatchEvent({
                type: "socketError",
                data: a
            })
        }
        function q(a) {
            E = 0;
            for (var b in G)
                v.join(b)
        }
        var r = {
            camera: "cameraChange",
            pointer: "pointerMove",
            joystick: "joystick",
            state: "viewerState",
            txt: "chatReceived",
            joinok: "userListChange",
            sessionId: "connectSucceeded",
            joined: "userListChange",
            left: "userListChange",
            "private": "privateMessage",
            join_error: "socketError"
        }, t, w = null , C = Array.isArray(a) ? a : [a], E = 0, G = {}, B = {}, v = this;
        this.connect = function(a) {
            if (!t)
                return "undefined" !== typeof window.WebSocket ? (d || (d = "undefined" !== typeof lmv_io ? lmv_io : io),
                this.sessionID = a,
                t = d.connect(C[E] + "?sessionID=" + a, {
                    path: b,
                    forceNew: !0
                }),
                t.on("connect", q),
                t.on("message", f),
                t.on("connect_error", h),
                t.on("error", m),
                !0) : !1
        }
        ;
        this.join = function(a) {
            t && t.connected ? (delete G[a],
            B[a] = {
                id: a,
                users: [],
                userSet: {}
            },
            t.emit("join", {
                roomId: a,
                name: c()
            })) : G[a] = 1
        }
        ;
        this.disconnect = function() {
            t && 
            (t.disconnect(),
            t = null ,
            B = {},
            w = null )
        }
        ;
        this.sendMessage = function(a, b, c) {
            t.emit("message", {
                type: a,
                from: w,
                msg: b,
                roomId: c
            })
        }
        ;
        this.sendPrivateMessage = function(a, b) {
            t.emit("message", {
                type: "private",
                target: a,
                from: w,
                msg: b
            })
        }
        ;
        this.sendChatMessage = function(a, b) {
            var c = {
                type: "txt",
                from: w,
                msg: a,
                roomId: b
            };
            t.emit("message", c);
            f(c)
        }
        ;
        this.getUserById = function(a, b) {
            for (var c = B[b].users, d = 0; d < c.length; d++)
                if (c[d].id == a)
                    return c[d];
            return null 
        }
        ;
        this.getLocalId = function() {
            return w
        }
        ;
        this.getChannelInfo = function(a) {
            return B[a]
        }
        ;
        this.isConnected = function() {
            return t
        }
    }
    var h = Teratek.Viewing
      , g = h.Private;
    g.config = {
        userName: ""
    };
    g.setUserName = function(a) {
        g.config.userName = a
    }
    ;
    var d;
    f.prototype.constructor = f;
    h.EventDispatcher.prototype.apply(f.prototype);
    var c = {};
    f.GetInstance = function(a, b) {
        a || (a = g.EnvironmentConfigurations[g.env].LMV.RTC);
        Array.isArray(a) || (a = [a]);
        var d = c[a[0]];
        if (d)
            return d;
        d = new g.MessageClient(a,b);
        return c[a[0]] = d
    }
    ;
    Teratek.Viewing.Private.MessageClient = f
}
)();
TeratekNamespace("Teratek.Viewing.Private");
(function() {
    var f = Teratek.Viewing.Private;
    f.P2PClient = function(f) {
        function g(a) {
            try {
                m = new RTCPeerConnection(E),
                m.onicecandidate = function(a) {
                    a.candidate ? n.sendPrivateMessage(r, {
                        type: "candidate",
                        label: a.candidate.sdpMLineIndex,
                        id: a.candidate.sdpMid,
                        candidate: a.candidate.candidate
                    }) : stderr("End of candidates.")
                }
                ,
                m.ondatachannel = function(a) {
                    stderr("Data channel added.");
                    w = a.channel;
                    w.onmessage = b;
                    l.dispatchEvent({
                        type: "dataChannelAdded",
                        data: a.channel
                    })
                }
                ,
                m.onaddstream = function(a) {
                    stderr("Remote stream added.");
                    l.dispatchEvent({
                        type: "remoteStreamAdded",
                        data: a.stream
                    })
                }
                ,
                m.onremovestream = function(a) {
                    stderr("Remote stream removed. Event: ", a);
                    l.dispatchEvent({
                        type: "remoteStreamRemoved",
                        data: a.stream
                    })
                }
                ,
                a && (w = m.createDataChannel("sendDataChannel", {
                    reliable: !1,
                    ordered: !1
                }),
                w.onmessage = b)
            } catch (c) {
                stderr("Failed to create PeerConnection, exception: " + c.message),
                alert("Cannot create RTCPeerConnection object.")
            }
        }
        function d(a) {
            stderr("createOffer() error: ", e)
        }
        function c(a) {
            m.setLocalDescription(a);
            n.sendPrivateMessage(r, 
            a);
            if (C.length) {
                for (a = 0; a < C.length; a++)
                    m.addIceCandidate(C[a]);
                C = []
            }
        }
        function a(a) {
            a = a.split("\n");
            for (var b = !1, c = !1, d = !1, f = 0; f < a.length; f++)
                0 == a[f].indexOf("a=mid:data") && (b = !0),
                0 == a[f].indexOf("a=mid:video") && (d = !0),
                0 == a[f].indexOf("a=mid:audio") && (c = !0);
            return b && !d && !c
        }
        function b(a) {
            a = JSON.parse(a.data);
            switch (a.type) {
            case "camera":
                l.dispatchEvent({
                    type: "cameraChange",
                    data: a
                });
                break;
            case "joystick":
                l.dispatchEvent({
                    type: "joystick",
                    data: a
                });
                break;
            case "state":
                l.dispatchEvent({
                    type: "viewerState",
                    data: a
                })
            }
        }
        function k() {
            q = !1;
            m.close();
            r = t = m = null 
        }
        var l = this, n = f, m, q = !1, r, t, w, C = [], E = {
            iceServers: [{
                url: "stun:stun.l.google.com:19302"
            }]
        }, G = {
            mandatory: {
                OfferToReceiveAudio: !0,
                OfferToReceiveVideo: !0
            }
        }, B = {
            mandatory: {
                OfferToReceiveAudio: !1,
                OfferToReceiveVideo: !1
            }
        };
        n.addEventListener("privateMessage", function(a) {
            var b = a.data.msg;
            stderr("Client received message:" + JSON.stringify(b));
            "offer" != b.type || q ? "answer" === b.type && q ? m.setRemoteDescription(new RTCSessionDescription(b)) : "candidate" === b.type ? (a = new RTCIceCandidate({
                sdpMLineIndex: b.label,
                candidate: b.candidate
            }),
            q ? m.addIceCandidate(a) : C.push(a)) : "bye" === b && q && (l.dispatchEvent({
                type: "remoteHangup",
                data: null 
            }),
            stderr("Session terminated."),
            k()) : (stderr("Received offer. Accepting."),
            l.receiveCall(a.data))
        }
        );
        this.hangup = function() {
            stderr("Hanging up.");
            q && (n.sendPrivateMessage(r, "bye"),
            k())
        }
        ;
        this.initUserMedia = function(a) {
            var b = {
                video: !0,
                audio: !0
            };
            window.getUserMedia(b, function(b) {
                stderr("Adding local stream.");
                a && a(b);
                l.dispatchEvent({
                    type: "localStreamAdded",
                    data: b
                })
            }
            , function(a) {
                stderr("getUserMedia error: ", 
                a)
            }
            );
            stderr("Getting user media with constraints", b)
        }
        ;
        this.callUser = function(a, b) {
            r ? stderr("Already in a call. Ignoring call request.") : (r = a,
            stderr("Calling user " + r),
            b ? (g(!0),
            q = !0,
            stderr("Sending data channel offer to peer"),
            m.createOffer(c, d)) : this.initUserMedia(function(a) {
                t = a;
                q || "undefined" == typeof t || (g(!1),
                m.addStream(t),
                q = !0,
                stderr("Sending audio/video offer to peer"),
                m.createOffer(c, d))
            }
            ))
        }
        ;
        this.receiveCall = function(b) {
            r = b.from;
            r || (r = b.senderId);
            a(b.msg.sdp) ? (g(!0),
            q = !0,
            m.setRemoteDescription(new RTCSessionDescription(b.msg)),
            stderr("Sending data-only answer to peer."),
            m.createAnswer(c, null , B)) : this.initUserMedia(function(a) {
                t = a;
                q || "undefined" == typeof t || (g(!1),
                m.addStream(t),
                q = !0);
                m.setRemoteDescription(new RTCSessionDescription(b.msg));
                stderr("Sending audio+video answer to peer.");
                m.createAnswer(c, null , G)
            }
            )
        }
        ;
        this.getCurrentCallTarget = function() {
            return r
        }
        ;
        this.dataChannel = function() {
            return w
        }
    }
    ;
    f.P2PClient.prototype.constructor = f.P2PClient;
    Teratek.Viewing.EventDispatcher.prototype.apply(f.P2PClient.prototype)
}
)();
(function() {
    function f(f) {
        this.queue = [];
        f.eventCallback && (this.callback = f.eventCallback);
        this.sessionId = f.sessionId;
        if (!this.sessionId) {
            var d = Date.now() + "";
            this.sessionId = parseFloat((1E4 * Math.random() | 0) + "" + d.substring(4))
        }
        this.endpoint = f.endpoint ? f.endpoint + "/logs" : null ;
        this.flushThreshold = f.flushThreshold || 10;
        this.ready = !1;
        this.retries = 0;
        this.lastFlushTime = Date.now();
        this.heartbeat = null ;
        f = {
            category: "viewer_start",
            touch: isTouchDevice(),
            env: h.env,
            referer: window.location.href,
            version: LMV_VIEWER_VERSION
        };
        this.log(f)
    }
    var h = Teratek.Viewing.Private;
    f.prototype.setupWS = function() {
        var f = this;
        f.reconnectPending = !1;
        if (this.endpoint) {
            stderr("Opening web socket.");
            var d = function() {
                f.ready = !0;
                f.lastConnectTime = Date.now();
                stderr("Web socket opened successfully.");
                0 < f.retries && f.socket.send({
                    category: "reconnect",
                    sessionId: this.sessionId
                });
                f.flush()
            }
              , c = function() {
                f.reconnectPending || f.xhr || (f.ready = !1,
                3 > f.retries ? (stderr("Attempting web socket reconnect."),
                f.retries++,
                f.reconnectPending = !0,
                setTimeout(function() {
                    f.setupWS()
                }
                , 
                5E3)) : (stderr("Giving up on web sockets. Trying POST."),
                f.setupXHR()))
            }
              , a = function(a) {
                console.log(a.message);
                c()
            }
              , b = function(a) {
                6E4 < Date.now() - f.lastConnectTime ? (stderr("Web socket closed due to inactivity."),
                f.socket = null ,
                f.ready = !1,
                f.retries = 0) : c()
            }
            ;
            try {
/*                 this.socket = new WebSocket("wss://" + this.endpoint,"lmv-log-v1"), //this.endpoint=""
                this.socket.onopen = d,
                this.socket.onerror = a,
                this.socket.onclose = b,
                this.socket.onmessage = function(a) {
                    console.log(a.data)
                } */
            } catch (h) {
                f.setupXHR()
            }
        }
    }
    ;
    f.prototype.setupXHR = function() {
        this.socket = 
        null ;
        this.xhr = new XMLHttpRequest;
        this.ready = !0;
        this.retries = 0;
        this.flush();
        var f = this;
        this.heartbeat && clearInterval(this.heartbeat);
        this.heartbeat = setInterval(function() {
            f.flush()
        }
        , 6E4);
        "undefined" !== typeof window && window.addEventListener("beforeunload", function() {
            f.log({
                category: "viewer_stop"
            }, !0)
        }
        )
    }
    ;
    f.prototype.flush = function() {
        if (!(2 < this.retries) && this.queue.length && this.ready) {
            var f = this
              , d = this.queue;
            this.queue = [];
            var c = JSON.stringify(d);
            if (this.socket)
                try {
                    this.socket.send(c)
                } catch (a) {}
            else if (this.endpoint)
                try {
                    var b = 
                    this.xhr;
                    b.open("POST", "https://" + this.endpoint, !0);
                    b.send(c);
                    b.onreadystatechange = function() {
                        4 == b.readyState && 200 !== b.status && (f.retries++,
                        f.queue.unshift(d))
                    }
                } catch (h) {}
            else
                stderr(this.queue);
            this.lastFlushTime = Date.now()
        }
    }
    ;
    f.prototype.log = function(f, d) {
        h.offline || (this.callback && this.callback(f),
        2 < this.retries || (f.timestamp = Date.now(),
        f.sessionId = this.sessionId,
        this.queue.push(f),
        this.socket || this.ready ? (this.socket || this.queue.length > this.flushThreshold || 6E4 < f.timestamp - this.lastFlushTime || d) && 
        this.flush() : this.setupWS()))
    }
    ;
    Teratek.Viewing.Private.Logger = f
}
)();
var Autocam = Autocam || function(f, h) {
    function g(a) {
        m = !0;
        f.target.copy(l.center);
        f.pivot.copy(l.pivot);
        f.worldup ? f.worldup.copy(l.sceneUpDirection) : f.up.copy(l.sceneUpDirection);
        l.cameraChangedCallback && l.cameraChangedCallback(a);
        m = !1
    }
    function d(a, b) {
        var c = new THREE.Vector2(0,0);
        c.x = a / window.innerWidth;
        c.y = b / window.innerHeight;
        return c
    }
    function c(a, b, c) {
        var d, f, g, h = 0, k = null , n = null , m = l.snapOrbitDeadZone, q = l.orbitMultiplier;
        "h" == a ? (a = l.snapOrbitThresholdH,
        d = l.snapOrbitAccelerationAX,
        f = l.snapOrbitAccelerationBX,
        g = 1 - l.snapOrbitAccelerationPointX,
        n = l.lockDeltaX,
        k = l.lockedX) : (a = l.snapOrbitThresholdV,
        d = l.snapOrbitAccelerationAY,
        f = l.snapOrbitAccelerationBY,
        g = 1 - l.snapOrbitAccelerationPointY,
        n = l.lockDeltaY,
        k = l.lockedY);
        k ? (n += c,
        n < -m ? h = (n + m) * q * 1 / f : n > m && (h = (n - m) * q * 1 / f)) : (h = Math.abs(b) > a ? c * q : Math.abs(b) > g * a ? 0 < c * b ? c * q * d : c * q * 1 / d : 0 < c * b ? c * q * f : c * q * 1 / f,
        0 < h * b && Math.abs(h) > Math.abs(b) && (this.lockDeltaX = this.lockDeltaY = 0,
        h = b));
        return h
    }
    function a(a, b) {
        var c = !1
          , d = window.innerWidth
          , f = a.x % d
          , g = window.innerHeight
          , h = a.y % g
          , g = 0 < h ? 
        h - b.y : g + h - b.y;
        30 > Math.abs(0 < f ? f - b.x : d + f - b.x) && 30 > Math.abs(g) && (c = !0);
        return c
    }
    function b(a, b, c) {
        if (!N || !a) {
            if (a) {
                var d = new THREE.Vector2;
                d.x = (b.x - c.x) / window.innerWidth;
                b.x = c.x + (b.x - c.x) % window.innerWidth;
                d.y = (b.y - c.y) / window.innerHeight;
                b.y = c.y + (b.y - c.y) % window.innerHeight
            }
            N = a
        }
    }
    function k(a) {
        var b = l.sceneFrontDirection.clone().cross(l.sceneUpDirection)
          , c = Math.abs(Math.abs(a.dot(l.sceneUpDirection)) - 1)
          , d = Math.abs(Math.abs(a.dot(l.sceneFrontDirection)) - 1);
        a = Math.abs(Math.abs(a.dot(b)) - 1);
        return 1E-5 > 
        c || 1E-5 > d || 1E-5 > a
    }
    var l = this
      , n = null 
      , m = !1;
    this.cube = null ;
    this.camera = f;
    this.renderer = "WEBGL";
    this.startState = {};
    this.navApi = h;
    this.orthographicFaces = !1;
    this.canvas = this.pivotDisplayCallback = this.cameraChangedCallback = null ;
    var q = Date.now(), r, t = !1;
    this.dtor = function() {
        this.canvas = this.pivotDisplayCallback = this.cameraChangedCallback = this.cube = null 
    }
    ;
    this.showPivot = function(a) {
        this.pivotDisplayCallback && this.pivotDisplayCallback(a)
    }
    ;
    this.setWorldUpVector = function(a) {
        !m && a && 0 < a.lengthSq() && !a.normalize().equals(this.sceneUpDirection) && 
        (this.sceneUpDirection.copy(a),
        this.sceneFrontDirection.copy(this.getWorldFrontVector()),
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize(),
        this.cube && requestAnimationFrame(this.cube.render))
    }
    ;
    this.getWorldUpVector = function() {
        return this.sceneUpDirection.clone()
    }
    ;
    this.getWorldRightVector = function() {
        var a = this.sceneUpDirection.clone();
        Math.abs(a.z) <= Math.abs(a.y) ? a.set(a.y, -a.x, 0) : 0 <= a.z ? a.set(a.z, 0, -a.x) : a.set(-a.z, 0, a.x);
        return a.normalize()
    }
    ;
    this.getWorldFrontVector = 
    function() {
        return this.getWorldUpVector().cross(this.getWorldRightVector()).normalize()
    }
    ;
    this.goToView = function(a) {
        this.navApi.getIsLocked() || (a = {
            position: a.position.clone(),
            up: a.up.clone(),
            center: a.center.clone(),
            pivot: a.pivot.clone(),
            fov: a.fov,
            worldUp: a.worldUp.clone(),
            isOrtho: a.isOrtho
        },
        l.elapsedTime = 0,
        this.animateTransition(a))
    }
    ;
    this.getCurrentView = function() {
        return {
            position: f.position.clone(),
            up: f.up.clone(),
            center: this.center.clone(),
            pivot: this.pivot.clone(),
            fov: f.fov,
            worldUp: this.sceneUpDirection.clone(),
            isOrtho: !1 === f.isPerspective
        }
    }
    ;
    this.setCurrentViewAsHome = function(a) {
        a ? (this.navApi.setRequestFitToView(!0),
        t = !0) : this.homeVector = this.getCurrentView()
    }
    ;
    this.setHomeViewFrom = function(a) {
        var b = a.pivot ? a.pivot : this.center
          , c = a.target ? a.target : this.pivot
          , d = a.worldup ? a.worldup : this.sceneUpDirection;
        this.homeVector = {
            position: a.position.clone(),
            up: a.up.clone(),
            center: c.clone(),
            pivot: b.clone(),
            fov: a.fov,
            worldUp: d.clone(),
            isOrtho: !1 === a.isPerspective
        };
        this.originalHomeVector = {
            position: a.position.clone(),
            up: a.up.clone(),
            center: c.clone(),
            pivot: b.clone(),
            fov: a.fov,
            worldUp: d.clone(),
            worldFront: this.sceneFrontDirection.clone(),
            isOrtho: !1 === a.isPerspective
        }
    }
    ;
    this.toPerspective = function() {
        f.isPerspective || (f.toPerspective(),
        g(!1))
    }
    ;
    this.toOrthographic = function() {
        f.isPerspective && (f.toOrthographic(),
        g(!1))
    }
    ;
    this.setOrthographicFaces = function(a) {
        this.orthographicFaces = a
    }
    ;
    this.goHome = function() {
        this.navApi.getIsLocked() || (this.navApi.setPivotSetFlag(!1),
        this.goToView(this.homeVector))
    }
    ;
    this.resetHome = function() {
        this.homeVector.position.copy(this.originalHomeVector.position);
        this.homeVector.up.copy(this.originalHomeVector.up);
        this.homeVector.center.copy(this.originalHomeVector.center);
        this.homeVector.pivot.copy(this.originalHomeVector.pivot);
        this.homeVector.fov = this.originalHomeVector.fov;
        this.homeVector.worldUp.copy(this.originalHomeVector.worldUp);
        this.homeVector.isOrtho = this.originalHomeVector.isOrtho;
        this.goHome()
    }
    ;
    this.getView = function() {
        return this.center.clone().sub(f.position)
    }
    ;
    this.setCameraUp = function(a) {
        var b = this.dir.clone()
          , c = b.cross(a).normalize();
        0 === c.lengthSq() && 
        (b.copy(this.dir),
        a.z > a.y ? b.y += 1E-4 : b.z += 1E-4,
        c = b.cross(a).normalize());
        f.up.copy(c).cross(this.dir).normalize()
    }
    ;
    (function ba() {
        requestAnimationFrame(ba);
        var a = Date.now();
        r = a - q;
        q = a
    }
    )();
    this.ortho = !1;
    this.center = f.target ? f.target.clone() : new THREE.Vector3(0,0,0);
    this.pivot = f.pivot ? f.pivot.clone() : this.center.clone();
    this.sceneUpDirection = f.worldup ? f.worldup.clone() : f.up.clone();
    this.sceneFrontDirection = this.getWorldFrontVector();
    this.dir = this.getView();
    this.setCameraUp(f.up);
    this.saveCenter = this.center.clone();
    this.savePivot = this.pivot.clone();
    this.saveEye = f.position.clone();
    this.saveUp = f.up.clone();
    var w, C, E, G;
    this.cubeFront = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
    this.setHomeViewFrom(f);
    var B = new THREE.Quaternion, v = new THREE.Quaternion, D = new THREE.Quaternion, z = new THREE.Quaternion, H, I;
    this.userPanSpeed = .5;
    this.userLookSpeed = 2;
    this.userHeightSpeed = 5;
    this.walkMultiplier = 1;
    this.userZoomSpeed = 1.015;
    this.orbitMultiplier = 5;
    this.currentlyAnimating = !1;
    this.alignOrbitUpDirection = 
    this.preserveOrbitUpDirection = f.keepSceneUpright = !0;
    this.doCustomOrbit = this.constrainOrbitVertical = this.constrainOrbitHorizontal = !1;
    this.snapOrbitDeadZone = .045;
    this.snapOrbitThresholdH = this.snapOrbitThresholdV = THREE.Math.degToRad(15);
    this.snapOrbitAccelerationAX = this.snapOrbitAccelerationAY = 1.5;
    this.snapOrbitAccelerationBX = this.snapOrbitAccelerationBY = 2;
    this.snapOrbitAccelerationPointX = this.snapOrbitAccelerationPointY = .5;
    this.alignDirTable = Array(26);
    this.alignDirTable[0] = new THREE.Vector3(-1,0,0);
    this.alignDirTable[1] = new THREE.Vector3(1,0,0);
    this.alignDirTable[2] = new THREE.Vector3(0,-1,0);
    this.alignDirTable[3] = new THREE.Vector3(0,1,0);
    this.alignDirTable[4] = new THREE.Vector3(0,0,-1);
    this.alignDirTable[5] = new THREE.Vector3(0,0,1);
    this.alignDirTable[6] = new THREE.Vector3(-1,-1,0);
    this.alignDirTable[7] = new THREE.Vector3(-1,1,0);
    this.alignDirTable[8] = new THREE.Vector3(1,-1,0);
    this.alignDirTable[9] = new THREE.Vector3(1,1,0);
    this.alignDirTable[10] = new THREE.Vector3(0,-1,-1);
    this.alignDirTable[11] = 
    new THREE.Vector3(0,-1,1);
    this.alignDirTable[12] = new THREE.Vector3(0,1,-1);
    this.alignDirTable[13] = new THREE.Vector3(0,1,1);
    this.alignDirTable[14] = new THREE.Vector3(-1,0,-1);
    this.alignDirTable[15] = new THREE.Vector3(1,0,-1);
    this.alignDirTable[16] = new THREE.Vector3(-1,0,1);
    this.alignDirTable[17] = new THREE.Vector3(1,0,1);
    this.alignDirTable[18] = new THREE.Vector3(-1,-1,-1);
    this.alignDirTable[19] = new THREE.Vector3(-1,-1,1);
    this.alignDirTable[20] = new THREE.Vector3(-1,1,-1);
    this.alignDirTable[21] = new THREE.Vector3(-1,
    1,1);
    this.alignDirTable[22] = new THREE.Vector3(1,-1,-1);
    this.alignDirTable[23] = new THREE.Vector3(1,-1,1);
    this.alignDirTable[24] = new THREE.Vector3(1,1,-1);
    this.alignDirTable[25] = new THREE.Vector3(1,1,1);
    this.useSnap = this.combined = !1;
    this.lockDeltaX = 0;
    this.lockedX = !1;
    this.lockDeltaY = this.lastSnapRotateX = 0;
    this.lockedY = !1;
    this.lastSnapRotateY = 0;
    this.lastSnapDir = new THREE.Vector3(0,0,0);
    this.bottomLimit = this.topLimit = !1;
    this.maxSceneBound = this.minSceneBound = 0;
    var J = {
        destinationPercent: 1,
        duration: 1,
        zoomToFitScene: !0,
        useOffAxis: !1
    };
    this.shotParams = J;
    var L, F;
    this.zoomDelta = new THREE.Vector2;
    var N, K = new THREE.Vector3, M = new THREE.Vector3;
    this.rewindParams = {
        history: [],
        startTime: void 0,
        thumbnailSize: 56,
        thumbnailGapSize: 12,
        maxHistorySize: 25,
        snappingEnabled: !0,
        timelineIndex: 0,
        timelineIndexSlide: 0,
        open: !1,
        openLocation: new THREE.Vector2(0,0),
        openBracket: new THREE.Vector2(0,0),
        openBracketA: new THREE.Vector2(0,0),
        openBracketB: new THREE.Vector2(0,0),
        openLocationOrigin: new THREE.Vector2(0,0),
        locationOffset: new THREE.Vector2(0,
        0),
        snapOffset: new THREE.Vector2(0,0),
        slideOffset: new THREE.Vector2(0,0),
        snapped: !0,
        resetWeights: !1,
        recordEnabled: !1,
        elementIsRecording: !1
    };
    this.viewCubeMenuOpen = !1;
    this.menuSize = new THREE.Vector2(0,0);
    this.menuOrigin = new THREE.Vector2(0,0);
    f.lookAt(this.center);
    this.setCube = function(a) {
        this.cube = a
    }
    ;
    this.loadObject = function(a, b, c) {
        loader = new THREE.JSONLoader;
        loader.load(a, function(a, d) {
            var f = new THREE.MeshPhongMaterial(d);
            mesh = new THREE.Mesh(a,f);
            mesh.scale = b;
            mesh.position.copy(c);
            mesh.geometry.computeBoundingBox();
            f = mesh.geometry.boundingBox.clone();
            M.set(f.max.x, f.max.y, f.max.z);
            K.set(f.min.x, f.min.y, f.min.z);
            M.multiply(b);
            K.multiply(b);
            scene.add(mesh);
            objects.push(mesh)
        }
        )
    }
    ;
    this.sync = function(a) {
        a.isPerspective !== f.isPerspective && (a.isPerspective ? f.toPerspective() : (f.toOrthographic(),
        a.saveFov && (f.saveFov = a.saveFov)));
        f.fov = a.fov;
        f.position.copy(a.position);
        a.target && (this.center.copy(a.target),
        f.target.copy(a.target));
        a.pivot && (this.pivot.copy(a.pivot),
        f.pivot.copy(a.pivot));
        this.dir.copy(this.center).sub(f.position);
        this.setCameraUp(a.up);
        a = a.worldup ? a.worldup : a.up;
        1E-4 < a.distanceToSquared(this.sceneUpDirection) && this.setWorldUpVector(a);
        t && !this.navApi.getTransitionActive() && (t = !1,
        this.setCurrentViewAsHome(!1));
        this.cube && requestAnimationFrame(this.cube.render)
    }
    ;
    this.refresh = function() {
        this.cube && this.cube.refreshCube()
    }
    ;
    THREE.Box2.prototype.setCenter = function(a) {
        var b = new THREE.Vector2(Math.abs(this.max.x - this.min.x) / 2,Math.abs(this.max.y - this.min.y) / 2);
        this.min.copy(a).sub(b);
        this.max.copy(a).add(b);
        return this
    }
    ;
    THREE.Box2.prototype.getIcon2DCoords = function(a, b) {
        var c = this.center;
        b.set((a.x - c.x) / (this.size().x / 2), (a.y - c.y) / (this.size().y / 2))
    }
    ;
    THREE.Matrix3.prototype.makeRotationFromQuaternion = function(a) {
        var b = this.elements
          , c = a.x
          , d = a.y
          , f = a.z
          , g = a.w
          , h = c + c
          , k = d + d
          , l = f + f;
        a = c * h;
        var n = c * k
          , c = c * l
          , m = d * k
          , d = d * l
          , f = f * l
          , h = g * h
          , k = g * k
          , g = g * l;
        b[0] = 1 - (m + f);
        b[3] = n - g;
        b[6] = c + k;
        b[1] = n + g;
        b[4] = 1 - (a + f);
        b[7] = d - h;
        b[2] = c - k;
        b[5] = d + h;
        b[8] = 1 - (a + m);
        return this
    }
    ;
    THREE.Quaternion.prototype.setFromRotationMatrix3 = function(a) {
        var b = a.elements
          , 
        c = b[0];
        a = b[3];
        var d = b[6]
          , f = b[1]
          , g = b[4]
          , h = b[7]
          , k = b[2]
          , l = b[5]
          , b = b[8]
          , n = c + g + b;
        0 < n ? (c = .5 / Math.sqrt(n + 1),
        this.w = .25 / c,
        this.x = (l - h) * c,
        this.y = (d - k) * c,
        this.z = (f - a) * c) : c > g && c > b ? (c = 2 * Math.sqrt(1 + c - g - b),
        this.w = (l - h) / c,
        this.x = .25 * c,
        this.y = (a + f) / c,
        this.z = (d + k) / c) : g > b ? (c = 2 * Math.sqrt(1 + g - c - b),
        this.w = (d - k) / c,
        this.x = (a + f) / c,
        this.y = .25 * c,
        this.z = (h + l) / c) : (c = 2 * Math.sqrt(1 + b - c - g),
        this.w = (f - a) / c,
        this.x = (d + k) / c,
        this.y = (h + l) / c,
        this.z = .25 * c);
        return this
    }
    ;
    THREE.Quaternion.prototype.rotate = function(a) {
        var b = (new THREE.Matrix4).makeRotationFromQuaternion(this).elements
          , 
        b = (new THREE.Matrix3).set(b[0], b[1], b[2], b[4], b[5], b[6], b[8], b[9], b[10]);
        return a.applyMatrix3(b)
    }
    ;
    THREE.Vector3.prototype.findAngleWith = function(a, b) {
        var c = 0
          , d = this.clone().normalize().clone().dot(a.clone().normalize())
          , c = this.clone().cross(a).clone().normalize();
        if (c.clone().length() < Number.MIN_VALUE)
            c = 0 < d ? 0 : 180;
        else {
            b = 0 < c.clone().dot(b.clone().normalize()) ? c : -c;
            var f = (new THREE.Quaternion).setFromAxisAngle(b, 90 * THREE.Math.degToRad)
              , f = f.clone().rotate(a).clone().normalize().clone().dot(this)
              , c = 
            Math.acos(d) * THREE.Math.radToDeg;
            Math.abs(c - 90) < Number.MIN_VALUE && (c = 90);
            if (90 > c && 0 < d * f || 90 < c && 0 > d * f || 90 == c && 0 < f)
                c *= -1
        }
        return c = THREE.Math.degToRad(c)
    }
    ;
    "contains" in String.prototype || (String.prototype.contains = function(a, b) {
        return -1 !== String.prototype.indexOf.call(this, a, b)
    }
    );
    Math.linearClamp = function(a, b, c) {
        return a <= b ? 0 : a >= c ? 1 : (a - b) / (c - b)
    }
    ;
    Math.easeClamp = function(a, b, c) {
        return a <= b ? 0 : a >= c ? 1 : .5 * (Math.sin(((a - b) / (c - b) - .5) * Math.PI) + 1)
    }
    ;
    Math.linearInterp = function(a, b, c) {
        return b * (1 - a) + c * a
    }
    ;
    Math.equalityClamp = 
    function(a, b, c) {
        return a <= b ? b : a >= c ? c : a
    }
    ;
    Math.round2 = function(a) {
        return Math.round(100 * a) / 100
    }
    ;
    Math.round1 = function(a) {
        return Math.round(10 * a) / 10
    }
    ;
    this.animateTransition = function(a) {
        if (a) {
            var b = !1
              , c = 0;
            this.setCameraOrtho(a.isOrtho);
            if (l.elapsedTime >= J.duration)
                c = 1,
                l.center.copy(a.center),
                l.pivot.copy(a.pivot),
                f.position.copy(a.position),
                f.up.copy(a.up),
                a.isOrtho || (f.fov = a.fov),
                (b = !a.worldUp.equals(this.sceneUpDirection)) && this.setWorldUpVector(a.worldUp),
                this.currentlyAnimating = !1,
                g(b),
                this.showPivot(!1),
                this.cube && requestAnimationFrame(this.cube.render),
                this.addHistoryElement(),
                this.navApi.setTransitionActive(!1);
            else {
                this.currentlyAnimating = !0;
                this.showPivot(!0);
                this.navApi.setTransitionActive(!0);
                c = Math.easeClamp(l.elapsedTime / J.duration, 0, J.destinationPercent);
                oneMinusTime = 1 - c;
                l.elapsedTime += r / 500;
                var b = l.center.clone().multiplyScalar(oneMinusTime).add(a.center.clone().multiplyScalar(c))
                  , d = f.position.clone().multiplyScalar(oneMinusTime).add(a.position.clone().multiplyScalar(c))
                  , h = f.up.clone().multiplyScalar(oneMinusTime).add(a.up.clone().multiplyScalar(c))
                  , 
                k = f.pivot.clone().multiplyScalar(oneMinusTime).add(a.pivot.clone().multiplyScalar(c))
                  , n = this.sceneUpDirection.clone().multiplyScalar(oneMinusTime).add(a.worldUp.clone().multiplyScalar(c))
                  , c = f.fov * oneMinusTime + a.fov * c;
                l.center.copy(b);
                l.pivot.copy(k);
                f.position.copy(d);
                f.up.copy(h);
                a.isOrtho || (f.fov = c);
                (b = 1E-4 < n.distanceToSquared(this.sceneUpDirection)) && this.setWorldUpVector(n);
                f.lookAt(l.center);
                g(b);
                this.cube && requestAnimationFrame(this.cube.render);
                requestAnimationFrame(function() {
                    l.animateTransition(a)
                }
                )
            }
        }
    }
    ;
    this.sphericallyInterpolateTransition = function(a) {
        var b, c, d;
        b = 0;
        this.currentlyAnimating = !0;
        this.navApi.setTransitionActive(!0);
        l.elapsedTime >= J.duration ? (b = 1,
        this.currentlyAnimating = !1) : (b = Math.easeClamp(l.elapsedTime / J.duration, 0, J.destinationPercent),
        l.elapsedTime += r / 500);
        1 === b ? (c = F.position,
        b = F.center,
        d = F.up) : (d = new THREE.Matrix3,
        c = B.clone(),
        c.slerp(v, b),
        d.makeRotationFromQuaternion(c),
        c = Math.linearInterp(b, H, I),
        d = d.elements,
        b = L.center.clone().multiplyScalar(1 - b).add(F.center.clone().multiplyScalar(b)),
        c = b.clone().sub((new THREE.Vector3(d[0],d[1],d[2])).multiplyScalar(c)),
        d = new THREE.Vector3(d[3],d[4],d[5]));
        l.center.copy(b);
        f.position.copy(c);
        f.up.copy(d);
        l.navApi.getUsePivotAlways() || l.pivot.copy(b);
        f.lookAt(l.center);
        !0 === this.currentlyAnimating ? (this.showPivot(!0),
        requestAnimationFrame(function() {
            l.sphericallyInterpolateTransition(a)
        }
        )) : (this.navApi.setTransitionActive(!1),
        this.showPivot(!1),
        this.addHistoryElement(),
        this.orthographicFaces && this.isFaceView() && this.setCameraOrtho(!0),
        a && a());
        g(!1);
        this.cube && requestAnimationFrame(this.cube.render)
    }
    ;
    this.getOrientation = function() {
        if (this.cube) {
            var a = Math.round1(f.up.x)
              , b = Math.round1(f.up.y)
              , c = Math.round1(f.up.z)
              , d = this.sceneFrontDirection.clone()
              , g = this.sceneUpDirection.clone()
              , h = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
            d.x = Math.round1(d.x);
            d.y = Math.round1(d.y);
            d.z = Math.round1(d.z);
            g.x = Math.round1(g.x);
            g.y = Math.round1(g.y);
            g.z = Math.round1(g.z);
            h.x = Math.round1(h.x);
            h.y = Math.round1(h.y);
            h.z = Math.round1(h.z);
            var k = h.clone().multiplyScalar(-1)
              , l = g.clone().multiplyScalar(-1)
              , n = d.clone().multiplyScalar(-1);
            switch (this.cube.currentFace) {
            case "front":
                if (g.x == a && g.y == b && g.z == c)
                    return "up";
                if (l.x == a && l.y == b && l.z == c)
                    return "down";
                if (h.x == a && h.y == b && h.z == c)
                    return "right";
                if (k.x == a && k.y == b && k.z == c)
                    return "left";
                break;
            case "right":
                if (g.x == a && g.y == b && g.z == c)
                    return "up";
                if (l.x == a && l.y == b && l.z == c)
                    return "down";
                if (n.x == a && n.y == b && n.z == c)
                    return "left";
                if (d.x == a && d.y == b && d.z == c)
                    return "right";
                break;
            case "left":
                if (g.x == a && g.y == 
                b && g.z == c)
                    return "up";
                if (l.x == a && l.y == b && l.z == c)
                    return "down";
                if (d.x == a && d.y == b && d.z == c)
                    return "left";
                if (n.x == a && n.y == b && n.z == c)
                    return "right";
                break;
            case "back":
                if (g.x == a && g.y == b && g.z == c)
                    return "up";
                if (l.x == a && l.y == b && l.z == c)
                    return "down";
                if (k.x == a && k.y == b && k.z == c)
                    return "right";
                if (h.x == a && h.y == b && h.z == c)
                    return "left";
                break;
            case "top":
                if (n.x == a && n.y == b && n.z == c)
                    return "down";
                if (d.x == a && d.y == b && d.z == c)
                    return "up";
                if (h.x == a && h.y == b && h.z == c)
                    return "right";
                if (k.x == a && k.y == b && k.z == c)
                    return "left";
                break;
            case "bottom":
                if (d.x == 
                a && d.y == b && d.z == c)
                    return "down";
                if (n.x == a && n.y == b && n.z == c)
                    return "up";
                if (h.x == a && h.y == b && h.z == c)
                    return "right";
                if (k.x == a && k.y == b && k.z == c)
                    return "left"
            }
        }
    }
    ;
    this.setCameraOrtho = function(a) {
        a && f.isPerspective && f.toOrthographic();
        a || f.isPerspective || f.toPerspective()
    }
    ;
    this.resetOrientation = function() {
        this.setCameraOrtho(this.originalHomeVector.isOrtho);
        this.sceneUpDirection.copy(this.originalHomeVector.worldUp);
        this.sceneFrontDirection.copy(this.originalHomeVector.worldFront);
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        this.setCameraUp(this.sceneUpDirection);
        g(!0)
    }
    ;
    this.setCurrentViewAsFront = function() {
        this.cube && (this.cube.currentFace = "front");
        this.sceneUpDirection.copy(f.up.clone());
        this.sceneFrontDirection.copy(this.getView()).normalize();
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        this.orthographicFaces && this.setCameraOrtho(!0);
        g(!0)
    }
    ;
    this.setCurrentViewAsTop = function() {
        this.cube && (this.cube.currentFace = "top");
        this.sceneUpDirection.copy(this.getView()).multiplyScalar(-1).normalize();
        this.sceneFrontDirection.copy(f.up);
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        g(!0)
    }
    ;
    this.calculateCubeTransform = function(a) {
        var b = this.sceneUpDirection.clone()
          , c = this.sceneFrontDirection.clone()
          , d = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
        L = f.clone();
        L.center = l.center.clone();
        L.pivot = l.pivot.clone();
        F = f.clone();
        F.center = l.center.clone();
        F.pivot = l.pivot.clone();
        var g = new THREE.Vector3(0,0,0);
        a.contains("back") && (g = g.add(c));
        a.contains("front") && (g = g.sub(c));
        a.contains("top") && (g = g.add(b));
        a.contains("bottom") && (g = g.sub(b));
        a.contains("right") && (g = g.add(d));
        a.contains("left") && (g = g.sub(d));
        a = b;
        var h = g.clone().normalize();
        if (1 - Math.abs(h.dot(b)) < Number.MIN_VALUE)
            for (var k = this.getView().normalize(), c = [c.clone(), c.clone().negate(), d.clone(), d.clone().negate()], b = 0 < h.dot(b) ? 1 : -1, k = k.clone().add(f.up.clone().multiplyScalar(b)).normalize(), d = -2, h = 0; 4 > h; h++) {
                var n = k.dot(c[h]);
                n > d && (d = n,
                a = c[h].multiplyScalar(b))
            }
        I = H = this.getView().length();
        F.position.copy(F.center.clone().add(g.multiplyScalar(I / g.length())));
        F.up.copy(a);
        g = L.center.clone().sub(L.position).normalize();
        a = g.clone().cross(L.up).normalize();
        c = a.clone().cross(g).normalize();
        b = new THREE.Matrix3;
        b.set(g.x, c.x, a.x, g.y, c.y, a.y, g.z, c.z, a.z);
        B.setFromRotationMatrix3(b);
        g = F.center.clone().sub(F.position).normalize();
        a = g.clone().cross(F.up).normalize();
        c = a.clone().cross(g).normalize();
        b.set(g.x, c.x, a.x, g.y, c.y, a.y, g.z, c.z, a.z);
        D.setFromAxisAngle(g, 0);
        z.setFromAxisAngle(c, 0);
        v.setFromRotationMatrix3(b);
        v.multiply(D).multiply(z).normalize()
    }
    ;
    this.centerShot = function(a) {
        if (!L || a)
            l.elapsedTime = 0,
            L = F = f.clone(),
            L.center = l.center;
        a = l.pivot.clone();
        var b = a.clone().sub(L.position)
          , c = L.center.clone().sub(L.position).normalize()
          , d = L.up.clone()
          , h = c.clone().cross(d).normalize()
          , d = h.clone().cross(c).normalize()
          , c = h.clone().multiplyScalar(h.dot(b))
          , b = d.clone().multiplyScalar(d.dot(b))
          , b = c.clone().add(b);
        F.position.copy(L.position.clone().add(b));
        F.center = a;
        F.pivot = a;
        a = 0;
        l.elapsedTime >= J.duration ? a = 1 : (a = Math.easeClamp(l.elapsedTime / 
        J.duration, 0, J.destinationPercent),
        l.elapsedTime += r / 2E3);
        b = f.position.clone().multiplyScalar(1 - a).add(F.position.clone().multiplyScalar(a));
        d = l.center.clone().multiplyScalar(1 - a).add(F.center.clone().multiplyScalar(a));
        c = l.pivot.clone().multiplyScalar(1 - a).add(F.pivot.clone().multiplyScalar(a));
        f.position.copy(b);
        l.center.copy(d);
        l.pivot.copy(c);
        f.lookAt(l.center);
        g(!1);
        1 === a ? this.addHistoryElement() : requestAnimationFrame(function() {
            l.centerShot(!1)
        }
        )
    }
    ;
    this.levelShot = function() {
        var a = this.getView()
          , 
        b = a.length()
          , c = this.sceneUpDirection.clone()
          , d = f.up.clone().normalize()
          , a = a.normalize()
          , g = a.dot(c);
        1 - Math.abs(g) > Number.MIN_VALUE ? (d = a.clone().cross(c),
        a = c.clone().cross(d),
        a.normalize()) : a = d.clone();
        a.multiplyScalar(b);
        b = {
            center: a.add(f.position),
            up: c,
            position: f.position,
            pivot: l.center.clone().add(a),
            fov: f.fov,
            worldUp: c
        };
        l.elapsedTime = 0;
        l.animateTransition(b)
    }
    ;
    this.fitToWindow = function() {
        var a = this.getView()
          , b = f.up.clone();
        a.normalize();
        b.normalize();
        F = f.clone();
        F.center = l.center;
        var c = b
          , b = c.clone();
        if (!(Math.abs(b.clone().dot(a)) < Number.MIN_VALUE) && (a.normalize(),
        b = c.clone().dot(a),
        b = a.clone().multiplyScalar(b),
        b = c.clone().sub(b),
        b.length() < Number.MIN_VALUE)) {
            for (var c = new THREE.Vector3(0,0,0), b = [new THREE.Vector3(0,1,0), new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,1,1), new THREE.Vector3(1,0,1), new THREE.Vector3(1,1,0), new THREE.Vector3(1,1,1)], d = 0; 7 > d; d++)
                if (Math.abs(b[d].dot(a)) < Number.MIN_VALUE) {
                    c = b[d];
                    break
                }
            b = c
        }
        b.normalize();
        b.normalize();
        F.up.copy(b);
        d = a.clone().cross(b);
        d.normalize();
        var g = K.clone()
          , h = M.clone()
          , k = [g, h]
          , c = new THREE.Vector3(h.x - g.x,h.y - g.y,h.z - g.z);
        k[2] = new THREE.Vector3(h.x,g.y,h.z);
        k[3] = new THREE.Vector3(h.x,g.y,g.z);
        k[4] = new THREE.Vector3(h.x,h.y,g.z);
        k[5] = new THREE.Vector3(g.x,h.y,h.z);
        k[6] = new THREE.Vector3(g.x,h.y,g.z);
        k[7] = new THREE.Vector3(g.x,g.y,h.z);
        for (g = 0; 8 > g; g++)
            h = k[g].clone().sub(f.position),
            k[g].setX(h.clone().dot(d)),
            k[g].setY(h.clone().dot(b)),
            k[g].setZ(h.clone().dot(a));
        var g = THREE.Math.degToRad(f.topFov), h = THREE.Math.degToRad(f.bottomFov), 
        n = THREE.Math.degToRad(f.leftFov), m = THREE.Math.degToRad(f.rightFov), q, r, B, z;
        q = 0 <= n ? Number.MAX_VALUE : Number.MIN_VALUE;
        r = 0 <= m ? Number.MAX_VALUE : Number.MIN_VALUE;
        B = 0 <= g ? Number.MAX_VALUE : Number.MIN_VALUE;
        z = 0 <= h ? Number.MAX_VALUE : Number.MIN_VALUE;
        for (var t = 1 / Math.tan(m), v = -1 / Math.tan(n), w = 1 / Math.tan(g), C = -1 / Math.tan(h), G = 0; 8 > G; G++) {
            var D = k[G].clone()
              , E = D.z - v * D.x;
            q = 0 <= n ? Math.min(q, E) : Math.max(q, E);
            E = D.z - t * D.x;
            r = 0 <= m ? Math.min(r, E) : Math.max(r, E);
            E = D.z - w * D.y;
            B = 0 <= g ? Math.min(B, E) : Math.max(B, E);
            E = D.z - C * D.y;
            z = 0 <= 
            h ? Math.min(z, E) : Math.max(z, E)
        }
        k = (r - q) / (v - t);
        q = v * k + q;
        z = (z - B) / (w - C);
        B = w * z + B;
        w = 0;
        q <= B ? (g = (g - h) / 2,
        Math.abs(g) > Number.MIN_VALUE && (g = 1 / Math.tan(g),
        z = z - B / g + q / g),
        w = q) : (g = (m - n) / 2,
        Math.abs(g) > Number.MIN_VALUE && (g = 1 / Math.tan(g),
        k = k - q / g + B / g),
        w = B);
        g = new THREE.Vector3(k,z,w);
        d = d.clone().multiplyScalar(g.x);
        b = b.clone().multiplyScalar(g.y);
        g = a.clone().multiplyScalar(g.z);
        g = d.clone().add(b.clone().add(g));
        F.position.add(g);
        b = c.clone().sub(F.position).dot(a);
        F.center = F.position.clone().add(a.multiplyScalar(b));
        F.pivot = 
        c.clone();
        a = {
            center: F.center,
            up: F.up,
            position: F.position,
            pivot: F.pivot,
            fov: f.fov,
            worldUp: l.sceneUpDirection.clone()
        };
        l.elapsedTime = 0;
        l.animateTransition(a)
    }
    ;
    this.updatePivotPosition = function(a) {
        var b;
        b = new THREE.Vector3(a.x / window.innerWidth * 2 - 1,2 * -(a.y / window.innerHeight) + 1,.5);
        b = b.unproject(f);
        b = (new THREE.Raycaster(f.position,b.sub(f.position).normalize())).intersectObjects(objects);
        if ("zoom" == l.mode)
            if (void 0 !== b[0])
                a = b[0].point,
                l.pivot.copy(a);
            else {
                a.y = Math.abs(a.y - window.innerHeight);
                var c = 
                f.position;
                b = l.center.clone().sub(c);
                var d = f.up
                  , g = b.clone().cross(d)
                  , h = b.clone().length()
                  , k = h * Math.tan(THREE.Math.degToRad(f.leftFov))
                  , n = h * Math.tan(THREE.Math.degToRad(f.rightFov))
                  , m = h * Math.tan(THREE.Math.degToRad(f.topFov))
                  , h = h * Math.tan(THREE.Math.degToRad(f.bottomFov))
                  , k = a.x * (k + n) / window.innerWidth - k;
                a = a.y * (m + h) / window.innerHeight - h;
                d = d.clone().normalize().clone().multiplyScalar(a);
                g = g.clone().normalize().clone().multiplyScalar(k);
                l.ortho ? a = c.clone().add(g).clone().add(d) : (a = c,
                b = b.clone().add(d).clone().add(g));
                l.pivot.copy(a.clone().add(b))
            }
        else
            void 0 !== b[0] ? (wheel.cursorImage("pivot"),
            a = b[0].point,
            l.isMouseDown || l.pivot.copy(a)) : wheel.cursorImage("SWInvalidArea")
    }
    ;
    this.onDrawHeight = function(a, b, c, d, g) {
        a = new THREE.Vector3(0,1,0);
        a = f.position.clone().dot(a);
        Math.linearClamp(a, l.minSceneBound, l.maxSceneBound)
    }
    ;
    this.drawDropdownMenu = function(a, b, c, d, f, g, h) {
        var k = 0;
        if (n)
            g.appendChild(n);
        else {
            n = document.createElement("div");
            n.className = "dropDownMenu";
            n.style.top = "100px";
            n.style.left = "-400px";
            for (var l = 0, m = 
            0, q = 0; q < a.length; q++) {
                var r;
                if (null  === a[q])
                    r = document.createElement("li"),
                    r.style.height = "1px",
                    l += 1,
                    r.style.backgroundColor = "#E0E0E0";
                else {
                    var B = Teratek.Viewing.i18n.translate(a[q])
                      , m = B.length > m ? B.length : m;
                    if (c[q]) {
                        r = document.createElement("div");
                        var z = document.createElement("input")
                          , t = document.createElement("label");
                        z.type = "radio";
                        z.className = "dropDownMenuCheck";
                        t.innerHTML = B;
                        t.className = "dropDownMenuCheckText";
                        r.appendChild(z);
                        r.appendChild(t);
                        r.className = "dropDownMenuCheckbox"
                    } else
                        r = document.createElement("li"),
                        r.textContent = B,
                        r.className = b[q] ? "dropDownMenuItem" : "dropDownMenuItemDisabled";
                    r.id = "menuItem" + k;
                    k++;
                    l += 25;
                    r.setAttribute("data-i18n", a[q])
                }
                n.appendChild(r)
            }
            g.appendChild(n);
            n.style.minWidth = Math.max(256, 7.4 * m) + "px";
            k = n.getBoundingClientRect().width;
            this.menuSize.x = k;
            this.menuSize.y = l
        }
        for (q = k = 0; q < a.length; q++)
            null  !== a[q] && (c[q] && (l = document.getElementById("menuItem" + k)) && (l.children[0].checked = c[q]()),
            k++);
        a = f - 15;
        c = d + 1;
        f = this.canvas.getBoundingClientRect();
        c + this.menuSize.x > f.right && (c = d - this.menuSize.x - 
        1);
        a + this.menuSize.y > f.bottom && (a = f.bottom - this.menuSize.y);
        a -= h.y;
        c -= h.x;
        n.style.top = a + "px";
        n.style.left = c + "px";
        this.menuOrigin.x = c;
        this.menuOrigin.y = a
    }
    ;
    this.removeDropdownMenu = function(a) {
        a.removeChild(n)
    }
    ;
    this.isFaceView = function() {
        var a = this.center.clone().sub(f.position).normalize();
        return k(a) && k(f.up)
    }
    ;
    this.startInteraction = function(a, b) {
        this.startCursor = new THREE.Vector2(a,b);
        this.startState = {
            saveCenter: this.center.clone(),
            saveEye: this.camera.position.clone(),
            savePivot: this.pivot.clone(),
            saveUp: this.camera.up.clone()
        };
        this.lockDeltaX = 0;
        this.lockedX = !1;
        this.lockDeltaY = this.lastSnapRotateX = 0;
        this.lockedY = !1;
        this.lastSnapRotateY = 0;
        this.lastSnapDir = new THREE.Vector3(0,0,0)
    }
    ;
    this.orbit = function(a, b, h, k) {
        if (!this.navApi.getIsLocked() && !0 !== this.currentlyAnimating) {
            var n = "wheel";
            l.orthographicFaces && !f.isPerspective && (f.toPerspective(),
            k && k.saveEye.copy(this.camera.position));
            k && (n = "cube");
            "cube" == n ? (this.saveCenter.copy(k.saveCenter),
            this.saveEye.copy(k.saveEye),
            this.savePivot.copy(k.savePivot),
            this.saveUp.copy(k.saveUp),
            this.doCustomOrbit = this.useSnap = !0) : (this.saveCenter.copy(this.center),
            this.savePivot.copy(this.pivot),
            this.saveEye.copy(f.position),
            this.saveUp.copy(f.up),
            this.doCustomOrbit = this.useSnap = !1);
            l.combined && void 0 == C && (C = this.saveCenter.clone(),
            w = this.saveEye.clone(),
            G = this.savePivot.clone(),
            E = this.saveUp.clone());
            if (this.preserveOrbitUpDirection) {
                var n = d(a.x - b.x, a.y - b.y)
                  , m = d(h.x, h.y);
                b = this.sceneUpDirection.clone();
                var q = this.sceneFrontDirection.clone()
                  , r = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
                h = l.combined ? G : this.savePivot;
                k = l.combined ? w : this.saveEye;
                var B = l.combined ? C : this.saveCenter
                  , z = l.combined ? E : this.saveUp
                  , t = h.clone().sub(k).normalize()
                  , v = B.clone().sub(k).normalize()
                  , K = v.clone().cross(z);
                a = k.clone().sub(h).length();
                k = k.clone().sub(B).length();
                t = t.clone().multiplyScalar(-1);
                v = v.clone().multiplyScalar(-1);
                z = z.clone();
                this.constrainOrbitHorizontal || (-.009 > b.dot(this.saveUp) && (n.x = -n.x,
                m.x = -m.x),
                B = 0,
                this.lastSnapRotateX = B = l.combined ? m.x * this.orbitMultiplier : this.useSnap ? this.lastSnapRotateX + 
                c("h", 0, -m.x) : n.x * this.orbitMultiplier,
                B = (new THREE.Quaternion).setFromAxisAngle(b, -B),
                t.applyQuaternion(B),
                v.applyQuaternion(B),
                K.applyQuaternion(B),
                z.applyQuaternion(B));
                this.constrainOrbitVertical || (q = q.clone().multiplyScalar(q.dot(K)),
                r = r.clone().multiplyScalar(r.dot(K)),
                r = q.clone().add(r),
                r.clone().normalize(),
                K = 0,
                l.combined ? K = m.y * this.orbitMultiplier : (m = c("v", 0, m.y),
                K = this.useSnap ? this.lastSnapRotateY + m : n.y * this.orbitMultiplier),
                n = (new THREE.Quaternion).setFromAxisAngle(r, -K),
                this.navApi.getOrbitPastWorldPoles() || 
                (m = z.clone(),
                m.applyQuaternion(n).normalize(),
                0 > b.dot(m) && (m = v.clone(),
                m.applyQuaternion(n).normalize(),
                b = m.angleTo(b),
                Math.abs(b) > .5 * Math.PI && (b -= 0 < b ? Math.PI : -Math.PI),
                K -= b,
                n.setFromAxisAngle(r, -K))),
                t.applyQuaternion(n).normalize(),
                v.applyQuaternion(n).normalize(),
                z.applyQuaternion(n).normalize(),
                this.lastSnapRotateY = K);
                h = t.multiplyScalar(a).add(h);
                f.position.copy(h);
                f.up.copy(z);
                this.center.copy(h);
                this.center.sub(v.multiplyScalar(k));
                l.combined && (C.copy(this.center),
                w.copy(f.position),
                G.copy(this.pivot),
                E.copy(f.up))
            }
            f.lookAt(this.center);
            g(!1)
        }
    }
    ;
    this.endInteraction = function() {}
    ;
    this.look = function(a) {
        if (!this.navApi.getIsLocked()) {
            var b = d(a.x, a.y)
              , c = this.userLookSpeed;
            a = this.getView();
            var h = f.up
              , k = a.clone().cross(h).normalize()
              , l = this.sceneUpDirection.clone()
              , b = b.clone();
            b.x *= Math.PI;
            b.y *= Math.PI / f.aspect;
            b.multiplyScalar(c);
            c = (new THREE.Quaternion).setFromAxisAngle(k, -b.y);
            if (f.keepSceneUpright && !this.navApi.getOrbitPastWorldPoles()) {
                var n = h.clone();
                n.applyQuaternion(c).normalize();
                0 > n.dot(l) && 
                (n = a.clone(),
                n.applyQuaternion(c),
                n = n.angleTo(l),
                Math.abs(n) > .5 * Math.PI && (n -= 0 < n ? Math.PI : -Math.PI),
                b.y -= n,
                c.setFromAxisAngle(k, -b.y))
            }
            a = c.clone().rotate(a);
            h = c.clone().rotate(h);
            h.normalize();
            k = f.keepSceneUpright ? l : h;
            k = (new THREE.Quaternion).setFromAxisAngle(k, -b.x);
            a = k.clone().rotate(a);
            h = k.clone().rotate(h);
            this.center.copy(a.add(f.position));
            f.up.copy(h);
            f.lookAt(this.center);
            g(!1)
        }
    }
    ;
    this.pan = function(a) {
        if (!this.navApi.getIsLocked()) {
            a = d(a.x, a.y);
            var b = this.getView()
              , c = f.up.clone().cross(b)
              , h = 
            b.clone().cross(c);
            c.normalize();
            h.normalize();
            b.normalize();
            var k = this.pivot.clone().sub(f.position)
              , k = b.clone().dot(k)
              , b = k * (Math.tan(THREE.Math.degToRad(f.leftFov)) + Math.tan(THREE.Math.degToRad(f.rightFov)))
              , k = k * (Math.tan(THREE.Math.degToRad(f.topFov)) + Math.tan(THREE.Math.degToRad(f.bottomFov)))
              , b = a.x * Math.abs(b);
            a = a.y * Math.abs(k);
            k = new THREE.Vector3;
            c = c.clone().multiplyScalar(b);
            h = h.clone().multiplyScalar(a);
            k = c.clone().add(h).clone().multiplyScalar(this.userPanSpeed);
            f.position.add(k);
            this.center.add(k);
            f.lookAt(this.center);
            g(!1)
        }
    }
    ;
    this.zoom = function(a) {
        if (!this.navApi.getIsLocked()) {
            var b = this.userZoomSpeed
              , c = Number.MAX_VALUE;
            a = a.x + a.y;
            var d = Math.pow(b, a)
              , h = this.pivot.clone().sub(this.pivot.clone().sub(this.saveEye).clone().multiplyScalar(d))
              , k = h.clone().add(l.D.clone().multiplyScalar(l.D.clone().dot(this.pivot.clone().sub(h).clone())));
            if (!(d >= c)) {
                if (0 < a) {
                    Math.pow(b, a - 0);
                    if (0 > a)
                        return;
                    f.position.copy(h);
                    this.center.copy(k);
                    h.clone().sub(this.saveEye).dot(l.D) > c && f.position.copy(this.saveEye.sub(l.D).clone().multiplyScalar(c))
                } else
                    f.position.copy(h),
                    this.center.copy(k);
                f.lookAt(this.center);
                g(!1)
            }
        }
    }
    ;
    this.walk = function(c, h, k, l, n) {
        if (!this.navApi.getIsLocked()) {
            k = this.sceneUpDirection.clone();
            l = this.sceneFrontDirection.clone();
            n = this.sceneFrontDirection.clone().cross(this.sceneUpDirection);
            a(c, h) ? (wheel.cursorImage("SWWalk"),
            b(!0, c, h),
            x = h.x,
            y = h.y) : b(!1, c, h);
            x = c.x;
            y = c.y;
            var m = d(x - h.x, y - h.y)
              , q = -m.x
              , r = -m.y
              , B = 0 > q ? -1 : 1
              , m = 0 > r ? -1 : 1
              , z = Math.abs(q)
              , t = Math.abs(r)
              , t = new THREE.Vector2(30,30)
              , t = d(t.x, t.y)
              , z = a(c, h) ? 0 : Math.abs(q) - t.x
              , t = a(c, h) ? 0 : Math.abs(r) - t.y
              , 
            z = z / .25
              , t = t / .25
              , z = 1 > z ? Math.easeClamp(z, 0, 1) : Math.pow(z, 1)
              , t = 1 > t ? Math.easeClamp(t, 0, 1) : Math.pow(t, 1)
              , q = 0 < z ? z * B : 0
              , m = 0 < t ? t * m : 0;
            c = this.getView();
            h = c.length();
            c.normalize();
            c.clone().cross(f.up).normalize();
            n = n.clone().multiplyScalar(n.clone().dot(c));
            n = l.clone().multiplyScalar(l.clone().dot(c)).clone().add(n);
            n = n.clone().length() > Number.MIN_VALUE ? n.normalize() : f.up;
            l = 1 * m * this.walkMultiplier;
            m = Math.cos(.65);
            1 != m && (k.clone().dot(f.up) < -Number.MIN_VALUE && k.clone().dot(c) < -m || k.clone().dot(f.up) > Number.MIN_VALUE && 
            k.clone().dot(c) > m) && (n = -n);
            q = -q * this.walkMultiplier * .05;
            m = f.up;
            if (k.clone().dot(f.up) < -Number.MIN_VALUE || Math.abs(k.clone().dot(f.up)) < Number.MIN_VALUE && k.clone().dot(c) > Number.MIN_VALUE)
                q = -q;
            m = k;
            q = (new THREE.Quaternion).setFromAxisAngle(m, q);
            q.normalize();
            c = q.clone().rotate(c);
            c.normalize();
            f.up.copy(q.clone().rotate(f.up));
            f.up.normalize();
            f.position.add(n.clone().multiplyScalar(l));
            this.center.copy(f.position.clone().add(c.clone().multiplyScalar(h)));
            k.normalize();
            f.lookAt(this.center);
            g(!1)
        }
    }
    ;
    this.updown = function(a) {
        if (!this.navApi.getIsLocked()) {
            var b = Math.pow(a, 2);
            0 > a && (b = -b);
            b = d(0, b);
            b.y = .01 * b.y * (l.maxSceneBound - l.minSceneBound);
            b = l.userHeightSpeed * b.y;
            var c = l.m_amount;
            if (0 === a)
                b = 0;
            else {
                var h = l.saveEye.clone().sub(worldUp.clone().multiplyScalar(c + b))
                  , c = l.saveEye.clone().sub(worldUp.clone().multiplyScalar(c))
                  , k = 0
                  , k = (l.maxSceneBound - l.minSceneBound) / 1E3;
                l.topLimit && 0 < a ? (k = l.maxSceneBound - k,
                l.topLimit = !1) : l.bottomLimit && 0 > a ? (k = l.minSceneBound + k,
                l.bottomLimit = !1) : k = h.dot(worldUp);
                a = c.dot(worldUp);
                k < l.minSceneBound ? a < l.minSceneBound && (l.bottomLimit = !0,
                b = 0) : k > l.maxSceneBound && a > l.maxSceneBound && (l.topLimit = !0,
                b = 0)
            }
            l.m_amount += b;
            a = new THREE.Vector3(0,1,0);
            b = l.saveEye.clone().sub(a.clone().multiplyScalar(l.m_amount));
            h = b.clone().dot(a);
            f.position.copy(b);
            h < l.minSceneBound && f.position.add(a.clone().multiplyScalar(l.minSceneBound - h));
            h > l.maxSceneBound && f.position.add(a.clone().multiplyScalar(l.maxSceneBound - h));
            this.center.copy(f.position.clone().add(l.saveCenter.clone().sub(l.saveEye)));
            f.lookAt(this.center);
            g(!1)
        }
    }
    ;
    this.addHistoryElement = function() {}
    ;
    this.addIntermediateHistoryElement = function() {
        this.rewindParams.history = this.rewindParams.snapped ? this.rewindParams.history.slice(0, this.rewindParams.timelineIndex) : 0 < this.rewindParams.slideOffset.x ? this.rewindParams.history.slice(0, this.rewindParams.timelineIndex) : this.rewindParams.history.slice(0, this.rewindParams.timelineIndex + 1);
        this.addHistoryElement()
    }
    ;
    this.clearHistory = function() {
        this.rewindParams.history.length = 0;
        this.rewindParams.timelineIndex = 
        0;
        this.rewindParams.timelineIndexSlide = 0;
        this.rewindParams.resetWeights = !0
    }
    ;
    this.openTimeline = function(a) {
        this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;
        this.rewindParams.resetWeights && (this.rewindParams.slideOffset.x = 0,
        this.rewindParams.snapped = this.rewindParams.snappingEnabled);
        0 === this.rewindParams.history.length && this.addHistoryElement();
        for (var b = 0; b < this.rewindParams.history.length; b++) {
            var c = this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize;
            this.rewindParams.history[b].thumbnailBounds.setCenter((new THREE.Vector2(a.x + 
            (b - this.rewindParams.timelineIndex) * c,a.y)).add(this.rewindParams.slideOffset));
            this.rewindParams.resetWeights && (this.rewindParams.history[b].weight = b == this.rewindParams.timelineIndex ? 1 : 0)
        }
        this.rewindParams.resetWeights && (this.rewindParams.resetWeights = !1);
        c = 2 * (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize);
        this.rewindParams.open = !0;
        this.rewindParams.openLocation = a.clone();
        this.rewindParams.openLocationOrigin = a.clone();
        this.rewindParams.openBracket = a.clone();
        this.rewindParams.openBracketA = 
        new THREE.Vector2(c,a.y);
        this.rewindParams.openBracketB = new THREE.Vector2(window.innerWidth - c,a.y);
        this.rewindParams.openBracketA.x > this.rewindParams.openBracketB.x && (a = this.rewindParams.openBracketA.x,
        this.rewindParams.openBracketA.x = this.rewindParams.openBracketB.x,
        this.rewindParams.openBracketB.x = a);
        this.rewindParams.locationOffset = new THREE.Vector2(0,0);
        this.rewindParams.snapOffset = new THREE.Vector2(0,0)
    }
    ;
    this.slideTimeline = function(a) {
        if (this.rewindParams.open && 0 !== this.rewindParams.history.length) {
            var b = 
            a.clone().add(this.rewindParams.locationOffset)
              , c = 2 * (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize);
            a = window.innerWidth - c;
            var d = this.rewindParams.history[0].thumbnailBounds.center().x
              , f = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x
              , g = 0;
            b.x < this.rewindParams.openBracketA.x && (g = b.x - this.rewindParams.openBracketA.x,
            d -= g,
            c < d && (g = Math.min(g + (d - c), 0)));
            b.x > this.rewindParams.openBracketB.x && (g = b.x - this.rewindParams.openBracketB.x,
            c = f - g,
            a > c && 
            (g = Math.max(g + (c - a), 0)));
            this.rewindParams.openLocation.x += g;
            this.rewindParams.openBracketA.x += g;
            this.rewindParams.openBracketB.x += g;
            this.rewindParams.openBracket.x = b.x - (this.rewindParams.openLocation.x - this.rewindParams.openLocationOrigin.x);
            a = new THREE.Vector2(-g,0);
            b = b.clone().sub(this.rewindParams.openLocation.clone().sub(this.rewindParams.openLocationOrigin));
            a.x += this.rewindParams.snapOffset.x;
            this.rewindParams.snapOffset.x = 0;
            c = !1;
            if (this.rewindParams.snappingEnabled)
                for (f = 0; f < this.rewindParams.history.length; f++)
                    if (d = 
                    this.rewindParams.history[f].thumbnailBounds.center().add(a),
                    4 > Math.abs(d.x - b.x) || this.rewindParams.snapped && 16 > Math.abs(d.x - b.x)) {
                        c = !0;
                        0 !== g ? (this.rewindParams.snapOffset.x = d.x - b.x,
                        a.x -= this.rewindParams.snapOffset.x) : this.rewindParams.openBracket.x += d.x - b.x;
                        b.x = d.x;
                        break
                    }
            this.rewindParams.snapped = c;
            c = -1;
            for (f = g = 0; f < this.rewindParams.history.length; f++) {
                d = this.rewindParams.history[f].thumbnailBounds.clone();
                this.rewindParams.history[f].thumbnailBounds.setCenter(this.rewindParams.history[f].thumbnailBounds.center().add(a));
                if (this.rewindParams.history[f].thumbnail) {
                    var h = this.rewindParams.history[f].thumbnailBounds.center().x - this.rewindParams.thumbnailSize / 2;
                    $("#rewindFrame" + f).css("left", h);
                    $("#rewindBorder" + f).css("left", h - 4)
                }
                h = new THREE.Vector2(2 * (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize),2 * (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize));
                d.setFromCenterAndSize(d.center(), h);
                h = new THREE.Vector2(0,0);
                d.getIcon2DCoords(b, h);
                h = 1 - Math.abs(Math.equalityClamp(h.x, -1, 1));
                this.rewindParams.history[f].weight = h;
                0 === f && b.x < d.center().x && (this.rewindParams.history[f].weight = 1);
                f === this.rewindParams.history.length - 1 && b.x > d.center().x && (this.rewindParams.history[f].weight = 1);
                g += this.rewindParams.history[f].weight;
                this.rewindParams.history[f].weight > c && (c = this.rewindParams.history[f].weight,
                this.rewindParams.snappingEnabled && 1 == this.rewindParams.history[f].weight ? (this.rewindParams.slideOffset.x = 0,
                this.rewindParams.snapped = !0) : this.rewindParams.slideOffset.x = this.rewindParams.history[f].thumbnailBounds.center().x - 
                b.x,
                this.rewindParams.timelineIndexSlide = f)
            }
            for (a = 0; a < this.rewindParams.history.length; a++)
                this.rewindParams.history[a].weight /= g;
            a = this.rewindParams.history[0].thumbnailBounds.center().x;
            b = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;
            this.rewindParams.openBracket.x < a ? (this.rewindParams.locationOffset.x += a - this.rewindParams.openBracket.x,
            this.rewindParams.openBracket.x = a) : this.rewindParams.openBracket.x > b && (this.rewindParams.locationOffset.x += b - this.rewindParams.openBracket.x,
            this.rewindParams.openBracket.x = b)
        }
    }
    ;
    this.shiftBackOneElement = function() {
        0 !== this.rewindParams.history.length && (0 < this.rewindParams.timelineIndex || 0 !== this.rewindParams.slideOffset.x) && ((this.rewindParams.snapped || 0 < this.rewindParams.slideOffset.x) && this.rewindParams.timelineIndex--,
        this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex,
        this.rewindParams.resetWeights = !0,
        l.elapsedTime = 0,
        this.animateToRewindIndex())
    }
    ;
    this.animateToRewindIndex = function() {
        var a = this.rewindParams.timelineIndex
          , 
        b = 0;
        l.elapsedTime >= J.duration ? b = 1 : (b = Math.easeClamp(l.elapsedTime / J.duration, 0, J.destinationPercent),
        l.elapsedTime += r / 500);
        l.center.copy(l.center.clone().multiplyScalar(1 - b).clone().add(this.rewindParams.history[a].camera.center.clone().multiplyScalar(b)));
        f.position.copy(f.position.clone().multiplyScalar(1 - b).clone().add(this.rewindParams.history[a].camera.position.clone().multiplyScalar(b)));
        f.up.copy(this.rewindParams.history[a].camera.up);
        l.pivot.copy(l.center);
        f.lookAt(l.center);
        g(!1);
        this.cube && 
        requestAnimationFrame(this.cube.render);
        1 !== b && requestAnimationFrame(function() {
            l.animateToRewindIndex()
        }
        )
    }
    ;
    this.closeTimeline = function() {
        this.rewindParams.timelineIndex != this.rewindParams.timelineIndexSlide && (this.rewindParams.timelineIndex = this.rewindParams.timelineIndexSlide);
        this.rewindParams.open = !1
    }
    ;
    this.getInterpolatedCamera = function() {
        var a = new THREE.PerspectiveCamera(70,window.innerWidth / window.innerHeight,1,1E4);
        a.center = new THREE.Vector3(0,0,0);
        a.pivot = new THREE.Vector3(0,0,0);
        a.leftFov = 
        0;
        a.rightFov = 0;
        a.topFov = 0;
        a.bottomFov = 0;
        a.up.set(0, 0, 0);
        for (var b = 0; b < this.rewindParams.history.length; b++) {
            var c = this.rewindParams.history[b].camera
              , d = this.rewindParams.history[b].weight;
            a.center.add(c.center.clone().multiplyScalar(d));
            a.position.add(c.position.clone().multiplyScalar(d));
            a.up.add(c.up.clone().multiplyScalar(d));
            a.rotation.add(c.rotation.clone().multiplyScalar(d));
            a.pivot.add(c.pivot.clone().multiplyScalar(d));
            a.leftFov += c.leftFov * d;
            a.rightFov += c.rightFov * d;
            a.topFov += c.topFov * d;
            a.bottomFov += 
            c.bottomFov * d
        }
        f.position.copy(a.position);
        f.up.copy(a.up);
        f.rotation = a.rotation;
        f.leftFov = a.leftFov;
        f.rightFov = a.rightFov;
        f.topFov = a.topFov;
        f.bottomFov = a.bottomFov;
        l.center.copy(a.center);
        l.pivot.copy(a.pivot);
        f.lookAt(l.center);
        f.up.normalize();
        g(!1)
    }
}
;
Autocam.ViewCube = function(f, h, g, d) {
    function c(a, c) {
        var d = {};
        0 === a.type.indexOf("touch") ? 0 < a.touches.length ? (d.clientX = a.touches[0].clientX,
        d.clientY = a.touches[0].clientY,
        d.pageX = a.touches[0].pageX,
        d.pageY = a.touches[0].pageY,
        d.screenX = a.touches[0].screenX,
        d.screenY = a.touches[0].screenY,
        d.movementX = d.screenX - c.prevX,
        d.movementY = d.screenY - c.prevY,
        d.which = b.navApi.getUseLeftHandedInput() ? 3 : 1) : d = c.prevCoords : (d.clientX = a.clientX,
        d.clientY = a.clientY,
        d.pageX = a.pageX,
        d.pageY = a.pageY,
        d.screenX = a.screenX,
        d.screenY = 
        a.screenY,
        d.which = a.which,
        ia ? (d.movementX = a.movementX || a.mozMovementX || a.webkitMovementX || 0,
        d.movementY = a.movementY || a.mozMovementY || a.webkitMovementY || 0) : (d.movementX = d.screenX - c.prevX,
        d.movementY = d.screenY - c.prevY));
        c.prevX = d.screenX;
        c.prevY = d.screenY;
        return c.prevCoords = d
    }
    var a = this
      , b = h
      , k = h.camera;
    h.setCube(this);
    a.currentFace = "front";
    var l = "top,front;top right;top,left;top,back;bottom,front;bottom,right;bottom,left;bottom,back;left,front;front,right;right,back;back,left".split(";"), n = "front,top,right back,top,right front,top,left back,top,left front,bottom,right back,bottom,right front,bottom,left back,bottom,left".split(" "), 
    m = ["Go Home", null , "Orthographic", "Perspective", "Perspective with Ortho Faces", null , "Set current view as Home", "Focus and set as Home", "Reset Home", null , "Set current view as Front", "Set current view as Top", "Reset orientation"], q = [!0, null , !0, !0, !0, null , !0, !0, !0, null , !0, !0, !0], r = [null , null , function() {
        return !b.orthographicFaces && !k.isPerspective
    }
    , function() {
        return !b.orthographicFaces && k.isPerspective
    }
    , function() {
        return b.orthographicFaces
    }
    , null , null , null , null , null , null , null , null ], t, w, C, E, G, B;
    a.camera = 
    new THREE.PerspectiveCamera(45,window.innerWidth / window.innerHeight,1,2E3);
    a.camera.position.copy(k.position);
    a.center = new THREE.Vector3(0,0,0);
    a.camera.lookAt(a.center);
    var v, D, z, H, I, J = [], L, F = [], N = [], K = [], M = [], S = null , ba = null , P = null , aa, Z, V, ea, X, R = 0, T, O = 0, ca = !0, ia = !1, fa = !1, W = -1 != navigator.userAgent.search("Chrome"), ga = -1 != navigator.platform.search("Win32"), da = !1, na = !1, Y = [];
    this.height = this.width = 0;
    this.animSpeed = 500;
    this.animate = !0;
    this.compass = !1;
    this.viewScaleFactorCompass = 1.5;
    this.viewScale = 1;
    this.draggable = 
    !0;
    this.wantHomeButton = !1;
    this.wantContextMenu = this.wantRollArrows = !0;
    this.inactiveOpacity = .5;
    var Ia = function(a) {
        a = a.getBoundingClientRect();
        return {
            x: a.left,
            y: a.top,
            w: a.width,
            h: a.height
        }
    }
      , Ha = function() {
        b.navApi.getIsLocked() || (g.style.opacity = "1.0",
        na = !1);
        requestAnimationFrame(a.render)
    }
      , xa = function(c) {
        if (na || b.viewCubeMenuOpen || b.navApi.getIsLocked())
            b.navApi.getIsLocked() || (g.style.opacity = 1);
        else {
            var d = Math.max(4 * Math.abs((c.clientX - T.x) / T.w - .5) - 1, 0);
            c = Math.max(4 * Math.abs((c.clientY - T.y) / T.h - .5) - 
            1, 0);
            d = Math.max(0, Math.min(Math.sqrt(d * d + c * c), 1));
            g.style.opacity = 1 - d * (1 - a.inactiveOpacity)
        }
    }
      , ka = function() {
        b.viewCubeMenuOpen || (g.style.opacity = a.inactiveOpacity,
        na = !0,
        requestAnimationFrame(a.render))
    }
      , ja = function(b) {
        var c = new Image;
        c.crossOrigin = "anonymous";
        var d = new THREE.Texture(c);
        c.onload = function() {
            d.needsUpdate = !0;
            O++;
            11 <= O && requestAnimationFrame(a.render)
        }
        ;
        c.src = b;
        return d
    }
      , za = function(a, b, c) {
        var d = new THREE.Vector3;
        d.copy(a);
        d = d.unproject(b);
        return (new THREE.Raycaster(b.position,d.sub(b.position).normalize())).intersectObjects(c)
    }
      , 
    ha = function(a, b) {
        var c = a.clientX - b.x
          , d = a.clientY - b.y
          , c = c / b.w * 2 - 1
          , d = (b.h - d) / b.h * 2 - 1;
        return new THREE.Vector3(c,d,.5)
    }
      , qa = function(d) {
        d.preventDefault();
        d.stopPropagation();
        if (!b.navApi.getIsLocked() && !b.currentlyAnimating) {
            d = c(d, a);
            T = Ia(g);
            g.removeEventListener("mousemove", Ma, !1);
            document.addEventListener("mouseup", Na, !1);
            document.addEventListener("touchend", Na, !1);
            b.navApi.getUsePivotAlways() || (b.pivot.copy(b.center),
            b.navApi.setPivotPoint(b.center),
            b.navApi.setPivotSetFlag(!1));
            b.startInteraction(d.pageX, 
            d.pageY);
            0 == b.rewindParams.history.length && b.addHistoryElement();
            b.rewindParams.snapped && b.rewindParams.timelineIndex + 1 == b.rewindParams.history.length || b.addIntermediateHistoryElement();
            var f = b.navApi.getUseLeftHandedInput() ? 1 : 3;
            d.which !== f && (0 >= a.animSpeed ? console.error("animSpeed cannot be 0 or less, use ViewCube.animate flag to turn on and off animation") : (d = ha(d, T),
            d = za(d, a.camera, M),
            0 < d.length && (pa(),
            a.draggable && (document.addEventListener("mousemove", La, !1),
            document.addEventListener("touchmove", 
            La, !1),
            ia && (g.requestPointerLock(),
            fa = W && ga)))))
        }
    }
      , La = function(d) {
        d.preventDefault();
        d.stopPropagation();
        0 >= a.animSpeed ? (document.removeEventListener("mousemove", La, !1),
        document.removeEventListener("touchmove", La, !1),
        console.error("animSpeed cannot be 0 or less")) : b.currentlyAnimating || (d = c(d, a),
        ia && fa && (fa = !1,
        d.movementX = d.movementY = 0),
        d.movementX === d.movementY && 0 === d.movementX ? b.currentlyAnimating = !1 : (ca = !1,
        da = !0,
        b.showPivot(!0),
        b.currentCursor = new THREE.Vector2(d.pageX,d.pageY),
        b.orbit(b.currentCursor, 
        b.startCursor, new THREE.Vector3(-d.movementX,d.movementY,0), b.startState),
        a.camera.lookAt(a.center),
        requestAnimationFrame(a.render)))
    }
      , Ja = function(a) {
        a || (document.removeEventListener("mouseup", Na, !1),
        document.removeEventListener("touchend", Na, !1));
        document.removeEventListener("mousemove", La, !1);
        document.removeEventListener("touchmove", La, !1);
        g.addEventListener("mousemove", Ma, !1)
    }
      , Na = function(d) {
        d.preventDefault();
        d.stopPropagation();
        var f, h, l;
        if (b.currentlyAnimating || da)
            b.endInteraction(),
            b.showPivot(!1),
            da = !1,
            Ja(!1);
        else {
            var n = c(d, a);
            if (b.viewCubeMenuOpen) {
                d = n.clientX - T.x;
                f = n.clientY - T.y;
                if (b.menuOrigin.x <= d && d <= b.menuOrigin.x + b.menuSize.x && b.menuOrigin.y <= f && f <= b.menuOrigin.y + b.menuSize.y)
                    switch (Math.floor((f - 5 - b.menuOrigin.y) / 25)) {
                    case 0:
                        b.goHome();
                        break;
                    case 1:
                        b.setOrthographicFaces(!1);
                        b.toOrthographic();
                        break;
                    case 2:
                        b.setOrthographicFaces(!1);
                        b.toPerspective();
                        break;
                    case 3:
                        b.setOrthographicFaces(!0);
                        ca ? b.toOrthographic() : b.toPerspective();
                        break;
                    case 4:
                        b.setCurrentViewAsHome(!1);
                        break;
                    case 5:
                        b.setCurrentViewAsHome(!0);
                        break;
                    case 6:
                        b.resetHome();
                        break;
                    case 7:
                        b.setCurrentViewAsFront();
                        break;
                    case 8:
                        b.setCurrentViewAsTop();
                        break;
                    case 9:
                        b.resetOrientation()
                    }
                b.viewCubeMenuOpen = !1;
                b.removeDropdownMenu(g);
                (n.clientX < T.x || n.clientX > T.w + T.x || n.clientY < T.y || n.clientY > T.h + T.y) && ka();
                a.mouseMoveSave && a.processMouseMove(a.mouseMoveSave);
                Ja(!1)
            } else if (f = b.navApi.getUseLeftHandedInput() ? 1 : 3,
            n.which === f)
                b.viewCubeMenuOpen = !0,
                b.drawDropdownMenu(m, q, r, n.clientX, n.clientY, g, T),
                Ja(!0);
            else {
                l = ha(n, T);
                f = za(l, a.camera, M);
                h = za(l, B, F);
                l = za(l, B, K);
                if (0 < h.length && ca) {
                    var z = b.getOrientation();
                    switch (a.currentFace) {
                    case "front":
                        switch (z) {
                        case "up":
                            h[0].object === F[0] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[1] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[2] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[3] && (b.calculateCubeTransform("left"),
                            a.currentFace = "left");
                            break;
                        case "right":
                            h[0].object === F[0] ? (b.calculateCubeTransform("right"),
                            a.currentFace = 
                            "right") : h[0].object === F[1] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[2] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[3] && (b.calculateCubeTransform("top"),
                            a.currentFace = "top");
                            break;
                        case "down":
                            h[0].object === F[0] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[1] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[2] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[3] && 
                            (b.calculateCubeTransform("right"),
                            a.currentFace = "right");
                            break;
                        case "left":
                            h[0].object === F[0] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[1] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[2] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[3] && (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom")
                        }
                        break;
                    case "right":
                        switch (z) {
                        case "up":
                            h[0].object === F[0] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === 
                            F[1] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[2] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[3] && (b.calculateCubeTransform("front"),
                            a.currentFace = "front");
                            break;
                        case "right":
                            h[0].object === F[0] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[1] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[2] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[3] && (b.calculateCubeTransform("top"),
                            a.currentFace = "top");
                            break;
                        case "down":
                            h[0].object === F[0] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[1] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[2] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[3] && (b.calculateCubeTransform("back"),
                            a.currentFace = "back");
                            break;
                        case "left":
                            h[0].object === F[0] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[1] ? (b.calculateCubeTransform("back"),
                            a.currentFace = 
                            "back") : h[0].object === F[2] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[3] && (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom")
                        }
                        break;
                    case "left":
                        switch (z) {
                        case "up":
                            h[0].object === F[0] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[1] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[2] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[3] && (b.calculateCubeTransform("back"),
                            a.currentFace = "back");
                            break;
                        case "right":
                            h[0].object === F[0] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[1] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[2] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[3] && (b.calculateCubeTransform("top"),
                            a.currentFace = "top");
                            break;
                        case "down":
                            h[0].object === F[0] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[1] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === 
                            F[2] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[3] && (b.calculateCubeTransform("front"),
                            a.currentFace = "front");
                            break;
                        case "left":
                            h[0].object === F[0] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[1] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[2] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[3] && (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom")
                        }
                        break;
                    case "back":
                        switch (z) {
                        case "up":
                            h[0].object === 
                            F[0] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[1] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[2] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[3] && (b.calculateCubeTransform("right"),
                            a.currentFace = "right");
                            break;
                        case "right":
                            h[0].object === F[0] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[1] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[2] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[3] && (b.calculateCubeTransform("top"),
                            a.currentFace = "top");
                            break;
                        case "down":
                            h[0].object === F[0] ? (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom") : h[0].object === F[1] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[2] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[3] && (b.calculateCubeTransform("left"),
                            a.currentFace = "left");
                            break;
                        case "left":
                            h[0].object === F[0] ? (b.calculateCubeTransform("right"),
                            a.currentFace = 
                            "right") : h[0].object === F[1] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[2] ? (b.calculateCubeTransform("top"),
                            a.currentFace = "top") : h[0].object === F[3] && (b.calculateCubeTransform("bottom"),
                            a.currentFace = "bottom")
                        }
                        break;
                    case "top":
                        switch (z) {
                        case "up":
                            h[0].object === F[0] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[1] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[2] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : 
                            h[0].object === F[3] && (b.calculateCubeTransform("left"),
                            a.currentFace = "left");
                            break;
                        case "right":
                            h[0].object === F[0] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[1] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[2] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[3] && (b.calculateCubeTransform("back"),
                            a.currentFace = "back");
                            break;
                        case "down":
                            h[0].object === F[0] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === 
                            F[1] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[2] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[3] && (b.calculateCubeTransform("right"),
                            a.currentFace = "right");
                            break;
                        case "left":
                            h[0].object === F[0] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[1] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[2] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[3] && (b.calculateCubeTransform("front"),
                            a.currentFace = "front")
                        }
                        break;
                    case "bottom":
                        switch (z) {
                        case "up":
                            h[0].object === F[0] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[1] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[2] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[3] && (b.calculateCubeTransform("left"),
                            a.currentFace = "left");
                            break;
                        case "right":
                            h[0].object === F[0] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[1] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[2] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[3] && (b.calculateCubeTransform("front"),
                            a.currentFace = "front");
                            break;
                        case "down":
                            h[0].object === F[0] ? (b.calculateCubeTransform("back"),
                            a.currentFace = "back") : h[0].object === F[1] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[2] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[3] && (b.calculateCubeTransform("right"),
                            a.currentFace = "right");
                            break;
                        case "left":
                            h[0].object === F[0] ? (b.calculateCubeTransform("left"),
                            a.currentFace = "left") : h[0].object === F[1] ? (b.calculateCubeTransform("right"),
                            a.currentFace = "right") : h[0].object === F[2] ? (b.calculateCubeTransform("front"),
                            a.currentFace = "front") : h[0].object === F[3] && (b.calculateCubeTransform("back"),
                            a.currentFace = "back")
                        }
                    }
                    b.elapsedTime = 0;
                    b.sphericallyInterpolateTransition()
                }
                if (0 < l.length) {
                    b.elapsedTime = 0;
                    if (a.wantHomeButton && l[0].object === K[ea]) {
                        b.goHome();
                        Ja(!1);
                        return
                    }
                    if (a.wantContextMenu && l[0].object === 
                    K[X]) {
                        b.viewCubeMenuOpen = !0;
                        b.drawDropdownMenu(m, q, r, n.clientX, n.clientY, g, T);
                        Ja(!0);
                        return
                    }
                    a.wantRollArrows && ca && (l[0].object === K[aa] || l[0].object === K[Z]) && (n = l[0].object === K[Z],
                    h = {
                        center: b.center.clone(),
                        position: k.position.clone(),
                        pivot: k.pivot.clone(),
                        fov: k.fov,
                        worldUp: b.sceneUpDirection.clone(),
                        isOrtho: !1 === k.isPerspective
                    },
                    l = b.center.clone().sub(k.position).normalize(),
                    n ? h.up = k.up.clone().cross(l) : (h.up = k.up.clone().multiplyScalar(-1),
                    h.up.cross(l)),
                    h.up.normalize(),
                    b.elapsedTime = 0,
                    b.animateTransition(h))
                }
                0 < 
                f.length && (a.currentFace = f[0].object.name,
                b.orthographicFaces && -1 !== a.currentFace.indexOf(",") && b.setCameraOrtho(!1),
                b.calculateCubeTransform(a.currentFace),
                b.elapsedTime = 0,
                a.mouseMoveSave = d,
                b.sphericallyInterpolateTransition(function() {
                    a.mouseMoveSave && a.processMouseMove(a.mouseMoveSave)
                }
                ));
                Ja(!1)
            }
        }
    }
    ;
    this.processMouseMove = function(d) {
        var f, g;
        if (b.viewCubeMenuOpen || b.currentlyAnimating)
            a.mouseMoveSave = d;
        else {
            a.mouseMoveSave = null ;
            d = c(d, a);
            g = ha(d, T);
            d = za(g, a.camera, N);
            f = za(g, B, F);
            g = za(g, B, K);
            S && !da && 
            (S.material.color.setHex(14540253),
            S = null ,
            requestAnimationFrame(a.render));
            if (0 < f.length && !da) {
                S = f[0].object;
                for (f = L.children.length; 0 <= --f; )
                    if (S === F[f]) {
                        S = L.children[f];
                        S.material.color.setHex(45055);
                        break
                    }
                requestAnimationFrame(a.render)
            }
            ba && !da && (ba.material.opacity = 0,
            ba = null ,
            requestAnimationFrame(a.render));
            0 < d.length && !da && (ba = d[0].object,
            ba.material.opacity = .3,
            requestAnimationFrame(a.render));
            0 < g.length && !da ? P !== g[0].object && (a.wantHomeButton && g[0].object === K[ea] ? (P = g[0].object,
            K[ea].material.map = 
            Y[0]) : a.wantRollArrows && g[0].object === K[aa] ? (P = g[0].object,
            K[V].material.map = Y[1]) : a.wantRollArrows && g[0].object === K[Z] ? (P = g[0].object,
            K[V].material.map = Y[2]) : a.wantContextMenu && g[0].object === K[X] ? (P = g[0].object,
            K[X].material.map = Y[6]) : a.wantHomeButton && P === K[ea] ? (P = null ,
            K[ea].material.map = Y[3]) : !a.wantRollArrows || P !== K[aa] && P !== K[Z] && P !== K[V] ? a.wantContextMenu && P === K[X] && (P = null ,
            K[X].material.map = Y[5]) : (P = null ,
            K[V].material.map = Y[4]),
            requestAnimationFrame(a.render)) : null  === P || da || (a.wantHomeButton && 
            P === K[ea] ? (P = null ,
            K[ea].material.map = Y[3]) : !a.wantRollArrows || P !== K[aa] && P !== K[Z] && P !== K[V] ? a.wantContextMenu && P === K[X] && (P = null ,
            K[X].material.map = Y[5]) : (P = null ,
            K[V].material.map = Y[4]),
            requestAnimationFrame(a.render))
        }
    }
    ;
    var Ma = function(c) {
        b.navApi.getIsLocked() || a.processMouseMove(c)
    }
      , Ea = function() {
        T = Ia(g);
        a.width = g.offsetWidth;
        a.height = g.offsetHeight;
        a.camera.aspect = a.width / a.height;
        a.camera.updateProjectionMatrix();
        a.camera.topFov = a.camera.bottomFov = a.camera.fov / 2;
        a.camera.leftFov = a.camera.rightFov = 
        a.camera.aspect * a.camera.fov / 2;
        a.renderer.setSize(a.width, a.height);
        requestAnimationFrame(a.render)
    }
      , ya = function(a, b) {
        var c, d = new THREE.Geometry;
        c = new THREE.Vector3(0,0,0);
        var f = new THREE.Vector3(60,-60,105)
          , g = new THREE.Vector3(60,60,105)
          , h = new THREE.Vector3(-60,60,105)
          , k = new THREE.Vector3(-60,-60,105);
        d.vertices.push(c);
        d.vertices.push(f);
        d.vertices.push(g);
        d.vertices.push(h);
        d.vertices.push(k);
        d.faces.push(new THREE.Face3(1,2,3));
        d.faces.push(new THREE.Face3(1,3,4));
        d.applyMatrix((new THREE.Matrix4).makeRotationX(a));
        d.applyMatrix((new THREE.Matrix4).makeRotationY(b));
        d.computeFaceNormals();
        d.computeVertexNormals();
        c = new THREE.MeshBasicMaterial({
            overdraw: !0,
            opacity: 0,
            color: 45055,
            transparent: !0
        });
        return new THREE.Mesh(d,c)
    }
      , la = function(a, b, c) {
        var d = new THREE.Geometry
          , f = new THREE.Vector3(60,105,105)
          , g = new THREE.Vector3(-60,105,105)
          , h = new THREE.Vector3(-60,60,105)
          , k = new THREE.Vector3(60,60,105)
          , l = new THREE.Vector3(60,105,60)
          , n = new THREE.Vector3(-60,105,60)
          , m = new THREE.Vector3(-60,105,105)
          , q = new THREE.Vector3(60,
        105,105);
        d.vertices.push(f);
        d.vertices.push(g);
        d.vertices.push(h);
        d.vertices.push(k);
        d.vertices.push(l);
        d.vertices.push(n);
        d.vertices.push(m);
        d.vertices.push(q);
        d.faces.push(new THREE.Face3(0,1,2));
        d.faces.push(new THREE.Face3(0,2,3));
        d.faces.push(new THREE.Face3(4,5,6));
        d.faces.push(new THREE.Face3(4,6,7));
        d.applyMatrix((new THREE.Matrix4).makeRotationX(a));
        d.applyMatrix((new THREE.Matrix4).makeRotationY(b));
        d.applyMatrix((new THREE.Matrix4).makeRotationZ(c));
        d.computeFaceNormals();
        d.computeVertexNormals();
        a = new THREE.MeshBasicMaterial({
            overdraw: !0,
            opacity: 0,
            color: 45055,
            transparent: !0
        });
        return new THREE.Mesh(d,a)
    }
      , ta = function(a, b) {
        var c, d = new THREE.Geometry;
        c = new THREE.Vector3(105,105,105);
        var f = new THREE.Vector3(60,105,105)
          , g = new THREE.Vector3(60,60,105)
          , h = new THREE.Vector3(105,60,105)
          , k = new THREE.Vector3(105,105,60)
          , l = new THREE.Vector3(105,105,105)
          , n = new THREE.Vector3(105,60,105)
          , m = new THREE.Vector3(105,60,60)
          , q = new THREE.Vector3(105,105,105)
          , r = new THREE.Vector3(105,105,60)
          , B = new THREE.Vector3(60,
        105,60)
          , z = new THREE.Vector3(60,105,105);
        d.vertices.push(c);
        d.vertices.push(f);
        d.vertices.push(g);
        d.vertices.push(h);
        d.vertices.push(k);
        d.vertices.push(l);
        d.vertices.push(n);
        d.vertices.push(m);
        d.vertices.push(q);
        d.vertices.push(r);
        d.vertices.push(B);
        d.vertices.push(z);
        d.faces.push(new THREE.Face3(0,1,2));
        d.faces.push(new THREE.Face3(0,2,3));
        d.faces.push(new THREE.Face3(4,5,6));
        d.faces.push(new THREE.Face3(4,6,7));
        d.faces.push(new THREE.Face3(8,9,10));
        d.faces.push(new THREE.Face3(8,10,11));
        d.applyMatrix((new THREE.Matrix4).makeRotationX(a));
        d.applyMatrix((new THREE.Matrix4).makeRotationY(b));
        d.computeFaceNormals();
        d.computeVertexNormals();
        c = new THREE.MeshBasicMaterial({
            overdraw: !0,
            opacity: 0,
            color: 45055,
            transparent: !0
        });
        return new THREE.Mesh(d,c)
    }
      , oa = function(a) {
        var c = b.cubeFront.clone()
          , d = b.sceneUpDirection.clone()
          , f = c.clone().cross(d);
        d.copy(f).cross(c);
        c.normalize();
        d.normalize();
        f.normalize();
        var g = (new THREE.Vector3(c.x,d.x,f.x)).multiplyScalar(a.x);
        g.add((new THREE.Vector3(c.y,d.y,f.y)).multiplyScalar(a.y));
        g.add((new THREE.Vector3(c.z,
        d.z,f.z)).multiplyScalar(a.z));
        return g
    }
    ;
    this.render = function() {
        var c = a.compass ? a.viewScaleFactorCompass * a.viewScale : a.viewScale
          , d = b.center.clone().sub(k.position).normalize()
          , f = k.up.normalize()
          , d = oa(d)
          , f = oa(f);
        a.camera.position.copy(d);
        a.camera.position.multiplyScalar(-c / a.camera.position.length());
        a.camera.up = f.normalize();
        a.camera.lookAt(a.center);
        ca = b.isFaceView();
        !ca || na || b.currentlyAnimating ? pa() : (G.add(L),
        c = a.wantRollArrows ? 1 : 0,
        K[V].material.opacity = c,
        K[X].material.opacity = c);
        I.material.opacity = 
        na ? 0 : a.wantContextMenu ? 1 : 0;
        z.material.opacity = na ? 0 : a.wantHomeButton ? 1 : 0;
        if (c = a.renderer)
            c.clear(),
            c.render(t, a.camera),
            c.render(w, a.camera),
            c.render(E, a.camera),
            c.render(C, a.camera),
            c.render(G, B)
    }
    ;
    var pa = function() {
        G.remove(L);
        K[V].material.opacity = 0;
        K[X].material.opacity = 0
    }
    ;
    this.refreshCube = function() {
        Ea()
    }
    ;
    this.setSize = function(b, c) {
        a.width = b;
        a.height = c;
        if (1 < g.children.length)
            for (var d = 1; d < g.children.length; d++)
                g.children[d].style.bottom = (a.height / 5).toString() + "px";
        Ea()
    }
    ;
    this.useTransparency = function(a) {
        (na = 
        a) ? (g.onmouseover = Ha,
        g.onmousemove = xa,
        g.onmouseout = ka,
        ka()) : (g.onmouseover = null ,
        g.onmouseout = null ,
        g.onmousemove = null ,
        g.style.opacity = "1.0")
    }
    ;
    this.dtor = function() {
        this.renderer = null 
    }
    ;
    (function() {
        var c = g.getBoundingClientRect();
        a.width = c.width;
        a.height = c.height;
        T = Ia(g);
        B = new THREE.PerspectiveCamera(70,a.height / a.width,1,1E4);
        B.position.set(0, 0, 500);
        t = new THREE.Scene;
        w = new THREE.Scene;
        C = new THREE.Scene;
        E = new THREE.Scene;
        G = new THREE.Scene;
        ca = !0;
        R = 200;
        a.viewScale = 3.5 * R;
        var f = THREE.LinearFilter
          , c = Teratek.Viewing.Private.getResourceUrl
          , 
        h = d || "res/textures/"
          , k = (new THREE.DDSLoader).load(c(h + "VCcrossRGBA8small.dds"));
        k.minFilter = k.maxFilter = f;
        h = THREE.ShaderLib.cube;
        h = new THREE.ShaderMaterial({
            fragmentShader: h.fragmentShader,
            vertexShader: h.vertexShader,
            uniforms: THREE.UniformsUtils.clone(h.uniforms),
            depthWrite: !1
        });
        h.uniforms.tCube.value = k;
        var m = new THREE.BoxGeometry(R,R,R,4,4,4)
          , k = new THREE.BoxGeometry(R + 1,R + 1,R + 1,4,4,4);
        v = new THREE.Mesh(m,h);
        v.position.set(0, 0, 0);
        w.add(v);
        h = ja(c("res/textures/VCedge1.png"));
        h.minFilter = h.maxFilter = 
        f;
        D = new THREE.Mesh(k,new THREE.MeshBasicMaterial({
            map: h,
            overdraw: !1,
            transparent: !0,
            shading: THREE.SmoothShading
        }));
        D.position.set(0, 0, 0);
        E.add(D);
        var f = R
          , h = new THREE.Geometry
          , k = new THREE.Vector3(-30,0,0)
          , m = new THREE.Vector3(30,0,0)
          , q = new THREE.Vector3(0,-30,0);
        h.vertices.push(k);
        h.vertices.push(m);
        h.vertices.push(q);
        h.faces.push(new THREE.Face3(1,0,2));
        h.computeFaceNormals();
        var q = new THREE.MeshBasicMaterial({
            overdraw: !0,
            color: 14540253,
            transparent: !1,
            opacity: 1,
            shading: THREE.FlatShading
        })
          , r = new THREE.MeshBasicMaterial({
            overdraw: !0,
            color: 14540253,
            transparent: !1,
            opacity: 1,
            shading: THREE.FlatShading
        })
          , ka = new THREE.MeshBasicMaterial({
            overdraw: !0,
            color: 14540253,
            transparent: !1,
            opacity: 1,
            shading: THREE.FlatShading
        })
          , da = new THREE.MeshBasicMaterial({
            overdraw: !0,
            color: 14540253,
            transparent: !1,
            opacity: 1,
            shading: THREE.FlatShading
        })
          , k = new THREE.PlaneBufferGeometry(.5 * R,.3 * R,2,2)
          , m = new THREE.MeshBasicMaterial({
            transparent: !0,
            opacity: 0
        })
          , q = new THREE.Mesh(h,q)
          , na = new THREE.Mesh(k,m);
        q.position.set(0, f, 0);
        na.position.set(0, .9 * f, .1);
        var r = new THREE.Mesh(h,
        r)
          , xa = new THREE.Mesh(k,m);
        r.position.set(0, -f, 0);
        xa.position.set(0, .9 * -f, .1);
        r.rotation.z += Math.PI;
        xa.rotation.z += Math.PI;
        var ka = new THREE.Mesh(h,ka)
          , za = new THREE.Mesh(k,m);
        ka.position.set(f, 0, 0);
        za.position.set(.9 * f, 0, .1);
        ka.rotation.z -= Math.PI / 2;
        za.rotation.z -= Math.PI / 2;
        h = new THREE.Mesh(h,da);
        k = new THREE.Mesh(k,m);
        h.position.set(-f, 0, 0);
        k.position.set(.9 * -f, 0, .1);
        h.rotation.z += Math.PI / 2;
        k.rotation.z += Math.PI / 2;
        L = new THREE.Object3D;
        L.position.set(0, 0, 0);
        L.add(q);
        L.add(r);
        L.add(ka);
        L.add(h);
        G.add(na);
        G.add(xa);
        G.add(za);
        G.add(k);
        G.add(L);
        F.push(na);
        F.push(xa);
        F.push(za);
        F.push(k);
        f = new THREE.PlaneBufferGeometry(R / 3,R / 3,2,2);
        h = new THREE.MeshBasicMaterial({
            map: ja(c("res/textures/VChome.png")),
            transparent: !0,
            shading: THREE.FlatShading
        });
        z = new THREE.Mesh(f,h);
        z.position.set(-R, R, 0);
        ea = K.length;
        G.add(z);
        K.push(z);
        f = new THREE.PlaneBufferGeometry(1.5 * R,1.5 * R,2,2);
        h = new THREE.MeshBasicMaterial({
            map: ja(c("res/textures/VCarrows.png")),
            shading: THREE.FlatShading,
            transparent: !0
        });
        f = new THREE.Mesh(f,h);
        f.position.set(.5 * 
        R + 20, .5 * R + 20, 0);
        h = new THREE.PlaneBufferGeometry(.6 * R,.45 * R,2,2);
        k = new THREE.MeshBasicMaterial({
            transparent: !0,
            opacity: 0
        });
        h = new THREE.Mesh(h,k);
        h.position.set(.5 * R + 20, R + 20, .1);
        k = new THREE.PlaneBufferGeometry(.45 * R,.6 * R,2,2);
        m = new THREE.MeshBasicMaterial({
            transparent: !0,
            opacity: 0
        });
        k = new THREE.Mesh(k,m);
        k.position.set(R + 20, .5 * R + 20, .1);
        G.add(f);
        G.add(h);
        G.add(k);
        aa = K.length;
        K.push(h);
        Z = K.length;
        K.push(k);
        V = K.length;
        K.push(f);
        f = new THREE.PlaneBufferGeometry(R / 2.3,R / 2.3,2,2);
        h = new THREE.MeshBasicMaterial({
            map: ja(c("res/textures/VCcontext.png")),
            transparent: !0,
            shading: THREE.FlatShading
        });
        I = new THREE.Mesh(f,h);
        I.position.set(R, -R, 0);
        X = K.length;
        G.add(I);
        K.push(I);
        f = new THREE.Geometry;
        f.vertices.push(new THREE.Vector3(0,0,0));
        f.vertices.push(new THREE.Vector3(-R / 2,-R / 2 - 20,-R / 2));
        f.vertices.push(new THREE.Vector3(R / 2,-R / 2 - 20,-R / 2));
        f.vertices.push(new THREE.Vector3(R / 2,-R / 2 - 20,R / 2));
        f.vertices.push(new THREE.Vector3(-R / 2,-R / 2 - 20,R / 2));
        f.faces.push(new THREE.Face3(4,3,2));
        f.faces.push(new THREE.Face3(4,2,1));
        h = new THREE.MeshBasicMaterial({
            color: 0,
            transparent: !0,
            opacity: .5
        });
        H = new THREE.Mesh(f,h);
        t.add(H);
        h = [];
        k = [];
        h[0] = ta(0, 0);
        h[1] = ta(0, Math.PI / 2);
        h[2] = ta(0, -Math.PI / 2);
        h[3] = ta(0, Math.PI);
        h[4] = ta(Math.PI / 2, 0);
        h[5] = ta(Math.PI / 2, Math.PI / 2);
        h[6] = ta(Math.PI / 2, -Math.PI / 2);
        h[7] = ta(Math.PI / 2, Math.PI);
        k[0] = la(0, 0, 0);
        k[1] = la(0, Math.PI / 2, 0);
        k[2] = la(0, -Math.PI / 2, 0);
        k[3] = la(0, Math.PI, 0);
        k[4] = la(Math.PI / 2, 0, 0);
        k[5] = la(Math.PI / 2, Math.PI / 2, 0);
        k[6] = la(Math.PI / 2, -Math.PI / 2, 0);
        k[7] = la(Math.PI / 2, Math.PI, 0);
        k[8] = la(0, 0, Math.PI / 2);
        k[9] = la(0, 0, -Math.PI / 2);
        k[10] = 
        la(-Math.PI / 2, 0, -Math.PI / 2);
        k[11] = la(-Math.PI, 0, -Math.PI / 2);
        J.push(ya(0, 0));
        J[0].name = "front";
        N.push(J[0]);
        M.push(J[0]);
        C.add(J[0]);
        J.push(ya(0, Math.PI / 2));
        J[1].name = "right";
        N.push(J[1]);
        M.push(J[1]);
        C.add(J[1]);
        J.push(ya(0, Math.PI));
        J[2].name = "back";
        N.push(J[2]);
        M.push(J[2]);
        C.add(J[2]);
        J.push(ya(0, -Math.PI / 2));
        J[3].name = "left";
        N.push(J[3]);
        M.push(J[3]);
        C.add(J[3]);
        J.push(ya(Math.PI / 2, 0));
        J[4].name = "bottom";
        N.push(J[4]);
        M.push(J[4]);
        C.add(J[4]);
        J.push(ya(-Math.PI / 2, 0));
        J[5].name = "top";
        N.push(J[5]);
        M.push(J[5]);
        C.add(J[5]);
        f = J.length;
        for (m = 0; m < h.length; m++)
            J.push(h[m]),
            J[f + m].name = n[m],
            C.add(J[f + m]),
            N.push(J[f + m]),
            M.push(J[f + m]);
        f = J.length;
        for (m = 0; m < k.length; m++)
            J.push(k[m]),
            J[f + m].name = l[m],
            C.add(J[f + m]),
            N.push(J[f + m]),
            M.push(J[f + m]);
        "CANVAS" === b.renderer.toUpperCase() ? a.renderer = new THREE.CanvasRenderer : "WEBGL" === b.renderer.toUpperCase() ? a.renderer = new FireflyWebGLRenderer({
            alpha: !0,
            antialias: !0
        }) : (console.log("Incorrect use of Autocam.renderer property"),
        a.renderer = new THREE.CanvasRenderer);
        a.useTransparency(!0);
        a.setSize(a.width, a.height);
        a.camera.topFov = a.camera.bottomFov = a.camera.fov / 2;
        a.camera.leftFov = a.camera.rightFov = a.camera.aspect * a.camera.fov / 2;
        a.renderer.autoClear = !1;
        a.renderer.setSize(a.width, a.height);
        a.renderer.sortObjects = !1;
        g.appendChild(a.renderer.domElement);
        g.addEventListener("touchstart", qa, !1);
        g.addEventListener("mousedown", qa, !1);
        g.addEventListener("mousemove", Ma, !1);
        ia = !1;
        Y.push(ja(c("res/textures/VChomeS.png")));
        Y.push(ja(c("res/textures/VCarrowsS0.png")));
        Y.push(ja(c("res/textures/VCarrowsS1.png")));
        Y.push(ja(c("res/textures/VChome.png")));
        Y.push(ja(c("res/textures/VCarrows.png")));
        Y.push(ja(c("res/textures/VCcontext.png")));
        Y.push(ja(c("res/textures/VCcontextS.png")))
    }
    )()
}
;
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.ToolController = function(f, h, g, d, c) {
    function a(a, c) {
        return h.navigation.getUseLeftHandedInput() && 0 === a || k && 1 === a || b && !n && 0 === a && c.ctrlKey
    }
    this.domElement = h.canvasWrap;
    this.selector = f.selector;
    this.autocam = g;
    this.lastClickY = this.lastClickX = -1;
    this.scrollInputEnabled = !0;
    var b = -1 != navigator.userAgent.search("Mac OS")
      , k = -1 != navigator.userAgent.search("Firefox")
      , l = -1 !== navigator.userAgent.search("Chrome")
      , n = -1 !== navigator.userAgent.search("Safari") && !l
      , m = {}
      , q = []
      , r = !1
      , t = -1
      , w = -1
      , C = !1
      , E = null 
      , 
    G = void 0
      , B = !1
      , v = {}
      , D = this;
    this.__registerToolByName = function(a, b) {
        m[b] = a
    }
    ;
    this.registerTool = function(a) {
        var b = a.getNames();
        if (!b || 0 == b.length)
            return console.log("Cannot register tool with no name."),
            !1;
        for (var c = !1, f = 0; f < b.length; ++f)
            "default" !== b[f] && (this.__registerToolByName(a, b[f]),
            c = !0);
        a.utilities = d;
        a.controller = this;
        a.register && a.register();
        return c
    }
    ;
    this.deregisterTool = function(a) {
        this.deactivateTool(a.getName());
        var b = a.getNames();
        if (!b || 0 == b.length)
            return !1;
        for (var c = b.length; 0 <= --c; )
            this.__deregisterToolName(b[c]);
        a.deregister && a.deregister();
        a.utilities = null ;
        a.controller = null ;
        return !0
    }
    ;
    this.__deregisterToolName = function(a) {
        if (a in m) {
            for (var b = q.length; 0 <= --b; )
                q[b] === a && (m[a].deactivate(a),
                q.splice(b, 1));
            delete m[a]
        }
    }
    ;
    this.getTool = function(a) {
        return m[a]
    }
    ;
    this.getActiveToolName = function() {
        var a = q.length;
        return 0 < a ? q[a - 1] : "default"
    }
    ;
    this.activateTool = function(a) {
        if (r)
            return !1;
        var b = m[a];
        if (b) {
            var c = null ;
            "intercept" === q[q.length - 1] && (c = q.pop());
            q.push(a);
            b.activate(a);
            c && q.push(c);
            h.fireEvent({
                type: Teratek.Viewing.TOOL_CHANGE_EVENT,
                toolName: a,
                active: !0
            });
            return !0
        }
        stderr("activateTool not found: " + a);
        return !1
    }
    ;
    this.deactivateTool = function(a) {
        if (r)
            return !1;
        for (var b = q.length; 0 <= --b; )
            if (q[b] === a)
                return q.splice(b, 1),
                m[a].deactivate(a),
                h.fireEvent({
                    type: Teratek.Viewing.TOOL_CHANGE_EVENT,
                    toolName: a,
                    active: !1
                }),
                !0;
        stderr("deactivateTool not found: " + a);
        return !1
    }
    ;
    this.getToolNames = function() {
        return Object.keys(m)
    }
    ;
    this.setDefaultTool = function(a) {
        var b = this.getDefaultTool();
        return a && a !== b ? (this.__registerToolByName(a, "default"),
        b && 
        b.deactivate("default"),
        a.activate("default"),
        !0) : !1
    }
    ;
    this.getDefaultTool = function() {
        return m["default"]
    }
    ;
    this.setDefaultTool(c);
    this.setIsLocked = function(a) {
        var b = r;
        r = !!a;
        return b
    }
    ;
    this.getIsLocked = function() {
        return r
    }
    ;
    this.__checkCursor = function() {
        for (var a = null , b = q.length; 0 <= --b; ) {
            var c = m[q[b]];
            if ("getCursor" in c && (a = c.getCursor()))
                break
        }
        a || (a = "auto");
        E != a && (E = h.canvas.style.cursor = a)
    }
    ;
    this.update = function(a) {
        this.__checkCursor();
        var b = !1;
        d && d.update() && (b = !0);
        for (var c = q.length; 0 <= --c; ) {
            var f = 
            m[q[c]];
            "update" in f && f.update(a) && (b = !0)
        }
        h.navigation.getCamera().dirty ? (h.navigation.updateCamera(),
        this.cameraUpdated = b = !0) : this.cameraUpdated = !1;
        b ? (h.navigation.updateCamera(),
        this.moveDelay = Date.now() + 150) : 0 !== this.moveDelay && (0 < this.moveDelay - Date.now() ? b = !0 : this.moveDelay = 0);
        return b
    }
    ;
    this.__clientToCanvasCoords = function(a, b, c) {
        var d = h.navigation.getScreenViewport()
          , f = d.width
          , g = d.height
          , k = a.clientX - d.left
          , d = a.clientY - d.top;
        a.canvasX = k;
        a.canvasY = d;
        a.normalizedX = k / f * 2 - 1;
        a.normalizedY = (g - d) / g * 
        2 - 1;
        b && b.set(k / f, d / g, 0);
        c && c.set(k, d)
    }
    ;
    this.__invokeStack = function(a, b, c) {
        for (var d = q.length; 0 <= --d; ) {
            var f = m[q[d]];
            if (a in f && f[a](b, c))
                return !0
        }
        d = this.getDefaultTool();
        return a in d && d[a](b, c) ? !0 : !1
    }
    ;
    this.distributeEvent = function(a, b, c) {
        return this.__invokeStack(a, b, c)
    }
    ;
    this.handleResize = function() {
        h.navigation.setScreenViewport(h.container.getBoundingClientRect());
        for (var a = q.length; 0 <= --a; ) {
            var b = m[q[a]];
            "handleResize" in b && b.handleResize()
        }
    }
    ;
    this.handleSingleClick = function(a) {
        var b = this.applyButtonMappings(a);
        this.lastClickX = a.clientX;
        this.lastClickY = a.clientY;
        this.__invokeStack("handleSingleClick", a, b) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleDoubleClick = function(a) {
        var b = this.applyButtonMappings(a);
        this.__invokeStack("handleDoubleClick", a, b) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleSingleTap = function(a) {
        this.lastClickX = a.canvasX;
        this.lastClickY = a.canvasY;
        this.__invokeStack("handleSingleTap", a) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleDoubleTap = function(a) {
        this.lastClickX = 
        a.canvasX;
        this.lastClickY = a.canvasY;
        this.__invokeStack("handleDoubleTap", a) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleWheelInput = function(a, b) {
        this.__invokeStack("handleWheelInput", a) && (b.preventDefault(),
        b.stopPropagation())
    }
    ;
    this.applyButtonMappings = function(a) {
        var b = a.button;
        "buttons" in a && (a.firefoxSpoof ? b = 0 : !C || a.buttons & 1 ? 2 === b && a.buttons & 1 && (b = 0,
        a.firefoxSpoof = C = !0) : (a.firefoxSpoof = !0,
        C = !1,
        b = 0));
        h.navigation.getUseLeftHandedInput() && (b = 0 === b ? 2 : 2 === b ? 0 : b);
        return b
    }
    ;
    this.applyKeyMappings = 
    function(a, c) {
        switch (a.keyCode) {
        case 91:
        case 93:
        case 224:
            return b && a.metaKey && a.shiftKey ? null  : 17;
        case 16:
            return c && b && a.metaKey ? null  : 16;
        case 61:
            return 187;
        case 173:
        case 109:
            return 189
        }
        return a.keyCode
    }
    ;
    this.handleKeyDown = function(a) {
        var b = this.applyKeyMappings(a, !0);
        b && this.__invokeStack("handleKeyDown", a, b) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleKeyUp = function(a) {
        var b = this.applyKeyMappings(a, !0);
        b && this.__invokeStack("handleKeyUp", a, b) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleButtonDown = 
    function(a, b) {
        this.__invokeStack("handleButtonDown", a, b) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleButtonUp = function(a, b) {
        this.__invokeStack("handleButtonUp", a, b) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleMouseMove = function(a) {
        this.__invokeStack("handleMouseMove", a) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.handleBlur = function(a) {
        this.__invokeStack("handleBlur", a) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.keydown = function(a) {
        if (!(!D.domElement.contains(G) || document.activeElement instanceof 
        HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement)) {
            if (document.activeElement) {
                var c = document.activeElement.getAttribute("contenteditable");
                if ("true" === c || "" === c)
                    return
            }
            b && a.metaKey && 91 != a.keyCode && 93 != a.keyCode || D.handleKeyDown(a)
        }
    }
    ;
    this.keyup = function(a) {
        b && a.metaKey && 91 != a.keyCode && 93 != a.keyCode || D.handleKeyUp(a)
    }
    ;
    this.mousedown = function(b) {
        function c(a) {
            D.applyButtonMappings(a) === d && (document.removeEventListener("mouseup", c),
            D.mouseup(a))
        }
        _isIE11 && inFullscreen() || document.activeElement.blur();
        D.__clientToCanvasCoords(b);
        var d = D.applyButtonMappings(b);
        D.handleButtonDown(b, d);
        t = b.canvasX;
        w = b.canvasY;
        if (a(d, b)) {
            var f = void 0 !== v.time && 500 > b.timeStamp - v.time
              , g = void 0 !== v.x && void 0 !== v.y && 2 >= Math.abs(v.x - b.canvasX) && 2 >= Math.abs(v.y - b.canvasY);
            if (!f || !g || v.clickCount && 2 <= v.clickCount)
                v.clickCount = 0;
            v.clickCount ? 1 === v.clickCount && (v.clickCount = 2) : (v.clickCount = 1,
            v.x = b.canvasX,
            v.y = b.canvasY,
            v.time = b.timeStamp)
        }
        document.addEventListener("mouseup", c, !1);
        D.registerWindowMouseMove()
    }
    ;
    this.mousemove = 
    function(a) {
        D.__clientToCanvasCoords(a);
        var b = w - a.canvasY;
        if (2 < Math.abs(t - a.canvasX) || 2 < Math.abs(b))
            w = t = -1;
        D.handleMouseMove(a)
    }
    ;
    this.mouseup = function(b) {
        D.__clientToCanvasCoords(b);
        var c = D.applyButtonMappings(b);
        D.handleButtonUp(b, c);
        var d = t - b.canvasX
          , f = w - b.canvasY;
        w = t = -1;
        2 >= Math.abs(d) && 2 >= Math.abs(f) && D.handleSingleClick(b);
        a(c, b) && 2 === v.clickCount && (D.handleDoubleClick(b),
        v.clickCount = 0,
        v.x = void 0,
        v.y = void 0,
        v.time = void 0);
        D.unregisterWindowMouseMove()
    }
    ;
    this.doubleclick = function(a) {
        D.__clientToCanvasCoords(a);
        t = a.canvasX;
        w = a.canvasY;
        D.handleDoubleClick(a)
    }
    ;
    this.mousewheel = function(a) {
        if (D.scrollInputEnabled) {
            var b = 0;
            a.wheelDelta ? b = a.wheelDelta / 40 : a.detail && (b = -a.detail);
            D.handleWheelInput(b, a)
        }
    }
    ;
    this.blur = function(a) {
        D.handleBlur(a)
    }
    ;
    this.mouseover = function(a) {
        G = a.target
    }
    ;
    this.registerWindowMouseMove = function() {
        window.addEventListener("mousemove", D.mousemove);
        window.addEventListener("mouseover", D.mouseover);
        D.domElement.removeEventListener("mousemove", D.mousemove);
        D.domElement.removeEventListener("mouseover", 
        D.mouseover)
    }
    ;
    this.unregisterWindowMouseMove = function() {
        window.removeEventListener("mousemove", D.mousemove);
        window.removeEventListener("mouseover", D.mouseover);
        D.domElement.addEventListener("mousemove", D.mousemove);
        D.domElement.addEventListener("mouseover", D.mouseover)
    }
    ;
    this.enableMouseButtons = function(a) {
        a && !B ? (this.domElement.addEventListener("mousedown", this.mousedown),
        this.domElement.addEventListener("dblclick", this.doubleclick),
        this.domElement.addEventListener("mousemove", this.mousemove),
        this.domElement.addEventListener("mouseover", 
        this.mouseover)) : !a && B && (this.domElement.removeEventListener("mousedown", this.mousedown),
        this.domElement.removeEventListener("dblclick", this.doubleclick),
        this.domElement.removeEventListener("mousemove", this.mousemove),
        this.domElement.removeEventListener("mouseover", this.mouseover));
        var b = B;
        B = a;
        return b
    }
    ;
    this.enableMouseButtons(!0);
    this.domElement.addEventListener("mousewheel", this.mousewheel, !1);
    this.domElement.addEventListener("DOMMouseScroll", this.mousewheel, !1);
    window.addEventListener("keydown", 
    this.keydown, !1);
    window.addEventListener("keyup", this.keyup, !1);
    window.addEventListener("blur", this.blur, !1);
    this.uninitialize = function() {
        B && (this.domElement.removeEventListener("mousemove", this.mousemove),
        this.domElement.removeEventListener("mouseover", this.mouseover),
        window.removeEventListener("mousemove", D.mousemove),
        window.removeEventListener("mouseover", D.mouseover));
        window.removeEventListener("keydown", this.keydown);
        window.removeEventListener("keyup", this.keyup);
        window.removeEventListener("blur", 
        this.blur);
        G = f = h = d = D = q = m = this.autocam = this.selector = this.domElement = null 
    }
    ;
    this.set2DMode = function(a) {}
    ;
    this.setAutocam = function(a) {}
    ;
    this.syncCamera = function() {}
    ;
    this.recordHomeView = function() {
        var a = h.navigation.getCamera();
        g.sync(a);
        g.setHomeViewFrom(a)
    }
    ;
    this.setMouseWheelInputEnabled = function(a) {
        this.scrollInputEnabled = a
    }
}
;
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.ViewingUtilities = function(f, h, g) {
    this.autocam = h;
    this.viewerImpl = f;
    var d = g.getCamera()
      , c = {}
      , a = {}
      , b = new function(a) {
        var b = 0
          , c = new THREE.SphereGeometry(1)
          , d = new THREE.MeshPhongMaterial({
            color: 32512,
            ambient: 32512,
            opacity: .6,
            transparent: !0
        })
          , f = new THREE.Mesh(c,d);
        a.createOverlayScene("pivot");
        f.visible = !1;
        this.shown = function() {
            return f.visible
        }
        ;
        this.show = function(c, g, h) {
            f.scale.x = g;
            f.scale.y = g;
            f.scale.z = g;
            f.position.set(c.x, c.y, c.z);
            d.opacity = .6;
            f.visible = !0;
            a.addOverlay("pivot", f);
            a.invalidate(!1, 
            !1, !0);
            b = h ? Date.now() + 500 : 0
        }
        ;
        this.hide = function() {
            f.visible && (f.visible = !1,
            a.removeOverlay("pivot", f),
            a.invalidate(!1, !1, !0),
            b = 0)
        }
        ;
        this.fade = function() {
            if (0 < b) {
                var a = b - Date.now();
                if (0 >= a)
                    return this.hide(),
                    !0;
                d.opacity = a / 500 * .6;
                return !0
            }
            return !1
        }
        ;
        this.fading = function() {
            return 0 < b
        }
    }
    (this.viewerImpl);
    this.transitionView = function(a, b, c, f, q, r) {
        q = q || g.getWorldUpVector();
        if (r)
            if (f = q,
            r = b.clone().sub(a),
            0 === r.lengthSq())
                f = r.copy(f);
            else {
                var t = r.clone().cross(f);
                0 === t.lengthSq() && (f.z > f.y ? r.y -= 1E-4 : r.z -= 1E-4,
                t.crossVectors(r, f));
                f = t.cross(r).normalize()
            }
        f || (f = d.up);
        h.goToView({
            position: a,
            center: b,
            pivot: b,
            fov: c,
            up: f,
            worldUp: q,
            isOrtho: !1 === d.isPerspective
        })
    }
    ;
    this.goHome = function() {
        h.goHome()
    }
    ;
    this.getHitPoint = function(a, b) {
        b = 2 * (1 - b) - 1;
        var c = new THREE.Vector3(2 * a - 1,b,1);
        return (c = this.viewerImpl.hitTestViewport(c, !1)) ? c.intersectPoint : null 
    }
    ;
    this.activatePivot = function(a) {
        var c = d.isPerspective ? g.getPivotPlaneDistance() : g.getEyeVector().length()
          , f = g.getVerticalFov()
          , c = 2 * c * Math.tan(THREE.Math.degToRad(.5 * f))
          , 
        f = g.getScreenViewport()
          , c = 5 * c / (f.height * (window.devicePixelRatio || 1));
        b.show(g.getPivotPoint(), c, a)
    }
    ;
    this.pivotActive = function(a, c) {
        a = a && !g.getIs2D();
        c = c || !1;
        !a && b.shown() ? b.hide() : a && this.activatePivot(c)
    }
    ;
    this.pivotUpdate = function() {
        b.shown() && b.fade() && this.viewerImpl.invalidate(!1, !1, !0)
    }
    ;
    this.setPivotPoint = function(a, c, d) {
        g.setPivotPoint(a);
        c || g.setTarget(a);
        d && g.setPivotSetFlag(!0);
        this.setTemporaryPivot(null );
        g.getIs2D() || b.shown() && this.activatePivot(b.fading())
    }
    ;
    this.savePivot = function(b) {
        b || 
        (b = "default");
        c[b] = g.getPivotPoint();
        a[b] = g.getPivotSetFlag()
    }
    ;
    this.restorePivot = function(b) {
        b || (b = "default");
        if (c[b]) {
            var d = a[b];
            this.setPivotPoint(c[b], !0, d);
            d || g.setPivotSetFlag(!1);
            delete c[b];
            delete a[b]
        }
    }
    ;
    this.setTemporaryPivot = function(b) {
        if (b) {
            var d = g.getPivotPoint()
              , f = g.getPivotSetFlag();
            this.setPivotPoint(b, !0, f);
            c.TEMP = d;
            a.TEMP = f
        } else
            delete c.TEMP,
            delete a.TEMP
    }
    ;
    this.removeTemporaryPivot = function() {
        this.restorePivot("TEMP")
    }
    ;
    this.getBoundingBox = function(a) {
        return this.viewerImpl.getFitBounds(a)
    }
    ;
    this.fitToView = function(a) {
        a = g.fitBounds(a, this.viewerImpl.getFitBounds(!1));
        this.activatePivot(!0);
        return a
    }
    ;
    this.update = function() {
        g.getRequestFitToView() && !g.getTransitionActive() && (g.setRequestFitToView(!1),
        this.fitToView());
        g.getRequestHomeView() && !g.getTransitionActive() && (g.setRequestHomeView(!1),
        this.goHome());
        var a = g.getRequestTransition();
        a && !g.getTransitionActive() && (g.setRequestTransition(!1),
        this.transitionView(a.position, a.coi, a.fov, a.up, a.worldUp, a.reorient));
        return !1
    }
}
;
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.DefaultHandler = function(f, h, g) {
    this.clickConfig = null ;
    this.getNames = function() {
        return ["default"]
    }
    ;
    this.getName = function() {
        return this.getNames()[0]
    }
    ;
    this.setClickBehavior = function(d) {
        this.clickConfig = d
    }
    ;
    this.getClickBehavior = function() {
        return this.clickConfig
    }
    ;
    this.activate = function(d) {}
    ;
    this.deactivate = function(d) {}
    ;
    this.handleAction = function(d, c) {
        for (var a = 0; a < d.length; ++a)
            switch (d[a]) {
            case "selectOnly":
                f.selector && c && f.selector.setSelection([c.dbId], c.model);
                break;
            case "deselectAll":
                f.selector && 
                f.selector.setSelection([]);
                break;
            case "selectToggle":
                f.selector && c && f.selector.toggleSelection(c.dbId, c.model);
                break;
            case "isolate":
                c && f.isolate(c.dbId);
                break;
            case "showAll":
                f.showAll();
                break;
            case "setCOI":
                c && c.intersectPoint && (g.setPivotPoint(c.intersectPoint, !0, !0),
                g.pivotActive(!0, !0));
                break;
            case "hide":
                c && f.hide(c.dbId);
                break;
            case "show":
                c && f.show(c.dbId);
                break;
            case "toggleVisibility":
                c && f.toggleVisibility(c.dbId);
                break;
            case "focus":
                f.selector && (c ? f.selector.setSelection([c.dbId], c.model) : f.selector.setSelection([]),
                g.fitToView())
            }
    }
    ;
    this.handleSingleClick = function(d, c) {
        var a = d.ctrlKey || d.metaKey
          , b = d.shiftKey
          , h = d.altKey;
        if (0 === c) {
            var l = new THREE.Vector3(d.normalizedX,d.normalizedY,1)
              , l = f.hitTestViewport(l, !1)
              , n = "click";
            a && (n += "Ctrl");
            b && (n += "Shift");
            h && (n += "Alt");
            a = l ? "onObject" : "offObject";
            if (this.clickConfig && this.clickConfig[n] && this.clickConfig[n][a])
                return this.handleAction(this.clickConfig[n][a], l),
                !0
        } else if (1 === c && b && !h && !a && (l = new THREE.Vector3(d.normalizedX,d.normalizedY,1),
        (l = f.hitTestViewport(l, !1)) && 
        l.intersectPoint))
            return g.setPivotPoint(l.intersectPoint, !0, !0),
            g.pivotActive(!0, !0),
            !0;
        return !1
    }
    ;
    this.handleDoubleClick = function(d, c) {
        if (f.selector && 0 === c) {
            var a = new THREE.Vector3(d.normalizedX,d.normalizedY,1);
            (a = f.hitTestViewport(a, !1)) ? f.selector.setSelection([a.dbId], a.model) : f.selector.clearSelection();
            g.fitToView();
            return !0
        }
        return 1 === c ? (h.fitBounds(!1, g.getBoundingBox(!0)),
        h.setPivotSetFlag(!1),
        !0) : !1
    }
    ;
    this.handleSingleTap = function(d) {
        d.clientX = d.pointers[0].clientX;
        d.clientY = d.pointers[0].clientY;
        f.api.triggerSingleTapCallback(d);
        return d.hasOwnProperty("pointers") && 2 === d.pointers.length ? (h.setRequestHomeView(!0),
        !0) : f.selector ? (d = new THREE.Vector3(d.normalizedX,d.normalizedY,1),
        (d = f.hitTestViewport(d, !1)) ? (f.selector.setSelection([d.dbId], d.model),
        f.api.triggerSelectionChanged([d.dbId])) : (f.selector.clearSelection(),
        f.api.triggerSelectionChanged(null )),
        !0) : !1
    }
    ;
    this.handleDoubleTap = function(d) {
        d.clientX = d.pointers[0].clientX;
        d.clientY = d.pointers[0].clientY;
        f.api.triggerDoubleTapCallback(d);
        d = this.handleSingleTap(d, 0);
        g.fitToView();
        return d
    }
    ;
    this.handlePressHold = function(d) {
        return "press" === d.type ? (d.clientX = d.pointers[0].clientX,
        d.clientY = d.pointers[0].clientY,
        f.api.triggerContextMenu(d)) : !1
    }
}
;
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.GestureHandler = function(f) {
    var h = f.navigation
      , g = ["gestures"]
      , d = this
      , c = !0
      , a = !0
      , b = null 
      , k = isTouchDevice();
    h.setIsTouchDevice(k);
    k && (b = new Hammer.Manager(f.canvasWrap,{
        recognizers: [[Hammer.Pan, {
            event: "drag",
            pointers: 1
        }], [Hammer.Tap, {
            event: "doubletap",
            taps: 2,
            interval: 300,
            threshold: 6,
            posThreshold: 30
        }], [Hammer.Tap, {
            event: "doubletap2",
            pointers: 2,
            taps: 2,
            interval: 300,
            threshold: 6,
            posThreshold: 40
        }], [Hammer.Tap, {
            event: "singletap2",
            pointers: 2,
            threshold: 3
        }], [Hammer.Tap, {
            event: "singletap",
            threshold: 2
        }], 
        [Hammer.Press, {
            event: "press",
            time: 500
        }], [Hammer.Pan, {
            event: "drag3",
            pointers: 3,
            threshold: 15
        }], [Hammer.Pan, {
            event: "pan",
            pointers: 2,
            threshold: 20
        }], [Hammer.Pinch, {
            enable: !0,
            threshold: .05
        }], [Hammer.Rotate, {
            enable: !0,
            threshold: 7
        }]],
        inputClass: Hammer.TouchInput
    }),
    f.canvasWrap.addEventListener("touchstart", this.onTouchStart, !1));
    this.onTouchStart = function(a) {
        a.preventDefault()
    }
    ;
    this.getNames = function() {
        return g
    }
    ;
    this.getName = function() {
        return g[0]
    }
    ;
    this.__clientToCanvasCoords = function(a) {
        var b = h.getScreenViewport(), 
        c = b.width, d = b.height, f;
        a.hasOwnProperty("center") ? (f = a.center.x - b.left,
        b = a.center.y - b.top) : (f = a.pointers[0].clientX - b.left,
        b = a.pointers[0].clientY - b.top);
        a.canvasX = f;
        a.canvasY = b;
        a.normalizedX = f / c * 2 - 1;
        a.normalizedY = (d - b) / d * 2 - 1
    }
    ;
    this.distributeGesture = function(a) {
        d.__clientToCanvasCoords(a);
        d.controller.distributeEvent("handleGesture", a) && a.preventDefault();
        a = a.type;
        -1 !== a.indexOf("end", a.length - 3) && b.stop()
    }
    ;
    this.onSingleTap = function(a) {
        d.__clientToCanvasCoords(a);
        d.controller.distributeEvent("handleSingleTap", 
        a) && a.preventDefault()
    }
    ;
    this.onDoubleTap = function(a) {
        d.__clientToCanvasCoords(a);
        d.controller.distributeEvent("handleDoubleTap", a) && a.preventDefault()
    }
    ;
    this.onPressHold = function(a) {
        d.__clientToCanvasCoords(a);
        "press" === a.type ? c = d.controller.enableMouseButtons(!1) : d.controller.enableMouseButtons(c);
        d.controller.distributeEvent("handlePressHold", a) && a.preventDefault()
    }
    ;
    this.activate = function(c) {
        b && (b.on("dragstart dragmove dragend", this.distributeGesture),
        b.on("singletap", this.onSingleTap),
        b.on("singletap2", 
        this.onSingleTap),
        b.on("doubletap", this.onDoubleTap),
        b.on("doubletap2", this.onDoubleTap),
        b.on("press pressup", this.onPressHold),
        b.on("drag3start drag3move drag3end", this.distributeGesture),
        a && (b.on("panstart panmove panend", this.distributeGesture),
        b.on("pinchstart pinchmove pinchend", this.distributeGesture),
        b.on("rotatestart rotatemove rotateend", this.distributeGesture)),
        b.get("doubletap2").recognizeWith("doubletap"),
        b.get("singletap2").recognizeWith("singletap"),
        b.get("singletap").requireFailure("doubletap"))
    }
    ;
    this.deactivate = function(c) {
        b && (b.off("dragstart dragmove dragend", this.distributeGesture),
        b.off("singletap", this.onSingleTap),
        b.off("singletap2", this.onSingleTap),
        b.off("doubletap", this.onDoubleTap),
        b.off("doubletap2", this.onDoubleTap),
        b.off("press pressup", this.onPressHold),
        b.off("drag3start drag3move drag3end", this.distributeGesture),
        a && (b.off("panstart panmove panend", this.distributeGesture),
        b.off("pinchstart pinchmove pinchend", this.distributeGesture),
        b.off("rotatestart rotatemove rotateend", 
        this.distributeGesture)))
    }
    ;
    this.update = function() {
        return !1
    }
    ;
    this.handleBlur = function(a) {
        return !1
    }
    ;
    this.disableTwoFingerSwipe = function() {
        a = !1;
        b && (b.remove(Hammer.Pan),
        b.remove(Hammer.Pinch),
        b.remove(Hammer.Rotate),
        b.off("panstart panmove panend", this.distributeGesture),
        b.off("pinchstart pinchmove pinchend", this.distributeGesture),
        b.off("rotatestart rotatemove rotateend", this.distributeGesture))
    }
}
;
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.OrbitDollyPanTool = function(f, h) {
    function g(a, c) {
        var d = window.innerWidth
          , f = window.innerHeight;
        Z.set((a - .5 * d - 0) / (.5 * d), (.5 * f + 0 - c) / (.5 * f), 0);
        d = Z.length();
        1 < d ? Z.normalize() : Z.z = Math.sqrt(1 - d * d);
        S.copy(b.position).sub(b.pivot);
        P.copy(b.up).setLength(Z.y);
        P.add(aa.copy(b.up).cross(S).setLength(Z.x));
        P.add(S.setLength(Z.z));
        return P
    }
    var d = this, c = -1 != navigator.userAgent.search("Mac OS"), a = h.navigation, b = a.getCamera(), k = ["orbit", "freeorbit", "dolly", "pan"], l = k[0], n = [l], m = l, q = null , r = 0, t = 0, w = 
    !1, C = null , E = !1, G, B, v = null , D = -5, z = new THREE.Vector3, H = new THREE.Vector3, I = new THREE.Vector2, J = new THREE.Vector2, L = new THREE.Vector2, F = new THREE.Vector2, N = new THREE.Vector3, K = new THREE.Vector3, M = new THREE.Vector3, S = new THREE.Vector3, ba = new THREE.Vector3, P = new THREE.Vector3, aa = new THREE.Vector3, Z = new THREE.Vector3, V = new THREE.Vector3, ea = new THREE.Quaternion, X = [!1, !1, !1, !1, !1, !1], R = 0, T = 0, O = 0, ca = 0, ia = 1, fa = 5, W = .025;
    this.getNames = function() {
        return k
    }
    ;
    this.getName = function() {
        return k[0]
    }
    ;
    this.activate = function(a) {
        n.push(a);
        m = a
    }
    ;
    this.deactivate = function(a) {
        var b = n.length - 1;
        0 < b && n[b] === a && (n.pop(),
        m = n[b - 1])
    }
    ;
    this.adjustDollyLookSpeed = function(a) {
        0 === a ? (W = .025,
        fa = 5) : (W *= 0 < a ? 1.1 : .9,
        fa *= 0 < a ? 1.1 : .9,
        1E-6 > W && (W = 1E-6),
        1E-6 > fa && (fa = 1E-6))
    }
    ;
    this.getDollySpeed = function(b) {
        var c = a.getEyeVector()
          , d = a.getPosition();
        b = b.clone().sub(d).dot(c.normalize()) * W;
        return .01 > Math.abs(b) ? 0 > b ? -.01 : .01 : b
    }
    ;
    this.getLookSpeed = function() {
        return fa
    }
    ;
    this.coiIsActive = function() {
        return a.getPivotSetFlag() && a.isPointVisible(a.getPivotPoint())
    }
    ;
    this.adjustSpeed = 
    function(a) {
        this.adjustDollyLookSpeed(a);
        this.utilities.autocam && (this.utilities.autocam.orbitMultiplier = this.getLookSpeed())
    }
    ;
    this.initTracking = function(c, d) {
        var f;
        if (b.isPerspective) {
            f = .5 * (b.near + b.far);
            var g = this.utilities.getHitPoint(c, d)
              , h = a.getPosition();
            g && g.sub ? (f = g.sub(h),
            g = a.getEyeVector().normalize(),
            f = Math.abs(g.dot(f))) : a.getPivotSetFlag() && a.isPointVisible(a.getPivotPoint()) && (g = a.getPivotPlaneDistance(),
            1E-5 < g && (f = g))
        } else
            f = a.getEyeVector().length();
        ia = f
    }
    ;
    this.initOrbit = function() {
        this.utilities.setTemporaryPivot(0 >= 
        a.getPivotPoint().sub(a.getPosition()).dot(a.getEyeVector()) ? a.getTarget() : null )
    }
    ;
    this.getCursor = function() {
        switch (l) {
        case "freeorbit":
        case "orbit":
            return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAt1BMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8AAAAzMzP6+vri4uISEhKKioqtra2dnZ2EhIR9fX10dHRkZGQdHR3t7e3Hx8e5ubm1tbWoqKhWVlZKSko4ODgICAjv7+/o6OjMzMyxsbFOTk4pKSkXFxcEBAT29vbW1tZ6enpISEgLCwvhzeX+AAAAGXRSTlMANRO0nHRJHfnskIxQRKh89syDVwTWZjEJxPFEswAAAOFJREFUKM+1j+lygkAQhIflEAJe0Rw9u4CCeKKoSTTX+z9XoMJWWeX+ssrvZ3f19DQ5zOw/0DUMQPlmQ72bE2adBp8/Rp3CQUi3ILx+bxj4fjDs9T1Bmo6bbPPN8aDU4bjJt4nb+de789kSFyxn826jW3ICLNZZKU8nWWbrBTCRVm04U8TpjquRFf1Go0d7l8aYOrUR7FGEFr1S9LGymwthgX2gE/Kl0cHPOtF2xOWZ5QpIC93RflW4InkDoPRXesd5LJIMQPzV7tCMa7f6BvhJL79AVDmYTNQ1NhnxbI/uwB8H5Bjd4zQPBAAAAABJRU5ErkJggg==), auto";
        case "dolly":
            return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAgVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8mJiYAAADNzc2/v7+fn59paWlPT08MDAwICAj6+vqpqak7Ozv29vby8vLp6em2traAgIBkZGRZWVlAQEAaGhpISEgkS7tbAAAAFHRSTlMAOvhpZD8mkQWegMy9qY1YVE01EYiqlE0AAADZSURBVCjPbY9ZloMgEAAbEbfsmRZZXbJn7n/AAX2RQVN/VD26AXLOeZLDGo6IbfI9tHq8cdxuj1HwvgCoaiHqKoRk+M3hB9jueUW8PnfsE/bJ3vms7nCkq7NoE3s99AXxoh8vFoXCpknrn5faAuJCenT0xPkYqnxQFJaU0gdZrsKm8aHZrAIffBj40mc1jsTfIJRWegq6opTMvlfqLqYg7kr1ZB7jFgeaMC59N//8O4WZ1IiPF8b5wMHcJn8zB4g4mc77zpxgAbMSUVoGK4iV0hL4wrksz+H0Bw5+E+HrniDQAAAAAElFTkSuQmCC), auto";
        case "pan":
            return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAABHVBMVEUAAABPTk4AAAAAAAAJCQkRERE0MzQQEBAODg4QEBB4d3dbWlo9PDw/Pj4vLy8sLCwZGBgWFhYcHBwKCgoSEhIAAAAKCgoICAgKCgoQEBAODg4EBAQICAgPDw8REREMDAx2dnY0NDQvLy9QUFAaGhomJSYjIyM7OjokJCQNDA0mJiYNDQ0AAAAUFBQJCQkQEBAEBAQNDQ0PDw8VFRX///+amJkAAAD5+fnz8/PKycn9/f339vbi4eLR0dDNzMyAgIB8e3xycHH7+/vw7+/o6OjX1ta7urq4t7iwsLCnp6eioqKbmppva21OTk74+Pjl5eXc3Nzb29vLy8vDw8PDwsKrqqqdnZ2WlpaSkpKTkZKMiouEg4NkZGRISEgxLzBpgbsEAAAANHRSTlMA+fiQXgngKSYG/vX17uvBuqackpCNg3BpUkpAPBwTDvj18+vl0s/NwrOwoZZ+TDg4NBkBGrzX8QAAAP5JREFUKM99j9Vuw0AQRdeuKZyGkyZNmbnXDLHDVGb8/8/oy7paK1bO0+oc7WiGnGiaxq+QRTQAOh8f9Jv4H/Ge8PZPrCdlvkxfYluUT2WyyCq3mZ7unwlKVLcqOzA/Mf71j0TWJ/Ym6rPeca05Ni4iIevYc7yoUD2zQFhq71BdI9nvBeBabFDSPe8DswlUc1Riw3VxbH0NHBUPQ0jrbDnPYDjALQBMq9E7nkC5y7VDKTZlUg8Q0lmjvl74zlYErgvKa42GPKf3/a0kQmYCDY1SYMDosqMoiWrGwz/uAbNvc/fNon4kXRKGq+PUo2Mb96afV0iUxqGU2s4VBbKUP65NL/LKF+7ZAAAAAElFTkSuQmCC), auto"
        }
        return null 
    }
    ;
    this.getMotionDelta = function(b, d) {
        var f = a && a.getReverseZoomDirection() ? -1.5 : 1.5;
        c && (f *= -1);
        X[0] && (H.x += .01,
        L.x += 20);
        X[1] && (H.x -= .01,
        L.x -= 20);
        X[2] && (H.y += .01,
        L.y += 20);
        X[3] && (H.y -= .01,
        L.y -= 20);
        X[4] && (H.z += f);
        X[5] && (H.z -= f);
        var f = H.x - z.x
          , g = H.y - z.y
          , h = H.z - z.z;
        .001 > Math.abs(f) && (f = 0);
        .001 > Math.abs(g) && (g = 0);
        .001 > Math.abs(h) && (h = 0);
        b.set(f, g, h);
        d && d.set(L.x - J.x, L.y - J.y)
    }
    ;
    this.stepMotionDelta = function(a, b) {
        b ? (z.x += .6 * a.x,
        z.y += .6 * a.y,
        z.z += .6 * a.z) : z.copy(H);
        J.copy(L)
    }
    ;
    this.update = function() {
        var c = !1, d = !1, f;
        this.getMotionDelta(N, F);
        f = N.x;
        var g = N.y
          , n = N.z;
        w || this.checkInteractionMode();
        (w = -1 < D) && this.controller.setIsLocked(!0);
        if (0 !== f || 0 !== g || 0 !== n) {
            switch (l) {
            case "orbit":
                this.utilities.autocam && this.utilities.autocam.startState && (F.x = -F.x,
                C && this.utilities.autocam.orbit(L, C, F.multiplyScalar(2), this.utilities.autocam.startState));
                break;
            case "freeorbit":
                S.subVectors(b.position, b.pivot);
                ba.subVectors(b.position, b.target);
                d = ba.length();
                ba.normalize();
                if (f = Math.acos(K.dot(M) / K.length() / M.length()))
                    f *= 2,
                    V.crossVectors(K, 
                    M).normalize(),
                    ea.setFromAxisAngle(V, -f),
                    S.applyQuaternion(ea),
                    b.up.applyQuaternion(ea),
                    M.applyQuaternion(ea),
                    ba.applyQuaternion(ea),
                    K.copy(M);
                b.position.addVectors(b.pivot, S);
                b.target.subVectors(b.position, ba.multiplyScalar(d));
                b.dirty = !0;
                break;
            case "dolly":
                n *= .6;
                0 <= D ? (g = -g,
                n = Math.abs(f) > Math.abs(g) ? f : g,
                n *= 100,
                d = f = .5) : (f = a.getScreenViewport(),
                d = G / f.width,
                f = B / f.height);
                d = !a.getIs2D() && a.getZoomTowardsPivot() ? this.coiIsActive() ? a.getPivotPoint() : a.getWorldPoint(.5, .5) : a.getWorldPoint(d, f);
                a.dollyFromPoint(n * 
                this.getDollySpeed(d), d);
                break;
            case "pan":
                a.panRelative(-f, g, ia);
                break;
            case "dollypan":
                0 === f && 0 === g || a.panRelative(-f, g, ia),
                f = a.getScreenViewport(),
                d = G / f.width,
                f = B / f.height,
                d = a.getWorldPoint(d, f),
                f = a.getPosition(),
                f = a.getIs2D() ? f.sub(d).length() : ia,
                g = (r / t - 1) * f,
                a.dollyFromPoint(g, d),
                r = t,
                ia = f + g
            }
            d = !0
        }
        this.stepMotionDelta(N, "pan" !== l && "dollypan" !== l);
        -1 === D && 1E-5 > Math.abs(n) && (this.interactionEnd(-1),
        d = c = !0);
        (R || T) && -1 !== k.indexOf(h.getActiveNavigationTool()) && (d = !0);
        !E && (c || -5 < D) && (-1 < D && (z.copy(H),
        this.utilities.removeTemporaryPivot()),
        this.utilities.autocam.endInteraction(),
        D = -5,
        w && this.controller.setIsLocked(!1),
        w = !1,
        q = C = null );
        d ? this.utilities.pivotActive(a.getPivotSetFlag(), -1 >= D) : this.utilities.pivotUpdate();
        return b.dirty
    }
    ;
    this.checkInteractionMode = function() {
        var a;
        a = 1 === D && R ? n[1] : 2 === D && R && !T && !O || 2 === D && T && !R && !O || "dolly" === m && !T && "pinch" !== q || 0 !== N.z ? O || T || R || 2 !== D && 1 !== D ? "dolly" : "pan" : !(2 !== D || R || T ^ O) || 2 === D && R && O || 1 === D && !R && !O || 1 === D && T || 1 === D && O && !T || 0 === D && R && !O && !T || "pan" === m && 
        1 !== D && !T && "pinch" !== q || ca ? "pan" : "pan" === q || "pinch" === q ? "dollypan" : m;
        a !== l && (l = a,
        ("pan" === l && -1 < D || "dollypan" === l) && this.initTracking(z.x, z.y))
    }
    ;
    this.interactionStart = function(c, d) {
        if (d || c > D)
            D = c,
            E = !0,
            -1 < c && ("pan" === l && this.initTracking(z.x, z.y),
            "orbit" === l && this.initOrbit()),
            this.utilities.pivotActive(a.getPivotSetFlag(), -1 === c),
            this.utilities.autocam && (this.utilities.autocam.sync(b),
            this.utilities.autocam.startInteraction(J.x, J.y),
            C = J.clone())
    }
    ;
    this.interactionCheck = function() {
        (X[0] || X[1] || X[2] || 
        X[3] || X[4] || X[5] || R || O || T || ca) && this.interactionStart(-4, !0)
    }
    ;
    this.interactionEnd = function(a) {
        a === D && (-1 !== a && this.utilities.pivotActive(!1),
        E = !1)
    }
    ;
    this.handleWheelInput = function(b) {
        if (this.isDragging)
            return !1;
        if (a.getIs2D()) {
            var c = a.getScreenViewport()
              , c = f.intersectGround(G + c.width, B + c.height);
            this.utilities.setPivotPoint(c, !0, !0)
        }
        a.getReverseZoomDirection() && (b *= -1);
        H.z += b;
        c = Date.now();
        v || (v = c);
        0 != b && this.interactionStart(-1);
        return !0
    }
    ;
    this.resetKeys = function() {
        this.autoMove(-1, !1);
        ca = T = O = R = 0
    }
    ;
    this.autoMove = function(a, b) {
        b && this.isDragging || (0 > a ? X[0] = X[1] = X[2] = X[3] = X[4] = X[5] = b : X[a] = b,
        b || this.interactionEnd(-4),
        this.interactionCheck())
    }
    ;
    this.updateModifierState = function(a) {
        O = c && a.metaKey || a.ctrlKey ? 1 : 0;
        R = a.shiftKey ? 1 : 0;
        T = a.altKey ? 1 : 0
    }
    ;
    this.handleKeyDown = function(a, b) {
        this.updateModifierState(a);
        var c = !1;
        switch (b) {
        case 187:
            this.adjustSpeed(1);
            c = !0;
            break;
        case 189:
            this.adjustSpeed(-1);
            c = !0;
            break;
        case 48:
            this.adjustSpeed(0);
            c = !0;
            break;
        case 37:
            this.autoMove(0, !0);
            c = !0;
            break;
        case 39:
            this.autoMove(1, 
            !0);
            c = !0;
            break;
        case 33:
            this.autoMove(2, !0);
            c = !0;
            break;
        case 34:
            this.autoMove(3, !0);
            c = !0;
            break;
        case 38:
            this.autoMove(4, !0);
            c = !0;
            break;
        case 40:
            this.autoMove(5, !0);
            c = !0;
            break;
        default:
            return !1
        }
        this.isDragging || this.interactionStart(-4);
        return c
    }
    ;
    this.handleKeyUp = function(a, b) {
        this.updateModifierState(a);
        var c = !1;
        switch (b) {
        case 37:
            this.autoMove(0, !1);
            c = !0;
            break;
        case 39:
            this.autoMove(1, !1);
            c = !0;
            break;
        case 33:
            this.autoMove(2, !1);
            c = !0;
            break;
        case 34:
            this.autoMove(3, !1);
            c = !0;
            break;
        case 38:
            this.autoMove(4, !1);
            c = !0;
            break;
        case 40:
            this.autoMove(5, !1);
            c = !0;
            break;
        default:
            return !1
        }
        c && (this.interactionEnd(-4),
        E || this.interactionCheck());
        return c
    }
    ;
    this.handleDollyPan = function(b) {
        G = b.canvasX;
        B = b.canvasY;
        var c = a.getScreenViewport();
        L.x = I.x + b.deltaX;
        L.y = I.y + b.deltaY;
        H.x = L.x / c.width;
        H.y = L.y / c.height;
        var c = b.pointers[1].clientX - b.pointers[0].clientX
          , d = b.pointers[1].clientY - b.pointers[0].clientY;
        t = Math.sqrt(c * c + d * d);
        b = b.type;
        -1 !== b.indexOf("start", b.length - 5) && (r = t)
    }
    ;
    this.handleGesture = function(a) {
        switch (a.type) {
        case "dragstart":
            return q = 
            "drag",
            this.handleButtonDown(a, 0);
        case "dragmove":
            return "drag" === q ? this.handleMouseMove(a) : !1;
        case "dragend":
            if ("drag" === q)
                return this.handleButtonUp(a, 0),
                q = null ,
                !0;
            break;
        case "panstart":
            return q = "pan",
            this.isDragging = !0,
            z.x = .5 * (a.normalizedX + 1),
            z.y = 1 - .5 * (a.normalizedY + 1),
            I.set(a.canvasX, a.canvasY),
            J.set(a.canvasX, a.canvasY),
            this.interactionStart(3),
            this.handleDollyPan(a),
            !0;
        case "panmove":
            return "pan" === q ? this.handleDollyPan(a) : !1;
        case "panend":
            if ("pan" === q)
                return this.isDragging = !1,
                this.handleDollyPan(a),
                this.interactionEnd(3),
                !0;
            break;
        case "pinchstart":
            return this.isDragging = !0,
            q = "pinch",
            z.x = .5 * (a.normalizedX + 1),
            z.y = 1 - .5 * (a.normalizedY + 1),
            I.set(a.canvasX, a.canvasY),
            J.set(a.canvasX, a.canvasY),
            this.interactionStart(3),
            this.handleDollyPan(a),
            !0;
        case "pinchmove":
            return "pinch" === q ? this.handleDollyPan(a) : !1;
        case "pinchend":
            if ("pinch" === q)
                return this.isDragging = !1,
                this.handleDollyPan(a),
                this.interactionEnd(3),
                !0
        }
        return !1
    }
    ;
    this.handleButtonDown = function(a, b) {
        this.updateModifierState(a);
        z.x = .5 * (a.normalizedX + 
        1);
        z.y = 1 - .5 * (a.normalizedY + 1);
        J.set(a.canvasX, a.canvasY);
        H.copy(z);
        L.copy(J);
        K.copy(g(a.canvasX, a.canvasY));
        M.copy(K);
        G = a.canvasX;
        B = a.canvasY;
        this.isDragging = !0;
        this.interactionStart(b);
        return !0
    }
    ;
    this.handleButtonUp = function(a, b) {
        this.updateModifierState(a);
        H.x = .5 * (a.normalizedX + 1);
        H.y = 1 - .5 * (a.normalizedY + 1);
        L.set(a.canvasX, a.canvasY);
        M.copy(g(a.canvasX, a.canvasY));
        K.copy(M);
        G = a.canvasX;
        B = a.canvasY;
        this.interactionEnd(b);
        this.isDragging = !1;
        return !0
    }
    ;
    this.handleMouseMove = function(a) {
        this.updateModifierState(a);
        if (!this.isDragging)
            return z.x = .5 * (a.normalizedX + 1),
            z.y = 1 - .5 * (a.normalizedY + 1),
            J.set(a.canvasX, a.canvasY),
            H.x = z.x,
            H.y = z.y,
            L.copy(J),
            G = a.canvasX,
            B = a.canvasY,
            f.rolloverObject(G, B),
            !1;
        H.x = .5 * (a.normalizedX + 1);
        H.y = 1 - .5 * (a.normalizedY + 1);
        L.set(a.canvasX, a.canvasY);
        M.copy(g(a.canvasX, a.canvasY));
        G = a.canvasX;
        B = a.canvasY;
        return !0
    }
    ;
    this.handleBlur = function(a) {
        this.resetKeys();
        this.interactionEnd(D)
    }
    ;
    h.addEventListener(Teratek.Viewing.ESCAPE_EVENT, function(a) {
        d.handleBlur(a)
    }
    )
}
;
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.HotGestureTool = function(f) {
    navigator.userAgent.search("Mac OS");
    f.navigation.getCamera();
    var h = ["hottouch"]
      , g = null 
      , d = null 
      , c = !1
      , a = !1
      , b = null ;
    this.getNames = function() {
        return h
    }
    ;
    this.getName = function() {
        return h[0]
    }
    ;
    this.activate = function(a) {}
    ;
    this.deactivate = function(a) {}
    ;
    this.__checkStart = function() {
        b && (this.controller.distributeEvent("handleGesture", b),
        b = null )
    }
    ;
    this.update = function() {
        if (this.controller.getIsLocked())
            return !1;
        var b = f.getActiveNavigationTool()
          , h = !1 === c && !0 === a
          , n = !0 === 
        c && !1 === a;
        if (h || n) {
            h = h ? "worldup" : "fov";
            if (b === h)
                return !1;
            if (b === g)
                return f.setActiveNavigationTool(h),
                g = h,
                this.__checkStart(),
                !1;
            d = b;
            f.setActiveNavigationTool(h);
            g = h;
            this.__checkStart()
        } else
            g && (f.setActiveNavigationTool(d),
            d = g = null );
        return !1
    }
    ;
    this.resetKeys = function() {}
    ;
    this.updateModifierState = function(a) {}
    ;
    this.handleGesture = function(d) {
        if (d === b)
            return !1;
        switch (d.type) {
        case "drag3start":
            b = d;
            c = !0;
            break;
        case "drag3end":
            c = !1;
            break;
        case "rotatestart":
            b = d;
            a = !0;
            break;
        case "rotateend":
            a = !1
        }
        return !1
    }
    ;
    this.handleKeyDown = function(a, b) {
        this.updateModifierState(a);
        return !1
    }
    ;
    this.handleKeyUp = function(a, b) {
        this.updateModifierState(a);
        return !1
    }
    ;
    this.handleButtonDown = function(a, b) {
        this.updateModifierState(a);
        return !1
    }
    ;
    this.handleButtonUp = function(a, b) {
        this.updateModifierState(a);
        return !1
    }
    ;
    this.handleMouseMove = function(a) {
        this.updateModifierState(a);
        return !1
    }
    ;
    this.handleBlur = function(a) {
        this.resetKeys();
        return !1
    }
}
;
"use strict";
TeratekNamespace("Teratek.Viewing.Private");
Teratek.Viewing.HotkeyManager = function() {
    function f(a, b) {
        return a - b
    }
    function h() {
        var d = c.join(), f, g;
        for (g = 0; g < b.length; )
            f = b[g],
            f.keys === d ? b.splice(g, 1) : g++;
        for (g = 0; g < a.length; )
            f = a[g],
            f.keys !== d ? a.splice(g, 1) : g++
    }
    function g(f, g) {
        var k = c.join()
          , q = c.slice(0)
          , r = c.indexOf(g);
        -1 < r && c.splice(r, 1);
        var t = c.join()
          , w = c.slice(0);
        h();
        for (var C = [], E = [], G, r = d.length - 1; 0 <= r; r--)
            G = d[r],
            G.keys === k && G.onRelease ? C.unshift(G) : G.keys === t && G.onPress && E.unshift(G);
        for (r = C.length - 1; 0 <= r && (G = C[r],
        !G.onRelease(q)); r--)
            G.options.tryUntilSuccess && 
            b.unshift(G);
        for (r = E.length - 1; 0 <= r && (G = E[r],
        !G.onPress(w)); r--)
            G.options.tryUntilSuccess && a.unshift(G)
    }
    var d = []
      , c = []
      , a = []
      , b = []
      , k = ["hotkeys"];
    return {
        pushHotkeys: function(a, b, c) {
            if (d.some(function(b) {
                return b.id === a
            }
            ))
                return !1;
            for (var g = 0; g < b.length; g++)
                d.push({
                    id: a,
                    keys: b[g].keycodes.sort(f).join(),
                    onPress: b[g].onPress,
                    onRelease: b[g].onRelease,
                    options: c || {}
                });
            return !0
        },
        popHotkeys: function(a) {
            for (var b = !1, c = d.length - 1; 0 <= c; c--)
                d[c].id === a && (d.splice(c, 1),
                b = !0);
            return b
        },
        handleKeyDown: function(f, g) {
            if (-1 === 
            c.indexOf(g)) {
                for (var k = c.join(), q = c.slice(0), r = 0; r < c.length && c[r] < g; )
                    r++;
                c.splice(r, 0, g);
                var t = c.join()
                  , w = c.slice(0);
                h();
                for (var C = [], E = [], G, r = d.length - 1; 0 <= r; r--)
                    G = d[r],
                    G.keys === k && G.onRelease ? C.unshift(G) : G.keys === t && G.onPress && E.unshift(G);
                for (r = C.length - 1; 0 <= r && (G = C[r],
                !G.onRelease(q)); r--)
                    G.options.tryUntilSuccess && b.unshift(G);
                for (r = E.length - 1; 0 <= r && (G = E[r],
                !G.onPress(w)); r--)
                    G.options.tryUntilSuccess && a.unshift(G)
            }
        },
        handleKeyUp: g,
        handleBlur: function() {
            for (var a = c.length - 1; 0 <= a; a--)
                g(null , 
                c[a])
        },
        getName: function() {
            return k[0]
        },
        getNames: function() {
            return k
        },
        activate: function() {},
        deactivate: function() {},
        update: function() {
            var c, d;
            for (d = 0; d < b.length; )
                c = b[d],
                !0 === c.onRelease(c.keys.split()) ? b.splice(d, 1) : d++;
            for (d = 0; d < a.length; )
                c = a[d],
                !0 === c.onPress(c.keys.split()) ? a.splice(d, 1) : d++;
            return !1
        },
        KEYCODES: {
            BACKSPACE: 8,
            TAB: 9,
            ENTER: 13,
            SHIFT: 16,
            CONTROL: 17,
            ALT: 18,
            ESCAPE: 27,
            SPACE: 32,
            PAGEUP: 33,
            PAGEDOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            INSERT: 45,
            DELETE: 46,
            ZERO: 48,
            a: 65,
            b: 66,
            c: 67,
            d: 68,
            e: 69,
            f: 70,
            g: 71,
            h: 72,
            i: 73,
            j: 74,
            k: 75,
            l: 76,
            m: 77,
            n: 78,
            o: 79,
            p: 80,
            q: 81,
            r: 82,
            s: 83,
            t: 84,
            u: 85,
            v: 86,
            w: 87,
            x: 88,
            y: 89,
            z: 90,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            SEMICOLON: 186,
            EQUALS: 187,
            COMMA: 188,
            DASH: 189,
            PERIOD: 190,
            SLASH: 191,
            LBRACKET: 219,
            RBRACKET: 221,
            SINGLEQUOTE: 222
        }
    }
}
;
Teratek.Viewing.theHotkeyManager = new Teratek.Viewing.HotkeyManager;
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.FovTool = function(f) {
    var h = f.navigation
      , g = h.getCamera()
      , d = ["fov"]
      , c = !1
      , a = 0
      , b = null 
      , k = null 
      , l = !1
      , n = 0
      , m = -5
      , q = new THREE.Vector3
      , r = new THREE.Vector3
      , t = new THREE.Vector3
      , w = null ;
    this.getNames = function() {
        return d
    }
    ;
    this.getName = function() {
        return d[0]
    }
    ;
    this.activate = function(a) {
        n = 0
    }
    ;
    this.deactivate = function(a) {
        m = -5
    }
    ;
    this.getCursor = function() {
        return 0 !== n && -5 === m ? null  : "url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAACEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnAwMD/yEhIf8AAABmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAGknJyf/goKC/8/Pz/8aGhr/AAAALQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAABTFBQU/2lpaf/MzMz///////////+Wlpb/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAOAAAAKFTU1P/t7e3////////////8PDw////////////AQEB/wAAAAEAAAAAAAAAFAAAAH0KCgr/AAAAYwAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAjCwsL/6Ghof/t7e3///////Dw8P9MTEz/LS0t//Pz8///////Ghoa/wAAABoAAAANDQ0N/319ff+rq6v/Y2Nj/wAAAK8AAABGAAAA////////////AAAA/wAAAF0hISH/jIyM////////////sLCw/xEREf8AAACHAAAArKysrP//////V1dX/wAAAFcAAABSUlJS//f39///////8PDw/6+vr/86Ojr/LS0t////////////FRUV/1xcXP/Gxsb/+Pj4//Hx8f9MTEz/AAAAsAAAAEcAAAAAAAAAZ2dnZ///////pKSk/wAAAKQAAACtra2t///////////////////////m5ub/kZGR/wAAAP8AAAD/q6ur//Hx8f//////vb29/x0dHf8AAACIAAAAAAAAAAAAAAAAAAAAOjo6Ov//////5+fn/wAAAOcAAADd3d3d////////////////////////////+/v7/9bW1v/i4uL//v7+//Pz8/9hYWH/AAAAvQAAAFQAAAAAAAAAAAAAAAAAAAAAAAAAJycnJ//6+vr//////wMDA/8AAADv7+/v/////////////////////////////////////////////////7y8vP8ODg7/AAAAKwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJiYmJv/6+vr//////wkJCf8AAADv7+/v//////////////////////////////////f39//9/f3//////+np6f+UlJT/GBgY/wAAAH0AAAACAAAAAAAAAAAAAAAAAAAAKSkpKf///////v7+/w0NDf8AAADd3d3d////////////////////////////29vb/39/f/+Xl5f/5+fn////////////5ubm/1RUVP8CAgL/AAAAPwAAAAAAAAAAAAAAOTk5Of//////8PDw/wgICP8AAAChoaGh/////////////////+np6f+YmJj/QkJC/wAAAP8AAAD/UFBQ/7e3t//39/f///////////+oqKj/EBAQ/wAAAIgAAAAAAAAAZ2dnZ///////29vb/wEBAf8AAAA4NTU1/9zc3P/t7e3/tbW1/01NTf8AAACYAAAA////////////AwMD/wsLC/9oaGj/y8vL////////////8fHx/zg4OP8AAACWAAAApaWlpf//////n5+f/wAAAJ8AAAAAAAAAczg4OP9LS0v/EhIS/wAAAE0AAAAAAAAA////////////FRUV/wAAABUAAABoJSUl/4GBgf/i4uL///////////9+fn7/Pz8///b29v//////SkpK/wAAAEoAAAAAAAAAAAAAADgAAABLAAAAEgAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAJQAAAIE8PDz/np6e//z8/P/////////////////8/Pz/CQkJ/wAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAA8DAwM/09PT/+7u7v///////////+QkJD/AAAAkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////Dw8P/wAAAA8AAAAAAAAAAAAAAAAAAAAAAAAADAAAAFIYGBj/aGho/729vf8WFhb/AAAAJwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////FRUV/wAAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAQEB/w8PD/8AAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////DAwM/wAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x/h/nO/4fw1D+HwFy/h4BRu4YAHOGEABkAAAAXAAAIFwAAOBnAAHgIAAD4GUAAOB4AABgXAAAIGMAAABtggAAVMYYAHT+HgE7/g8BcP4Pw2/+D+dc/h//XP///2c=), auto"
    }
    ;
    this.getMotionDelta = function(a) {
        var b = r.x - q.x
          , c = r.y - q.y
          , d = r.z - q.z;
        .001 > Math.abs(b) && (b = 0);
        .001 > Math.abs(c) && (c = 0);
        .001 > Math.abs(d) && (d = 0);
        a.set(b, c, d)
    }
    ;
    this.stepMotionDelta = function(a, b) {
        b ? (q.x += .6 * a.x,
        q.y += .6 * a.y,
        q.z += .6 * a.z) : q.copy(r)
    }
    ;
    this.getAccumulatedWheelDelta = function() {
        var c = Date.now()
          , d = 0;
        k && 100 < c - k ? (d = 0 > a && -3 < a ? -3 : 0 < a && 3 > a ? 3 : a,
        a = 0,
        k = b = null ,
        l = !1) : b && 100 < c - b && (l ? 3 <= Math.abs(a) && (d = a,
        a = 0) : (d = 0 > a && -3 < a ? -3 : 0 < a && 3 > a ? 3 : a,
        l = !0,
        a = 0));
        return d
    }
    ;
    this.update = function() {
        var a = !1
          , b = -5 < m;
        if (-5 < m) {
            this.controller.setIsLocked(!0);
            this.getMotionDelta(t);
            var d = t.x
              , f = t.y
              , k = t.z;
            if (0 !== d || 0 !== f || 0 !== k)
                b = !0,
                0 <= m ? (f = -f,
                k = Math.abs(d) > Math.abs(f) ? d : f,
                0 !== k && (k *= -1,
                h.setVerticalFov(h.getVerticalFov() * (1 + k), !0))) : (d = this.getAccumulatedWheelDelta() / 3,
                0 !== d && h.setFocalLength(h.getFocalLength() + d, !0));
            this.stepMotionDelta(t, !0);
            -1 === m && 1E-5 > Math.abs(k) && (this.interactionEnd(-1),
            a = !0)
        }
        b ? this.utilities.pivotActive(h.getPivotSetFlag(), !0) : this.utilities.pivotUpdate();
        !c && (a || -5 < m) && (-1 < m && q.copy(r),
        m = -5,
        this.controller.setIsLocked(!1));
        return g.dirty
    }
    ;
    this.interactionStart = function(a, b) {
        if (b || a > m)
            m = a,
            c = !0;
        h.toPerspective()
    }
    ;
    this.interactionEnd = function(a) {
        a === m && (-1 !== a && this.utilities.pivotActive(!1),
        c = !1)
    }
    ;
    this.handleWheelInput = function(c) {
        if (-1 < m)
            return !1;
        h.getReverseZoomDirection() && (c *= -1);
        r.z += c;
        a += c;
        var d = Date.now();
        b || (b = d);
        k = d;
        0 != c && this.interactionStart(-1);
        return !0
    }
    ;
    this.handleGesture = function(a) {
        switch (a.type) {
        case "dragstart":
            return this.handleButtonDown(a, 0);
        case "dragmove":
            return this.handleMouseMove(a);
        case "dragend":
            return this.handleButtonUp(a, 
            0);
        case "drag3start":
            return w = "drag",
            this.handleButtonDown(a, 0);
        case "drag3move":
            return "drag" === w ? this.handleMouseMove(a) : !1;
        case "drag3end":
            "drag" === w && this.handleButtonUp(a, 0),
            w = null 
        }
        return !1
    }
    ;
    this.handleButtonDown = function(a, b) {
        n += 1 << b;
        return 2 !== b ? (q.x = .5 * (a.normalizedX + 1),
        q.y = 1 - .5 * (a.normalizedY + 1),
        r.copy(q),
        this.interactionStart(b),
        !0) : !1
    }
    ;
    this.handleButtonUp = function(a, b) {
        n -= 1 << b;
        return 2 !== b ? (r.x = .5 * (a.normalizedX + 1),
        r.y = 1 - .5 * (a.normalizedY + 1),
        this.interactionEnd(b),
        !0) : !1
    }
    ;
    this.handleMouseMove = 
    function(a) {
        r.x = .5 * (a.normalizedX + 1);
        r.y = 1 - .5 * (a.normalizedY + 1);
        return -1 < m
    }
    ;
    this.handleBlur = function(a) {
        this.interactionEnd(m);
        return !1
    }
}
;
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.WorldUpTool = function(f, h) {
    var g = h.navigation
      , d = g.getCamera()
      , c = ["worldup"]
      , a = this
      , b = function() {
        var a = new THREE.Vector3;
        return function(b, c, d, f) {
            b = new THREE.Vector3(b,c,d);
            c = f.dot(b);
            a.copy(f);
            a.multiplyScalar(c);
            return b.sub(a)
        }
    }
    ()
      , k = 2 * Math.PI
      , l = !1
      , n = !1
      , m = !1
      , q = new function(a, c) {
        function d(a, b) {
            var c = Math.abs(a - b);
            return c > k ? c : Math.min(k - c, c)
        }
        function f(a, b) {
            var c = l(a);
            if (1E-5 > c.distanceToSquared(b))
                return !0;
            C.set(-b.x, -b.y, -b.z);
            return 1E-5 > c.distanceToSquared(C)
        }
        function h(a) {
            return a > 
            k ? a : 0 >= a ? a + Math.PI : a - Math.PI
        }
        function l(a) {
            w.set(0, 0, 0);
            if (0 <= a) {
                var b = 3 <= a ? -1 : 1;
                a %= 3;
                0 === a && (w.x = b);
                1 === a && (w.y = b);
                2 === a && (w.z = b)
            }
            da && w.multiplyScalar(-1);
            return w
        }
        function n(a, b) {
            for (var c = d(W[0], a), f = 0, g = 1; 6 > g; ++g) {
                var h = d(W[g], a);
                h < c && (c = h,
                f = g)
            }
            return c < b ? f : -1
        }
        function m(a) {
            if (0 !== a) {
                var b = 30 * Math.PI / 180
                  , c = C.copy(P.position).sub(V).normalize();
                E.setFromAxisAngle(c, a);
                a = g.getWorldUpVector();
                c = Math.abs(c.angleTo(a));
                (c < b || Math.PI - c < b) && a.copy(g.getCameraUpVector());
                a.applyQuaternion(E);
                g.setIsLocked(!1);
                g.setWorldUpVector(a, !0);
                g.setIsLocked(!0)
            }
        }
        function q(a, b) {
            0 > a.dot(b) && (b = b.clone().multiplyScalar(-1));
            g.orient(ca, V, P.position, b);
            ca.position.copy(b.multiplyScalar(.495));
            for (var c = !1, f = na ? Ha : Ia, h = 0; 6 > h; ++h) {
                var k = d(W[h], ga), n;
                n = a;
                n = k < f ? 1E-5 > l(h).distanceToSquared(n) : !1;
                n && (c = !0);
                k = n ? 4 : 3 * (1 - 3 * k / Math.PI);
                1 > k && (k = 1);
                k *= aa;
                fa[h].visible = n;
                n = ia[h];
                n.scale.x = k;
                n.scale.y = k;
                n.scale.z = k
            }
            X.visible = c;
            R.visible = c;
            return T.visible = c
        }
        function r(a) {
            ga += a;
            ga > Math.PI ? ga -= k : ga <= -Math.PI && (ga = k + ga);
            var b;
            a: {
                if (!na && 
                (b = n(ga, Ia),
                0 <= b)) {
                    na = !0;
                    ga = W[b];
                    b = l(b);
                    break a
                }
                b = !1
            }
            if (b)
                Y = ga,
                a = b,
                g.setIsLocked(!1),
                g.setWorldUpVector(a, !0),
                g.setIsLocked(!0);
            else if (na && 0 > n(ga, Ha) ? (na = !1,
            b = !0) : b = !1,
            b)
                m(ga - Y),
                Y = 0;
            else {
                if (na)
                    return !1;
                m(a)
            }
            return !0
        }
        var t = 2 * Math.tan(THREE.Math.degToRad(15))
          , K = new THREE.MeshPhongMaterial({
            color: 12303291,
            ambient: 12303291,
            opacity: .5,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1
        })
          , w = new THREE.Vector3
          , C = new THREE.Vector3
          , E = new THREE.Quaternion
          , P = new THREE.PerspectiveCamera(30,c.aspect,c.near,c.far)
          , aa = 1
          , 
        Z = 1
          , V = null 
          , ea = null 
          , X = null 
          , R = null 
          , T = null 
          , O = null 
          , ca = null 
          , ia = null 
          , fa = null 
          , W = Array(6)
          , ga = 0
          , da = !1
          , na = !0
          , Y = 0
          , Ia = 5 * Math.PI / 180
          , Ha = 7 * Math.PI / 180
          , xa = 1;
        a.createOverlayScene("roll", null , null , P);
        this.updateRollCamera = function(a, b) {
            P.position.copy(c.position);
            P.quaternion.copy(c.quaternion);
            P.up.copy(c.up);
            P.aspect = c.aspect;
            a && b && (P.near = b - a,
            P.far = b + a);
            P.updateProjectionMatrix()
        }
        ;
        this.isSnapped = function() {
            return na
        }
        ;
        this.resize = function() {
            var a = xa * t
              , b = a * c.aspect
              , a = (1 > c.aspect ? b : a) * Z;
            O.scale.x = a;
            O.scale.y = a;
            O.scale.z = 
            a
        }
        ;
        this.start = function(b, c) {
            this.updateHUD(b, c);
            a.addOverlay("roll", O)
        }
        ;
        this.updateHUD = function(a, k) {
            V = a;
            .35 > k ? k = .35 : .8 < k && (k = .8);
            Z = k;
            aa = .8 / k;
            var l = w.copy(a).sub(c.position);
            xa = l.length();
            var n = xa * t
              , m = n * c.aspect
              , n = (1 > c.aspect ? m : n) * k;
            this.updateRollCamera(n, xa);
            var m = g.getWorldUpVector()
              , r = g.getCameraUpVector();
            if (!O) {
                O = new THREE.Object3D;
                var G = new THREE.RingGeometry(.5 - .01 * aa,.5,60);
                ea = G = new THREE.Mesh(G,K);
                var J = .007 * aa
                  , F = new THREE.BoxGeometry(.93,J,J)
                  , I = new THREE.BoxGeometry(J,.93,J)
                  , J = new THREE.BoxGeometry(J,
                J,.93);
                X = new THREE.Mesh(F,K);
                R = new THREE.Mesh(I,K);
                T = new THREE.Mesh(J,K);
                O.add(X);
                O.add(R);
                O.add(T);
                ca = new THREE.Mesh(new THREE.CircleGeometry(.005),K);
                O.add(ca);
                ia = Array(6);
                fa = Array(6);
                for (F = 0; 6 > F; ++F)
                    I = .0025 * aa,
                    ia[F] = new THREE.Mesh(new THREE.CircleGeometry(.005 * aa,16),K),
                    fa[F] = new THREE.Mesh(new THREE.CircleGeometry(I,16),K),
                    fa[F].visible = !1,
                    ia[F].add(fa[F]),
                    G.add(ia[F]);
                O.add(G)
            }
            g.orient(ea, a, P.position, m);
            G = l.clone().normalize();
            F = Array(3);
            l = Array(6);
            F[0] = b(1, 0, 0, G);
            F[1] = b(0, 1, 0, G);
            F[2] = b(0, 0, 
            1, G);
            I = r.clone().cross(G).normalize();
            for (G = 0; 3 > G; ++G)
                J = F[G],
                l[G] = J.length(),
                .1 > l[G] ? W[G] = 1E3 : (J.multiplyScalar(1 / l[G]),
                W[G] = Math.atan2(I.dot(J), r.dot(J)));
            W[3] = h(W[0]);
            W[4] = h(W[1]);
            W[5] = h(W[2]);
            l[3] = l[0];
            l[4] = l[1];
            l[5] = l[2];
            G = Ia + Ha + 2 * Math.PI / 180;
            for (F = 0; 6 > F; ++F)
                if (1E3 !== W[F])
                    for (I = F + 1; 6 > I; ++I)
                        if (1E3 !== W[I] && d(W[F], W[I]) < G)
                            if (l[F] < l[I] && !f(F, m) || f(I, m)) {
                                W[F] = 1E3;
                                break
                            } else
                                W[I] = 1E3;
            for (G = 0; 6 > G; ++G)
                1E3 !== W[G] ? (l = C.set(0, 0, 1),
                E.setFromAxisAngle(l, W[G]),
                l = C.set(0, .54, 0),
                l.applyQuaternion(E),
                ia[G].position.copy(l),
                ia[G].visible = !0) : ia[G].visible = !1;
            O.scale.x = n;
            O.scale.y = n;
            O.scale.z = n;
            O.position.copy(a);
            Y = ga = 0;
            da = 0 > m.dot(r);
            na = q(m, r)
        }
        ;
        this.handleRoll = function(a, b, c) {
            this.updateRollCamera();
            q(g.getWorldUpVector(), g.getCameraUpVector());
            return 0 !== a || 0 !== b ? (a = c.x - a - .5,
            b = c.y - b - .5,
            r(Math.atan2(c.y - .5, c.x - .5) - Math.atan2(b, a))) : !1
        }
        ;
        this.handleRollTouch = function(a) {
            this.updateRollCamera();
            q(g.getWorldUpVector(), g.getCameraUpVector());
            a -= ga;
            return .001 < Math.abs(a) ? r(a) : !1
        }
        ;
        this.end = function() {
            a.removeOverlay("roll", 
            O)
        }
    }
    (f,d)
      , r = new THREE.Vector3
      , t = new THREE.Vector3
      , w = new THREE.Vector3
      , C = null 
      , E = 0;
    this.getNames = function() {
        return c
    }
    ;
    this.getName = function() {
        return c[0]
    }
    ;
    this.activate = function(a) {
        h.addEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
        m = !1
    }
    ;
    this.deactivate = function(a) {
        q.end();
        g.setIsLocked(!1);
        h.removeEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
        this.utilities.restorePivot();
        C = null ;
        m = l = !1
    }
    ;
    this.getCursor = function() {
        return "auto"
    }
    ;
    this.getMotionDelta = 
    function(a) {
        var b = t.x - r.x
          , c = t.y - r.y
          , d = t.z - r.z;
        .001 > Math.abs(b) && (b = 0);
        .001 > Math.abs(c) && (c = 0);
        .001 > Math.abs(d) && (d = 0);
        a.set(b, c, d)
    }
    ;
    this.stepMotionDelta = function() {
        r.copy(t)
    }
    ;
    this.update = function() {
        if (!m) {
            var a = g.getEyeVector()
              , b = .5 * (d.near + d.far);
            a.normalize().multiplyScalar(b);
            a = a.add(d.position);
            this.utilities.savePivot();
            this.utilities.setPivotPoint(a, !0, !0);
            this.utilities.pivotActive(!0);
            q.start(a, .65);
            m = !0
        }
        a = n;
        this.getMotionDelta(w);
        var b = w.x
          , c = w.y
          , f = w.z;
        if (n || "roll" === C || l && (0 !== b || 0 !== c || 
        0 !== f))
            n = "roll" === C ? q.handleRollTouch(E) : q.handleRoll(b, c, t);
        this.stepMotionDelta();
        d.dirty && (a = !0);
        return a
    }
    ;
    this.handleResize = function() {
        q.resize();
        n = !0
    }
    ;
    this.handleGesture = function(a) {
        switch (a.type) {
        case "dragstart":
            return C = "drag",
            this.handleButtonDown(a, 0);
        case "dragmove":
            return this.handleMouseMove(a);
        case "dragend":
            return C = null ,
            this.handleButtonUp(a, 0);
        case "rotatestart":
            g.setIsLocked(!0);
            h.removeEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange);
            C = "roll";
            E = THREE.Math.degToRad(a.rotation);
            var b = a.pointers[1].clientX - a.pointers[0].clientX;
            a = a.pointers[1].clientY - a.pointers[0].clientY;
            Math.sqrt(b * b + a * a);
            b = g.getScreenViewport();
            Math.min(b.width, b.height);
            return !0;
        case "rotatemove":
            return E = THREE.Math.degToRad(a.rotation),
            "roll" === C;
        case "rotateend":
            g.setIsLocked(!1),
            h.addEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, this.handleCameraChange),
            E = THREE.Math.degToRad(a.rotation),
            C = null 
        }
        return !1
    }
    ;
    this.handleWheelInput = function(a) {
        return !0
    }
    ;
    this.handleCameraChange = function() {
        var a = g.getEyeVector()
          , 
        b = .5 * (d.near + d.far);
        a.normalize().multiplyScalar(b);
        a = a.add(d.position);
        q.updateHUD(a, .65)
    }
    ;
    this.handleButtonDown = function(b, c) {
        r.x = .5 * (b.normalizedX + 1);
        r.y = 1 - .5 * (b.normalizedY + 1);
        t.copy(r);
        l = !0;
        C = null ;
        g.setIsLocked(!0);
        this.controller.setIsLocked(!0);
        h.removeEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, a.handleCameraChange);
        return !0
    }
    ;
    this.handleButtonUp = function(b, c) {
        t.x = .5 * (b.normalizedX + 1);
        t.y = 1 - .5 * (b.normalizedY + 1);
        l = !1;
        n = !0;
        g.setIsLocked(!1);
        this.controller.setIsLocked(!1);
        h.addEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, 
        a.handleCameraChange);
        return !0
    }
    ;
    this.handleMouseMove = function(a) {
        t.x = .5 * (a.normalizedX + 1);
        t.y = 1 - .5 * (a.normalizedY + 1);
        return !0
    }
    ;
    this.handleBlur = function(a) {
        l = !1;
        C = null ;
        return !1
    }
}
;
(function() {
    function f(d, c) {
        function a() {
            return c.getData().instanceTree
        }
        function b() {
            var b = [], f = [], g = t.selectedObjectIds, k = a(), l;
            for (l in g)
                if (g = parseInt(l))
                    b.push(g),
                    k && k.enumNodeFragments(g, function(a) {
                        f.push(a)
                    }
                    , !1);
            d.api.fireEvent({
                type: h.SELECTION_CHANGED_EVENT,
                fragIdsArray: f,
                dbIdArray: b,
                nodeArray: b,
                model: c
            })
        }
        function f() {
            var c = !1, d = t.selectedObjectIds, g = a(), h;
            for (h in d) {
                var d = parseInt(h)
                  , k = g.isNodeHidden(d);
                d && k && (r(d),
                c = !0)
            }
            c && b()
        }
        function g(b) {
            var f = a();
            if (0 < w[b])
                w[b]--,
                0 == w[b] && d.highlightObjectNode(c, 
                b, !1);
            else if (0 > w[b])
                throw "Selection State machine broken. Negatively selected object!";
            f && f.enumNodeChildren(b, function(a) {
                g(a)
            }
            , !1)
        }
        function n(b, f) {
            var g = a();
            w[b] ? w[b]++ : (d.highlightObjectNode(c, b, !0, f),
            w[b] = 1);
            g && g.enumNodeChildren(b, function(a) {
                n(a, !0)
            }
            , !1)
        }
        function m(a) {
            if (void 0 !== a && t.selectedObjectIds[a])
                return !0
        }
        function q(b) {
            a() && (b = a().findNodeForSelection(b, t.selectionMode));
            m(b) || (t.selectedObjectIds[b] = b,
            t.selectionCount++,
            n(b))
        }
        function r(a) {
            m(a) && (g(a),
            t.selectedObjectIds[a] = 0,
            t.selectionCount--)
        }
        var t = this;
        this.selectedObjectIds = {};
        this.selectionCount = 0;
        this.selectionMode = h.SelectionMode.LEAF_OBJECT;
        var w = {};
        this.getSelectionLength = function() {
            return t.selectionCount
        }
        ;
        this.getSelection = function() {
            var a = [], b = t.selectedObjectIds, c;
            for (c in b)
                b = parseInt(c),
                a.push(b);
            return a
        }
        ;
        this.clearSelection = function(a) {
            if (0 < this.selectionCount) {
                var c = t.selectedObjectIds, d;
                for (d in c)
                    c = parseInt(d),
                    void 0 !== c && g(c);
                t.selectedObjectIds = {};
                t.selectionCount = 0;
                a || b()
            }
        }
        ;
        this.toggleSelection = function(a) {
            a ? (m(a) ? 
            r(a) : q(a),
            b()) : console.error("Attempting to select node 0.")
        }
        ;
        this.setSelectionMode = function(a) {
            this.clearSelection(!0);
            this.selectionMode = a
        }
        ;
        this.setSelection = function(a) {
            var c;
            a: if (t.selectionCount !== a.length)
                c = !1;
            else {
                for (c = 0; c < a.length; c++)
                    if (!m(a[c])) {
                        c = !1;
                        break a
                    }
                c = !0
            }
            if (!c && (this.clearSelection(!0),
            null  != a && 0 !== a.length)) {
                for (c = 0; c < a.length; c++)
                    q(a[c]);
                b()
            }
        }
        ;
        this.getSelectionBounds = function() {
            var b = new THREE.Box3, d = new THREE.Box3, f = a(), g = c.getFragmentList(), h = t.selectedObjectIds, k;
            for (k in h)
                h = 
                parseInt(k),
                f.enumNodeFragments(h, function(a) {
                    g.getWorldBounds(a, d);
                    b.union(d)
                }
                , !0);
            return b
        }
        ;
        this.getSelectionVisibility = function() {
            var b = !1, c = !1, d = t.selectedObjectIds, f;
            for (f in d)
                if (d = parseInt(f)) {
                    var g = a();
                    g && g.isNodeHidden(d) ? c = !0 : b = !0;
                    if (b && c)
                        break
                }
            return {
                hasVisible: b,
                hasHidden: c
            }
        }
        ;
        this.dtor = function() {
            this.selectedObjectIds = null 
        }
        ;
        d.api.addEventListener(h.ISOLATE_EVENT, function(a) {
            f()
        }
        );
        d.api.addEventListener(h.HIDE_EVENT, function(a) {
            f()
        }
        )
    }
    var h = Teratek.Viewing
      , g = h.Private;
    g.Selector = f;
    g.MultiModelSelector = 
    function(d) {
        function c() {
            1 < a.length && stderr("This selection call does not yet support multiple models.")
        }
        var a = [];
        this.addModel = function(b) {
            -1 == a.indexOf(b) && (b.selector = new f(d,b),
            a.push(b))
        }
        ;
        this.removeModel = function(b) {
            var c = a.indexOf(b);
            b.selector = null ;
            a.splice(c, 1)
        }
        ;
        this.getSelectionLength = function() {
            c();
            return a[0].selector.getSelectionLength()
        }
        ;
        this.getSelection = function() {
            c();
            return a[0].selector.getSelection()
        }
        ;
        this.clearSelection = function(b) {
            for (var c = 0; c < a.length; c++)
                a[c].selector.clearSelection(b)
        }
        ;
        this.toggleSelection = function(b, d) {
            d || (c(),
            d = a[0]);
            d.selector.toggleSelection(b)
        }
        ;
        this.setSelectionMode = function(b) {
            for (var c = 0; c < a.length; c++)
                a[c].selector.setSelectionMode(b)
        }
        ;
        this.setSelection = function(b, d) {
            b && 0 !== b.length ? (d || (c(),
            d = a[0]),
            d.selector.setSelection(b)) : this.clearSelection()
        }
        ;
        this.getSelectionBounds = function() {
            if (1 == a.length)
                return a[0].selector.getSelectionBounds();
            for (var b = new THREE.Box3, c = 0; c < a.length; c++) {
                var d = a[c].selector.getSelectionBounds();
                b.union(d)
            }
            return b
        }
        ;
        this.getSelectionVisibility = 
        function() {
            c();
            return a[0].selector.getSelectionVisibility()
        }
        ;
        this.dtor = function() {
            for (var b = 0; b < a.length; b++)
                a[b].selector.dtor()
        }
    }
}
)();
(function() {
    function f(d) {
        this.viewer = d;
        this.models = []
    }
    var h = Teratek.Viewing
      , g = function(d, c) {
        this.viewerImpl = d;
        this.model = c;
        this.isolatedNodes = [];
        this.hiddenNodes = []
    }
    ;
    g.prototype.getInstanceTree = function() {
        return this.model ? this.model.getData().instanceTree : null 
    }
    ;
    g.prototype.getIsolatedNodes = function() {
        return this.isolatedNodes.slice(0)
    }
    ;
    g.prototype.getHiddenNodes = function() {
        return this.hiddenNodes.slice(0)
    }
    ;
    g.prototype.isolate = function(d) {
        var c = this.getInstanceTree().getRootId()
          , c = "number" == typeof d && 
        d === c || "object" == typeof d && d.dbId === c;
        d && !c ? this.isolateMultiple(Array.isArray(d) ? d : [d]) : this.isolateNone()
    }
    ;
    g.prototype.isolateNone = function() {
        this.model.setAllVisibility(!0);
        this.viewerImpl.sceneUpdated(!0);
        var d = this.model ? this.model.getRootId() : null ;
        d && this.setVisibilityOnNode(d, !0);
        this.hiddenNodes = [];
        this.isolatedNodes = [];
        this.viewerImpl.invalidate(!0);
        this.viewerImpl.api.fireEvent({
            type: h.ISOLATE_EVENT,
            nodeIdArray: [],
            model: this.model
        })
    }
    ;
    g.prototype.isolateMultiple = function(d) {
        if (d && 0 != d.length) {
            var c = 
            this.model.getRootId();
            c && this.setVisibilityOnNode(c, !1);
            this.model.setAllVisibility(!1);
            this.viewerImpl.sceneUpdated(!0);
            this.isolatedNodes = d.slice(0);
            this.hiddenNodes = [];
            for (c = 0; c < d.length; c++)
                this.setVisibilityOnNode(d[c], !0);
            this.viewerImpl.api.fireEvent({
                type: h.ISOLATE_EVENT,
                nodeIdArray: d,
                model: this.model
            })
        } else
            this.isolateNone();
        this.viewerImpl.invalidate(!0)
    }
    ;
    g.prototype.hide = function(d) {
        var c;
        if (Array.isArray(d)) {
            for (var a = 0; a < d.length; ++a)
                this.setVisibilityOnNode(d[a], !1);
            0 < d.length && (c = 
            {
                type: h.HIDE_EVENT,
                nodeIdArray: d
            })
        } else
            this.setVisibilityOnNode(d, !1),
            c = {
                type: h.HIDE_EVENT,
                nodeIdArray: [d]
            };
        c && this.viewerImpl.api.fireEvent(c)
    }
    ;
    g.prototype.show = function(d) {
        var c;
        if (Array.isArray(d)) {
            for (var a = 0; a < d.length; ++a)
                this.setVisibilityOnNode(d[a], !0);
            0 < d.length && (c = {
                type: h.SHOW_EVENT,
                nodeIdArray: d
            })
        } else
            this.setVisibilityOnNode(d, !0),
            c = {
                type: h.SHOW_EVENT,
                nodeIdArray: [d]
            };
        c && this.viewerImpl.api.fireEvent(c)
    }
    ;
    g.prototype.toggleVisibility = function(d) {
        var c = this.getInstanceTree().isNodeHidden(d);
        this.setVisibilityOnNode(d, c);
        this.viewerImpl.api.fireEvent({
            type: c ? h.SHOW_EVENT : h.HIDE_EVENT,
            nodeIdArray: [d]
        })
    }
    ;
    g.prototype.setVisibilityOnNode = function(d, c) {
        var a = this.viewerImpl
          , b = this.model
          , f = this.getInstanceTree()
          , g = !c;
        f ? f.enumNodeChildren(d, function(a) {
            f.setNodeHidden(a, g);
            f.enumNodeFragments(a, function(a) {
                b.setVisibility(a, c)
            }
            , !1)
        }
        , !0) : b.setVisibility(d, c);
        a.sceneUpdated(!0);
        this.updateNodeVisibilityTracking(d, c)
    }
    ;
    g.prototype.updateNodeVisibilityTracking = function(d, c) {
        if (0 < this.isolatedNodes.length) {
            var a = 
            this.isolatedNodes.indexOf(d);
            c && -1 === a ? this.isolatedNodes.push(d) : c || -1 === a || this.isolatedNodes.splice(a, 1)
        } else
            a = this.hiddenNodes.indexOf(d),
            c || -1 !== a ? c && -1 !== a && this.hiddenNodes.splice(a, 1) : this.hiddenNodes.push(d);
        (a = this.getInstanceTree()) && a.root && a.root.dbId === d && (c ? (this.isolatedNodes = [],
        this.hiddenNodes = []) : (this.isolatedNodes = [],
        this.hiddenNodes = [d]))
    }
    ;
    g.prototype.setNodeOff = function(d, c) {
        var a = this.viewerImpl
          , b = this.model
          , f = this.getInstanceTree();
        f ? f.enumNodeChildren(d, function(a) {
            f.setNodeOff(a, 
            c);
            f.enumNodeFragments(a, function(a) {
                b.getFragmentList().setFragOff(a, c)
            }
            , !1)
        }
        , !0) : b.getFragmentList().setFragOff(d, c);
        a.sceneUpdated(!0)
    }
    ;
    h.Private.VisibilityManager = g;
    f.prototype.addModel = function(d) {
        -1 == this.models.indexOf(d) && (d.visibilityManager = new g(this.viewer,d),
        this.models.push(d))
    }
    ;
    f.prototype.removeModel = function(d) {
        var c = this.models.indexOf(d);
        d.visibilityManager = null ;
        this.models.splice(c, 1)
    }
    ;
    f.prototype.warn = function() {
        1 < this.models.length && stderr("This selection call does not yet support multiple models.")
    }
    ;
    f.prototype.getIsolatedNodes = function(d) {
        d || (this.warn(),
        d = this.models[0]);
        return d.visibilityManager.getIsolatedNodes()
    }
    ;
    f.prototype.getHiddenNodes = function(d) {
        d || (this.warn(),
        d = this.models[0]);
        return d.visibilityManager.getHiddenNodes()
    }
    ;
    f.prototype.isolate = function(d, c) {
        c || (this.warn(),
        c = this.models[0]);
        c.visibilityManager.isolate(d)
    }
    ;
    f.prototype.hide = function(d, c) {
        c || (this.warn(),
        c = this.models[0]);
        c.visibilityManager.hide(d)
    }
    ;
    f.prototype.show = function(d, c) {
        c || (this.warn(),
        c = this.models[0]);
        c.visibilityManager.show(d)
    }
    ;
    f.prototype.toggleVisibility = function(d, c) {
        c || (this.warn(),
        c = this.models[0]);
        c.visibilityManager.toggleVisibility(d)
    }
    ;
    f.prototype.setVisibilityOnNode = function(d, c, a) {
        a || (this.warn(),
        a = this.models[0]);
        a.visibilityManager.setVisibilityOnNode(d, c)
    }
    ;
    f.prototype.setNodeOff = function(d, c, a) {
        a || (this.warn(),
        a = this.models[0]);
        a.visibilityManager.setNodeOff(d, c)
    }
    ;
    h.Private.MultiModelVisibilityManager = f
}
)();
LMV_WORKER_URL || (LMV_WORKER_URL = "src/workers/MainWorker.js");
void 0 == ENABLE_INLINE_WORKER && (ENABLE_INLINE_WORKER = !1);
(function() {
    var f = Teratek.Viewing.Private
      , h = null ;
    f.initWorkerScript = function(g, d) {
        if (ENABLE_INLINE_WORKER && !h) {
            var c = new XMLHttpRequest
              , a = LMV_WORKER_URL
              , b = f.getResourceUrl(LMV_WORKER_URL);
            b && (a = b);
            c.open("GET", a, !0);
            c.withCredentials = !1;
            c.onload = function() {
                var a;
                window.URL = window.URL || window.webkitURL;
                try {
                    a = new Blob([c.responseText],{
                        type: "application/javascript"
                    })
                } catch (b) {
                    a = new BlobBuilder,
                    a.append(c.responseText),
                    a = a.getBlob()
                }
                h = URL.createObjectURL(a);
                g && g()
            }
            ;
            c.send()
        } else
            g && g()
    }
    ;
    f.createWorker = 
    function() {
        return ENABLE_INLINE_WORKER ? new Worker(h) : new Worker(f.getResourceUrl(LMV_WORKER_URL))
    }
    ;
    f.createWorkerWithIntercept = function() {
        var g = f.createWorker();
        g.checkEvent = function(d) {
            return d.data && d.data.assetRequest ? (f.assets && f.assets.push(d.data.assetRequest),
            !0) : !1
        }
        ;
        g.addEventListenerWithIntercept = function(d) {
            var c = function(a) {
                g.checkEvent(a) || d(a)
            }
            ;
            g.addEventListener("message", c, !1);
            return c
        }
        ;
        return g
    }
}
)();
(function() {
    function f(a) {
        if ((a = a.data) && a.debug)
            stderr(a.message);
        else if (a.cbId) {
            var c = b[a.cbId];
            if (a && a.error) {
                if (c[1])
                    c[1](a.error)
            } else if (c[0])
                c[0](a.result);
            delete b[a.cbId]
        }
    }
    function h(c, d) {
        var f = a++;
        b[f] = [c, d];
        return f
    }
    var g = Teratek.Viewing
      , d = g.Private
      , c = function(a, b, c) {
        this.sharedDbPath = a;
        this.propWorker = null ;
        this.eventTarget = c;
        this.svf = b;
        this.domainParam = auth ? "domain=" + encodeURIComponent(window.location.origin) : ""
    }
    ;
    c.prototype.dtor = function() {
        this.propWorker && (this.propWorker.removeEventListener("message", 
        f),
        this.propWorker.terminate(),
        this.propWorker = null )
    }
    ;
    var a = 1
      , b = {};
    c.prototype.load = function() {
        var a = this;
        this.propWorker || (this.propWorker = d.createWorkerWithIntercept("Property"),
        this.propWorker.addEventListenerWithIntercept(f));
        var b = h(function(b) {
            var c = b.instanceTree
              , f = b.instanceBoxes;
            c ? (a.svf.instanceTree = new d.InstanceTree(c,f,b.objectCount,b.maxTreeDepth),
            a.svf.fragToNodeDone = !0) : b.objectCount && (a.svf.hasObjectProperties = b.objectCount);
            a.eventTarget.fireEvent({
                type: g.OBJECT_TREE_CREATED_EVENT,
                svf: a.svf
            })
        }
        , function(b) {
            a.propertyDbError = b;
            a.eventTarget.fireEvent({
                type: g.OBJECT_TREE_UNAVAILABLE_EVENT,
                svf: a.svf
            })
        }
        )
          , c = d.pathToURL(this.svf.basePath);
        this.sharedDbPath && !this.svf.propertydb.values.length && (c = this.sharedDbPath,
        stderr("Using shared property db: " + c));
        this.propWorker.postMessage({
            operation: "GET_OBJECT_TREE",
            url: c,
            propertydb: this.svf.propertydb,
            headers: g.HTTP_REQUEST_HEADERS,
            fragToDbId: this.svf.fragments.fragId2dbId,
            fragBoxes: this.svf.fragments.boxes,
            auth: auth,
            viewing_url: VIEWING_URL,
            oss_url: OSS_URL,
            cbId: b,
            queryParams: this.domainParam
        })
    }
    ;
    c.prototype.asyncPropertyOperation = function(a, b, c) {
        var d = this;
        if (d.svf.instanceTree || d.svf.hasObjectProperties)
            a.cbId = h(b, c),
            this.propWorker.postMessage(a);
        else if (d.propertyDbError)
            c && c(d.propertyDbError);
        else {
            var f = function(h) {
                d.eventTarget.removeEventListener(g.OBJECT_TREE_CREATED_EVENT, f);
                d.eventTarget.removeEventListener(g.OBJECT_TREE_UNAVAILABLE_EVENT, f);
                h.svf.instanceTree || h.svf.hasObjectProperties || d.propertyDbError ? d.asyncPropertyOperation(a, 
                b, c) : c && c({
                    code: g.UNKNOWN_FAILURE,
                    msg: "Failed to load properties"
                })
            }
            ;
            d.eventTarget.addEventListener(g.OBJECT_TREE_CREATED_EVENT, f);
            d.eventTarget.addEventListener(g.OBJECT_TREE_UNAVAILABLE_EVENT, f)
        }
    }
    ;
    c.prototype.getProperties = function(a, b, c) {
        this.asyncPropertyOperation({
            operation: "GET_PROPERTIES",
            dbId: a
        }, b, c)
    }
    ;
    c.prototype.searchProperties = function(a, b, c, d) {
        this.asyncPropertyOperation({
            operation: "SEARCH_PROPERTIES",
            searchText: a,
            attributeNames: b
        }, c, d)
    }
    ;
    c.prototype.getExternalIdMapping = function(a, b) {
        this.asyncPropertyOperation({
            operation: "BUILD_EXTERNAL_ID_MAPPING"
        }, 
        a, b)
    }
    ;
    c.prototype.getObjectTree = function(a, b) {
        var c = this;
        if (c.svf.instanceTree)
            a(c.svf.instanceTree);
        else if (c.propertyDbError || "hasObjectProperties" in c.svf)
            b && b(c.propertyDbError);
        else {
            var d = function() {
                c.eventTarget.removeEventListener(g.OBJECT_TREE_CREATED_EVENT, d);
                c.eventTarget.removeEventListener(g.OBJECT_TREE_UNAVAILABLE_EVENT, d);
                c.getObjectTree(a, b)
            }
            ;
            c.eventTarget.addEventListener(g.OBJECT_TREE_CREATED_EVENT, d);
            c.eventTarget.addEventListener(g.OBJECT_TREE_UNAVAILABLE_EVENT, d)
        }
    }
    ;
    c.prototype.attributeToIdMap = 
    function(a, b) {
        this.asyncPropertyOperation({
            operation: "ATTRIBUTES_MAP"
        }, a, b)
    }
    ;
    d.PropDbLoader = c
}
)();
(function() {
    var f = isMobileDevice() ? 2 : 6
      , h = Teratek.Viewing
      , g = Teratek.Viewing.Private
      , d = function(c) {
        this.viewer3DImpl = c;
        this.next_pack = 0;
        this.loading = !1;
        this.loadedPacksCount = 0;
        this.loadedPacks = [];
        this.tmpMatrix = new THREE.Matrix4;
        this.logger = g.logger;
        this.loadTime = 0;
        this.domainParam = auth ? "domain=" + encodeURIComponent(window.location.origin) : "";
        this.pageOutGeometryEnabled = this.cullGeometryOnLoading = this.onDemandLoading = !1
    }
    ;
    d.prototype.dtor = function() {
        this.svf = null ;
        this.svfWorker && (this.svfWorker.terminate(),
        this.svfWorker = null );
        if (this.pack_workers) {
            for (var c = 0; c < this.pack_workers.length; c++)
                this.pack_workers[c].terminate();
            this.pack_workers = null 
        }
    }
    ;
    g.pathToURL = function(c) {
        if ("http://" == c.substr(0, 7) || "https://" == c.substr(0, 8) || "file:///" == c.substr(0, 8) || "urn:" == c.substr(0, 4))
            return c;
        var a = window.location.pathname
          , b = a.lastIndexOf("/")
          , a = a.substr(0, b + 1);
        return window.location.protocol + "//" + window.location.host + a + c
    }
    ;
    d.prototype.loadFile = function(c, a, b, d) {
        if (this.loading)
            return console.log("Loading of SVF already in progress. Ignoring new request."),
            !1;
        this.dtor();
        var f = c.indexOf("urn:");
        if (-1 != f) {
            c = decodeURIComponent(c);
            f = c.substr(f, c.substr(f).indexOf("/"));
            stderr("Extracted URN: " + f);
            var h = f.lastIndexOf(":");
            this.svfUrn = f.substr(h + 1)
        } else
            this.svfUrn = c;
        this.sharedDbPath = a.sharedPropertyDbPath;
        this.currentLoadPath = c;
        var m = this;
        g.initWorkerScript(function() {
            m.loadSvfCB(c, a, b, d)
        }
        );
        return !0
    }
    ;
    d.prototype.interceptManifest = void 0;
    d.prototype.loadSvfCB = function(c, a, b, d) {
        this.t0 = (new Date).getTime();
        this.failedToLoadSomeGeometryPacks = null ;
        var l = this
          , 
        n = {
            url: g.pathToURL(c),
            headers: h.HTTP_REQUEST_HEADERS,
            objectIds: a.ids,
            globalOffset: a.globalOffset,
            auth: auth,
            viewing_url: VIEWING_URL,
            oss_url: OSS_URL,
            queryParams: this.domainParam,
            bvhOptions: {
                isWeakDevice: isAndroidDevice() || isIOSDevice()
            }
        }
          , m = this.svfWorker = g.createWorkerWithIntercept("SVF Load")
          , q = function(a) {
            var c = function() {
                m.removeEventListener("message", q);
                m.terminate();
                m = l.svfWorker = null 
            }
            ;
            if (a.data && a.data.manifest)
                l.interceptManifest(a.data.manifest),
                n.operation = "LOAD_SVF_CONTD",
                n.manifest = a.data.manifest,
                m.postMessage(n);
            else if (a.data && a.data.svf) {
                var w = l.svf = a.data.svf;
                l.failedToLoadSomeGeometryPacks && (d && d(l.failedToLoadSomeGeometryPacks.code, l.failedToLoadSomeGeometryPacks.msg),
                l.failedToLoadSomeGeometryPacks = null );
                l.onSvfLoadDone(w);
                var C = l.model = new g.RenderModel(w);
                C.initialize(l);
                C.loader = l;
                b && b(l.model);
                l.viewer3DImpl.api.fireEvent({
                    type: h.MODEL_ROOT_LOADED_EVENT,
                    svf: w
                });
                C = w.geompacks.length;
                l.svf.loadDone = !1;
                if (0 == C)
                    l.onGeomLoadDone();
                else if (w.fragments.length > g.FRAGS_PERSISTENT_MAX_COUNT ? 
                (l.onDemandLoading = g.onDemandLoading,
                l.cullGeometryOnLoading = g.cullGeometryOnLoading) : (l.onDemandLoading = !1,
                l.cullGeometryOnLoading = !1),
                stderr("SVF on demand loading: " + l.onDemandLoading),
                stderr("SVF culling geometry on loading: " + l.cullGeometryOnLoading),
                l.onDemandLoading)
                    l.loadedPacksCount = 0;
                else if (C)
                    for (var C = Math.min(C, f), E = 0; E < C; E++) {
                        var G = w.geompacks[E];
                        G.loading = !0;
                        l.loadGeometryPack(G.id, G.uri);
                        l.next_pack = E + 1
                    }
                1 == a.data.progress && (l.loading = !1,
                c());
                w.fragments.polygonCounts || (w.fragments.polygonCounts = 
                new Int32Array(w.fragments.length))
            } else
                a.data && a.data.bvh ? 1 == a.data.progress && (l.svf.bvh || (l.svf.bvh = a.data.bvh,
                l.model.setBVH(new NodeArray(l.svf.bvh.nodes,l.svf.bvh.useLeanNodes), l.svf.bvh.primitives),
                l.viewer3DImpl.invalidate(!1, !0)),
                l.loading = !1,
                c()) : a.data && a.data.progress ? 1 == a.data.progress && (l.loading = !1,
                c()) : a.data && a.data.error ? (l.loading = !1,
                c(),
                d && d(a.data.error.code, a.data.error.msg)) : a.data && a.data.debug ? stderr(a.data.message) : (stderr("SVF download failed."),
                l.loading = !1,
                c())
        }
        ;
        m.addEventListenerWithIntercept(q);
        n.operation = "LOAD_SVF";
        n.interceptManifest = !!this.interceptManifest;
        m.postMessage(n);
        return !0
    }
    ;
    d.prototype.loadGeometryPackOnDemand = function(c) {
        var a = this;
        if (a.onDemandLoading) {
            var b = a.svf.geompacks[c];
            if (!b.loading) {
                var d, l, n = function(b) {
                    if (b.data && b.data.mesh) {
                        if (a.processReceivedMesh(b.data),
                        1 <= b.data.progress) {
                            --a.pack_workers[b.data.workerId].queued;
                            a.svf.geompacks[b.data.packId].loading = !1;
                            var c = a.model.geomPacksMissingLastFrame()
                              , f = c.indexOf(b.data.packId);
                            0 <= f && c.splice(f, 1);
                            c = !0;
                            for (l = 0; l < 
                            a.pack_workers.length; l++)
                                if (0 != a.pack_workers[l].queued) {
                                    c = !1;
                                    break
                                }
                            -1 == a.loadedPacks.indexOf(b.data.packId) && a.loadedPacks.push(b.data.packId);
                            if (c && 0 == a.model.geomPacksMissingLastFrame().length)
                                if (a.loadedPacks.length == a.svf.geompacks.length)
                                    a.onGeomLoadDone();
                                else
                                    a.onGeomPackFilesLoadDone()
                        }
                    } else if (b.data && b.data.progress) {
                        --a.pack_workers[b.data.workerId].queued;
                        a.loadedPacksCount++;
                        b = null ;
                        c = a.model.geomPacksMissingLastFrame();
                        for (d = 0; d < c.length && (f = c[d],
                        b = a.svf.geompacks[f],
                        b.loading); ++d)
                            ;
                        b && !b.loading && a.loadGeometryPackOnDemand(f);
                        a.viewer3DImpl.signalProgress(100 * a.loadedPacks.length / a.svf.geompacks.length)
                    } else
                        b.data && b.data.debug ? stderr(b.data.message) : b.data && b.data.error ? a.failedToLoadSomeGeometryPacks = {
                            code: b.data.error.code,
                            msg: b.data.error.msg
                        } : (a.pack_workers[b.data.workerId].queued -= 2,
                        a.svf.geompacks[b.data.packId].loading = !1)
                }
                ;
                if (!this.pack_workers)
                    for (this.pack_workers = [],
                    d = 0; d < f; d++) {
                        var m = g.createWorkerWithIntercept("Mesh Load");
                        m.addEventListenerWithIntercept(n);
                        m.queued = 0;
                        this.pack_workers.push(m)
                    }
                m = 0;
                n = this.pack_workers[0].queued;
                for (d = 1; d < f; d++)
                    this.pack_workers[d].queued < n && (m = d,
                    n = this.pack_workers[d].queued);
                if (2 < n)
                    a.model.addGeomPackMissingLastFrame(c);
                else {
                    var q = b.uri
                      , n = this.pack_workers[m];
                    n.queued += 2;
                    b.loading = !0;
                    a.svf.partPacksLoadDone = !1;
                    c = {
                        operation: "LOAD_GEOMETRY",
                        url: g.pathToURL(this.svf.basePath + q),
                        packId: parseInt(c),
                        headers: h.HTTP_REQUEST_HEADERS,
                        workerId: m,
                        auth: auth,
                        viewing_url: VIEWING_URL,
                        oss_url: OSS_URL,
                        queryParams: this.domainParam
                    };
                    n.postMessage(c)
                }
            }
        }
    }
    ;
    d.prototype.loadGeometryPack = function(c, a) {
        var b, d, l, n, m = this;
        b = function(a) {
            if (a.data && a.data.mesh) {
                if (m.processReceivedMesh(a.data),
                1 <= a.data.progress) {
                    --m.pack_workers[a.data.workerId].queued;
                    a = !0;
                    for (n = 0; n < m.pack_workers.length; n++)
                        if (0 != m.pack_workers[n].queued) {
                            a = !1;
                            break
                        }
                    if (a) {
                        for (n = 0; n < f; n++)
                            m.pack_workers[n].terminate();
                        m.pack_workers = null 
                    }
                    m.svf.fragments.numLoaded == m.svf.fragments.length && (m.svf.proteinMaterials && PROTEIN_ROOT && PRISM_ROOT || m.viewer3DImpl.matman().loadTextures(m.svf),
                    m.onGeomLoadDone())
                }
            } else if (a.data && 
            a.data.progress) {
                --m.pack_workers[a.data.workerId].queued;
                if (m.next_pack < m.svf.geompacks.length) {
                    a = null ;
                    var b = m.model.geomPacksMissingLastFrame();
                    for (l = 0; l < b.length && (!(a = m.svf.geompacks[b[l]]) || a.loading); ++l)
                        ;
                    if (!a || a.loading)
                        for (; m.next_pack < m.svf.geompacks.length && (a = m.svf.geompacks[m.next_pack++],
                        a.loading); )
                            ;
                    a && !a.loading ? (a.loading = !0,
                    m.loadGeometryPack(a.id, a.uri)) : (m.viewer3DImpl.modelQueue().enforceBvh = !1,
                    m.svf.fragments.packIds = null )
                }
                m.viewer3DImpl.signalProgress(100 * m.next_pack / m.svf.geompacks.length)
            } else
                a.data && 
                a.data.debug ? stderr(a.data.message) : a.data && a.data.error ? m.failedToLoadSomeGeometryPacks = {
                    code: a.data.error.code,
                    msg: a.data.error.msg
                } : m.pack_workers[a.data.workerId].queued -= 2
        }
        ;
        if (!this.pack_workers)
            for (this.pack_workers = [],
            l = 0; l < f; l++)
                d = g.createWorkerWithIntercept("Mesh Load"),
                d.addEventListenerWithIntercept(b),
                d.queued = 0,
                this.pack_workers.push(d);
        d = 0;
        b = this.pack_workers[0].queued;
        for (l = 1; l < f; l++)
            this.pack_workers[l].queued < b && (d = l,
            b = this.pack_workers[l].queued);
        b = this.pack_workers[d];
        b.queued += 
        2;
        d = {
            operation: "LOAD_GEOMETRY",
            url: g.pathToURL(this.svf.basePath + a),
            packId: parseInt(c),
            headers: h.HTTP_REQUEST_HEADERS,
            workerId: d,
            auth: auth,
            viewing_url: VIEWING_URL,
            oss_url: OSS_URL,
            queryParams: this.domainParam
        };
        b.postMessage(d)
    }
    ;
    d.prototype.processReceivedMesh = function(c) {
        var a = c.packId + ":" + c.meshIndex
          , b = this.svf
          , d = b.fragments
          , f = d.mesh2frag[a];
        if (void 0 === f)
            stderr("Mesh " + a + " was not referenced by any fragments.");
        else {
            Array.isArray(f) || (f = [f]);
            if (this.cullGeometryOnLoading) {
                for (var h = !0, m = 0; m < f.length; ++m) {
                    if (f[m] < 
                    g.FRAGS_PERSISTENT_COUNT) {
                        h = !1;
                        break
                    }
                    h = h && this.viewer3DImpl.modelQueue().checkCull(f[m], !0, !0);
                    if (!h)
                        break
                }
                if (h) {
                    c.mesh = null ;
                    return
                }
            }
            BufferGeometryUtils.meshToGeometry(c);
            var m = f.length
              , h = this.model
              , q = h.getFragmentList().getGeometryId(f[0])
              , q = h.getGeometryList().addGeometry(c.geometry, m, q);
            this.cullGeometryOnLoading && 1 < m && null  == h.getFragmentList().geomidsmap[q] && (h.getFragmentList().geomidsmap[q] = {
                n: m,
                t: 0
            });
            q = (c.geometry.attributes.index.array || c.geometry.ib).length / 3;
            for (m = 0; m < f.length; m++) {
                var r = 
                0 | f[m];
                h.getFragmentList().getOriginalWorldMatrix(r, this.tmpMatrix);
                var t = d.materials[r].toString();
                d.polygonCounts && (d.polygonCounts[r] = q);
                t = this.viewer3DImpl.createThreeMesh(this.model, c.geometry, t, this.tmpMatrix);
                h.activateFragment(r, t)
            }
            this.onDemandLoading || (d.mesh2frag[a] = null );
            d.numLoaded += f.length;
            b.geomPolyCount > b.nextRepaintPolys && (b.numRepaints++,
            b.nextRepaintPolys += 1E4 * Math.pow(1.5, b.numRepaints),
            this.viewer3DImpl.invalidate(!1, !0))
        }
    }
    ;
    d.prototype.onSvfLoadDone = function(c) {
        c.geomPolyCount = 
        0;
        c.instancePolyCount = 0;
        c.geomMemory = 0;
        c.fragments.numLoaded = 0;
        c.meshCount = 0;
        c.gpuNumMeshes = 0;
        c.gpuMeshMemory = 0;
        c.nextRepaintPolys = 1E4;
        c.numRepaints = 0;
        c.urn = this.svfUrn;
        c.basePath = "";
        var a = this.currentLoadPath.lastIndexOf("/");
        -1 != a && (c.basePath = this.currentLoadPath.substr(0, a + 1));
        a = Date.now();
        this.loadTime += a - this.t0;
        stderr("SVF load: " + (a - this.t0));
        this.onDemandLoading && (isAndroidDevice() || isIOSDevice()) || this.loadPropertyDb();
        this.viewer3DImpl.matman().convertMaterials(c);
        this.t0 = a;
        c.bbox = (new THREE.Box3).copy(c.bbox);
        if (c.cameras)
            for (a = 0; a < c.cameras.length; a++) {
                var b = c.cameras[a];
                b.position = (new THREE.Vector3).copy(b.position);
                b.target = (new THREE.Vector3).copy(b.target);
                b.up = (new THREE.Vector3).copy(b.up)
            }
        c.proteinMaterials && PROTEIN_ROOT && PRISM_ROOT && this.viewer3DImpl.matman().loadTextures(c);
        stderr("scene bounds: " + JSON.stringify(c.bbox));
        this.viewer3DImpl.signalProgress(5, "Hold on, getting the model...");
        this.viewer3DImpl.invalidate(!1, !1)
    }
    ;
    d.prototype.addTransparencyFlagsToMaterials = function(c) {
        for (var a in c) {
            var b = 
            c[a];
            b.transparent = b.materials[b.userassets[0]].transparent
        }
    }
    ;
    d.prototype.makeBVH = function(c) {
        var a = performance.now()
          , b = c.materials ? c.materials.materials : null ;
        b && this.addTransparencyFlagsToMaterials(b);
        c.bvh = new BVHBuilder(c.fragments,b);
        c.bvh.build({
            isWeakDevice: isAndroidDevice() || isIOSDevice()
        });
        c = performance.now();
        stderr("BVH build time: " + (c - a))
    }
    ;
    d.prototype.onGeomPackFilesLoadDone = function() {
        stderr("Part of geom pack files are load done.");
        this.svf.partPacksLoadDone = !0;
        this.viewer3DImpl.invalidate(!1, 
        !0)
    }
    ;
    d.prototype.onGeomLoadDone = function() {
        this.svf.loadDone = !0;
        this.onDemandLoading || (this.svf.fragments.entityIndexes = null ,
        this.svf.fragments.mesh2frag = null );
        var c = Date.now()
          , a = "Fragments load time: " + (c - this.t0);
        this.loadTime += c - this.t0;
        this.svf.bvh || (this.makeBVH(this.svf),
        this.model.setBVH(this.svf.bvh.nodes, this.svf.bvh.primitives));
        stderr(a);
        this.logger && (c = {
            category: "model_load_stats",
            is_f2d: !1,
            has_prism: this.viewer3DImpl.matman().hasPrism,
            load_time: this.loadTime,
            geometry_size: this.model.getGeometryList().geomMemory,
            meshes_count: this.model.getGeometryList().geoms.length,
            fragments_count: this.model.getFragmentList().getCount(),
            urn: this.svfUrn
        },
        this.logger.log(c, !0));
        g.assets && window.webkit && (window.webkit.messageHandlers.callbackHandler.postMessage({
            command: "assets",
            data: g.assets
        }),
        g.assets = null );
        this.currentLoadPath = null ;
        this.viewer3DImpl.onLoadComplete()
    }
    ;
    d.prototype.loadPropertyDb = function() {
        this.svf.propWorker = new g.PropDbLoader(this.sharedDbPath,this.svf,this.viewer3DImpl.api);
        this.svf.propWorker.load()
    }
    ;
    g.SvfLoader = d;
    h.FileLoaderManager.registerFileLoader("svf", ["svf"], g.SvfLoader)
}
)();
(function() {
    function f(d) {
        this.viewer3DImpl = d;
        this.loading = !1;
        this.tmpMatrix = new THREE.Matrix4;
        this.logger = g.logger;
        this.loadTime = 0;
        this.domainParam = auth ? "domain=" + encodeURIComponent(window.location.origin) : ""
    }
    var h = Teratek.Viewing
      , g = Teratek.Viewing.Private;
    f.prototype.dtor = function() {
        this.svf = null 
    }
    ;
    f.prototype.loadFile = function(d, c, a, b) {
        if (this.loading)
            return console.log("Loading of SVF already in progress. Ignoring new request."),
            !1;
        this.parsingWorker && (this.parsingWorker.terminate(),
        this.parsingWorker = 
        null );
        this.streamingWorker && (this.streamingWorker.terminate(),
        this.streamingWorker = null );
        var f = d.indexOf("urn:");
        if (-1 != f) {
            d = decodeURIComponent(d);
            f = d.substr(f, d.substr(f).indexOf("/"));
            stderr("Extracted URN: " + f);
            var h = f.lastIndexOf(":");
            this.svfUrn = f.substr(h + 1)
        } else
            this.svfUrn = d;
        this.sharedDbPath = c.sharedPropertyDbPath;
        this.currentLoadPath = d;
        this.isf2d = !0;
        var n = this;
        g.initWorkerScript(function() {
            n.loadFydoCB(d, c.ids, a, b)
        }
        );
        return !0
    }
    ;
    f.prototype.loadFydoCB = function(d, c, a, b) {
        this.t0 = Date.now();
        var f = g.pathToURL(d)
          , l = this.streamingWorker = g.createWorker()
          , n = this.parsingWorker = g.createWorker()
          , m = this
          , q = {};
        l.addEventListener("message", function(a) {
            if (a.data && "F2DBLOB" == a.data.type) {
                var c = {
                    operation: "PARSE_F2D",
                    data: a.data.buffer,
                    metadata: a.data.metadata,
                    manifest: a.data.manifest,
                    basePath: a.data.basePath,
                    f2dLoadOptions: q,
                    url: f
                };
                n.postMessage(c, [c.data]);
                l.terminate()
            } else
                a.data && "F2DSTREAM" == a.data.type ? (c = {
                    operation: "PARSE_F2D_FRAME",
                    data: a.data.frames,
                    url: f,
                    f2dLoadOptions: q
                },
                a.data.metadata && 
                (c.metadata = a.data.metadata,
                c.manifest = a.data.manifest),
                a.data.finalFrame && (c.finalFrame = !0),
                a.data.progress && m.viewer3DImpl.signalProgress(100 * a.data.progress),
                n.postMessage(c, c.data ? [c.data] : void 0),
                a.data.finalFrame && l.terminate()) : a.data && "F2DAssetURL" == a.data.type ? g.assets = g.assets.concat(a.data.urls) : a.data && a.data.debug ? stderr(a.data.message) : a.data && a.data.error ? (m.loading = !1,
                l.terminate(),
                b && b.call(this, a.data.error.code, a.data.error.msg)) : (stderr("F2D download failed."),
                m.loading = !1,
                l.terminate())
        }
        , 
        !1);
        n.addEventListener("message", function(c) {
            if (c.data && c.data.f2d) {
                var d = m.svf = c.data.f2d;
                n.terminate();
                stderr("Num polylines: " + d.numPolylines);
                stderr("Line segments: " + d.numLineSegs);
                stderr("Circular arcs: " + d.numCircles);
                stderr("Ellipitcal arcs:" + d.numEllipses);
                stderr("Plain triangles:" + d.numTriangles);
                stderr("Total # of op codes generated by fydo.parse: " + d.opCount);
                m.onSvfLoadDone(m.svf);
                var f = m.model = new g.RenderModel(d);
                f.initialize(f, this);
                f.loader = m;
                a && a(m.model);
                m.viewer3DImpl.api.fireEvent({
                    type: h.MODEL_ROOT_LOADED_EVENT,
                    svf: m.svf
                });
                for (f = 0; f < d.meshes.length; f++)
                    m.processReceivedMesh2D(d.meshes[f], f);
                d.meshes = null ;
                m.onGeomLoadDone();
                m.loading = !1
            } else if (c.data && c.data.f2dframe) {
                var k = 0;
                c.data.meshes ? (d = c.data.bbox,
                m.svf.bbox = new THREE.Box3(d.min,d.max)) : m.svf = c.data.f2dframe;
                k = c.data.baseIndex;
                d = m.svf;
                d.fragments && d.fragments.initialized ? (d.maxObjectNumber = c.data.maxObjectNumber,
                d.viewports = c.data.viewports,
                d.currentVpId = c.data.currentVpId,
                d.clips = c.data.clips) : (m.onSvfLoadDone(d),
                f = m.model = new g.RenderModel(d),
                f.initialize(f, 
                this),
                f.loader = m,
                a && a(m.model),
                m.viewer3DImpl.api.fireEvent({
                    type: h.MODEL_ROOT_LOADED_EVENT,
                    svf: d
                }));
                if (c.data.meshes && c.data.meshes.length) {
                    for (f = 0; f < c.data.meshes.length; f++)
                        m.processReceivedMesh2D(c.data.meshes[f], k + f);
                    c.data.finalFrame && (m.onGeomLoadDone(),
                    m.loading = !1,
                    n.terminate())
                }
            } else
                c.data && c.data.progress || (c.data && c.data.debug ? stderr(c.data.message) : c.data && c.data.error ? (m.loading = !1,
                n.terminate(),
                stderr("Error while parsing F2d: " + JSON.stringify(c.data.error.args)),
                b && b.call(this, c.data.error.code, 
                c.data.error.msg)) : (stderr("F2D download failed."),
                m.loading = !1,
                n.terminate()))
        }
        , !1);
        l.postMessage({
            operation: "STREAM_F2D",
            url: f,
            headers: h.HTTP_REQUEST_HEADERS,
            objectIds: c,
            auth: auth,
            viewing_url: VIEWING_URL,
            oss_url: OSS_URL,
            queryParams: this.domainParam
        });
        return !0
    }
    ;
    f.prototype.processReceivedMesh = function(d) {
        var c = d.packId + ":" + d.meshIndex
          , a = this.svf
          , b = a.fragments
          , f = b.mesh2frag[c];
        if (void 0 === f)
            stderr("Mesh " + c + " was not referenced by any fragments.");
        else {
            Array.isArray(f) || (f = [f]);
            BufferGeometryUtils.meshToGeometry(d);
            var g = f.length
              , h = this.model;
            h.getGeometryList().addGeometry(d.geometry, g);
            for (var g = (d.geometry.attributes.index.array || d.geometry.ib).length / 3, m = 0; m < f.length; m++) {
                var q = 0 | f[m];
                h.getFragmentList().getOriginalWorldMatrix(q, this.tmpMatrix);
                var r = b.materials[q].toString();
                b.polygonCounts && (b.polygonCounts[q] = g);
                r = this.viewer3DImpl.createThreeMesh(this.model, d.geometry, r, this.tmpMatrix);
                h.activateFragment(q, r)
            }
            b.mesh2frag[c] = null ;
            b.numLoaded += f.length;
            d = b.numLoaded;
            a.geomPolyCount > a.nextRepaintPolys && 
            (a.numRepaints++,
            a.nextRepaintPolys += 1E4 * Math.pow(1.5, a.numRepaints),
            this.viewer3DImpl.invalidate(!1, !0));
            0 == d % 20 && this.viewer3DImpl.invalidate(!1, !0)
        }
    }
    ;
    f.prototype.processReceivedMesh2D = function(d, c) {
        var a = {
            mesh: d,
            is2d: !0,
            packId: "0",
            meshIndex: c
        }
          , b = "0:" + c
          , f = this.svf.fragments
          , g = Object.keys(a.mesh.dbIds).map(function(a) {
            return parseInt(a)
        }
        );
        f.fragId2dbId[c] = g;
        for (var h = 0; h < g.length; h++) {
            var m = g[h]
              , q = f.dbId2fragId[m];
            Array.isArray(q) ? q.push(c) : f.dbId2fragId[m] = "undefined" !== typeof q ? [q, c] : c
        }
        f.mesh2frag[b] = 
        c;
        f.materials[c] = this.viewer3DImpl.matman().create2DMaterial(this.svf, d.material);
        f.length++;
        this.processReceivedMesh(a)
    }
    ;
    f.prototype.onSvfLoadDone = function(d) {
        d.fragments = {};
        d.fragments.mesh2frag = {};
        d.fragments.materials = [];
        d.fragments.fragId2dbId = [];
        d.fragments.dbId2fragId = [];
        d.fragments.length = 0;
        d.fragments.initialized = !0;
        d.geomPolyCount = 0;
        d.instancePolyCount = 0;
        d.geomMemory = 0;
        d.fragments.numLoaded = 0;
        d.meshCount = 0;
        d.gpuNumMeshes = 0;
        d.gpuMeshMemory = 0;
        d.nextRepaintPolys = 1E4;
        d.numRepaints = 0;
        d.urn = this.svfUrn;
        d.basePath = "";
        var c = this.currentLoadPath.lastIndexOf("/");
        -1 != c && (d.basePath = this.currentLoadPath.substr(0, c + 1));
        c = Date.now();
        this.loadTime += c - this.t0;
        stderr("SVF load: " + (c - this.t0));
        this.t0 = c;
        d.bbox = (new THREE.Box3).copy(d.bbox);
        stderr("scene bounds: " + JSON.stringify(d.bbox));
        this.viewer3DImpl.signalProgress(5, "Hold on, getting the model...");
        this.viewer3DImpl.invalidate(!1, !1)
    }
    ;
    f.prototype.onGeomLoadDone = function() {
        this.svf.loadDone = !0;
        this.svf.fragments.entityIndexes = null ;
        this.svf.fragments.mesh2frag = 
        null ;
        var d = Date.now()
          , c = "Fragments load time: " + (d - this.t0);
        this.loadTime += d - this.t0;
        this.loadPropertyDb();
        stderr(c);
        this.logger && (d = {
            category: "model_load_stats",
            is_f2d: !0,
            has_prism: this.viewer3DImpl.matman().hasPrism,
            load_time: this.loadTime,
            geometry_size: this.model.getGeometryList().geomMemory,
            meshes_count: this.model.getGeometryList().geoms.length,
            urn: this.svfUrn
        },
        this.logger.log(d, !0));
        g.assets && window.webkit && (window.webkit.messageHandlers.callbackHandler.postMessage({
            command: "assets",
            data: g.assets
        }),
        g.assets = null );
        this.currentLoadPath = null ;
        this.isf2d = void 0;
        this.viewer3DImpl.onLoadComplete()
    }
    ;
    f.prototype.loadPropertyDb = function() {
        this.svf.propWorker = new g.PropDbLoader(this.sharedDbPath,this.svf,this.viewer3DImpl.api);
        this.svf.propWorker.load()
    }
    ;
    g.F2DLoader = f;
    h.FileLoaderManager.registerFileLoader("f2d", ["f2d"], g.F2DLoader)
}
)();
(function(f) {
    function h(d, c) {
        var a = c || 65536;
        this.useInstancing = d;
        this.stride = 12;
        this.vb = new ArrayBuffer(4 * this.stride * (this.useInstancing ? a / 4 : a));
        this.vbf = new Float32Array(this.vb);
        this.vbi = new Int32Array(this.vb);
        this.vcount = 0;
        this.ib = this.useInstancing ? null  : new Uint16Array(a);
        this.icount = 0;
        this.minx = this.miny = Infinity;
        this.maxx = this.maxy = -Infinity;
        this.dbIds = {};
        this.numTriangleGeoms = this.numCirculars = this.numEllipticals = 0
    }
    var g = 2 * Math.PI;
    h.prototype.expandStride = function() {
        var d = this.stride;
        if (!(12 <= 
        d)) {
            for (var c = this.stride + 2, a = new ArrayBuffer(this.vb.byteLength / d * c), b = new Uint8Array(this.vb), f = new Uint8Array(a), g = 0, h = this.vcount; g < h; g++)
                for (var m = g * d * 4, q = g * c * 4, r = 0; r < 4 * d; r++)
                    f[q + r] = b[m + r];
            this.vb = a;
            this.vbf = new Float32Array(a);
            this.vbi = new Int32Array(a);
            this.stride = c
        }
    }
    ;
    h.prototype.addToBounds = function(d, c) {
        d < this.minx && (this.minx = d);
        d > this.maxx && (this.maxx = d);
        c < this.miny && (this.miny = c);
        c > this.maxy && (this.maxy = c)
    }
    ;
    h.prototype.setVertexFlag = function(d, c, a, b) {
        this.vbi[d * this.stride + 9] = b | a | c << 16
    }
    ;
    h.prototype.addVertexTriangleGeom = function(d, c, a, b, f, g, h, m, q) {
        for (var r = this.vcount, t = this.useInstancing ? 1 : 4, w = 0; w < t; w++) {
            var C = (r + w) * this.stride
              , E = this.vbf;
            E[C] = d;
            E[C + 1] = c;
            E[C + 2] = a;
            E[C + 3] = b;
            E[C + 4] = f;
            E[C + 5] = g;
            this.vbi[C + 6] = h;
            this.vbi[C + 7] = m;
            this.vbi[C + 8] = q << 16;
            this.vcount++;
            this.dbIds[m] = 1
        }
        return r
    }
    ;
    h.prototype.addVertexLine = function(d, c, a, b, f, g, h, m, q, r) {
        for (var t = this.vcount, w = this.useInstancing ? 1 : 4, C = 0; C < w; C++) {
            var E = (t + C) * this.stride
              , G = this.vbf;
            G[E] = d;
            G[E + 1] = c;
            G[E + 2] = a;
            G[E + 3] = b;
            G[E + 4] = g;
            G[E + 5] = 
            f;
            this.vbi[E + 6] = h;
            this.vbi[E + 7] = m;
            this.vbi[E + 8] = q << 16 | r;
            this.dbIds[m] = 1;
            this.vcount++
        }
        return t
    }
    ;
    h.prototype.addVertexArc = function(d, c, a, b, f, g, h, m, q, r, t) {
        for (var w = this.vcount, C = this.useInstancing ? 1 : 4, E = 0; E < C; E++) {
            var G = (w + E) * this.stride
              , B = this.vbf;
            B[G] = d;
            B[G + 1] = c;
            B[G + 2] = a;
            B[G + 3] = b;
            B[G + 4] = m;
            B[G + 5] = f;
            this.vbi[G + 6] = q;
            this.vbi[G + 7] = r;
            this.vbi[G + 8] = t << 16 | 0;
            f != g && (B[G + 10] = g,
            B[G + 11] = h);
            this.dbIds[r] = 1;
            this.vcount++
        }
        return w
    }
    ;
    h.prototype.addVertex = function(d, c, a, b, f, g, h, m, q) {
        if (!this.useInstancing) {
            var r = 
            this.vcount
              , t = r * this.stride
              , w = this.vbf;
            w[t] = d;
            w[t + 1] = c;
            w[t + 2] = a;
            w[t + 3] = b;
            w[t + 4] = f;
            w[t + 5] = 0;
            this.vbi[t + 6] = g;
            this.vbi[t + 7] = h;
            this.vbi[t + 8] = q << 16 | 0;
            this.setVertexFlag(r, m, 0, 0);
            this.vcount++;
            this.dbIds[h] = 1;
            return r
        }
    }
    ;
    h.prototype.addVertexPolytriangle = function(d, c, a, b, f, g, h, m, q) {
        this.useInstancing || (this.addVertex(d, c, a, b, f, g, h, m, q),
        this.addToBounds(d, c))
    }
    ;
    h.prototype.setVertexColor = function(d, c) {
        this.useInstancing || (this.vbi[d * this.stride + 6] = c)
    }
    ;
    h.prototype.addTriangle = function(d, c, a) {
        if (!this.useInstancing) {
            var b = 
            this.ib
              , f = this.icount;
            if (f + 3 >= b.length) {
                for (var g = new Uint16Array(2 * b.length), h = 0; h < f; h++)
                    g[h] = b[h];
                this.ib = b = g
            }
            b[f] = d;
            b[f + 1] = c;
            b[f + 2] = a;
            this.icount += 3
        }
    }
    ;
    h.prototype.finalizeQuad = function(d, c, a) {
        this.useInstancing ? this.setVertexFlag(d, a, 0, c) : (this.addTriangle(d, d + 1, d + 2),
        this.addTriangle(d, d + 2, d + 3),
        this.setVertexFlag(d, a, 1, c),
        this.setVertexFlag(d + 1, a, 3, c),
        this.setVertexFlag(d + 2, a, 4, c),
        this.setVertexFlag(d + 3, a, 2, c))
    }
    ;
    h.prototype.addSegment = function(d, c, a, b, f, g, h, m, q, r, t) {
        var w = a - d
          , C = b - c
          , E = 0;
        if (w || C)
            E = 
            Math.atan2(C, w);
        w = Math.sqrt(w * w + C * C);
        f = this.addVertexLine(d, c, E, w, f, .5 * g, h, m, r, t);
        this.finalizeQuad(f, 16, q);
        this.addToBounds(d, c);
        this.addToBounds(a, b)
    }
    ;
    h.prototype.addTriangleGeom = function(d, c, a, b, f, g, h, m, q, r) {
        this.numTriangleGeoms++;
        h = this.addVertexTriangleGeom(d, c, a, b, f, g, h, m, q, r);
        this.finalizeQuad(h, 80, q);
        this.addToBounds(d, c);
        this.addToBounds(a, b);
        this.addToBounds(f, g)
    }
    ;
    h.prototype.addCircularArc = function(d, c, a, b, f, h, n, m, q, r) {
        this.numCirculars++;
        0 == a && 0 == b && (b = g);
        var t = Math.abs(a - b);
        if (1E-4 < 
        t && 1E-4 < Math.abs(t - g)) {
            var t = d + f * Math.cos(a)
              , w = c + f * Math.sin(a);
            this.addSegment(t, w, t, w, 0, h, n, m, q, r);
            t = d + f * Math.cos(b);
            w = c + f * Math.sin(b);
            this.addSegment(t, w, t, w, 0, h, n, m, q, r)
        } else
            this.addToBounds(d - f, c - f),
            this.addToBounds(d + f, c + f);
        d = this.addVertexArc(d, c, a, b, f, f, 0, .5 * h, n, m, r);
        this.finalizeQuad(d, 32, q)
    }
    ;
    h.prototype.addEllipticalArc = function(d, c, a, b, f, h, n, m, q, r, t, w) {
        this.expandStride();
        this.numEllipticals++;
        0 == a && 0 == b && (b = g);
        var C = Math.abs(a - b);
        if (1E-4 < Math.abs(C - g)) {
            var C = d + f * Math.cos(a)
              , E = c + h * Math.sin(a);
            this.addSegment(C, E, C, E, 0, m, q, r, t, w);
            C = d + f * Math.cos(b);
            E = c + h * Math.sin(b);
            this.addSegment(C, E, C, E, 0, m, q, r, t, w)
        } else
            this.addToBounds(d - f, c - h),
            this.addToBounds(d + f, c + h);
        d = this.addVertexArc(d, c, a, b, f, h, n, .5 * m, q, r, w);
        this.finalizeQuad(d, 48, t)
    }
    ;
    h.prototype.addTexturedQuad = function(d, c, a, b, f, g, h) {
        var m = .5 * b;
        f = this.addVertexLine(d, c + m, 0, a, 0, m, 4278255615, f, h, 0);
        this.finalizeQuad(f, 64, g);
        this.addToBounds(d, c);
        this.addToBounds(d + a, c + b)
    }
    ;
    h.prototype.isFull = function(d) {
        d || (d = 3);
        return this.useInstancing ? 32767 < 
        4 * this.vcount + d : 32767 < this.vcount + d
    }
    ;
    h.prototype.toMesh = function() {
        var d = {};
        d.vb = new Float32Array(this.vb.slice(0, this.vcount * this.stride * 4));
        d.vbstride = this.stride;
        var c = this.useInstancing ? 1 : 0;
        d.vblayout = {
            fields1: {
                offset: 0,
                itemSize: 3,
                bytesPerItem: 4,
                divisor: c
            },
            fields2: {
                offset: 3,
                itemSize: 3,
                bytesPerItem: 4,
                divisor: c
            },
            color4b: {
                offset: 6,
                itemSize: 4,
                bytesPerItem: 1,
                divisor: c,
                normalize: !0
            },
            dbId4b: {
                offset: 7,
                itemSize: 4,
                bytesPerItem: 1,
                divisor: c,
                normalize: !0
            },
            linetype4b: {
                offset: 8,
                itemSize: 4,
                bytesPerItem: 1,
                divisor: c,
                normalize: !1
            },
            flags4b: {
                offset: 9,
                itemSize: 4,
                bytesPerItem: 1,
                divisor: c,
                normalize: !1
            }
        };
        10 < this.stride && (d.vblayout.extraParams = {
            offset: 10,
            itemSize: 2,
            bytesPerItem: 4,
            divisor: c,
            normalize: !1
        });
        if (this.useInstancing) {
            for (var a in d.vblayout)
                d.vblayout[a].divisor = 1;
            d.numInstances = this.vcount;
            c = new Int32Array(4);
            c[0] = 1;
            c[1] = 3;
            c[2] = 4;
            c[3] = 2;
            d.vblayout.instFlags4b = {
                offset: 0,
                itemSize: 4,
                bytesPerItem: 1,
                normalize: !1,
                divisor: 0
            };
            d.vblayout.instFlags4b.array = c.buffer;
            c = d.indices = new Uint16Array(6);
            c[0] = 0;
            c[1] = 1;
            c[2] = 
            2;
            c[3] = 0;
            c[4] = 2;
            c[5] = 3
        } else
            d.indices = new Uint16Array(this.ib.buffer.slice(0, 2 * this.icount));
        d.dbIds = this.dbIds;
        c = this.maxx - this.minx;
        a = this.maxy - this.miny;
        var b = Math.max(c, a);
        d.boundingBox = {
            min: {
                x: this.minx,
                y: this.miny,
                z: .001 * -b
            },
            max: {
                x: this.maxx,
                y: this.maxy,
                z: .001 * b
            }
        };
        b = d.boundingSphere = {};
        b.center = {
            x: .5 * (this.minx + this.maxx),
            y: .5 * (this.miny + this.maxy),
            z: 0
        };
        b.radius = .5 * Math.sqrt(c * c + a * a);
        return d
    }
    ;
    f.VertexBufferBuilder = h
}
)(Teratek.Viewing.Private);
function init_three_triangulator() {
    Teratek.Viewing.Private.Triangulator || (Teratek.Viewing.Private.Triangulator = function() {
        function f() {
            this.bbox = new THREE.Box2;
            this.right = this.left = null ;
            this.node_edges = []
        }
        function h(c, a, b) {
            this.pts = c;
            this.edges = a;
            this.bbox = b;
            this.pipResult = !1
        }
        function g(c, a) {
            this.edges = c;
            this.bbox = a;
            this.pts = [];
            this.idmap = {};
            this.xymap = {};
            this.contours = [];
            this.scale = 1E6 / this.bbox.size().length()
        }
        function d(c) {
            this.indices = [];
            this.cset = c;
            var a = this.pts = c.pts;
            this.intervalTree = new h(c.pts,
            c.edges,c.bbox);
            this.intervalTree.build();
            for (var b = 0; b < a.length; b++)
                a[b].id = b;
            var d = new lmv_poly2tri.SweepContext([]);
            d.points_ = a.slice();
            if (c.contours)
                for (b = this.cset.contours,
                c = 0; c < b.length; c++) {
                    for (var f = b[c], g = f[0] !== f[f.length - 1], m = [], q = 0; q < f.length - 1; q++)
                        m.push(a[f[q]]);
                    d.initEdges(m, g)
                }
            else
                for (c = this.cset.edges,
                b = 0; b < c.length; b++)
                    f = c[b],
                    f.p1 != f.p2 && d.initEdges([a[f.p1], a[f.p2]], !0);
            this.triangulate(d);
            this.processResult(d)
        }
        h.prototype.splitNode = function(c) {
            if (!(c.bbox.min.y >= c.bbox.max.y || 
            3 > c.node_edges.length)) {
                var a = .5 * (c.bbox.min.y + c.bbox.max.y);
                c.left = new f;
                c.right = new f;
                for (var b = this.pts, d = c.node_edges, g = [], h = new THREE.Vector2, m = 0; m < d.length; m++) {
                    var q = this.edges[d[m]]
                      , r = b[q.p1].y
                      , t = b[q.p2].y;
                    if (r > t)
                        var w = r
                          , r = t
                          , t = w;
                    w = null ;
                    t < a ? (c.left.node_edges.push(d[m]),
                    w = c.left.bbox) : r > a ? (c.right.node_edges.push(d[m]),
                    w = c.right.bbox) : g.push(d[m]);
                    w && (h.set(b[q.p1].x, b[q.p1].y),
                    w.expandByPoint(h),
                    h.set(b[q.p2].x, b[q.p2].y),
                    w.expandByPoint(h))
                }
                c.node_edges = g;
                c.left.node_edges.length && this.splitNode(c.left);
                c.right.node_edges.length && this.splitNode(c.right)
            }
        }
        ;
        h.prototype.build = function() {
            this.root = new f;
            for (var c = this.root.node_edges, a = 0; a < this.edges.length; a++)
                c.push(a);
            this.root.bbox.copy(this.bbox);
            this.splitNode(this.root)
        }
        ;
        h.prototype.pointInPolygonRec = function(c, a, b) {
            if (c.bbox.min.y <= b && c.bbox.max.y >= b)
                for (var d = this.pts, f = c.node_edges, g = 0, h = f.length; g < h; g++) {
                    var q = this.edges[f[g]]
                      , r = d[q.p1]
                      , t = r.x
                      , r = r.y
                      , w = d[q.p2]
                      , q = w.x
                      , w = w.y
                      , C = w >= b;
                    r >= b != C && (w - b) * (t - q) >= (q - a) * (r - w) == C && (this.pipResult = !this.pipResult)
                }
            (d = 
            c.left) && d.bbox.min.y <= b && d.bbox.max.y >= b && this.pointInPolygonRec(d, a, b);
            (c = c.right) && c.bbox.min.y <= b && c.bbox.max.y >= b && this.pointInPolygonRec(c, a, b)
        }
        ;
        h.prototype.pointInPolygon = function(c, a) {
            this.pipResult = !1;
            this.pointInPolygonRec(this.root, c, a);
            return this.pipResult
        }
        ;
        g.prototype.getPointIndex = function(c, a, b) {
            var d = this.idmap[b];
            if (void 0 !== d)
                return d;
            var f = 0 | c * this.scale
              , d = 0 | a * this.scale
              , g = this.xymap[f];
            void 0 === g ? (this.xymap[f] = g = {},
            f = void 0) : f = g[d];
            void 0 === f && (g[d] = f = this.pts.length,
            this.idmap[b] = 
            f,
            this.pts.push({
                x: c,
                y: a
            }));
            return f
        }
        ;
        g.prototype.snapEdges = function() {
            for (var c = 0; c < this.edges.length; c++) {
                var a = this.edges[c];
                a.p1 = this.getPointIndex(a.pt1.x, a.pt1.y, a.eid1);
                a.p2 = this.getPointIndex(a.pt2.x, a.pt2.y, a.eid2)
            }
        }
        ;
        g.prototype.stitchContours = function() {
            for (var c = {}, a = 0; a < this.edges.length; a++) {
                var b = this.edges[a];
                b.p1 !== b.p2 && (void 0 !== c[b.p1] ? c[b.p1].push(b.p2) : c[b.p1] = [b.p2],
                void 0 !== c[b.p2] ? c[b.p2].push(b.p1) : c[b.p2] = [b.p1])
            }
            var b = [], d;
            for (d in c)
                if (2 !== c[d].length) {
                    stderr("Incomplete edge table");
                    break
                }
            for (; ; ) {
                var f = void 0;
                for (d in c)
                    if (1 < c[d].length) {
                        f = d;
                        break
                    }
                if (!f)
                    for (d in c)
                        if (0 < c[d].length) {
                            f = d;
                            break
                        }
                if (!f)
                    break;
                var a = -1
                  , g = parseInt(f)
                  , f = c[f];
                for (b.push(g); f && f.length; ) {
                    var h = f.shift();
                    h === a && (h = f.shift());
                    if (void 0 === h) {
                        delete c[g];
                        break
                    }
                    b.push(h);
                    0 == f.length ? delete c[g] : f[0] === a && delete c[g];
                    a = g;
                    g = h;
                    f = c[h]
                }
                b.length && (this.contours.push(b),
                b = [])
            }
            c = [];
            for (a = 0; a < this.contours.length; a++)
                f = this.contours[a],
                f[0] !== f[f.length - 1] && c.push(f);
            if (c.length)
                for (c = !0; c; ) {
                    c = !1;
                    g = {};
                    b = this.contours;
                    for (a = 0; a < b.length; a++)
                        f = b[a],
                        h = f[0],
                        f = f[f.length - 1],
                        h !== f && (g[h] ? g[h].push(-a - 1) : g[h] = [-a - 1],
                        g[f] ? g[f].push(a) : g[f] = [a]);
                    for (d in g)
                        if (a = g[d],
                        2 == a.length) {
                            g = void 0;
                            0 > a[0] && 0 > a[1] && (g = -a[0] - 1,
                            f = -a[1] - 1,
                            b[f].shift(),
                            Array.prototype.push.apply(b[g].reverse(), b[f]),
                            g = f);
                            0 > a[0] && 0 < a[1] && (g = -a[0] - 1,
                            f = a[1],
                            b[f].pop(),
                            Array.prototype.push.apply(b[f], b[g]));
                            0 < a[0] && 0 > a[1] && (g = a[0],
                            f = -a[1] - 1,
                            b[g].pop(),
                            Array.prototype.push.apply(b[g], b[f]),
                            g = f);
                            0 < a[0] && 0 < a[1] && (g = a[0],
                            f = a[1],
                            b[g].pop(),
                            Array.prototype.push.apply(b[g], 
                            b[f].reverse()),
                            g = f);
                            void 0 !== g && (b.splice(g, 1),
                            c = !0);
                            break
                        }
                }
        }
        ;
        d.prototype.triangulate = function(c) {
            try {
                c.triangulate()
            } catch (a) {}
        }
        ;
        d.prototype.processResult = function(c) {
            for (var a = 0; a < c.map_.length; a++) {
                var b = c.map_[a]
                  , d = b.points_[0]
                  , f = b.points_[1]
                  , b = b.points_[2];
                void 0 !== d.id && void 0 !== f.id && void 0 !== b.id && this.filterFace(d.id, f.id, b.id)
            }
        }
        ;
        d.prototype.pointInEdgeList = function(c, a) {
            for (var b, d, f, g, h, q, r = this.cset.pts, t = this.cset.edges, w = !1, C = 0, E = t.length; C < E; ++C)
                d = t[C],
                f = r[d.p1].x,
                g = r[d.p1].y,
                b = g >= 
                a,
                h = r[d.p2].x,
                q = r[d.p2].y,
                d = q >= a,
                b != d && (q - a) * (f - h) >= (h - c) * (g - q) == d && (w = !w);
            return w
        }
        ;
        d.prototype.pointInContour = function(c, a, b) {
            var d, f, g, h, q, r, t = !1, w = this.cset.pts;
            g = w[b[b.length - 1]].x;
            h = w[b[b.length - 1]].y;
            d = h >= a;
            for (var C = 0, E = b.length; C < E; ++C)
                q = w[b[C]].x,
                r = w[b[C]].y,
                f = r >= a,
                d != f && (r - a) * (g - q) >= (q - c) * (h - r) == f && (t = !t),
                d = f,
                g = q,
                h = r;
            return t
        }
        ;
        d.prototype.pointInPolygon = function(c, a) {
            for (var b = !1, d = 0; d < this.cset.contours.length; d++)
                this.pointInContour(c, a, this.cset.contours[d]) && (b = !b);
            return b
        }
        ;
        d.prototype.filterFace = 
        function(c, a, b) {
            var d = this.pts[c]
              , f = this.pts[a]
              , g = this.pts[b];
            this.intervalTree.pointInPolygon((d.x + f.x + g.x) / 3, (d.y + f.y + g.y) / 3) && (0 < (f.x - d.x) * (g.y - d.y) - (g.x - d.x) * (f.y - d.y) ? this.indices.push(c, a, b) : this.indices.push(c, b, a))
        }
        ;
        return {
            TriangulatedSurface: d,
            ContourSet: g,
            Edge: function(c, a, b, d, f, g, h) {
                this.pt1 = c;
                this.pt2 = a;
                this.p2 = this.p1 = -1;
                this.eid1 = h + ":" + (b < d ? b + ":" + d : d + ":" + b);
                this.eid2 = h + ":" + (f < g ? f + ":" + g : g + ":" + f)
            }
        }
    }
    ())
}
function init_three_intersector() {
    Teratek.Viewing.Private.Intersector || (Teratek.Viewing.Private.Intersector = function() {
        function f(a, b, c, f, g) {
            var h = d.subVectors(c, b)
              , k = a.normal.dot(h);
            if (1E-10 > Math.abs(k))
                return f.copy(b),
                g.copy(c),
                2;
            k = 1 / k;
            a = -(b.dot(a.normal) * k + a.constant * k);
            if (-1E-10 > a || a > 1 + 1E-10)
                return 0;
            b = h.multiplyScalar(a).add(b);
            f.copy(b);
            return 1
        }
        function h(b, d, h, k, l, m, n, q, D) {
            var z = b.distanceToPoint(d)
              , H = b.distanceToPoint(h)
              , I = b.distanceToPoint(k);
            if (0 > z && 0 > H && 0 > I || 0 < z && 0 < H && 0 < I)
                return null ;
            var z = Math.sign(z), H = Math.sign(H), I = Math.sign(I), J, L, F, N, K, M;
            if (z !== H) {
                var S = f(b, d, h, c, a);
                if (2 == S) {
                    q.push(new g(d.clone(),h.clone(),l,l,m,m,D));
                    return
                }
                1 == S ? (F = l,
                N = m,
                J = c.clone()) : console.warn("Unexpected zero intersections where at least one was expected")
            }
            if (H !== I) {
                S = f(b, h, k, c, a);
                if (2 == S) {
                    q.push(new g(h.clone(),k.clone(),m,m,n,n,D));
                    return
                }
                1 == S ? J ? (K = m,
                M = n,
                L = c.clone()) : (F = m,
                N = n,
                J = c.clone()) : console.warn("Unexpected zero intersections where at least one was expected")
            }
            if (I !== z) {
                S = f(b, k, d, c, a);
                if (2 == 
                S) {
                    q.push(new g(k.clone(),d.clone(),n,n,l,l,D));
                    return
                }
                1 == S ? J ? (K = n,
                M = l,
                L = c.clone()) : console.warn("Unexpected single intersection point") : console.warn("Unexpected zero intersections where at least one was expected")
            }
            J && L ? q.push(new g(J,L,F,N,K,M,D)) : console.warn("Unexpected one intersection where two were expected")
        }
        var g = Teratek.Viewing.Private.Triangulator.Edge
          , d = new THREE.Vector3
          , c = new THREE.Vector3
          , a = new THREE.Vector3
          , b = new THREE.Vector3
          , k = new THREE.Vector3
          , l = new THREE.Vector3
          , n = new THREE.Vector3
          , 
        m = new THREE.Matrix4
          , q = new THREE.Plane;
        return {
            makePlaneBasis: function(a) {
                var b = new THREE.Vector3(0,0,1)
                  , c = a.normal.clone().cross(b)
                  , c = c.normalize()
                  , b = b.dot(a.normal)
                  , d = new THREE.Matrix4;
                if (!(1E-10 > Math.abs(c.x) && 1E-10 > Math.abs(c.y) && 1E-10 > Math.abs(c.z))) {
                    var f = c
                      , c = Math.sqrt(1 - b * b)
                      , g = 1 - b
                      , h = f.x
                      , k = f.y
                      , f = f.z
                      , l = g * h
                      , m = g * k;
                    d.set(l * h + b, l * k - c * f, l * f + c * k, 0, l * k + c * f, m * k + b, m * f - c * h, 0, l * f - c * k, m * f + c * h, g * f * f + b, 0, 0, 0, 0, 1)
                }
                d.elements[14] = a.constant;
                return d
            },
            convertToPlaneCoords: function(a, b, c) {
                for (var d = 0; d < b.length; d++) {
                    var f = 
                    b[d];
                    f.pt1.applyMatrix4(a);
                    f.pt2.applyMatrix4(a);
                    c.expandByPoint(f.pt1);
                    c.expandByPoint(f.pt2)
                }
            },
            intersectTrianglePlane: h,
            intersectMeshPlane: function(a, b, c) {
                var d = b.geometry
                  , f = c.length
                  , g = d.attributes
                  , B = b.matrixWorld;
                m.getInverse(B);
                q.copy(a).applyMatrix4(m);
                var v, D, z;
                if (void 0 !== g.index) {
                    a = g.index.array || d.ib;
                    var g = d.vb ? d.vb : g.position.array
                      , H = d.vb ? d.vbstride : 3;
                    (d = d.offsets) && 0 !== d.length || (d = [{
                        start: 0,
                        count: a.length,
                        index: 0
                    }]);
                    for (var I = 0, J = d.length; I < J; ++I) {
                        v = d[I].start;
                        for (var L = d[I].index, F = v, 
                        N = v + d[I].count; F < N; F += 3)
                            v = L + a[F],
                            D = L + a[F + 1],
                            z = L + a[F + 2],
                            k.x = g[v * H],
                            k.y = g[v * H + 1],
                            k.z = g[v * H + 2],
                            l.x = g[D * H],
                            l.y = g[D * H + 1],
                            l.z = g[D * H + 2],
                            n.x = g[z * H],
                            n.y = g[z * H + 1],
                            n.z = g[z * H + 2],
                            h(q, k, l, n, v, D, z, c, b.fragId)
                    }
                } else
                    for (g = d.vb ? d.vb : g.position.array,
                    H = d.vb ? d.vbstride : 3,
                    F = 0,
                    N = g.length; F < N; F += 3)
                        v = F,
                        D = F + 1,
                        z = F + 2,
                        k.x = g[v * H],
                        k.y = g[v * H + 1],
                        k.z = g[v * H + 2],
                        l.x = g[D * H],
                        l.y = g[D * H + 1],
                        l.z = g[D * H + 2],
                        n.x = g[z * H],
                        n.y = g[z * H + 1],
                        n.z = g[z * H + 2],
                        h(q, k, l, n, v, D, z, c, b.fragId);
                for (F = f; F < c.length; F++)
                    c[F].pt1.applyMatrix4(B),
                    c[F].pt2.applyMatrix4(B)
            },
            intersectBoxPlane: function(a, c) {
                b.set(c.min.x, c.min.y, c.min.z);
                var d = a.distanceToPoint(b)
                  , d = Math.sign(d);
                b.set(c.min.x, c.min.y, c.max.z);
                var f = a.distanceToPoint(b);
                if (Math.sign(f) !== d)
                    return !0;
                b.set(c.min.x, c.max.y, c.min.z);
                f = a.distanceToPoint(b);
                if (Math.sign(f) !== d)
                    return !0;
                b.set(c.min.x, c.max.y, c.max.z);
                f = a.distanceToPoint(b);
                if (Math.sign(f) !== d)
                    return !0;
                b.set(c.max.x, c.min.y, c.min.z);
                f = a.distanceToPoint(b);
                if (Math.sign(f) !== d)
                    return !0;
                b.set(c.max.x, c.min.y, c.max.z);
                f = a.distanceToPoint(b);
                if (Math.sign(f) !== 
                d)
                    return !0;
                b.set(c.max.x, c.max.y, c.min.z);
                f = a.distanceToPoint(b);
                if (Math.sign(f) !== d)
                    return !0;
                b.set(c.max.x, c.max.y, c.max.z);
                f = a.distanceToPoint(b);
                return Math.sign(f) !== d ? !0 : !1
            }
        }
    }
    ())
}
function NodeArray(f, h) {
    this.bytes_per_node = h ? 32 : 36;
    var g, d;
    f instanceof ArrayBuffer ? (g = f.byteLength / this.bytes_per_node,
    d = f,
    this.nodeCount = g) : (g = f | 0,
    d = new ArrayBuffer(this.bytes_per_node * g),
    this.nodeCount = 0);
    this.nodeCapacity = g;
    this.nodesRaw = d;
    this.is_lean_node = h;
    this.node_stride = this.bytes_per_node / 4;
    this.node_stride_short = this.bytes_per_node / 2;
    this.nodesF = new Float32Array(this.nodesRaw);
    this.nodesI = new Int32Array(this.nodesRaw);
    this.nodesS = new Uint16Array(this.nodesRaw)
}
NodeArray.prototype.setLeftChild = function(f, h) {
    this.nodesI[f * this.node_stride + 6] = h
}
;
NodeArray.prototype.getLeftChild = function(f) {
    return this.nodesI[f * this.node_stride + 6]
}
;
NodeArray.prototype.setPrimStart = function(f, h) {
    this.is_lean_node ? this.nodesI[f * this.node_stride + 6] = h : this.nodesI[f * this.node_stride + 8] = h
}
;
NodeArray.prototype.getPrimStart = function(f) {
    return this.is_lean_node ? this.nodesI[f * this.node_stride + 6] : this.nodesI[f * this.node_stride + 8]
}
;
NodeArray.prototype.setPrimCount = function(f, h) {
    this.nodesS[f * this.node_stride_short + 14] = h
}
;
NodeArray.prototype.getPrimCount = function(f) {
    return this.nodesS[f * this.node_stride_short + 14]
}
;
NodeArray.prototype.setFlags = function(f, h, g, d) {
    this.nodesS[f * this.node_stride_short + 15] = d << 3 | g << 2 | h & 3
}
;
NodeArray.prototype.getFlags = function(f) {
    return this.nodesS[f * this.node_stride_short + 15]
}
;
NodeArray.prototype.setBox0 = function(f, h) {
    var g = f * this.node_stride
      , d = this.nodesF;
    d[g] = h[0];
    d[g + 1] = h[1];
    d[g + 2] = h[2];
    d[g + 3] = h[3];
    d[g + 4] = h[4];
    d[g + 5] = h[5]
}
;
NodeArray.prototype.getBoxThree = function(f, h) {
    var g = f * this.node_stride
      , d = this.nodesF;
    h.min.x = d[g];
    h.min.y = d[g + 1];
    h.min.z = d[g + 2];
    h.max.x = d[g + 3];
    h.max.y = d[g + 4];
    h.max.z = d[g + 5]
}
;
NodeArray.prototype.setBoxThree = function(f, h) {
    var g = f * this.node_stride
      , d = this.nodesF;
    d[g] = h.min.x;
    d[g + 1] = h.min.y;
    d[g + 2] = h.min.z;
    d[g + 3] = h.max.x;
    d[g + 4] = h.max.y;
    d[g + 5] = h.max.z
}
;
NodeArray.prototype.makeEmpty = function(f) {
    f *= this.node_stride;
    var h = this.nodesI;
    h[f + 6] = -1;
    h[f + 7] = 0;
    this.is_lean_node || (h[f + 8] = -1)
}
;
NodeArray.prototype.realloc = function(f) {
    if (this.nodeCount + f > this.nodeCapacity) {
        var h = 0 | 3 * this.nodeCapacity / 2;
        h < this.nodeCount + f && (h = this.nodeCount + f);
        f = new ArrayBuffer(h * this.bytes_per_node);
        var g = new Int32Array(f);
        g.set(this.nodesI);
        this.nodeCapacity = h;
        this.nodesRaw = f;
        this.nodesF = new Float32Array(f);
        this.nodesI = g;
        this.nodesS = new Uint16Array(f)
    }
}
;
NodeArray.prototype.nextNodes = function(f) {
    this.realloc(f);
    var h = this.nodeCount;
    this.nodeCount += f;
    for (var g = 0; g < f; g++)
        this.makeEmpty(h + g);
    return h
}
;
NodeArray.prototype.getRawData = function() {
    return this.nodesRaw.slice(0, this.nodeCount * this.bytes_per_node)
}
;
var BOX_STRIDE = 6
  , POINT_STRIDE = 3
  , BOX_EPSILON = 1E-5
  , BOX_SCALE_EPSILON = 1E-5
  , MAX_DEPTH = 15
  , MAX_BINS = 16
  , BVHModule = function() {
    function f(a, b, c) {
        a[0] > b[c] && (a[0] = b[c]);
        a[3] < b[c] && (a[3] = b[c]);
        a[1] > b[c + 1] && (a[1] = b[c + 1]);
        a[4] < b[c + 1] && (a[4] = b[c + 1]);
        a[2] > b[c + 2] && (a[2] = b[c + 2]);
        a[5] < b[c + 2] && (a[5] = b[c + 2])
    }
    function h(a, b, c) {
        a[0] > b[c] && (a[0] = b[c]);
        a[1] > b[c + 1] && (a[1] = b[c + 1]);
        a[2] > b[c + 2] && (a[2] = b[c + 2]);
        a[3] < b[c + 3] && (a[3] = b[c + 3]);
        a[4] < b[c + 4] && (a[4] = b[c + 4]);
        a[5] < b[c + 5] && (a[5] = b[c + 5])
    }
    function g(a, b) {
        a[0] > b[0] && (a[0] = b[0]);
        a[1] > b[1] && (a[1] = b[1]);
        a[2] > b[2] && (a[2] = b[2]);
        a[3] < b[3] && (a[3] = b[3]);
        a[4] < b[4] && (a[4] = b[4]);
        a[5] < b[5] && (a[5] = b[5])
    }
    function d(a, b, c, d) {
        for (var f = 0; 3 > f; f++)
            a[b + f] = c[d + 3 + f] - c[d + f]
    }
    function c(a, b) {
        a[0] = b[0];
        a[1] = b[1];
        a[2] = b[2];
        a[3] = b[3];
        a[4] = b[4];
        a[5] = b[5]
    }
    function a(a) {
        a[0] = Infinity;
        a[1] = Infinity;
        a[2] = Infinity;
        a[3] = -Infinity;
        a[4] = -Infinity;
        a[5] = -Infinity
    }
    function b(a) {
        var b = a[3] - a[0]
          , c = a[4] - a[1];
        a = a[5] - a[2];
        return 0 > b || 0 > c || 0 > a ? 0 : 2 * (b * c + c * a + a * b)
    }
    function k() {
        this.vb_left = new Float32Array(6);
        this.vb_right = 
        new Float32Array(6);
        this.cb_left = new Float32Array(6);
        this.cb_right = new Float32Array(6);
        this.num_left = 0;
        this.num_bins = this.best_cost = this.best_split = -1
    }
    function l() {
        this.box_bbox = new Float32Array(6);
        this.box_centroid = new Float32Array(6);
        this.num_prims = 0
    }
    function n() {
        this.BL = new Float32Array(6);
        this.CL = new Float32Array(6);
        this.AL = this.NL = 0
    }
    k.prototype.reset = function() {
        this.num_left = 0;
        this.num_bins = this.best_cost = this.best_split = -1
    }
    ;
    l.prototype.reset = function() {
        this.num_prims = 0;
        a(this.box_bbox);
        a(this.box_centroid)
    }
    ;
    n.prototype.reset = function() {
        this.AL = this.NL = 0;
        a(this.BL);
        a(this.CL)
    }
    ;
    for (var m = [], q = 0; q < MAX_BINS; q++)
        m.push(new l);
    for (var r = [], q = 0; q < MAX_BINS - 1; q++)
        r.push(new n);
    var t = new Float32Array(6)
      , w = new Float32Array(6)
      , C = new Float32Array(3);
    return {
        bvh_subdivide: function(l, n, q, v, D, z, H, I) {
            d(C, 0, z, 0);
            var J = l.nodes
              , L = H ? l.frags_per_leaf_node_transparent : l.frags_per_leaf_node
              , F = H ? l.frags_per_inner_node_transparent : l.frags_per_inner_node
              , N = l.max_polys_per_node
              , K = 0;
            C[1] > C[0] && (K = 1);
            C[2] > C[K] && (K = 2);
            J.setBox0(n, 
            D);
            var M = 0;
            D = 0;
            if (l.polygonCounts)
                for (var S = q; S <= v && !(M += l.polygonCounts[l.primitives[S]],
                D++,
                M > N); S++)
                    ;
            S = v - q + 1;
            if (S <= L && M < N || 1 === S || I > MAX_DEPTH || C[K] < l.scene_epsilon)
                J.setLeftChild(n, -1),
                J.setPrimStart(n, q),
                J.setPrimCount(n, v - q + 1),
                J.setFlags(n, 0, 0, H ? 1 : 0);
            else {
                if (F) {
                    F = q;
                    K = l.primitives;
                    L = l.centroids;
                    N = v - F + 1;
                    N > l.frags_per_inner_node && (N = l.frags_per_inner_node);
                    N > D && (N = D);
                    J.setPrimStart(n, F);
                    J.setPrimCount(n, N);
                    F += N;
                    a(z);
                    for (D = F; D <= v; D++)
                        f(z, L, 3 * K[D]);
                    d(C, 0, z, 0);
                    K = 0;
                    C[1] > C[0] && (K = 1);
                    C[2] > C[K] && (K = 2);
                    q += J.getPrimCount(n)
                }
                D = new k;
                var ba = q
                  , F = K;
                if (C[F] < l.scene_epsilon)
                    D.best_cost = Infinity;
                else {
                    L = MAX_BINS;
                    L > v - ba + 1 && (L = v - ba + 1);
                    for (N = 0; N < L; N++)
                        m[N].reset();
                    for (N = 0; N < L - 1; N++)
                        r[N].reset();
                    var N = D.num_bins = L
                      , M = l.centroids
                      , S = l.primitives
                      , P = l.boxes
                      , aa = N * (1 - BOX_SCALE_EPSILON) / C[F];
                    z = z[F];
                    for (var Z = l.sort_prims; ba <= v; ba++) {
                        var V = S[ba] | 0
                          , ea = aa * (M[3 * V + F] - z) | 0;
                        0 > ea ? ea = 0 : ea >= N && (ea = N - 1);
                        Z[ba] = ea;
                        m[ea].num_prims++;
                        h(m[ea].box_bbox, P, 6 * V);
                        f(m[ea].box_centroid, M, 3 * V)
                    }
                    c(r[0].BL, m[0].box_bbox);
                    c(r[0].CL, m[0].box_centroid);
                    r[0].AL = b(r[0].BL);
                    r[0].NL = m[0].num_prims;
                    for (N = 1; N < L - 1; N++)
                        z = m[N],
                        F = r[N],
                        c(F.BL, r[N - 1].BL),
                        g(F.BL, z.box_bbox),
                        F.AL = b(F.BL),
                        c(F.CL, r[N - 1].CL),
                        g(F.CL, z.box_centroid),
                        F.NL = r[N - 1].NL + z.num_prims;
                    N = L - 1;
                    c(t, m[N].box_bbox);
                    c(w, m[N].box_centroid);
                    S = b(t);
                    L = m[N].num_prims;
                    F = N;
                    M = S * L + r[N - 1].AL * r[N - 1].NL;
                    c(D.vb_right, t);
                    c(D.cb_right, m[N].box_centroid);
                    c(D.vb_left, r[N - 1].BL);
                    c(D.cb_left, r[N - 1].CL);
                    D.num_left = r[N - 1].NL;
                    for (--N; 1 <= N; N--)
                        z = m[N],
                        g(t, z.box_bbox),
                        g(w, z.box_centroid),
                        S = b(t),
                        L += z.num_prims,
                        z = S * L + r[N - 
                        1].AL * r[N - 1].NL,
                        z <= M && (M = z,
                        F = N,
                        c(D.vb_right, t),
                        c(D.cb_right, w),
                        c(D.vb_left, r[N - 1].BL),
                        c(D.cb_left, r[N - 1].CL),
                        D.num_left = r[N - 1].NL);
                    D.best_split = F;
                    D.best_cost = M
                }
                if (0 > D.num_bins)
                    J.setPrimCount(n, J.getPrimCount(n) + v - q + 1);
                else {
                    z = l.primitives;
                    L = l.sort_prims;
                    F = 0;
                    N = q | 0;
                    S = D.best_split | 0;
                    for (M = q; M <= v; M++)
                        P = z[M] | 0,
                        L[M] < S ? z[N++] = P : L[F++] = P;
                    for (M = 0; M < F; M++)
                        z[N + M] = L[M];
                    z = J.nextNodes(2);
                    J.setFlags(n, K, .5 * (D.vb_left[3 + K] + D.vb_left[K]) < .5 * (D.vb_right[3 + K] + D.vb_right[K]) ? 0 : 1, H ? 1 : 0);
                    J.setLeftChild(n, z);
                    l.recursion_stack.push([l, 
                    z + 1, q + D.num_left, v, D.vb_right, D.cb_right, H, I + 1]);
                    l.recursion_stack.push([l, z, q, q + D.num_left - 1, D.vb_left, D.cb_left, H, I + 1])
                }
            }
        },
        compute_boxes: function(b) {
            var c = b.boxv_o
              , g = b.boxc_o
              , k = b.boxv_t
              , l = b.boxc_t;
            a(c);
            a(g);
            a(k);
            a(l);
            for (var m = b.centroids, n = b.boxes, q = 0, r = b.prim_count; q < r; q++) {
                var t = m
                  , w = 3 * q
                  , N = n
                  , K = 6 * q;
                t[w] = .5 * (N[K] + N[K + 3]);
                t[w + 1] = .5 * (N[K + 1] + N[K + 4]);
                t[w + 2] = .5 * (N[K + 2] + N[K + 5]);
                q >= b.first_transparent ? (f(l, m, 3 * q),
                h(k, n, 6 * q)) : (f(g, m, 3 * q),
                h(c, n, 6 * q))
            }
            d(C, 0, b.boxv_o, 0);
            c = Math.max(C[0], C[1], C[2]);
            b.scene_epsilon = 
            BOX_EPSILON * c
        },
        box_area: function(a, b) {
            var c = a[b + 3] - a[b]
              , d = a[b + 4] - a[b + 1]
              , f = a[b + 5] - a[b + 2];
            return 0 > c || 0 > d || 0 > f ? 0 : 2 * (c * d + d * f + f * c)
        }
    }
}
();
function BVHBuilder(f, h) {
    this.boxes = f.boxes;
    this.polygonCounts = f.polygonCounts;
    this.materials = f.materials;
    this.materialDefs = h;
    this.prim_count = f.length;
    this.frags_per_inner_node = this.frags_per_leaf_node = -1;
    this.nodes = null ;
    this.work_buf = new ArrayBuffer(4 * this.prim_count);
    this.sort_prims = new Int32Array(this.work_buf);
    this.primitives = new Int32Array(this.prim_count);
    this.centroids = new Float32Array(POINT_STRIDE * this.prim_count);
    this.boxv_o = new Float32Array(6);
    this.boxc_o = new Float32Array(6);
    this.boxv_t = 
    new Float32Array(6);
    this.boxc_t = new Float32Array(6);
    this.recursion_stack = []
}
BVHBuilder.prototype.sortPrimitives = function() {
    for (var f = new Float32Array(this.work_buf), h = this.materialDefs, g = this.materials, d = this.primitives, c = 0, a = 0, b = this.prim_count; a < b; a++) {
        d[a] = a;
        var k = h && h[g[a]] ? h[g[a]].transparent : !1;
        k && c++;
        l ? (f[a] = BVHModule.box_area(this.boxes, BOX_STRIDE * a),
        k && (f[a] = -f[a])) : f[a] = k ? -1 : 1
    }
    var l = !1;
    if (c && c < this.prim_count) {
        h = new Int32Array(c);
        a = k = g = 0;
        for (b = this.prim_count; a < b; a++)
            0 <= f[a] ? d[g++] = d[a] : h[k++] = d[a];
        d.set(h, this.prim_count - c)
    }
    this.first_transparent = this.prim_count - 
    c
}
;
BVHBuilder.prototype.build = function(f) {
    var h = f && !!f.useSlimNodes;
    if (h)
        this.frags_per_leaf_node = 1,
        this.frags_per_inner_node = 0,
        this.frags_per_leaf_node_transparent = 1,
        this.frags_per_inner_node_transparent = 0,
        this.max_polys_per_node = Infinity;
    else {
        var g = f.isWeakDevice ? .5 : 1;
        this.frags_per_leaf_node = 0 | 32 * g;
        this.frags_per_inner_node = 0 | this.frags_per_leaf_node;
        this.frags_per_leaf_node_transparent = this.frags_per_leaf_node;
        this.frags_per_inner_node_transparent = 0;
        this.max_polys_per_node = 0 | 1E4 * g
    }
    if (this.nodes && this.nodes.is_lean_node == 
    h)
        this.nodes.nodeCount = 0;
    else {
        h = this.prim_count / this.frags_per_leaf_node;
        for (g = 1; g < h; )
            g *= 2;
        this.nodes = new NodeArray(g,f ? f.useSlimNodes : !1)
    }
    this.sortPrimitives();
    BVHModule.compute_boxes(this);
    f = this.nodes.nextNodes(2);
    for (BVHModule.bvh_subdivide(this, f, 0, this.first_transparent - 1, this.boxv_o, this.boxc_o, !1, 0); this.recursion_stack.length; )
        h = this.recursion_stack.pop(),
        BVHModule.bvh_subdivide(h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7]);
    for (BVHModule.bvh_subdivide(this, f + 1, this.first_transparent, this.prim_count - 
    1, this.boxv_t, this.boxc_t, !0, 0); this.recursion_stack.length; )
        h = this.recursion_stack.pop(),
        BVHModule.bvh_subdivide(h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7])
}
;
(function() {
    var f = Teratek.Viewing.Private;
    f.VertexBufferReader = function(f) {
        this.vb = f.vb.buffer;
        this.vbf = new Float32Array(this.vb);
        this.vbi = new Int32Array(this.vb);
        this.stride = f.vbstride;
        this.vcount = this.vbf.length / this.stride;
        this.useInstancing = !1
    }
    ;
    f.VertexBufferReader.prototype.getIdAt = function(f) {
        return this.vbi[f * this.stride + 7]
    }
    ;
    f.VertexBufferReader.prototype.getVertexFlagAt = function(f) {
        return this.vbi[f * this.stride + 9]
    }
    ;
    f.VertexBufferReader.prototype.getViewportIndexAt = function(f) {
        return this.vbi[f * 
        this.stride + 8] >> 16
    }
    ;
    f.VertexBufferReader.prototype.decodeLineAt = function(f, g, d, c) {
        var a = this.stride * f;
        f = this.vbf[a];
        g = this.vbf[a + 1];
        var b = this.vbf[a + 2]
          , k = this.vbf[a + 3]
          , a = f + k * Math.cos(b)
          , b = g + k * Math.sin(b);
        if (c.onLineSegment)
            c.onLineSegment(f, g, a, b, d)
    }
    ;
    f.VertexBufferReader.prototype.decodeCircularArcAt = function(f, g, d, c) {
        var a = this.stride * f;
        f = this.vbf[a];
        g = this.vbf[a + 1];
        var b = this.vbf[a + 2]
          , k = this.vbf[a + 3]
          , a = this.vbf[a + 5];
        if (c.onCircularArc)
            c.onCircularArc(f, g, b, k, a, d)
    }
    ;
    f.VertexBufferReader.prototype.decodeEllipticalArcAt = 
    function(f, g, d, c) {
        var a = this.stride * f;
        f = this.vbf[a];
        g = this.vbf[a + 1];
        var b = this.vbf[a + 2]
          , k = this.vbf[a + 3]
          , l = this.vbf[a + 5]
          , n = this.vbf[a + 10]
          , a = this.vbf[a + 11];
        if (c.onEllipticalArc)
            c.onEllipticalArc(f, g, b, k, l, n, a, d)
    }
    ;
    f.VertexBufferReader.prototype.enumGeomsForObject = function(f, g) {
        for (var d = 0; d < this.vcount; ) {
            var c = this.getVertexFlagAt(d)
              , a = c & 240
              , b = c & 15
              , c = c >> 16 & 255
              , k = this.getViewportIndexAt(d);
            if (this.getIdAt(d) === f)
                switch (a) {
                case 16:
                    this.decodeLineAt(d, c, k, g);
                    break;
                case 32:
                    this.decodeCircularArcAt(d, c, k, 
                    g);
                    break;
                case 48:
                    this.decodeEllipticalArcAt(d, c, k, g)
                }
            d += b && a ? 4 : 1
        }
    }
}
)();
var OUTSIDE = 0
  , INTERSECTS = 1
  , CONTAINS = 2;
(function() {
    function f() {
        this.frustum = new THREE.Frustum;
        this.viewProj = new THREE.Matrix4;
        this.viewDir = [0, 0, 1];
        this.ar = 1;
        this.viewport = new THREE.Vector3(1,1,1);
        this.areaCullThreshold = this.areaConv = 1
    }
    f.prototype.reset = function(f) {
        this.viewProj.multiplyMatrices(f.projectionMatrix, f.matrixWorldInverse);
        this.frustum.setFromMatrix(this.viewProj);
        var g = f.matrixWorldInverse.elements;
        this.ar = f.aspect;
        this.viewDir[0] = -g[2];
        this.viewDir[1] = -g[6];
        this.viewDir[2] = -g[10];
        this.areaConv = f.clientWidth * f.clientHeight / 
        4
    }
    ;
    f.prototype.projectedArea = function() {
        var f, g;
        return function(d) {
            f || (f = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3],
            g = new THREE.Box2);
            var c = this.viewProj;
            f[0].set(d.min.x, d.min.y, d.min.z);
            f[1].set(d.min.x, d.min.y, d.max.z);
            f[2].set(d.min.x, d.max.y, d.min.z);
            f[3].set(d.min.x, d.max.y, d.max.z);
            f[4].set(d.max.x, d.min.y, d.min.z);
            f[5].set(d.max.x, d.min.y, d.max.z);
            f[6].set(d.max.x, d.max.y, d.min.z);
            f[7].set(d.max.x, 
            d.max.y, d.max.z);
            for (d = 0; 8 > d; d++) {
                var a = f[d]
                  , b = a.x
                  , k = a.y
                  , l = a.z
                  , n = c.elements
                  , m = n[3] * b + n[7] * k + n[11] * l + n[15];
                0 > m && (m = -m);
                m = 1 / m;
                a.x = (n[0] * b + n[4] * k + n[8] * l + n[12]) * m;
                a.y = (n[1] * b + n[5] * k + n[9] * l + n[13]) * m
            }
            g.makeEmpty();
            g.setFromPoints(f);
            -1 > g.min.x && (g.min.x = -1);
            1 < g.min.x && (g.min.x = 1);
            -1 > g.min.y && (g.min.y = -1);
            1 < g.min.y && (g.min.y = 1);
            1 < g.max.x && (g.max.x = 1);
            -1 > g.max.x && (g.max.x = -1);
            1 < g.max.y && (g.max.y = 1);
            -1 > g.max.y && (g.max.y = -1);
            return (g.max.x - g.min.x) * (g.max.y - g.min.y)
        }
    }
    ();
    f.prototype.estimateDepth = function(f) {
        var g = 
        this.viewProj.elements
          , d = f.min.x
          , c = f.min.y
          , a = f.min.z
          , b = 1 / (g[3] * d + g[7] * c + g[11] * a + g[15])
          , k = (g[2] * d + g[6] * c + g[10] * a + g[14]) * b
          , d = f.max.x
          , c = f.max.y
          , a = f.max.z
          , b = 1 / (g[3] * d + g[7] * c + g[11] * a + g[15]);
        return Math.min(k, (g[2] * d + g[6] * c + g[10] * a + g[14]) * b)
    }
    ;
    f.prototype.intersectsBox = function() {
        var f, g;
        return function(d) {
            f || (f = new THREE.Vector3,
            g = new THREE.Vector3);
            for (var c = this.frustum.planes, a = 0, b = 0; 6 > b; b++) {
                var k = c[b];
                f.x = 0 < k.normal.x ? d.min.x : d.max.x;
                g.x = 0 < k.normal.x ? d.max.x : d.min.x;
                f.y = 0 < k.normal.y ? d.min.y : d.max.y;
                g.y = 0 < k.normal.y ? d.max.y : d.min.y;
                f.z = 0 < k.normal.z ? d.min.z : d.max.z;
                g.z = 0 < k.normal.z ? d.max.z : d.min.z;
                var l = k.distanceToPoint(f)
                  , k = k.distanceToPoint(g);
                if (0 > l && 0 > k)
                    return OUTSIDE;
                0 < l && 0 < k && a++
            }
            return 6 == a ? CONTAINS : INTERSECTS
        }
    }
    ();
    Teratek.Viewing.Private.FrustumIntersector = f
}
)();
var VBIntersector = function() {
    function f() {
        a || (a = new THREE.Matrix4,
        b = new THREE.Ray,
        k = new THREE.Vector3,
        l = new THREE.Vector3,
        n = new THREE.Vector3)
    }
    function h(c, d, g) {
        f();
        var h = c.geometry
          , m = c.material
          , E = m ? m.side : THREE.FrontSide
          , G = h.attributes;
        a.getInverse(c.matrixWorld);
        b.copy(d.ray).applyMatrix4(a);
        var B, v, D, z = d.precision;
        if (void 0 !== G.index) {
            var m = G.index.array || h.ib
              , G = h.vb ? h.vb : G.position.array
              , H = h.vb ? h.vbstride : 3
              , I = h.offsets;
            I && 0 !== I.length || (I = [{
                start: 0,
                count: m.length,
                index: 0
            }]);
            for (var J = 0, L = I.length; J < 
            L; ++J) {
                B = I[J].start;
                for (var F = I[J].index, h = B, N = B + I[J].count; h < N; h += 3) {
                    B = F + m[h];
                    v = F + m[h + 1];
                    D = F + m[h + 2];
                    k.fromArray(G, B * H);
                    l.fromArray(G, v * H);
                    n.fromArray(G, D * H);
                    var K;
                    K = E === THREE.BackSide ? b.intersectTriangle(n, l, k, !0) : b.intersectTriangle(k, l, n, E !== THREE.DoubleSide);
                    if (null  !== K) {
                        K.applyMatrix4(c.matrixWorld);
                        var M = d.ray.origin.distanceTo(K);
                        M < z || M < d.near || M > d.far || g.push({
                            distance: M,
                            point: K,
                            face: new THREE.Face3(B,v,D,THREE.Triangle.normal(k, l, n)),
                            faceIndex: null ,
                            fragId: c.fragId,
                            dbId: c.dbId
                        })
                    }
                }
            }
        } else
            for (G = 
            h.vb ? h.vb : G.position.array,
            H = h.vb ? h.vbstride : 3,
            h = 0,
            N = G.length; h < N; h += 3)
                B = h,
                v = h + 1,
                D = h + 2,
                k.fromArray(G, B * H),
                l.fromArray(G, v * H),
                n.fromArray(G, D * H),
                K = m.side === THREE.BackSide ? b.intersectTriangle(n, l, k, !0) : b.intersectTriangle(k, l, n, m.side !== THREE.DoubleSide),
                null  !== K && (K.applyMatrix4(c.matrixWorld),
                M = d.ray.origin.distanceTo(K),
                M < z || M < d.near || M > d.far || g.push({
                    distance: M,
                    point: K,
                    face: new THREE.Face3(B,v,D,THREE.Triangle.normal(k, l, n)),
                    faceIndex: null ,
                    fragId: c.fragId,
                    dbId: c.dbId
                }))
    }
    function g(c, d, g) {
        f();
        var h = 
        d.linePrecision
          , h = h * h
          , k = c.geometry;
        a.getInverse(c.matrixWorld);
        b.copy(d.ray).applyMatrix4(a);
        var l = new THREE.Vector3
          , m = new THREE.Vector3
          , n = new THREE.Vector3
          , v = new THREE.Vector3
          , D = c.mode === THREE.LineStrip ? 1 : 2;
        if (k instanceof THREE.BufferGeometry) {
            var z = k.attributes;
            if (void 0 !== z.index) {
                var H = k.ib ? k.ib : z.index.array
                  , z = k.vb ? k.vb : z.position.array
                  , I = k.vb ? k.vbstride : 3;
                (k = k.offsets) && 0 !== k.length || (k = [{
                    start: 0,
                    count: H.length,
                    index: 0
                }]);
                for (var J = 0; J < k.length; J++)
                    for (var L = k[J].start, F = k[J].count, N = k[J].index, 
                    K = L; K < L + F - 1; K += D) {
                        var M = N + H[K + 1];
                        l.fromArray(z, (N + H[K]) * I);
                        m.fromArray(z, M * I);
                        M = b.distanceSqToSegment(l, m, v, n);
                        M > h || (M = b.origin.distanceTo(v),
                        M < d.near || M > d.far || g.push({
                            distance: M,
                            point: n.clone().applyMatrix4(c.matrixWorld),
                            face: null ,
                            faceIndex: null ,
                            fragId: c.fragId,
                            dbId: c.dbId
                        }))
                    }
            } else
                for (z = k.vb ? k.vb : z.position.array,
                I = k.vb ? k.vbstride : 3,
                K = 0; K < z.length / I - 1; K += D)
                    l.fromArray(z, I * K),
                    m.fromArray(z, I * K + I),
                    M = b.distanceSqToSegment(l, m, v, n),
                    M > h || (M = b.origin.distanceTo(v),
                    M < d.near || M > d.far || g.push({
                        distance: M,
                        point: n.clone().applyMatrix4(c.matrixWorld),
                        face: null ,
                        faceIndex: null ,
                        fragId: c.fragId,
                        dbId: c.dbId
                    }))
        }
    }
    function d(a, b, c) {
        a.isLine ? g(a, b, c) : h(a, b, c)
    }
    function c(a, b, f, g) {
        a instanceof THREE.Mesh ? d(a, b, f) : a.raycast(b, f);
        if (!0 === g) {
            a = a.children;
            g = 0;
            for (var h = a.length; g < h; g++)
                c(a[g], b, f, !0)
        }
    }
    var a, b, k, l, n, m = function(a, b) {
        return a.distance - b.distance
    }
    ;
    return {
        meshRayCast: h,
        lineRayCast: g,
        rayCast: d,
        intersectObject: function(a, b, d, f) {
            c(a, b, d, f);
            d.sort(m)
        }
    }
}
()
  , BufferGeometryUtils = function() {
    function f() {
        c = new THREE.BufferAttribute(void 0,
        1);
        a = function() {
            THREE.BufferGeometry.call(this);
            this.name = this.uuid = null ;
            this.numInstances = void 0;
            this.streamingIndex = this.streamingDraw = !1;
            this.svfid = void 0;
            this.vb = null ;
            this.vbbuffer = void 0;
            this.ib = null ;
            this.vaos = this.ibbuffer = void 0;
            this.vbNeedsUpdate = !1;
            this.byteSize = this.vbstride = 0;
            this.attributesKeys = void 0;
            this.__webglInit = !1
        }
        ;
        a.prototype = Object.create(THREE.BufferGeometry.prototype);
        a.prototype.constructor = a
    }
    var h = Teratek.Viewing.Private, g = {}, d = {}, c, a;
    return {
        meshToGeometry: function(b) {
            var k = 
            b.mesh, l;
            a || f();
            l = new a;
            l.byteSize = 0;
            l.vb = k.vb;
            l.vbbuffer = void 0;
            l.vbNeedsUpdate = !0;
            l.byteSize += k.vb.byteLength;
            l.vbstride = k.vbstride;
            k.isLines && (l.isLines = k.isLines);
            b.is2d && (l.is2d = !0);
            l.numInstances = k.numInstances;
            for (var n in k.vblayout) {
                var m = l.attributes, q = n, r;
                a: {
                    var t = n;
                    r = k.vblayout[n];
                    var w = l.numInstances
                      , C = void 0;
                    if (r.array)
                        C = new THREE.BufferAttribute(r.array,r.itemSize);
                    else {
                        t = t + "|" + r.bytesPerItem + "|" + r.normalize + "|" + r.isPattern + "|" + r.divisor + "|" + r.offset;
                        if (C = g[t]) {
                            r = C;
                            break a
                        }
                        C = new THREE.BufferAttribute(void 0,
                        r.itemSize);
                        g[t] = C
                    }
                    C.bytesPerItem = r.bytesPerItem;
                    C.normalize = r.normalize;
                    C.isPattern = r.isPattern;
                    w && (C.divisor = r.divisor);
                    r.array ? geometry.byteSize += r.array.byteLength : r.hasOwnProperty("offset") ? C.itemOffset = r.offset : stderr("VB attribute is neither interleaved nor separate. Something is wrong with the buffer specificaiton.");
                    r = C
                }
                m[q] = r
            }
            h.memoryOptimizedLoading ? (l.attributes.index = c,
            l.ib = k.indices,
            l.ibbuffer = void 0) : l.addAttribute("index", new THREE.BufferAttribute(k.indices,1));
            n = "";
            for (var E in l.attributes)
                n += 
                E + "|";
            E = d[n];
            E || (E = Object.keys(l.attributes),
            d[n] = E);
            l.attributesKeys = E;
            l.byteSize += k.indices.byteLength;
            65535 < k.vb.length / k.vbstride && stderr("Mesh with >65535 vertices. It will fail to draw.");
            l.boundingBox = (new THREE.Box3).copy(k.boundingBox);
            l.boundingSphere = (new THREE.Sphere).copy(k.boundingSphere);
            l.drawcalls = null ;
            l.offsets = null ;
            b.geometry = l;
            b.mesh = null 
        }
    }
}
();
(function() {
    function f(f) {
        this.geoms = [null ];
        this.instancePolyCount = this.geomPolyCount = this.gpuNumMeshes = this.gpuMeshMemory = this.geomMemory = this.numGeomsInMemory = 0;
        this.is2d = f.is2d();
        this.svf = f.getData();
        f = this.svf.geomMetadata ? this.svf.geomMetadata.primCounts.length : 0;
        this.geomBoxes = new Float32Array(6 * Math.max(1, f));
        this.svf.packFileTotalSize && this.svf.packFileTotalSize - 6 * this.svf.primitiveCount <= h.GPU_MEMORY_LIMIT && f < h.GPU_OBJECT_LIMIT && (this.svf.disableStreaming = !0)
    }
    var h = Teratek.Viewing.Private;
    f.prototype.getGeometry = function(f) {
        return this.geoms[f]
    }
    ;
    f.prototype.addGeometry = function(f, d, c) {
        var a = h.GPU_MEMORY_LIMIT
          , b = 2 * a
          , k = h.GPU_OBJECT_LIMIT;
        this.isf2d && (b *= 2);
        this.disableStreaming || this.gpuMeshMemory < a && this.geoms.length < k ? (f.streamingDraw = !1,
        f.streamingIndex = !1) : this.gpuMeshMemory >= b ? (f.streamingDraw = !0,
        f.streamingIndex = !0) : 1E5 > (this.is2d ? 100001 : f.byteSize * (d || 1)) && (f.streamingDraw = !0,
        f.streamingIndex = !0);
        f.streamingDraw || (this.gpuMeshMemory += f.byteSize,
        this.gpuNumMeshes += 1);
        this.numGeomsInMemory++;
        if (void 0 === c || 0 >= c)
            c = this.geoms.length;
        this.geoms[c] = f;
        this.geomBoxes.length / 6 < this.geoms.length && (a = new Float32Array(3 * this.geoms.length / 2 * 6),
        a.set(this.geomBoxes),
        this.geomBoxes = a);
        a = f.boundingBox;
        this.geomBoxes[6 * c] = a.min.x;
        this.geomBoxes[6 * c + 1] = a.min.y;
        this.geomBoxes[6 * c + 2] = a.min.z;
        this.geomBoxes[6 * c + 3] = a.max.x;
        this.geomBoxes[6 * c + 4] = a.max.y;
        this.geomBoxes[6 * c + 5] = a.max.z;
        h.memoryOptimizedLoading && !this.is2d && (f.boundingBox = null ,
        f.boundingSphere = null );
        this.geomMemory += f.byteSize;
        a = (f.attributes.index.array || 
        f.ib).length / 3;
        this.svf.geomPolyCount = this.geomPolyCount += a;
        this.instancePolyCount += a * (d || 1);
        return f.svfid = c
    }
    ;
    f.prototype.removeGeometry = function(f) {
        var d = this.getGeometry(f);
        if (!d)
            return 0;
        d = d.byteSize;
        this.geoms[f] = null ;
        this.numGeomsInMemory--;
        return d
    }
    ;
    f.prototype.getModelBox = function(f, d) {
        if (this.geoms[f]) {
            var c = 6 * f
              , a = this.geomBoxes;
            d.min.x = a[c];
            d.min.y = a[c + 1];
            d.min.z = a[c + 2];
            d.max.x = a[c + 3];
            d.max.y = a[c + 4];
            d.max.z = a[c + 5]
        } else
            d.makeEmpty()
    }
    ;
    f.prototype.dispose = function(f) {
        for (var d = 0, c = this.geoms.length; d < 
        c; d++)
            this.geoms[d] && f.deallocateGeometry(this.geoms[d])
    }
    ;
    f.prototype.printStats = function() {
        stderr("Total geometry size: " + this.geomMemory / 1048576 + " MB");
        stderr("Number of meshes: " + this.geoms.length);
        stderr("Num Meshes on GPU: " + this.gpuNumMeshes);
        stderr("Net GPU geom memory used: " + this.gpuMeshMemory)
    }
    ;
    Teratek.Viewing.Private.GeometryList = f
}
)();
(function() {
    function f(f, d, c, a) {
        this.root = f;
        this.rootId = f.dbId;
        this.maxDepth = a;
        this.boxes = d;
        this.objectCount = c;
        this.nodeflags = new Int32Array(c);
        this.numOff = this.numHidden = 0;
        this.createDbIdToNodeMapping()
    }
    var h = Teratek.Viewing;
    h.SelectionMode = {
        LEAF_OBJECT: 0,
        FIRST_OBJECT: 1,
        LAST_OBJECT: 2
    };
    f.prototype.createDbIdToNodeMapping = function() {
        if (this.root) {
            var f = this.dbIdToNode = Array(this.objectCount)
              , d = this.nodeflags;
            (function a(b) {
                f[b.dbId] = b;
                var h = b.children
                  , l = b.flags;
                void 0 !== l ? d[b.dbId] = l : b.flags = d[b.dbId] = 
                h ? 0 : 6;
                if (h)
                    for (b = 0; b < h.length; b++)
                        a(h[b])
            }
            )(this.root)
        }
    }
    ;
    f.prototype.setFlagNode = function(f, d, c) {
        var a = this.nodeflags[f];
        if (!!(a & d) == c)
            return !1;
        this.nodeflags[f] = c ? a | d : a & ~d;
        return !0
    }
    ;
    f.prototype.setFlagGlobal = function(f, d) {
        var c = this.nodeflags
          , a = 0
          , b = c.length;
        if (d)
            for (; a < b; a++)
                c[a] |= f;
        else
            for (var h = ~f; a < b; a++)
                c[a] &= h
    }
    ;
    f.prototype.setNodeOff = function(f, d) {
        var c = this.setFlagNode(f, 1073741824, d);
        c && (d ? this.numOff++ : this.numOff--);
        return c
    }
    ;
    f.prototype.isNodeOff = function(f) {
        return !!(this.nodeflags[f] & 
        1073741824)
    }
    ;
    f.prototype.setNodeHidden = function(f, d) {
        var c = this.setFlagNode(f, 2147483648, d);
        c && (d ? this.numHidden++ : this.numHidden--);
        return c
    }
    ;
    f.prototype.isNodeHidden = function(f) {
        return !!(this.nodeflags[f] & 2147483648)
    }
    ;
    f.prototype.getNodeType = function(f) {
        return this.nodeflags[f] & 7
    }
    ;
    f.prototype.getNodeParentId = function(f) {
        return this.dbIdToNode[f].parent
    }
    ;
    f.prototype.getRootId = function() {
        return this.rootId
    }
    ;
    f.prototype.getNodeName = function(f) {
        return this.dbIdToNode[f].name
    }
    ;
    f.prototype.getChildCount = 
    function(f) {
        return (f = this.dbIdToNode[f]) && f.children ? f.children.length : 0
    }
    ;
    f.prototype.enumNodeFragments = function(f, d, c) {
        function a(f) {
            var g = b.dbIdToNode[f];
            if (void 0 !== g) {
                g = g.fragIds;
                if (void 0 !== g) {
                    Array.isArray(g) || d(g);
                    for (var h = 0; h < g.length; ++h)
                        d(g[h])
                }
                c && b.enumNodeChildren(f, function(b) {
                    a(b)
                }
                )
            }
        }
        var b = this;
        a("number" == typeof f ? f : f.dbId)
    }
    ;
    f.prototype.enumNodeChildren = function(f, d, c) {
        function a(f) {
            f = b.dbIdToNode[f];
            if (void 0 !== f && f.children)
                for (var g = 0; g < f.children.length; g++) {
                    var h = f.children[g].dbId;
                    d(h);
                    c && a(h)
                }
        }
        f = "number" == typeof f ? f : f.dbId;
        var b = this;
        c && d(f);
        a(f)
    }
    ;
    f.prototype.findNodeForSelection = function(f, d) {
        if (d === h.SelectionMode.LEAF_OBJECT)
            return f;
        var c = f;
        if (d === h.SelectionMode.FIRST_OBJECT) {
            for (var a = [], b = f; b; )
                a.push(b),
                b = this.getNodeParentId(b);
            for (b = a.length - 1; 0 <= b; b--) {
                var k = this.getNodeType(a[b]);
                if (5 !== k && 2 !== k && 3 !== k) {
                    c = a[b];
                    break
                }
            }
        } else if (d === h.SelectionMode.LAST_OBJECT)
            for (b = f; b; ) {
                k = this.getNodeType(b);
                if (4 === k) {
                    c = b;
                    break
                }
                b = this.getNodeParentId(b)
            }
        return c
    }
    ;
    Teratek.Viewing.Private.InstanceTree = 
    f
}
)();
var MESH_VISIBLE = 1
  , MESH_HIGHLIGHTED = 2
  , MESH_HIDE = 4
  , MESH_ISLINE = 8
  , MESH_MOVED = 16
  , MESH_TRAVERSED = 32
  , MESH_RENDERFLAG = 128;
(function() {
    function f(d, c, a) {
        this.fragments = d;
        this.svfLoader = a;
        d = this.fragments.length;
        this.geoms = c;
        (this.isFixedSize = 0 < this.fragments.length) ? (this.boxes = this.fragments.boxes,
        this.transforms = this.fragments.transforms,
        this.useThreeMesh = !g.memoryOptimizedLoading) : (this.transforms = this.boxes = null ,
        this.useThreeMesh = !0);
        0 >= d && (d = 1);
        this.vizmeshes = Array(d);
        this.vizflags = new Uint8Array(d);
        this.geomids = new Int32Array(d);
        this.materialids = new Int32Array(d);
        this.materialmap = {};
        this.reachLimit = !1;
        this.traversedGeom = 
        [];
        this.culledGeom = [];
        this.geomidsmap = {};
        this.animxforms = null ;
        for (c = 0; c < d; c++)
            this.vizflags[c] = 1,
            this.geomids[c] = -1;
        this.allVisible = !0;
        this.allVisibleDirty = !1;
        this.nextAvailableFragID = d
    }
    function h(d, c) {
        this.frags = d;
        this.fragId = c;
        this.position = this.quaternion = this.scale = null 
    }
    var g = Teratek.Viewing.Private;
    f.prototype.getNextAvailableFragmentId = function() {
        return this.nextAvailableFragID++
    }
    ;
    f.prototype.fragmentsHaveBeenAdded = function() {
        return this.vizflags.length > this.fragments.length
    }
    ;
    f.prototype.getSvfMaterialId = 
    function(d) {
        return (d = this.getMaterial(d)) ? d.svfMatId : void 0
    }
    ;
    f.prototype.requireGeometry = function(d) {
        var c = null 
          , a = this.geomids[d];
        0 <= a && (c = this.geoms.getGeometry(a));
        null  != c || this.reachLimit || this.svfLoader.loadGeometryPackOnDemand(this.fragments.packIds[d]);
        return c
    }
    ;
    f.prototype.setMesh = function(d, c, a) {
        var b = this.vizmeshes[d];
        b && b.parent && b.parent.remove(b);
        if (this.vizflags.length <= d) {
            this.isFixedSize && (console.warn("Attempting to resize a fragments list that was initialized with fixed data. This will have a performance impact."),
            this.isFixedSize = !1);
            b = Math.ceil(1.5 * this.vizflags.length);
            this.useThreeMesh && b < this.vizmeshes.length && (b = this.vizmeshes.length);
            var f = new Uint8Array(b);
            f.set(this.vizflags);
            this.vizflags = f;
            this.transforms && (f = new Float32Array(12 * b),
            f.set(this.transforms),
            this.transforms = f);
            this.boxes && (f = new Float32Array(6 * b),
            f.set(this.boxes),
            this.boxes = f);
            this.geomids && (f = new Int32Array(b),
            f.set(this.geomids),
            this.geomids = f);
            this.materialids && (b = new Int32Array(b),
            b.set(this.materialids),
            this.materialids = b)
        }
        this.useThreeMesh ? 
        (this.vizmeshes[d] = c,
        c.fragId = d,
        c.dbId = this.fragments.fragId2dbId[d] | 0) : (this.geomids[d] = c.geometry.svfid,
        this.materialids[d] = c.material.id,
        this.materialmap[c.material.id] || (this.materialmap[c.material.id] = c.material));
        this.vizflags[d] = 1 | (c.isLine ? MESH_ISLINE : 0);
        a && (b = c.matrixWorld,
        a = new THREE.Box3,
        a.copy(c.geometry.boundingBox),
        a.applyMatrix4(b),
        c = 12 * d,
        b = b.elements,
        f = this.transforms,
        f[c] = b[0],
        f[c + 1] = b[1],
        f[c + 2] = b[2],
        f[c + 3] = b[4],
        f[c + 4] = b[5],
        f[c + 5] = b[6],
        f[c + 6] = b[8],
        f[c + 7] = b[9],
        f[c + 8] = b[10],
        f[c + 9] = 
        b[12],
        f[c + 10] = b[13],
        f[c + 11] = b[14],
        d *= 6,
        c = this.boxes,
        c[d] = a.min.x,
        c[d + 1] = a.min.y,
        c[d + 2] = a.min.z,
        c[d + 3] = a.max.x,
        c[d + 4] = a.max.y,
        c[d + 5] = a.max.z)
    }
    ;
    f.prototype.isFlagSet = function(d, c) {
        return !!(this.vizflags[d] & c)
    }
    ;
    f.prototype.setFlagFragment = function(d, c, a) {
        var b = this.vizflags[d];
        if (!!(b & c) == a)
            return !1;
        this.vizflags[d] = a ? b | c : b & ~c;
        return !0
    }
    ;
    f.prototype.setFlagGlobal = function(d, c) {
        var a = this.vizflags
          , b = 0
          , f = a.length;
        if (c)
            for (; b < f; b++)
                a[b] |= d;
        else
            for (var g = ~d; b < f; b++)
                a[b] &= g
    }
    ;
    f.prototype.hideLines = function(d) {
        var c = 
        MESH_HIDE
          , a = this.vizflags
          , b = 0
          , f = a.length;
        if (d)
            for (; b < f; b++)
                a[b] & MESH_ISLINE && (a[b] |= c);
        else
            for (d = ~c; b < f; b++)
                a[b] & MESH_ISLINE && (a[b] &= d);
        this.allVisibleDirty = !0
    }
    ;
    f.prototype.isFragVisible = function(d) {
        return 1 == (this.vizflags[d] & 3)
    }
    ;
    f.prototype.isFragOff = function(d) {
        return !!(this.vizflags[d] & MESH_HIDE)
    }
    ;
    f.prototype.isLine = function(d) {
        return !!(this.vizflags[d] & MESH_ISLINE)
    }
    ;
    f.prototype.areAllVisible = function() {
        if (this.allVisibleDirty) {
            for (var d = this.vizflags, c = !0, a = 0, b = d.length; a < b; a++)
                if (0 === (d[a] & 
                1)) {
                    c = !1;
                    break
                }
            this.allVisible = c;
            this.allVisibleDirty = !1
        }
        return this.allVisible
    }
    ;
    f.prototype.getVizmesh = function() {
        var d;
        return function(c) {
            if (this.useThreeMesh)
                return this.vizmeshes[c];
            d || (d = new THREE.Mesh(void 0,void 0,!0),
            d.isTemp = !0,
            d.dbId = 0,
            d.fragId = -1);
            d.geometry = this.getGeometry(c);
            d.material = this.getMaterial(c);
            d.dbId = this.getDbIds(c);
            d.fragId = c;
            d.visible = !0;
            d.isLine = this.isLine(c);
            this.getWorldMatrix(c, d.matrixWorld);
            return d
        }
    }
    ();
    f.prototype.getMaterialId = function(d) {
        return this.useThreeMesh ? 
        this.vizmeshes[d].material.id : this.materialids[d]
    }
    ;
    f.prototype.getMaterial = function(d) {
        return this.useThreeMesh ? this.vizmeshes[d].material : this.materialmap[this.materialids[d]]
    }
    ;
    f.prototype.getGeometry = function(d) {
        return this.geoms.getGeometry(this.geomids[d])
    }
    ;
    f.prototype.getGeometryId = function(d) {
        return this.geomids[d]
    }
    ;
    f.prototype.setMaterial = function(d, c) {
        this.useThreeMesh ? this.vizmeshes[d].material = c : (this.materialids[d] = c.id,
        this.materialmap[c.id] = c)
    }
    ;
    f.prototype.getCount = function() {
        return this.vizflags.length
    }
    ;
    f.prototype.getDbIds = function(d) {
        return this.fragments.fragId2dbId[d]
    }
    ;
    f.prototype.dispose = function(d) {
        var c = {
            type: "dispose"
        };
        if (this.useThreeMesh) {
            d = {
                type: "removed"
            };
            for (var a = 0; a < this.vizmeshes.length; a++) {
                var b = this.vizmeshes[a];
                b && (b.dispatchEvent(d),
                b.geometry.dispatchEvent(c))
            }
        } else
            this.geoms.dispose(d)
    }
    ;
    f.prototype.setVisibility = function(d, c) {
        this.setFlagFragment(d, MESH_VISIBLE, c);
        this.allVisibleDirty = !0
    }
    ;
    f.prototype.setFragOff = function(d, c) {
        this.setFlagFragment(d, MESH_HIDE, c);
        this.allVisibleDirty = 
        !0
    }
    ;
    f.prototype.setAllVisibility = function(d) {
        this.setFlagGlobal(MESH_VISIBLE, d);
        this.allVisible = d;
        this.allVisibleDirty = !1
    }
    ;
    f.prototype.updateAnimTransform = function(d, c, a, b) {
        var f = this.animxforms;
        if (!f)
            for (var g = this.getCount(), f = this.animxforms = new Float32Array(10 * g), h = 0; h < g; h++) {
                var m = 10 * h;
                f[m] = 1;
                f[m + 1] = 1;
                f[m + 2] = 1;
                f[m + 3] = 0;
                f[m + 4] = 0;
                f[m + 5] = 0;
                f[m + 6] = 1;
                f[m + 7] = 0;
                f[m + 8] = 0;
                f[m + 9] = 0
            }
        m = 10 * d;
        g = !1;
        c && (f[m] = c.x,
        f[m + 1] = c.y,
        f[m + 2] = c.z,
        g = !0);
        a && (f[m + 3] = a.x,
        f[m + 4] = a.y,
        f[m + 5] = a.z,
        f[m + 6] = a.w,
        g = !0);
        b && (f[m + 7] = b.x,
        f[m + 8] = b.y,
        f[m + 9] = b.z,
        g = !0);
        this.setFlagFragment(d, MESH_MOVED, g);
        g || (f[m] = 1,
        f[m + 1] = 1,
        f[m + 2] = 1,
        f[m + 3] = 0,
        f[m + 4] = 0,
        f[m + 5] = 0,
        f[m + 6] = 1,
        f[m + 7] = 0,
        f[m + 8] = 0,
        f[m + 9] = 0)
    }
    ;
    f.prototype.getAnimTransform = function(d, c, a, b) {
        if (!this.animxforms || !this.isFlagSet(d, MESH_MOVED))
            return !1;
        d *= 10;
        var f = this.animxforms;
        c && (c.x = f[d],
        c.y = f[d + 1],
        c.z = f[d + 2]);
        a && (a.x = f[d + 3],
        a.y = f[d + 4],
        a.z = f[d + 5],
        a.w = f[d + 6]);
        b && (b.x = f[d + 7],
        b.y = f[d + 8],
        b.z = f[d + 9]);
        return !0
    }
    ;
    f.prototype.getOriginalWorldMatrix = function(d, c) {
        var a = 12 * d
          , b = c.elements
          , f = 
        this.transforms;
        f ? (b[0] = f[a],
        b[1] = f[a + 1],
        b[2] = f[a + 2],
        b[3] = 0,
        b[4] = f[a + 3],
        b[5] = f[a + 4],
        b[6] = f[a + 5],
        b[7] = 0,
        b[8] = f[a + 6],
        b[9] = f[a + 7],
        b[10] = f[a + 8],
        b[11] = 0,
        b[12] = f[a + 9],
        b[13] = f[a + 10],
        b[14] = f[a + 11],
        b[15] = 1) : c.identity()
    }
    ;
    f.prototype.getWorldMatrix = function() {
        var d, c, a, b;
        return function(f, g) {
            d || (d = new THREE.Matrix4,
            c = new THREE.Vector3,
            a = new THREE.Quaternion,
            b = new THREE.Vector3);
            this.getOriginalWorldMatrix(f, g);
            this.isFlagSet(f, MESH_MOVED) && (this.getAnimTransform(f, b, a, c),
            d.compose(c, a, b),
            g.multiplyMatrices(d, 
            g))
        }
    }
    ();
    f.prototype.getWorldBounds = function() {
        var d;
        return function(c, a) {
            d || (d = new THREE.Matrix4);
            if (this.boxes && !this.isFlagSet(c, MESH_MOVED)) {
                var b = this.boxes
                  , f = 6 * c;
                a.min.x = b[f];
                a.min.y = b[f + 1];
                a.min.z = b[f + 2];
                a.max.x = b[f + 3];
                a.max.y = b[f + 4];
                a.max.z = b[f + 5]
            } else
                this.getWorldMatrix(c, d),
                this.useThreeMesh ? (b = this.getVizmesh(c)) && b.geometry && a.copy(b.geometry.boundingBox) : this.geoms.getModelBox(this.geomids[c], a),
                a.empty() || a.applyMatrix4(d)
        }
    }
    ();
    Teratek.Viewing.Private.FragmentList = f;
    h.prototype.getWorldMatrix = 
    function(d) {
        return this.frags.getWorldMatrix(this.fragId, d)
    }
    ;
    h.prototype.getWorldBounds = function(d) {
        return this.frags.getWorldBounds(this.fragId, d)
    }
    ;
    h.prototype.getAnimTransform = function() {
        this.scale || (this.scale = new THREE.Vector3(1,1,1),
        this.quaternion = new THREE.Quaternion(0,0,0,1),
        this.position = new THREE.Vector3(0,0,0));
        return this.frags.getAnimTransform(this.fragId, this.scale, this.quaternion, this.position)
    }
    ;
    h.prototype.updateAnimTransform = function() {
        this.scale || (this.scale = new THREE.Vector3(1,
        1,1),
        this.quaternion = new THREE.Quaternion(0,0,0,1),
        this.position = new THREE.Vector3(0,0,0));
        return this.frags.updateAnimTransform(this.fragId, this.scale, this.quaternion, this.position)
    }
    ;
    h.prototype.getMaterial = function() {
        return this.frags.getMaterial(this.fragId)
    }
    ;
    h.prototype.setMaterial = function(d) {
        return this.frags.setMaterial(this.fragId, d)
    }
    ;
    Teratek.Viewing.Private.FragmentPointer = h
}
)();
(function() {
    function f(a, b, d, f) {
        this.frags = a;
        this.indices = b;
        this.start = d;
        this.count = f;
        this.lastItem = d;
        this.overrideMaterial = null ;
        this.sortDone = !1;
        this.avgFrameTime = void 0;
        this.numAdded = 0;
        this.boundingBox = new THREE.Box3;
        this.boundingBoxHidden = new THREE.Box3;
        this.sortDone = this.sortObjects = !1;
        this.indicesView = this.depths = null ;
        this.frustumCulled = !0;
        this.forceVisible = !1;
        this.renderImmediate = !a.useThreeMesh;
        c || (c = new THREE.Box3)
    }
    function h(a, b, c) {
        var d = b[c] & 127;
        switch (a) {
        case RENDER_HIDDEN:
            a = !(d & MESH_VISIBLE);
            break;
        case RENDER_HIGHLIGHTED:
            a = d & MESH_HIGHLIGHTED;
            break;
        default:
            a = 1 == (d & (MESH_VISIBLE | MESH_HIGHLIGHTED | MESH_HIDE))
        }
        b[c] = d | (a ? MESH_RENDERFLAG : 0);
        return a
    }
    function g(a, b, d, f) {
        var g = !1;
        d.getWorldBounds(f, c);
        a && !b.intersectsBox(c) && (g = !0);
        return g
    }
    var d = Teratek.Viewing.Private, c;
    f.prototype.getIndices = function() {
        return Array.isArray(this.indices) ? this.indices[0] : this.indices
    }
    ;
    f.prototype.sortByMaterial = function() {
        if (!(this.numAdded < this.count)) {
            var a = this.frags
              , b = this.getIndices();
            b || stderr("Only indexed RenderSubsets can be sorted.");
            var c = b.subarray(this.start, this.start + this.count);
            Array.prototype.sort.call(c, function(c, d) {
                var f = a.getMaterialId(b[c])
                  , g = a.getMaterialId(b[d]);
                return void 0 === f ? g ? 1 : 0 : void 0 === g ? -1 : f - g
            }
            );
            this.numAdded = 0;
            this.sortDone = !0
        }
    }
    ;
    f.prototype.sortByDepth = function() {
        function a(a, b) {
            d.getGeometry(a) ? (d.getWorldBounds(a, h),
            q[b] = g.estimateDepth(h)) : q[b] = -Infinity
        }
        function b(a, b) {
            return q[b] - q[a]
        }
        var d, f, g, h, q;
        return function(r) {
            d = this.frags;
            f = this.getIndices();
            g = r;
            h = c;
            f || stderr("Only indexed RenderSubsets can be sorted.");
            if (!this.indicesView || this.indicesView.length < this.count)
                this.indicesView = f.subarray(this.start, this.start + this.count);
            if (!this.depths || this.depths.length < this.count)
                this.depths = new Float32Array(this.count);
            q = this.depths;
            this.forEachNoMesh(a);
            Array.prototype.sort.call(this.indicesView, b)
        }
    }
    ();
    f.prototype.onFragmentAdded = function() {
        return function(a) {
            this.frags.getWorldBounds(a, c);
            this.boundingBox.union(c);
            this.sortDone = !1;
            this.lastItem <= a && (this.lastItem = a + 1,
            this.numAdded++)
        }
    }
    ();
    f.prototype.forEach = 
    d.pageOutGeometryEnabled ? function(a, b, c) {
        for (var f = this.getIndices(), g = this.frags, h = g.getCount() > d.FRAGS_PERSISTENT_MAX_COUNT, q = this.start, r = this.lastItem; q < r; q++) {
            var t = f ? f[q] : q;
            if (h) {
                if (g.isFlagSet(t, MESH_TRAVERSED) && b == MESH_RENDERFLAG)
                    continue;var w = g.getVizmesh(t);
                if (!c && b && g.isFlagSet(t, b))
                    if (w.geometry) {
                        if (b == MESH_RENDERFLAG && g.setFlagFragment(t, MESH_TRAVERSED, !0),
                        t > d.FRAGS_PERSISTENT_COUNT) {
                            var C = g.geomids[t]
                              , E = !0
                              , G = g.geomidsmap[C];
                            null  != G && (G.t++,
                            E = G.n == G.t);
                            E && g.traversedGeom.push(C)
                        }
                    } else
                        w.geometry = 
                        g.requireGeometry(t)
            } else
                w = g.getVizmesh(t);
            !(c || w && w.geometry) || b && !g.isFlagSet(t, b) || a(w, t)
        }
    }
     : function(a, b, c) {
        for (var d = this.getIndices(), f = this.frags, g = this.start, h = this.lastItem; g < h; g++) {
            var r = d ? d[g] : g
              , t = f.getVizmesh(r);
            !(c || t && t.geometry) || b && !f.isFlagSet(r, b) || a(t, r)
        }
    }
    ;
    f.prototype.forEachNoMesh = function(a, b, c) {
        for (var d = this.getIndices(), f = this.frags, g = this.start, h = this.lastItem; g < h; g++) {
            var r = d ? d[g] : g, t;
            if (f.useThreeMesh) {
                var w = f.getVizmesh(r);
                w && (t = w.geometry)
            } else
                t = f.getGeometry(r);
            !c && 
            !t || b && !f.isFlagSet(r, b) || a(r, g - this.start)
        }
    }
    ;
    f.prototype.raycast = function() {
        return function(a, b) {
            if (!1 !== a.ray.isIntersectionBox(this.boundingBox)) {
                var d = this
                  , f = c;
                this.forEach(function(c, g) {
                    d.frags.getWorldBounds(g, f);
                    a.ray.isIntersectionBox(f) && VBIntersector.rayCast(c, a, b)
                }
                , MESH_VISIBLE)
            }
        }
    }
    ();
    f.prototype.calculateBounds = function() {
        function a(a) {
            g.getWorldBounds(a, h);
            b[a] & 1 ? d.union(h) : f.union(h)
        }
        var b, d, f, g, h;
        return function() {
            this.boundingBox.makeEmpty();
            this.boundingBoxHidden.makeEmpty();
            b = this.frags.vizflags;
            d = this.boundingBox;
            f = this.boundingBoxHidden;
            g = this.frags;
            h = c;
            this.forEachNoMesh(a)
        }
    }
    ();
    f.prototype.applyVisibility = d.pageOutGeometryEnabled || d.onDemandLoading ? function() {
        function a(a, w) {
            if (!a && b.useThreeMesh)
                m && m(w);
            else if (g(q, f, b, w)) {
                if (a ? a.visible = !1 : stderr("Unexpected null mesh"),
                c[w] &= ~MESH_RENDERFLAG,
                w > d.FRAGS_PERSISTENT_COUNT) {
                    var C = b.geomids[w];
                    b.geoms.getGeometry(C) && (b.geomidsmap[C] || b.culledGeom.push(C))
                }
            } else
                C = h(n, c, w),
                a && (a.visible = !!C),
                r = r && !C
        }
        var b, c, f, n, m, q, r;
        return function(d, g, 
        h) {
            r = !0;
            f = g;
            n = d;
            m = h;
            d = f.intersectsBox(n === RENDER_HIDDEN ? this.boundingBoxHidden : this.boundingBox);
            if (d === OUTSIDE)
                return r;
            c = this.frags.vizflags;
            b = this.frags;
            q = d !== CONTAINS;
            this.forEach(a, null , m);
            return r
        }
    }
    () : function() {
        function a(a, b) {
            if (!a && c.useThreeMesh || !a.geometry)
                q && q(b);
            else if (g(r, f, c, b))
                a ? a.visible = !1 : stderr("Unexpected null mesh"),
                d[b] &= ~MESH_RENDERFLAG;
            else {
                var E = h(m, d, b);
                a && (a.visible = !!E);
                t = t && !E
            }
        }
        function b(a) {
            c.getGeometryId(a) ? g(r, f, c, a) ? d[a] &= ~MESH_RENDERFLAG : (a = h(m, d, a),
            t = t && !a) : 
            q && q(a)
        }
        var c, d, f, m, q, r, t;
        return function(g, h, E) {
            t = !0;
            f = h;
            m = g;
            q = E;
            g = f.intersectsBox(m === RENDER_HIDDEN ? this.boundingBoxHidden : this.boundingBox);
            if (g === OUTSIDE)
                return t;
            d = this.frags.vizflags;
            c = this.frags;
            r = g !== CONTAINS;
            E || c.useThreeMesh ? this.forEach(a, null , q) : this.forEachNoMesh(b, null );
            return t
        }
    }
    ();
    d.RenderBatch = f
}
)();
(function() {
    var f = Teratek.Viewing.Private;
    f.ModelIteratorLinear = function(h) {
        for (var g = h.getFragmentList(), d = g.getCount(), c = 0, a = [new Int32Array(d)], b = 0; b < d; b++)
            a[0][b] = b;
        b = 333;
        h.is2d && (b /= 6);
        if (isIOSDevice() || isAndroidDevice())
            b /= 3;
        var b = b | 0
          , k = 0 < b ? b : 333;
        h = 0 | (d + k - 1) / k;
        for (var l = Array(h), b = 0; b < h; b++) {
            var n = b * k
              , m = l[b] = new f.RenderBatch(g,a,n,k)
              , n = n + k;
            n > d && (n = d);
            m.lastItem = n
        }
        this.addFragment = function(b) {
            if (a[0].length <= b) {
                var c = 2 * a[0].length;
                c <= b && (c = b + 1);
                c = new Int32Array(c);
                c.set(a[0]);
                a[0] = c;
                this.visibleBoundsDirty = 
                !0
            }
            a[0][b] = b;
            c = 0 | b / k;
            if (l) {
                var d = l[c];
                d || (l[c] = d = new f.RenderBatch(g,a,c * k,k))
            }
            if (d)
                d.onFragmentAdded(b)
        }
        ;
        this.reset = function() {
            c = 0
        }
        ;
        this.nextBatch = function() {
            return c == l.length ? null  : l[c++]
        }
        ;
        this.getVisibleBounds = function(a, b) {
            for (var c = 0; c < l.length; c++)
                l[c].calculateBounds(),
                a.union(l[c].boundingBox),
                b.union(l[c].boundingBox),
                b.union(l[c].boundingBoxHidden)
        }
        ;
        this.rayCast = function(a, b) {
            for (var c = 0; c < l.length; c++)
                l[c].raycast(a, b)
        }
        ;
        this.getSceneCount = function() {
            return l.length
        }
        ;
        this.getGeomScenes = 
        function() {
            return l
        }
        ;
        this.done = function() {
            return c === l.length
        }
    }
}
)();
(function() {
    var f = Teratek.Viewing.Private;
    f.ModelIteratorBVH = function() {
        function h(a) {
            for (var b = l[a], c = m; c > n && l[k[c - 1]] > b; )
                k[c] = k[c - 1],
                c--;
            k[c] = a;
            m++
        }
        function g(a) {
            var d = c.getLeftChild(a);
            -1 !== d && (g(d),
            g(d + 1));
            r.makeEmpty();
            -1 !== d && (c.getBoxThree(d, t),
            r.union(t),
            c.getBoxThree(d + 1, t),
            r.union(t));
            c.getPrimCount(a) && (r.union(b[a].boundingBox),
            r.union(b[a].boundingBoxHidden));
            c.setBoxThree(a, r)
        }
        var d, c = null , a = null , b = null , k = null , l = null , n, m, q = !1, r = new THREE.Box3, t = new THREE.Box3, w, C = !1;
        this.initialize = 
        function(g, h, m) {
            d = g.getFragmentList();
            a = m;
            b = Array(h.nodeCount);
            c = h;
            k = new Int32Array(h.nodeCount + 1);
            l = new Float32Array(h.nodeCount);
            for (g = 0; g < h.nodeCount; g++)
                if (m = h.getPrimCount(g))
                    b[g] = new f.RenderBatch(d,a,h.getPrimStart(g),m),
                    b[g].lastItem = b[g].start + m,
                    h.getFlags(g) & 8 && (b[g].sortObjects = !0),
                    h.getBoxThree(g, b[g].boundingBox)
        }
        ;
        this.addFragment = function(a, b) {}
        ;
        this.reset = function(a) {
            w = a;
            m = n = 0;
            k[m++] = 0;
            C = q = !1
        }
        ;
        this.nextBatch = function() {
            q || n !== m || (k[m++] = 1,
            q = !0);
            for (; n !== m; ) {
                var a = k[--m];
                c.getBoxThree(a, 
                r);
                if (w.intersectsBox(r) !== OUTSIDE) {
                    var d = c.getLeftChild(a);
                    if (-1 !== d) {
                        var f = c.getFlags(a)
                          , g = 0 > w.viewDir[f & 3] ? 1 : 0
                          , t = f >> 2 & 1
                          , z = f >> 3 & 1
                          , H = f = 0;
                        q ? (g ^ 1 ^ z && (t = 1 - t),
                        k[m++] = d + t,
                        k[m++] = d + (1 - t)) : (g = d + t,
                        d = d + 1 - t,
                        c.getBoxThree(g, r),
                        l[g] = f = w.projectedArea(r),
                        c.getBoxThree(d, r),
                        l[d] = H = w.projectedArea(r),
                        0 < f && h(g),
                        0 < H && h(d))
                    }
                    if (0 !== c.getPrimCount(a))
                        return b[a]
                }
                q || n !== m || (k[m++] = 1,
                q = !0)
            }
            C = !0;
            return null 
        }
        ;
        this.getVisibleBounds = function(a, c) {
            for (var d = 0; d < b.length; d++) {
                var f = b[d];
                f && (f.calculateBounds(),
                a.union(f.boundingBox),
                c.union(f.boundingBox),
                c.union(f.boundingBoxHidden))
            }
            g(0);
            g(1)
        }
        ;
        this.rayCast = function(a, d) {
            for (var f = [1, 0], g = new THREE.Vector3; f.length; ) {
                var h = f.pop();
                c.getBoxThree(h, r);
                if (null  !== a.ray.intersectBox(r, g)) {
                    var k = c.getLeftChild(h);
                    -1 !== k && (f.push(k),
                    f.push(k + 1));
                    0 !== c.getPrimCount(h) && b[h].raycast(a, d)
                }
            }
        }
        ;
        this.getSceneCount = function() {
            return b.length
        }
        ;
        this.getGeomScenes = function() {
            return b
        }
        ;
        this.done = function() {
            return C
        }
    }
}
)();
(function() {
    function f(c) {
        function a(a) {
            a = b.getFragmentList().fragments.packIds[a];
            -1 == H.indexOf(a) && H.push(a)
        }
        h.Model.call(this, c);
        var b = this
          , f = new THREE.Box3
          , l = new THREE.Box3
          , n = new THREE.Box3
          , m = 0
          , q = 0;
        this.enforceBvh = this.visibleBoundsDirty = !1;
        this.id = d++;
        var r, t, w, C, E, G, B, v = !1, D = 0, z = g.PAGEOUT_NONE, H = [];
        this.getGeometryList = function() {
            return r
        }
        ;
        this.getFragmentList = function() {
            return t
        }
        ;
        this.initialize = function(a) {
            r = new g.GeometryList(this);
            var b = this.getData().fragments;
            t = new g.FragmentList(b,r,
            a);
            if (a = this.getBoundingBox())
                f.copy(a),
                l.copy(a);
            E = w = new g.ModelIteratorLinear(this)
        }
        ;
        this.dtor = function(a) {
            this.getFragmentList().dispose(a)
        }
        ;
        this.activateFragment = function(a, b) {
            t.setMesh(a, b, !1);
            E.addFragment(a);
            t.getWorldBounds(a, n);
            f.union(n);
            l.union(n)
        }
        ;
        this.setFragment = function(a, b) {
            void 0 === a && (a = this.getFragmentList().getNextAvailableFragmentId());
            t.setMesh(a, b, !0);
            w && w.addFragment(a);
            C && !t.fragmentsHaveBeenAdded() && C.addFragment(a);
            t.getWorldBounds(a, n);
            f.union(n);
            l.union(n);
            return a
        }
        ;
        this.setBVH = 
        function(a, b) {
            E = C = new g.ModelIteratorBVH;
            E.initialize(this, a, b)
        }
        ;
        this.resetIterator = function(a, b, c, d) {
            D = 0;
            if (d) {
                H = [];
                z = g.PAGEOUT_NONE;
                a = this.getFragmentList();
                a.traversedGeom = [];
                a.culledGeom = [];
                d = a.vizflags.length;
                for (var f = 0; f < d; ++f)
                    a.setFlagFragment(f, MESH_TRAVERSED, !1);
                for (var h in a.geomidsmap)
                    a.geomidsmap.hasOwnProperty(h) && (a.geomidsmap[h].t = 0)
            }
            v = !1;
            C && !t.fragmentsHaveBeenAdded() && (v = !0);
            E = v ? C : w;
            q = 0;
            B = c;
            G = b;
            E.reset(b);
            return E
        }
        ;
        this.nextBatch = function() {
            for (; ; ) {
                var b = E.nextBatch();
                q++;
                if (!b)
                    return null ;
                this.is2d() || (b.sortObjects && !this.getFragmentList().useThreeMesh ? b.sortByDepth(G) : b.sortDone || b.sortByMaterial());
                if (!b.applyVisibility(B, G, this.getFragmentList().fragments.packIds ? a : null ))
                    return b
            }
        }
        ;
        this.getVisibleBounds = function(a) {
            this.visibleBoundsDirty && (f.makeEmpty(),
            l.makeEmpty(),
            E.getVisibleBounds(f, l, a),
            this.visibleBoundsDirty = !1);
            return a ? l : f
        }
        ;
        this.rayIntersect = function(a, b, c) {
            this.visibleBoundsDirty && this.getVisibleBounds();
            var d = [];
            if (c)
                for (var f = 0; f < c.length; f++) {
                    var g = t.getVizmesh(c[f]);
                    if (g = VBIntersector.rayCast(g, a, d))
                        g.fragId = c[f],
                        d.push(g)
                }
            else
                E.rayCast(a, d);
            if (!d.length)
                return null ;
            d.sort(function(a, b) {
                return a.distance - b.distance
            }
            );
            for (var h, f = 0; f < d.length; f++)
                if (a = d[f].fragId,
                !this.is2d() && this.isFragVisible(a) && (a = t.getMaterial(a),
                !b || !a.transparent)) {
                    h = d[f];
                    c = d[f].point;
                    g = !1;
                    if (a.cutplanes)
                        for (var k = 0; k < a.cutplanes.length; k++)
                            g = g || 1E-6 < a.cutplanes[k].dot(new THREE.Vector4(c.x,c.y,c.z,1));
                    if (g)
                        h = null ;
                    else
                        break
                }
            h && (h.model = this);
            return h
        }
        ;
        this.setHighlighted = function(a, 
        b) {
            var c = t.setFlagFragment(a, MESH_HIGHLIGHTED, b);
            c && (b ? m++ : m--);
            return c
        }
        ;
        this.setVisibility = function(a, b) {
            t.setVisibility(a, b);
            this.visibleBoundsDirty = !0
        }
        ;
        this.setAllVisibility = function(a) {
            t.setAllVisibility(a);
            this.visibleBoundsDirty = !0
        }
        ;
        this.hideLines = function(a) {
            t.hideLines(a)
        }
        ;
        this.hasHighlighted = function() {
            return !!m
        }
        ;
        this.isFragVisible = function(a) {
            return t.isFragVisible(a)
        }
        ;
        this.areAllVisible = function() {
            return t.areAllVisible()
        }
        ;
        this.getGeomScenes = function() {
            return E.getGeomScenes()
        }
        ;
        this.getRenderProgress = 
        function() {
            return q / E.getSceneCount()
        }
        ;
        this.pageOutStatus = function() {
            return z
        }
        ;
        this.pageOutIfNeeded = function(a) {
            var b = this.getGeometryList()
              , c = this.getFragmentList()
              , d = b.numGeomsInMemory;
            if (d > g.GEOMS_COUNT_LIMIT) {
                var f = 0, h = 0, d = 0, k, m, l = g.GEOMS_PAGEOUT_COUNT;
                k = c.culledGeom.length;
                k = k > l ? l : k;
                for (d = 0; d < k; d++)
                    m = c.culledGeom[d],
                    m = b.removeGeometry(m),
                    0 < m && (f += m,
                    h++);
                c.culledGeom.splice(0, k);
                l -= k;
                if (0 < l) {
                    k = c.traversedGeom.length;
                    for (d = k > l ? k - l : 0; d < k; ++d)
                        m = c.traversedGeom[d],
                        m = b.removeGeometry(m),
                        0 < m && (f += m,
                        h++);
                    k = k > l ? l : k;
                    c.traversedGeom.splice(-k, k)
                }
                d = b.numGeomsInMemory;
                if (a && d > g.GEOMS_COUNT_LIMIT) {
                    k = b.geoms.length;
                    for (d = 0; d < k && !(m = b.removeGeometry(d),
                    0 < m && (f += m,
                    h++),
                    b.numGeomsInMemory < g.GEOMS_COUNT_LIMIT); ++d)
                        ;
                    stderr("A force page out occur. ")
                }
                D += h;
                stderr("Unload: " + h + " , Size: " + f / 1048576 + "MB. Remaining: " + b.numGeomsInMemory);
                if (b.numGeomsInMemory > g.GEOMS_COUNT_LIMIT)
                    return c.reachLimit = !0,
                    H = [],
                    g.PAGEOUT_FAIL
            }
            c.reachLimit = !1;
            return g.PAGEOUT_SUCCESS
        }
        ;
        this.frameUpdatePaging = function(a) {
            var b = this.getFragmentList()
              , 
            c = g.pageOutGeometryEnabled && b.getCount() > g.FRAGS_PERSISTENT_MAX_COUNT;
            c && !a && (z == g.PAGEOUT_FAIL ? b.traversedGeom.length > .5 * g.GEOMS_PAGEOUT_COUNT && (z = this.pageOutIfNeeded()) : z = this.pageOutIfNeeded());
            E.done() && c && (z = this.pageOutIfNeeded(),
            z == g.PAGEOUT_FAIL && 0 == D && this.pageOutIfNeeded(!0))
        }
        ;
        this.geomPacksMissingLastFrame = function() {
            return H
        }
        ;
        this.addGeomPackMissingLastFrame = function(a) {
            -1 == H.indexOf(a) && H.push(a)
        }
    }
    var h = Teratek.Viewing
      , g = h.Private
      , d = 1;
    f.prototype = Object.create(h.Model.prototype);
    f.prototype.constructor = 
    f;
    g.RenderModel = f
}
)();
(function() {
    var f = Teratek.Viewing.Private;
    f.RenderScene = function() {
        var h = !1
          , g = !1
          , d = 0
          , c = 0
          , a = null 
          , b = []
          , k = new f.FrustumIntersector
          , l = new THREE.Raycaster
          , n = !1
          , m = 0
          , q = performance;
        this.checkCull = function() {
            var a = new THREE.Box3;
            return function(c, d, f) {
                b[0].getFragmentList().getWorldBounds(c, a);
                return d && !k.intersectsBox(a) || f && (c = k.projectedArea(a),
                c *= k.areaConv,
                c < k.areaCullThreshold) ? !0 : !1
            }
        }
        ();
        this.addModel = function(a) {
            b.push(a)
        }
        ;
        this.removeModel = function(a) {
            a = b.indexOf(a);
            0 <= a && b.splice(a, 1)
        }
        ;
        this.isEmpty = 
        function() {
            return 0 === b.length
        }
        ;
        this.needsRender = function() {
            return h
        }
        ;
        this.resetNeedsRender = function() {
            h = !1
        }
        ;
        this.renderSome = function(k, m) {
            var l = q.now(), C, E = 0 === d;
            E && !n && (a = null ,
            n = !0);
            for (; ; ) {
                for (var G = !1, B; B = b[c].nextBatch(); ) {
                    k(B);
                    d++;
                    C = q.now();
                    var v = C - l
                      , l = C;
                    B.avgFrameTime = void 0 === B.avgFrameTime ? v : .8 * B.avgFrameTime + .2 * v;
                    m -= B.avgFrameTime;
                    C = !1;
                    E && null  !== a ? B == a && (C = !0) : 0 >= m && (C = !0);
                    if (C) {
                        G = !0;
                        break
                    }
                }
                b[c].frameUpdatePaging(E) === f.PAGEOUT_FAIL && (h = !0);
                if (!B)
                    if (c === b.length - 1) {
                        g = !0;
                        break
                    } else
                        c++;
                if (G)
                    break
            }
            E && 
            null  == a && (a = B);
            if (g || !E)
                a = null ,
                n = !1;
            return m
        }
        ;
        this.reset = function(a, f, h) {
            c = 0;
            m++;
            g = !1;
            d = 0;
            this.resetNeedsRender();
            k.reset(a);
            if (b.length)
                for (var l = 0; l < b.length; l++)
                    b[l].resetIterator(a, k, f, h)
        }
        ;
        this.isDone = function() {
            return g || this.isEmpty()
        }
        ;
        this.setAllVisibility = function(a) {
            for (var c = 0; c < b.length; c++)
                b[c].setAllVisibility(a)
        }
        ;
        this.hideLines = function(a) {
            for (var c = 0; c < b.length; c++)
                b[c].hideLines(a)
        }
        ;
        this.hasHighlighted = function() {
            for (var a = 0; a < b.length; a++)
                if (b[a].hasHighlighted())
                    return !0;
            return !1
        }
        ;
        this.areAllVisible = function() {
            for (var a = 0; a < b.length; a++)
                if (!b[a].areAllVisible())
                    return !1;
            return !0
        }
        ;
        this.invalidateVisibleBounds = function() {
            for (var a = 0; a < b.length; a++)
                b[a].visibleBoundsDirty = !0
        }
        ;
        this.getVisibleBounds = function(a) {
            return b[0].getVisibleBounds(a)
        }
        ;
        this.rayIntersect = function(a, c, d, f) {
            l.set(a, c);
            if (1 < b.length) {
                a = [];
                for (c = 0; c < b.length; c++) {
                    var g = b[c].rayIntersect(l, d, f);
                    g && a.push(g)
                }
                if (!a.length)
                    return null ;
                a.sort(function(a, b) {
                    return a.distance - b.distance
                }
                );
                return a[0]
            }
            return b[0].rayIntersect(l, 
            d, f)
        }
        ;
        this.getRenderProgress = function() {
            return b[0].getRenderProgress()
        }
        ;
        this.getFragmentList = function() {
            return b[0].getFragmentList()
        }
        ;
        this.getGeometryList = function() {
            return b[0].getGeometryList()
        }
        ;
        this.getSceneCount = function() {
            return b[0].getSceneCount()
        }
        ;
        this.getGeomScenes = function() {
            return b[0].getGeomScenes()
        }
        ;
        this.geomPacksMissingLastFrame = function() {
            return b[0].geomPacksMissingLastFrame()
        }
        ;
        this.explode = function(a) {
            if (b.length) {
                for (var c = 0; c < b.length; c++) {
                    var d = b[c]
                      , f = d.getData();
                    if (f.instanceTree) {
                        var g = 
                        d.getVisibleBounds(!0).center()
                          , h = a * (f.instanceTree.maxDepth - 1) + 1
                          , k = 0 | h
                          , m = h - k
                          , l = d.getFragmentList()
                          , n = new THREE.Vector3;
                        a *= 2;
                        if (f.instanceTree && f.instanceTree.boxes && 0 !== a) {
                            var q = f.instanceTree.boxes;
                            (function K(b, c, d, g, h, t, w, J) {
                                var G = 2 * a;
                                c == k && (G *= m);
                                var F = 6 * b
                                  , L = .5 * (q[F] + q[F + 3])
                                  , I = .5 * (q[F + 1] + q[F + 4])
                                  , E = .5 * (q[F + 2] + q[F + 5]);
                                0 < c && c <= k && (t += (L - d) * G,
                                w += (I - g) * G,
                                J += (E - h) * G);
                                f.instanceTree.enumNodeChildren(b, function(a) {
                                    K(a, c + 1, L, I, E, t, w, J)
                                }
                                , !1);
                                f.instanceTree.enumNodeFragments(b, function(a) {
                                    n.x = t;
                                    n.y = w;
                                    n.z = 
                                    J;
                                    l.updateAnimTransform(a, null , null , n)
                                }
                                , !1)
                            }
                            )(f.instanceTree.getRootId(), 0, g.x, g.y, g.x, 0, 0, 0)
                        } else
                            for (var d = l.fragments.boxes, h = 0, I = l.getCount(); h < I; h++)
                                if (0 == a)
                                    l.updateAnimTransform(h);
                                else {
                                    var J = 6 * h
                                      , L = .5 * (d[J] + d[J + 3])
                                      , F = .5 * (d[J + 1] + d[J + 4])
                                      , J = .5 * (d[J + 2] + d[J + 5])
                                      , L = a * (L - g.x)
                                      , F = a * (F - g.y)
                                      , J = a * (J - g.z);
                                    n.x = L;
                                    n.y = F;
                                    n.z = J;
                                    l.updateAnimTransform(h, null , null , n)
                                }
                    }
                }
                this.invalidateVisibleBounds()
            }
        }
    }
}
)();
function RenderContext() {
    function f() {
        function a(b) {
            b.material.blending = THREE.NoBlending;
            b.material.depthWrite = !1;
            b.material.depthTest = !1
        }
        var c = W.NormalsShader;
        g = new THREE.ShaderMaterial({
            fragmentShader: c.fragmentShader,
            vertexShader: c.vertexShader,
            uniforms: THREE.UniformsUtils.clone(c.uniforms)
        });
        g.blending = THREE.NoBlending;
        g.packedNormals = !0;
        l = new W.LmvShaderPass(W.SAOShader);
        a(l);
        k = new W.LmvShaderPass(W.SAOBlurShader);
        a(k);
        m = new W.LmvShaderPass(W.SAOMinifyFirstShader);
        a(m);
        n = new W.LmvShaderPass(W.SAOMinifyShader);
        a(n);
        q = new W.LmvShaderPass(W.FXAAShader);
        a(q);
        r = new W.LmvShaderPass(W.CelShader);
        a(r);
        t = new W.LmvShaderPass(W.BlendShader);
        a(t);
        b = new W.LmvShaderPass(W.BackgroundShader);
        a(b);
        w = new W.LmvShaderPass(W.CopyShader);
        a(w)
    }
    var h, g, d, c, a, b, k, l, n, m, q, r, t, w, C = !1, E, G = null , B = null , v = null , D = null , z = null , H = null , I = 0, J = 0, L = 1, F, N, K = !1, M = new Uint8Array(4), S = (new THREE.Color).setRGB(1, 1, 1), ba = (new THREE.Color).setRGB(0, 0, 0), P = null , aa = !1, Z = !1, V = !1, ea = !1, X = 0, R = 0, T = [.42, 0, 1, 1], O = {
        antialias: !0,
        sao: !1,
        useHdrTarget: !1,
        haveTwoSided: !1,
        useSSAA: !1,
        idbuffer: !0,
        customPresentPass: !1,
        toonShaded: !1,
        envMapBg: !1
    }, ca, ia, fa, W = Teratek.Viewing.Shaders;
    this.settings = O;
    this.init = function(a, b, c) {
        init_FireflyPhongShader(W);
        init_FireflyPrismShader(W);
        init_BackgroundShader(W);
        init_BlendShader(W);
        init_CelShader(W);
        init_CopyShader(W);
        init_FXAAShader(W);
        init_LineShader(W);
        init_NormalsShader(W);
        init_SAOBlurShader(W);
        init_SAOMinifyShader(W);
        init_SAOShader(W);
        init_FireflyBasicShader(W);
        a ? (aa = -1 != window.navigator.userAgent.indexOf("Firefox") && -1 != window.navigator.userAgent.indexOf("Mac OS"),
        Z = isAndroidDevice() || isIOSDevice(),
        O.idbuffer = !Z,
        F = b,
        N = c,
        h = a,
        f(),
        this.initPostPipeline(O.sao, O.antialias, !1)) : console.error("You need a gl context to make a renderer. Things will go downhill from here.")
    }
    ;
    this.overlayUpdate = function(a) {
        if (0 === X || -1 === X)
            return !1;
        a = t.uniforms.highlightIntensity.value;
        var b = .004 * (performance.now() - R)
          , b = Math.min(b, 1)
          , c = 3 * T[1]
          , d = 3 * (T[3] - T[1]) - c
          , b = (((1 - c - d) * b + d) * b + c) * b;
        return a != b ? (t.uniforms.highlightIntensity.value = b,
        !0) : !1
    }
    ;
    this.beginScene = function(d, f, g, k) {
        c = f;
        a = g;
        C = !1;
        if (B) {
            k && (P && !O.envMapBg ? (h.setClearColor(P, 1),
            h.clearTarget(B, !0, !0, !1)) : (b.uniforms.uCamDir.value = c.getWorldDirection(),
            b.uniforms.uCamUp.value = c.up,
            b.uniforms.uResolution.value.set(F, N),
            h.clearTarget(B, !1, !0, !1),
            b.render(h, B, null )));
            H && (h.setClearColor(S, 1),
            h.clearTarget(H, !0, !1, !1));
            if (O.sao || O.toonShaded)
                k && (h.setClearColor(ba, 0),
                h.clearTarget(E, !0, !1, !1)),
                g = f.near,
                k = f.far,
                l.uniforms.cameraNear.value = g,
                l.uniforms.cameraFar.value = k,
                r.uniforms.cameraNear.value = g,
                r.uniforms.cameraFar.value = 
                k,
                m.uniforms.cameraNear.value = g,
                m.uniforms.cameraInvNearFar.value = 1 / (g - k),
                g = f.projectionMatrix.elements,
                f.isPerspective ? (l.uniforms.projInfo.value.set(-2 / (B.width * g[0]), -2 / (B.height * g[5]), (1 - g[8]) / g[0], (1 + g[9]) / g[5]),
                r.uniforms.projInfo.value.copy(l.uniforms.projInfo.value),
                l.uniforms.isOrtho.value = 0,
                r.uniforms.isOrtho.value = 0) : (l.uniforms.projInfo.value.set(-2 / (B.width * g[0]), -2 / (B.height * g[5]), (1 - g[12]) / g[0], (1 - g[13]) / g[5]),
                r.uniforms.projInfo.value.copy(l.uniforms.projInfo.value),
                l.uniforms.isOrtho.value = 
                1,
                r.uniforms.isOrtho.value = 1),
                l.uniforms.projScale.value = .125 * B.height * g[5];
            this.renderScenePart(d, !0, !0, !1, !0)
        } else
            F || K || (console.error("Rendering to a canvas that was resized to zero. If you see this message you may be accidentally leaking a viewer instance."),
            K = !0)
    }
    ;
    this.renderScenePart = function(b, f, k, m, l) {
        C = !1;
        l = l ? a : void 0;
        V && ea ? O.idbuffer && m && (O.sao || O.toonShaded) ? h.render(b, c, [B, E, H], !1, l) : O.sao || O.toonShaded ? h.render(b, c, [B, E], !1, l) : O.idbuffer && m ? h.render(b, c, [B, H]) : h.render(b, c, B, !1, l) : (ea ? 
        O.idbuffer && m ? h.render(b, c, [B, H], !1, l) : h.render(b, c, B, !1, l) : (f && h.render(b, c, B, !1, l),
        O.idbuffer && m && d && (f = b.overrideMaterial,
        b.overrideMaterial = d,
        h.render(b, c, H, !1, void 0),
        b.overrideMaterial = f)),
        (O.sao || O.toonShaded) && k && (f = b.overrideMaterial,
        b.overrideMaterial = g,
        h.render(b, c, E, !1, void 0),
        b.overrideMaterial = f))
    }
    ;
    this.clearAllOverlays = function() {
        h.clearTarget(v, !0, !1, !1)
    }
    ;
    this.renderOverlays = function(a, b) {
        var d = 0, f;
        for (f in a) {
            var g = a[f]
              , k = g.scene
              , l = g.camera ? g.camera : c;
            k.children.length && (d || (d = 1,
            h.setClearColor(ba, 0),
            h.clearTarget(v, !0, !1, !1)),
            g.materialPre && (k.overrideMaterial = g.materialPre),
            h.render(k, l, v, !1, b),
            g.materialPost && (k.overrideMaterial = g.materialPost,
            h.context.depthFunc(h.context.GREATER),
            h.render(k, l, v, !1, b),
            h.context.depthFunc(h.context.LEQUAL)),
            k.overrideMaterial = null )
        }
        t.uniforms.useOverlay.value = d
    }
    ;
    this.computeSSAO = function(a) {
        if (a || !O.sao || O.toonShaded)
            t.uniforms.useAO.value = 0;
        else {
            if (!C) {
                if (G) {
                    a = G[0];
                    m.uniforms.resolution.value.set(1 / a.width, 1 / a.height);
                    m.render(h, a, E);
                    for (var b = 1; b < G.length; b++) {
                        var c = G[b];
                        n.uniforms.resolution.value.set(1 / c.width, 1 / c.height);
                        n.render(h, c, a);
                        a = c
                    }
                }
                l.render(h, z, B);
                k.uniforms.axis.value.set(1, 0);
                k.render(h, D, z);
                k.uniforms.axis.value.set(0, 1);
                k.render(h, z, D);
                C = !0
            }
            t.uniforms.useAO.value = 1
        }
    }
    ;
    this.presentBuffer = function(a) {
        O.sao || t.uniforms.useOverlay.value || t.uniforms.objID.value ? O.antialias ? (t.render(h, D, B),
        a ? (q.render(h, z, D),
        a.render(h, null , z)) : O.toonShaded ? (r.render(h, z, D),
        q.render(h, null , z)) : q.render(h, null , D)) : a ? (t.render(h, D, B),
        a.render(h, null , D)) : O.toonShaded ? (t.render(h, D, B),
        r.render(h, z, D),
        w.render(h, null , z)) : t.render(h, null , B) : O.antialias ? a ? (q.render(h, D, B),
        a.render(h, null , D)) : O.toonShaded ? (r.render(h, D, B),
        q.render(h, null , D)) : q.render(h, null , B) : a ? a.render(h, null , B) : O.toonShaded ? (r.render(h, D, B),
        w.render(h, null , D)) : w.render(h, null , B)
    }
    ;
    this.composeFinalFrame = function(a, b, c) {
        O.sao && !O.toonShaded && this.computeSSAO(a);
        c || this.presentBuffer()
    }
    ;
    this.cleanup = function() {
        B && (B.dispose(),
        B = null );
        E && (E.dispose(),
        E = null );
        v && (v.dispose(),
        v = null );
        D && (D.dispose(),
        D = null );
        z && (z.dispose(),
        z = null );
        if (G) {
            for (var a = 0; a < G.length; a++)
                G[a].dispose();
            G = []
        }
    }
    ;
    this.setSize = function(a, b, c) {
        F = a;
        N = b;
        var d = 0 | a * h.getPixelRatio()
          , f = 0 | b * h.getPixelRatio();
        O.logicalWidth = a;
        O.logicalHeight = b;
        O.deviceWidth = d;
        O.deviceHeight = f;
        if (0 == a && 0 == b)
            this.cleanup();
        else {
            h.setSize(a, b);
            stderr("width: " + d + " height: " + f);
            a = 1 / d;
            b = 1 / f;
            if (O.useSSAA || O.toonShaded && 1 >= h.getPixelRatio())
                d *= 2,
                f *= 2,
                c = !0;
            if (c || !B || B.width != d || B.height != f)
                stderr("Reallocating render targets."),
                this.cleanup(),
                B = new THREE.WebGLRenderTarget(d,f,{
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBFormat,
                    type: O.useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,
                    stencilBuffer: !1,
                    generateMipmaps: !1
                }),
                v = new THREE.WebGLRenderTarget(d,f,{
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    stencilBuffer: !1,
                    generateMipmaps: !1
                }),
                v.shareDepthFrom = B,
                z = D = E = null ,
                G = [];
            if (O.antialias || O.sao || O.customPresentPass || O.toonShaded)
                if (c || !D || D.width != d || D.height != f)
                    D = new THREE.WebGLRenderTarget(d,
                    f,{
                        minFilter: THREE.LinearFilter,
                        magFilter: THREE.LinearFilter,
                        format: THREE.RGBAFormat,
                        stencilBuffer: !1,
                        depthBuffer: !1,
                        generateMipmaps: !1
                    });
            if (O.sao || O.toonShaded) {
                if (c || !E || E.width != d || E.height != f) {
                    var g = THREE.FloatType;
                    isMobileDevice() && (g = THREE.HalfFloatType);
                    E = new THREE.WebGLRenderTarget(d,f,{
                        minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBFormat,
                        type: g,
                        stencilBuffer: !1
                    });
                    E.shareDepthFrom = B;
                    G = [];
                    for (g = 0; 5 > g; g++) {
                        var m = new THREE.WebGLRenderTarget(0 | d / (2 << g),0 | f / (2 << g),
                        {
                            minFilter: THREE.NearestFilter,
                            magFilter: THREE.NearestFilter,
                            format: THREE.RGBAFormat,
                            depthBuffer: !1,
                            stencilBuffer: !1
                        });
                        m.generateMipmaps = !1;
                        G.push(m);
                        l.uniforms["tDepth_mip" + (g + 1)].value = m
                    }
                    V = !aa && h.verifyMRTWorks([B, E]);
                    z = D.clone()
                }
                !z && O.antialias && O.customPresentPass && (z = D.clone());
                l.uniforms.size.value.set(d, f);
                l.uniforms.resolution.value.set(a, b);
                l.uniforms.tDepth.value = E;
                k.uniforms.size.value.set(d, f);
                k.uniforms.resolution.value.set(a, b);
                r.uniforms.tDepth.value = E
            }
            if (O.idbuffer) {
                if (c || !H || H.width != 
                d || H.height != f)
                    H = new THREE.WebGLRenderTarget(d,f,{
                        minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBFormat,
                        type: THREE.UnsignedByteType,
                        stencilBuffer: !1,
                        generateMipmaps: !1
                    }),
                    H.shareDepthFrom = B,
                    (ea = !aa && h.verifyMRTWorks([B, H])) || console.warn("ID buffer requested, but MRT is not supported. Some features will not work.");
                r.uniforms.tID.value = H
            } else
                H && (H.dispose(),
                H = null );
            q.uniforms.uResolution.value.set(a, b);
            r.uniforms.resolution.value.set(a, b);
            t.uniforms.tOverlay.value = v;
            t.uniforms.tAO.value = 
            z;
            t.uniforms.useAO.value = O.sao ? 1 : 0;
            t.uniforms.resolution.value.set(a, b);
            t.uniforms.tID.value = H
        }
    }
    ;
    this.getMaxAnisotropy = function() {
        return h.getMaxAnisotropy()
    }
    ;
    this.hasMRT = function() {
        return !aa && h.supportsMRT()
    }
    ;
    this.applyMRTFlags = function(a) {
        var b = a.mrtNormals
          , c = a.mrtIdBuffer;
        a.mrtNormals = this.hasMRT() && V && (O.sao || O.toonShaded);
        a.mrtIdBuffer = this.hasMRT() && ea && O.idbuffer;
        if (a.mrtNormals !== b || a.mrtIdBuffer !== c)
            a.needsUpdate = !0
    }
    ;
    this.initPostPipeline = function(a, c) {
        O.sao = a && !_isIE11;
        O.antialias = c && !_isIE11;
        O.sao && (O.toonShaded = !1);
        O.haveTwoSided && (g.side = THREE.DoubleSide);
        g.needsUpdate = !0;
        l.material.needsUpdate = !0;
        k.material.needsUpdate = !0;
        m.material.needsUpdate = !0;
        n.material.needsUpdate = !0;
        q.material.needsUpdate = !0;
        r.material.needsUpdate = !0;
        t.material.needsUpdate = !0;
        b.material.needsUpdate = !0;
        w.material.needsUpdate = !0;
        this.setSize(F, N)
    }
    ;
    this.setClearColors = function(a, c) {
        P = c ? a.equals(c) || Z ? new THREE.Color(.5 * (a.x + c.x),.5 * (a.y + c.y),.5 * (a.z + c.z)) : void 0 : a.clone();
        P || (b.uniforms.color1.value.copy(a),
        b.uniforms.color2.value.copy(c))
    }
    ;
    this.setAOOptions = function(a, b) {
        void 0 !== a && (l.uniforms.radius.value = a);
        void 0 !== b && (l.uniforms.intensity.value = b);
        C = !1
    }
    ;
    this.getAORadius = function() {
        return l.uniforms.radius.value
    }
    ;
    this.getAOIntensity = function() {
        return l.uniforms.intensity.value
    }
    ;
    this.setTonemapExposureBias = function(a) {
        I = a
    }
    ;
    this.getExposureBias = function() {
        return I
    }
    ;
    this.setTonemapMethod = function(a) {
        J = a;
        h.gammaInput = 0 === a ? !1 : !0
    }
    ;
    this.getToneMapMethod = function() {
        return J
    }
    ;
    this.toggleTwoSided = function(a) {
        O.haveTwoSided != a && g && (g.side = 
        a ? THREE.DoubleSide : THREE.FrontSide,
        g.needsUpdate = !0);
        O.haveTwoSided = a
    }
    ;
    this.toggleCelShading = function(a) {
        O.sao = !a;
        O.toonShaded = a;
        O.idbuffer = a;
        this.initPostPipeline(O.sao, O.antialias)
    }
    ;
    this.toggleEnvMapBackground = function(a) {
        O.envMapBg = a;
        b.uniforms.envMapBackground.value = a
    }
    ;
    this.enter2DMode = function(a) {
        d = a;
        ca = O.sao;
        ia = O.antialias;
        fa = O.idbuffer;
        O.idbuffer = !0;
        t.material.defines.IS_2D = "";
        this.initPostPipeline(!1, !1)
    }
    ;
    this.exit2DMode = function() {
        d = null ;
        O.idbuffer = fa;
        delete t.material.defines.IS_2D;
        this.initPostPipeline(ca, 
        ia)
    }
    ;
    this.idAtPixel = function(a, b) {
        if (!H)
            return 0;
        h.readRenderTargetPixels(H, .5 * (a + 1) * H.width, .5 * (b + 1) * H.height, 1, 1, M);
        var c = M[2] << 16 | M[1] << 8 | M[0];
        return c << 8 >> 8
    }
    ;
    this.rolloverObjectViewport = function(a, b) {
        var c = this.idAtPixel(a, b);
        if (c == X)
            return !1;
        t.uniforms.highlightIntensity.value = 0;
        R = performance.now();
        X = c;
        0 >= c && (c = 0,
        M[0] = M[1] = M[2] = M[3] = 0);
        t.uniforms.objID.value = c;
        t.uniforms.objIDv3.value.set(M[0] / 255, M[1] / 255, M[2] / 255);
        return !0
    }
    ;
    this.setUnitScale = function(a) {
        L = a
    }
    ;
    this.getUnitScale = function() {
        return L
    }
    ;
    this.getBlendPass = function() {
        return t
    }
    ;
    this.getColorTarget = function() {
        return B
    }
    ;
    this.getDepthMaterial = function() {
        return g
    }
}
function init_FXAAShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.FXAAShader && (f.FXAAShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            uResolution: {
                type: "v2",
                value: new THREE.Vector2(1 / 1024,1 / 512)
            }
        },
        vertexShader: "uniform vec2 uResolution;\nvarying vec2 vPos;\nvarying vec4 vPosPos;\nvoid main() {\nvPos = uv;\nvPosPos.xy = uv + vec2(-0.5, -0.5) * uResolution;\nvPosPos.zw = uv + vec2( 0.5,  0.5) * uResolution;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "#define FXAA_EDGE_SHARPNESS (8.0)\n#define FXAA_EDGE_THRESHOLD (0.125)\n#define FXAA_EDGE_THRESHOLD_MIN (0.05)\n#define FXAA_RCP_FRAME_OPT (0.50)\n#define FXAA_RCP_FRAME_OPT2 (2.0)\nuniform sampler2D tDiffuse;\nuniform highp vec2 uResolution;\nvarying vec2 vPos;\nvarying vec4 vPosPos;\nfloat FxaaLuma(vec3 rgb) {\nreturn dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nvoid main() {\nfloat lumaNw = FxaaLuma(texture2D(tDiffuse, vPosPos.xy).rgb);\nfloat lumaSw = FxaaLuma(texture2D(tDiffuse, vPosPos.xw).rgb);\nfloat lumaNe = FxaaLuma(texture2D(tDiffuse, vPosPos.zy).rgb) + 1.0/384.0;\nfloat lumaSe = FxaaLuma(texture2D(tDiffuse, vPosPos.zw).rgb);\nvec3 rgbM = texture2D(tDiffuse, vPos.xy).rgb;\nfloat lumaM = FxaaLuma(rgbM.rgb);\nfloat lumaMax = max(max(lumaNe, lumaSe), max(lumaNw, lumaSw));\nfloat lumaMin = min(min(lumaNe, lumaSe), min(lumaNw, lumaSw));\nfloat lumaMaxSubMinM = max(lumaMax, lumaM) - min(lumaMin, lumaM);\nfloat lumaMaxScaledClamped = max(FXAA_EDGE_THRESHOLD_MIN, lumaMax * FXAA_EDGE_THRESHOLD);\nif (lumaMaxSubMinM < lumaMaxScaledClamped) {\ngl_FragColor = vec4(rgbM, 1.0);\nreturn;\n}\nfloat dirSwMinusNe = lumaSw - lumaNe;\nfloat dirSeMinusNw = lumaSe - lumaNw;\nvec2 dir1 = normalize(vec2(dirSwMinusNe + dirSeMinusNw, dirSwMinusNe - dirSeMinusNw));\nvec3 rgbN1 = texture2D(tDiffuse, vPos.xy - dir1 * FXAA_RCP_FRAME_OPT*uResolution).rgb;\nvec3 rgbP1 = texture2D(tDiffuse, vPos.xy + dir1 * FXAA_RCP_FRAME_OPT*uResolution).rgb;\nfloat dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * FXAA_EDGE_SHARPNESS;\nvec2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);\nvec3 rgbN2 = texture2D(tDiffuse, vPos.xy - dir2 * FXAA_RCP_FRAME_OPT2*uResolution).rgb;\nvec3 rgbP2 = texture2D(tDiffuse, vPos.xy + dir2 * FXAA_RCP_FRAME_OPT2*uResolution).rgb;\nvec3 rgbA = rgbN1 + rgbP1;\nvec3 rgbB = ((rgbN2 + rgbP2) * 0.25) + (rgbA * 0.25);\nfloat lumaB = FxaaLuma(rgbB);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ngl_FragColor = vec4(rgbA * 0.5, 1.0);\nelse\ngl_FragColor = vec4(rgbB, 1.0);\n}"
    })
}
var PackDepthShaderChunk = "vec4 packDepth( const in float depth ) {\nvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nenc = fract(enc);\nenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\nreturn enc;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\nreturn dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}"
  , TonemapShaderChunk = "float luminance_post(vec3 rgb) {\nreturn dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\nreturn dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\nvec3 R = vec3( 3.240479, -1.537150, -0.498535);\nvec3 G = vec3(-0.969256,  1.875992,  0.041556);\nvec3 B = vec3( 0.055648, -0.204043,  1.057311);\nvec3 rgb;\nrgb.b = dot(xyz, B);\nrgb.g = dot(xyz, G);\nrgb.r = dot(xyz, R);\nreturn rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\nvec3 X = vec3(0.412453, 0.35758, 0.180423);\nvec3 Y = vec3(0.212671, 0.71516, 0.0721688);\nvec3 Z = vec3(0.0193338, 0.119194, 0.950227);\nvec3 xyz;\nxyz.x = dot(rgb, X);\nxyz.y = dot(rgb, Y);\nxyz.z = dot(rgb, Z);\nreturn xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\nfloat sum = xyz.x + xyz.y + xyz.z;\nsum = 1.0 / sum;\nvec3 xyY;\nxyY.z = xyz.y;\nxyY.x = xyz.x * sum;\nxyY.y = xyz.y * sum;\nreturn xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\nfloat x = xyY.x;\nfloat y = xyY.y;\nfloat Y = xyY.z;\nvec3 xyz;\nxyz.y = Y;\nxyz.x = x * (Y / y);\nxyz.z = (1.0 - x - y) * (Y / y);\nreturn xyz;\n}\nfloat T(float x)\n{\nfloat tmp = 1.0592 - 1.0631 / (1.0 + 4.5805 * pow(x, 1.5823));\nreturn clamp(tmp, 0.0, 1.0);\n}\nconst float Shift = 1.0 / 0.18;\nfloat toneMapCanonFilmic_NoGamma(float x) {\nx *= Shift;\nconst float A = 0.2;\nconst float B = 0.34;\nconst float C = 0.002;\nconst float D = 1.68;\nconst float E = 0.0005;\nconst float F = 0.252;\nconst float scale = 1.0/0.833837;\nreturn (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;\n}\nvec3 toneMapCanonFilmic_WithGamma(vec3 x) {\nx *= Shift;\nconst float A = 0.27;\nconst float B = 0.29;\nconst float C = 0.052;\nconst float D = 0.2;\nconst float F = 0.18;\nconst float scale = 1.0/0.897105;\nreturn (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;\n}\nvec3 toneMapCanonOGS_WithGamma_WithColorPerserving(vec3 x) {\nvec3 outColor = x.rgb;\nfloat inLum = luminance_pre(outColor);\nfloat outLum = toneMapCanonFilmic_NoGamma(inLum);\noutColor = outColor * (outLum / inLum);\nfloat gamma = 1.0/2.2;\noutColor = pow(outColor, vec3(gamma));\nreturn outColor;\n}"
  , 
OrderedDitheringShaderChunk = "vec3 orderedDithering(vec3 col) {\nconst vec4 m0 = vec4( 1.0, 13.0,  4.0, 16.0);\nconst vec4 m1 = vec4( 9.0,  5.0, 12.0,  8.0);\nconst vec4 m2 = vec4( 3.0, 15.0,  2.0, 14.0);\nconst vec4 m3 = vec4(11.0,  7.0, 10.0,  6.0);\nint i = int(mod(float(gl_FragCoord.x), 4.0));\nint j = int(mod(float(gl_FragCoord.y), 4.0));\nvec4 biasRow;\nif      (i==0) biasRow = m0;\nelse if (i==1) biasRow = m1;\nelse if (i==2) biasRow = m2;\nelse           biasRow = m3;\nfloat bias;\nif      (j==0) bias = biasRow.x;\nelse if (j==1) bias = biasRow.y;\nelse if (j==2) bias = biasRow.z;\nelse           bias = biasRow.w;\nreturn col + bias / 17.0 / 256.0;\n}"
  , 
CutPlanesShaderChunk = "#if NUM_CUTPLANES > 0\nuniform vec4 cutplanes[NUM_CUTPLANES];\n#ifdef CUTPLANES_LINE\nuniform vec3 cutplanesOutlineColor;\nuniform float cutplanesOutlineThickness;\n#endif\nbool checkCutPlanes(vec3 worldPosition) {\nbool isCut = false;\n#ifdef CUTPLANES_LINE\nbool isCutEdge = false;\nfloat eyeDist = length(vViewPosition);\n#endif\nfor (int i=0; i<NUM_CUTPLANES; i++) {\nfloat dotPlane = dot(vec4(worldPosition, 1.0), cutplanes[i]);\nisCut = isCut || (dotPlane > 0.0);\n#ifdef CUTPLANES_LINE\nisCutEdge = isCutEdge || (dotPlane > -cutplanesOutlineThickness*eyeDist);\n#endif\n}\nif (isCut) {\ndiscard;\nreturn true;\n}\n#ifdef CUTPLANES_LINE\nelse if (isCutEdge) {\ngl_FragColor = vec4(cutplanesOutlineColor, 1.0);\nreturn true;\n}\n#endif\nreturn false;\n}\n#endif"
  , 
PackNormalsShaderChunk = "#define kPI 3.14159265358979\nvec2 encodeNormal (vec3 n)\n{\nreturn (vec2(atan(n.y,n.x)/kPI, n.z)+1.0)*0.5;\n}\nvec3 decodeNormal (vec2 enc)\n{\nvec2 ang = enc * 2.0 - 1.0;\nvec2 scth = vec2(sin(ang.x * kPI), cos(ang.x * kPI));\nvec2 scphi = vec2(sqrt(1.0 - ang.y * ang.y), ang.y);\nreturn vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y);\n}";
function init_CopyShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.CopyShader && (f.CopyShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\nvUv = uv;\n}",
        fragmentShader: "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\ngl_FragColor = texture2D(tDiffuse, vUv);\n}"
    })
}
function init_CelShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.CelShader && (f.CelShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            tDepth: {
                type: "t",
                value: null 
            },
            tID: {
                type: "t",
                value: null 
            },
            resolution: {
                type: "v2",
                value: new THREE.Vector2(1 / 1024,1 / 512)
            },
            cameraNear: {
                type: "f",
                value: 1
            },
            cameraFar: {
                type: "f",
                value: 100
            },
            projInfo: {
                type: "v4",
                value: new THREE.Vector4(0,0,0,0)
            },
            isOrtho: {
                type: "f",
                value: 1
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: ["#extension GL_OES_standard_derivatives : enable\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform sampler2D tID;\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float isOrtho;\nuniform vec4 projInfo;\nvarying vec2 vUv;\nvec4 recoverNZ(vec4 nrmz) {\nfloat z = sqrt(1.0 - dot(nrmz.xy, nrmz.xy));\nnrmz.w = -(nrmz.z +cameraNear) / (cameraFar - cameraNear);\nnrmz.z = z;\nreturn nrmz;\n}", TonemapShaderChunk, "vec4 quantize(vec4 c) {\nc *= c;\nfloat L = max(c.x, max(c.y, c.z));\nc.xyz *= floor(L * 8.0 + 0.5) / (8.0 * L);\nc.w = 1.0;\nreturn sqrt(c);\n}\nvec4 quantizeRGB(vec4 c) {\nc *= c;\nc.xyz *= floor(c.xyz * 8.0 + 0.5) / 8.0;\nc.w = 1.0;\nreturn sqrt(c);\n}\nvec3 reconstructCSPosition(vec2 S, float z) {\nreturn vec3((S.xy * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\n}\nvec3 reconstructCSFaceNormal(vec3 C) {\nreturn normalize(cross(dFdy(C), dFdx(C)));\n}\nvec3 getPosition(ivec2 ssP, float depth) {\nvec3 P;\nP = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);\nreturn P;\n}\nint isObjectEdge() {\nvec4 MM = texture2D(tID, vUv + vec2( 0.0,  0.0));\nvec4 LL = texture2D(tID, vUv + vec2(-1.0, -1.0) * resolution);\nif (MM != LL) return 1;\nvec4 LM = texture2D(tID, vUv + vec2( 0.0, -1.0) * resolution);\nif (MM != LM) return 1;\nvec4 LR = texture2D(tID, vUv + vec2( 1.0, -1.0) * resolution);\nif (MM != LR) return 1;\nvec4 ML = texture2D(tID, vUv + vec2(-1.0,  0.0) * resolution);\nif (MM != ML) return 1;\nvec4 MR = texture2D(tID, vUv + vec2( 1.0,  0.0) * resolution);\nif (MM != MR) return 1;\nvec4 UL = texture2D(tID, vUv + vec2(-1.0,  1.0) * resolution);\nif (MM != UL) return 1;\nvec4 UM = texture2D(tID, vUv + vec2( 0.0,  1.0) * resolution);\nif (MM != UM) return 1;\nvec4 UR = texture2D(tID, vUv + vec2( 1.0,  1.0) * resolution);\nif (MM != UR) return 1;\nreturn 0;\n}\nfloat normalDiff(vec3 n1, vec3 n2) {\nfloat d = dot(n1.xyz, n2.xyz);\nreturn acos(clamp(d, -1.0, 1.0));\n}\nconst float r = 1.0;\nvoid main() {\nvec4 color = texture2D(tDiffuse, vUv);\nivec2 ssC = ivec2(gl_FragCoord.xy);\nif (isObjectEdge() == 1) {\ngl_FragColor = vec4(0,0,0,1);\nreturn;\n}\nvec4 MM = texture2D(tDepth, vUv + vec2( 0.0,  0.0));\nif (MM.z == 0.0) {\ngl_FragColor = quantize(color);\nreturn;\n}\nvec4 LL = texture2D(tDepth, vUv + vec2(-r, -r) * resolution);\nvec4 LM = texture2D(tDepth, vUv + vec2( 0.0, -r) * resolution);\nvec4 LR = texture2D(tDepth, vUv + vec2( r, -r) * resolution);\nvec4 ML = texture2D(tDepth, vUv + vec2(-r,  0.0) * resolution);\nvec4 MR = texture2D(tDepth, vUv + vec2( r,  0.0) * resolution);\nvec4 UL = texture2D(tDepth, vUv + vec2(-r, r) * resolution);\nvec4 UM = texture2D(tDepth, vUv + vec2( 0.0,  r) * resolution);\nvec4 UR = texture2D(tDepth, vUv + vec2( r,  r) * resolution);\nvec3 C = getPosition(ssC + ivec2(-1, -1), LL.z);\nvec3 LLz = reconstructCSFaceNormal(C);\nC = getPosition(ssC + ivec2( 0, -1), LM.z);\nvec3 LMz = reconstructCSFaceNormal(C);\nC = getPosition(ssC + ivec2( 1, -1), LR.z);\nvec3 LRz = reconstructCSFaceNormal(C);\nC = getPosition(ssC + ivec2(-1, 0), ML.z);\nvec3 MLz = reconstructCSFaceNormal(C);\nC = getPosition(ssC + ivec2( 0, 0), MM.z);\nvec3 MMz = reconstructCSFaceNormal(C);\nC = getPosition(ssC + ivec2( 1, 0), MR.z);\nvec3 MRz = reconstructCSFaceNormal(C);\nC = getPosition(ssC + ivec2(-1, 1), UL.z);\nvec3 ULz = reconstructCSFaceNormal(C);\nC = getPosition(ssC + ivec2(0, 1), UM.z);\nvec3 UMz = reconstructCSFaceNormal(C);\nC = getPosition(ssC + ivec2(1, 1), UR.z);\nvec3 URz = reconstructCSFaceNormal(C);\nLL = recoverNZ(LL);\nLM = recoverNZ(LM);\nLR = recoverNZ(LR);\nML = recoverNZ(ML);\nMM = recoverNZ(MM);\nMR = recoverNZ(MR);\nUL = recoverNZ(UL);\nUM = recoverNZ(UM);\nUR = recoverNZ(UR);\nfloat pLL = normalDiff(LL.xyz, MM.xyz);\nfloat pLM = normalDiff(LM.xyz, MM.xyz);\nfloat pLR = normalDiff(LR.xyz, MM.xyz);\nfloat pML = normalDiff(ML.xyz, MM.xyz);\nfloat pMM = normalDiff(MM.xyz, MM.xyz);\nfloat pMR = normalDiff(MR.xyz, MM.xyz);\nfloat pUL = normalDiff(UL.xyz, MM.xyz);\nfloat pUM = normalDiff(UM.xyz, MM.xyz);\nfloat pUR = normalDiff(UR.xyz, MM.xyz);\nfloat pLLz = normalDiff(LLz.xyz, MMz.xyz);\nfloat pLMz = normalDiff(LMz.xyz, MMz.xyz);\nfloat pLRz = normalDiff(LRz.xyz, MMz.xyz);\nfloat pMLz = normalDiff(MLz.xyz, MMz.xyz);\nfloat pMMz = normalDiff(MMz.xyz, MMz.xyz);\nfloat pMRz = normalDiff(MRz.xyz, MMz.xyz);\nfloat pULz = normalDiff(ULz.xyz, MMz.xyz);\nfloat pUMz = normalDiff(UMz.xyz, MMz.xyz);\nfloat pURz = normalDiff(URz.xyz, MMz.xyz);\nfloat dGx = (dFdx(UL.w) + 2.0 * dFdx(UM.w) + dFdx(UR.w)) - (dFdx(LL.w) + 2.0 * dFdx(LM.w) + dFdx(LR.w)) + (dFdx(UR.w) + 2.0 * dFdx(MR.w) - dFdx(LR.w)) - (dFdx(UL.w) + 2.0 * dFdx(ML.w) - dFdx(LL.w));\nfloat dGy = (dFdy(UL.w) + 2.0 * dFdy(UM.w) + dFdy(UR.w)) - (dFdy(LL.w) + 2.0 * dFdy(LM.w) + dFdy(LR.w)) + (dFdy(UR.w) + 2.0 * dFdy(MR.w) - dFdy(LR.w)) - (dFdy(UL.w) + 2.0 * dFdy(ML.w) - dFdy(LL.w));\nfloat Gn = (abs(pUL - pMM) + 2.0 * abs(pUM - pMM) + abs(pUR - pMM) + 2.0 * abs(pML - pMM) + 2.0 * abs(pMR - pMM) + abs(pLL - pMM) + 2.0 * abs(pLM - pMM) + abs(pLR - pMM));\nfloat Gnz = (abs(pULz - pMMz) + 2.0 * abs(pUMz - pMMz) + abs(pURz - pMMz) + 2.0 * abs(pMLz - pMMz) + 2.0 * abs(pMRz - pMMz) + abs(pLLz - pMMz) + 2.0 * abs(pLMz - pMMz) + abs(pLRz - pMMz));\nfloat G = (abs(UL.w - MM.w) + 2.0 * abs(UM.w - MM.w) + abs(UR.w - MM.w) + 2.0 * abs(ML.w - MM.w) + 2.0 * abs(MR.w - MM.w) + abs(LL.w - MM.w) + 2.0 * abs(LM.w - MM.w) + abs(LR.w - MM.w));\nfloat dd = abs(dFdx(G)) + abs(dFdy(G));\nif (dd > 0.004 || abs(Gnz) > 2.2 || abs(Gn) > 2.0)\ngl_FragColor = vec4(0.0,0.0,0.0,1.0);\nelse\ngl_FragColor = /*vec4(1.0,1.0,1.0,1.0);*/quantize(color);\n}"].join("\n")
    })
}
function init_BlendShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.BlendShader && (f.BlendShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            tAO: {
                type: "t",
                value: null 
            },
            useAO: {
                type: "i",
                value: 0
            },
            tOverlay: {
                type: "t",
                value: null 
            },
            useOverlay: {
                type: "i",
                value: 0
            },
            tID: {
                type: "t",
                value: null 
            },
            objID: {
                type: "i",
                value: 0
            },
            objIDv3: {
                type: "v3",
                value: new THREE.Vector3(0,0,0)
            },
            highlightIntensity: {
                type: "f",
                value: 1
            },
            resolution: {
                type: "v2",
                value: new THREE.Vector2(1 / 1024,1 / 512)
            }
        },
        defines: {},
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: ["uniform sampler2D tDiffuse;\nuniform sampler2D tAO;\nuniform int useAO;\nuniform sampler2D tOverlay;\nuniform int useOverlay;\nuniform vec2 resolution;\nuniform int objID;\nuniform vec3 objIDv3;\nuniform sampler2D tID;\nuniform float highlightIntensity;\nvarying vec2 vUv;", TonemapShaderChunk, "vec4 overlayEdgeDetect(vec2 vUv) {\n#define IS_SELECTION(C) ( (C).b > (C).r && (C).b > (C).g )\n#define CHECK_EDGE_ALPHA(I, J)     { vec4 c = texture2D( tOverlay, vUv+resolution*vec2((I),(J)) ); maxAlpha = max(maxAlpha, c.a); if (c.a > 0.0 && IS_SELECTION(c)) { hasEdge++; selectionPixel = c; } }\n#define CHECK_EDGE_SELECTION(I, J) { vec4 c = texture2D( tOverlay, vUv+resolution*vec2((I),(J)) ); maxAlpha = max(maxAlpha, c.a); if (c.a <= 0.0) hasEdge++; }\nint hasEdge = 0;\nvec4 center = texture2D(tOverlay, vUv);\nvec4 selectionPixel = vec4(0.0);\nfloat maxAlpha = 0.0;\nbool paintOutline = false;\nif (center.a <= 0.0) {\nCHECK_EDGE_ALPHA(-1.0,-1.0);\nCHECK_EDGE_ALPHA( 0.0,-1.0);\nCHECK_EDGE_ALPHA( 1.0,-1.0);\nCHECK_EDGE_ALPHA(-1.0, 0.0);\nCHECK_EDGE_ALPHA( 1.0, 0.0);\nCHECK_EDGE_ALPHA(-1.0, 1.0);\nCHECK_EDGE_ALPHA( 0.0, 1.0);\nCHECK_EDGE_ALPHA( 1.0, 1.0);\nif (hasEdge != 0) {\ncenter = selectionPixel;\npaintOutline = true;\n}\n}\nelse if (center.a > 0.0 && IS_SELECTION(center)) {\nCHECK_EDGE_SELECTION(-1.0,-1.0);\nCHECK_EDGE_SELECTION( 0.0,-1.0);\nCHECK_EDGE_SELECTION( 1.0,-1.0);\nCHECK_EDGE_SELECTION(-1.0, 0.0);\nCHECK_EDGE_SELECTION( 1.0, 0.0);\nCHECK_EDGE_SELECTION(-1.0, 1.0);\nCHECK_EDGE_SELECTION( 0.0, 1.0);\nCHECK_EDGE_SELECTION( 1.0, 1.0);\nif (hasEdge != 0)\npaintOutline = true;\nelse\ncenter.a = -center.a;\n}\nif (paintOutline) {\nfloat maxComponent = max(center.r, max(center.g, center.b));\ncenter.rgb /= maxComponent;\ncenter.rgb = sqrt(center.rgb);\ncenter.a = 0.5 + 0.5 * maxAlpha * 0.125 * float(hasEdge);\n}\nreturn center;\n}\nvec4 sampleColor() {\nreturn texture2D( tDiffuse, vUv );\n}\nfloat sampleAO() {\nreturn (useAO != 0) ? texture2D(tAO, vUv).r : 1.0;\n}\nvoid main() {\nvec4 texel = sampleColor();\ntexel.rgb *= sampleAO();\nif (useOverlay != 0) {\nvec4 overlay = overlayEdgeDetect(vUv);\nif (overlay.a < 0.0) {\noverlay.a = -overlay.a;\nif (overlay.a >= 0.99) {\noverlay.a = 0.75;\ntexel.rgb = vec3(luminance_post(texel.rgb));\n}\n}\ntexel.rgb = mix(texel.rgb, sqrt(overlay.rgb)/*sqrt=gamma*/, overlay.a);\n}\nif (objID != 0) {\nvec4 idAtPixel = texture2D(tID, vUv);\nvec3 idDelta = abs(idAtPixel.rgb - objIDv3.rgb);\nif (max(max(idDelta.r, idDelta.g), idDelta.b) < 1e-3) {\n#ifdef IS_2D\ntexel.rgb = mix(texel.rgb, vec3(1.0,1.0,0.0), highlightIntensity * 0.25);\n#else\ntexel.rgb += highlightIntensity * 0.2;\n#endif\n}\n}\ngl_FragColor = texel;\n}"].join("\n")
    })
}
(function() {
    var f = function(f, g) {
        this.textureID = void 0 !== g ? g : "tDiffuse";
        this.uniforms = THREE.UniformsUtils.clone(f.uniforms);
        this.material = new THREE.ShaderMaterial({
            uniforms: this.uniforms,
            vertexShader: f.vertexShader,
            fragmentShader: f.fragmentShader,
            defines: THREE.UniformsUtils.clone(f.defines)
        });
        this.renderToScreen = !1;
        this.enabled = !0;
        this.clear = !1;
        this.camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        var d = new THREE.BufferGeometry
          , c = new Float32Array(9);
        c[0] = -1;
        c[1] = -1;
        c[2] = 0;
        c[3] = 3;
        c[4] = -1;
        c[5] = 0;
        c[6] = 
        -1;
        c[7] = 3;
        c[8] = 0;
        var a = new Float32Array(6);
        a[0] = 0;
        a[1] = 0;
        a[2] = 2;
        a[3] = 0;
        a[4] = 0;
        a[5] = 2;
        var b = new Float32Array(9);
        b[0] = 0;
        b[1] = 0;
        b[2] = 1;
        b[3] = 0;
        b[4] = 0;
        b[5] = 1;
        b[6] = 0;
        b[7] = 0;
        b[8] = 1;
        d.addAttribute("position", new THREE.BufferAttribute(c,3));
        d.addAttribute("normal", new THREE.BufferAttribute(b,3));
        d.addAttribute("uv", new THREE.BufferAttribute(a,2));
        this.quad = new THREE.Mesh(d,this.material);
        this.scene = new THREE.Scene;
        this.scene.add(this.quad)
    }
    ;
    f.prototype = {
        render: function(f, g, d, c) {
            this.uniforms[this.textureID] && 
            (this.uniforms[this.textureID].value = d);
            this.renderToScreen || !g ? f.render(this.scene, this.camera) : f.render(this.scene, this.camera, g, this.clear)
        }
    };
    Teratek.Viewing.Shaders.LmvShaderPass = f
}
)();
function init_SAOShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.SAOShader && (f.SAOShader = {
        uniforms: {
            tDepth: {
                type: "t",
                value: null 
            },
            size: {
                type: "v2",
                value: new THREE.Vector2(512,512)
            },
            resolution: {
                type: "v2",
                value: new THREE.Vector2(1 / 512,1 / 512)
            },
            cameraNear: {
                type: "f",
                value: 1
            },
            cameraFar: {
                type: "f",
                value: 100
            },
            radius: {
                type: "f",
                value: 10
            },
            bias: {
                type: "f",
                value: .01
            },
            projScale: {
                type: "f",
                value: 500
            },
            projInfo: {
                type: "v4",
                value: new THREE.Vector4(0,0,0,0)
            },
            intensity: {
                type: "f",
                value: .5
            },
            isOrtho: {
                type: "f",
                value: 1
            },
            tDepth_mip1: {
                type: "t",
                value: null 
            },
            tDepth_mip2: {
                type: "t",
                value: null 
            },
            tDepth_mip3: {
                type: "t",
                value: null 
            },
            tDepth_mip4: {
                type: "t",
                value: null 
            },
            tDepth_mip5: {
                type: "t",
                value: null 
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: ["#define USE_MIPMAP 1\nuniform float cameraNear;\nuniform float cameraFar;\nuniform vec2 size;\nuniform vec2 resolution;\nuniform float lumInfluence;\nvarying vec2 vUv;\n#define NUM_SAMPLES (17)\n#define LOG_MAX_OFFSET (3)\n#define MAX_MIP_LEVEL (5)\n#define NUM_SPIRAL_TURNS (7)\nuniform float           projScale;\nuniform sampler2D tDepth;\n#ifdef USE_MIPMAP\nuniform sampler2D tDepth_mip1;\nuniform sampler2D tDepth_mip2;\nuniform sampler2D tDepth_mip3;\nuniform sampler2D tDepth_mip4;\nuniform sampler2D tDepth_mip5;\n#endif\nuniform float radius;\nuniform float bias;\nuniform float intensity;\nuniform float isOrtho;\nvec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){\nfloat alpha = float(float(sampleNumber) + 0.5) * (1.0 / float(NUM_SAMPLES));\nfloat angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;\nssR = alpha;\nreturn vec2(cos(angle), sin(angle));\n}\nfloat CSZToKey(float z) {\nreturn clamp(z * (1.0 / -cameraFar), 0.0, 1.0);\n}\nvoid packKey(float key, out vec2 p) {\nfloat temp = floor(key * 256.0);\np.x = temp * (1.0 / 256.0);\np.y = key * 256.0 - temp;\n}", 
        PackDepthShaderChunk, "float unpackDepthNearFar( const in vec4 rgba_depth ) {\nfloat depth = unpackDepth( rgba_depth );\nif (depth == 0.0)\nreturn -cameraFar * 1.0e10;\nreturn depth * (cameraNear - cameraFar) - cameraNear;\n}\nuniform vec4 projInfo;\nvec3 reconstructCSPosition(vec2 S, float z) {\nreturn vec3((S.xy * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);\n}\nvec3 reconstructCSFaceNormal(vec3 C) {\nreturn normalize(cross(dFdy(C), dFdx(C)));\n}\nvec3 reconstructNonUnitCSFaceNormal(vec3 C) {\nreturn cross(dFdy(C), dFdx(C));\n}\nvec3 getPosition(ivec2 ssP, float depth) {\nvec3 P;\nP = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);\nreturn P;\n}\nvec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {\nivec2 ssP = ivec2(ssR * unitOffset) + ssC;\nvec3 P;\nvec2 screenUV = (vec2(ssP) + vec2(0.5)) * resolution;\n#ifdef USE_MIPMAP\nint mipLevel = int(max(0.0, min(floor(log2(ssR)) - float(LOG_MAX_OFFSET), float(MAX_MIP_LEVEL))));\nif (mipLevel == 0) {\nP.z = texture2D(tDepth, screenUV).z;\nif (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n}\nelse if (mipLevel == 1)\nP.z = unpackDepthNearFar(texture2D(tDepth_mip1, screenUV));\nelse if (mipLevel == 2)\nP.z = unpackDepthNearFar(texture2D(tDepth_mip2, screenUV));\nelse if (mipLevel == 3)\nP.z = unpackDepthNearFar(texture2D(tDepth_mip3, screenUV));\nelse if (mipLevel == 4)\nP.z = unpackDepthNearFar(texture2D(tDepth_mip4, screenUV));\nelse if (mipLevel == 5)\nP.z = unpackDepthNearFar(texture2D(tDepth_mip5, screenUV));\n#else\nP.z = texture2D(tDepth, screenUV).z;\nif (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n#endif\nP = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);\nreturn P;\n}\nfloat sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {\nfloat ssR;\nvec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);\nssR *= ssDiskRadius;\nvec3 Q = getOffsetPosition(ssC, unitOffset, ssR);\nvec3 v = Q - C;\nfloat vv = dot(v, v);\nfloat vn = dot(v, n_C);\nconst float epsilon = 0.01;\nfloat f = max(radius * radius - vv, 0.0); return f * f * f * max((vn - bias) / (epsilon + vv), 0.0);\n}\nconst bool useNoise = true;\nvec2 rand( const vec2 coord ) {\nvec2 noise;\nif ( useNoise ) {\nfloat nx = dot ( coord, vec2( 12.9898, 78.233 ) );\nfloat ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\nnoise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\n} else {\nfloat ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\nfloat gg = fract( coord.t * ( size.y / 2.0 ) );\nnoise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\n}\nreturn ( noise * 2.0  - 1.0 );\n}\nfloat getRandomAngle(vec2 pos) {\nvec2 rnd = rand(pos);\nreturn atan(rnd.y, rnd.x);\n}\nvoid main() {\nivec2 ssC = ivec2(gl_FragCoord.xy);\nvec4 nrmz = texture2D(tDepth, vUv);\nif (nrmz.z == 0.0) {\ngl_FragColor.r = 1.0;\ngl_FragColor.a = 0.0;\npackKey(1.0, gl_FragColor.gb);\nreturn;\n}\nvec3 C = getPosition(ssC, nrmz.z);\npackKey(CSZToKey(C.z), gl_FragColor.gb);\nfloat randomPatternRotationAngle = getRandomAngle(vUv);\nvec3 n_C = vec3(nrmz.x, nrmz.y, sqrt(1.0 - dot(nrmz.xy, nrmz.xy)));\nfloat ssDiskRadius = -projScale * radius / mix(C.z, -1.0, isOrtho);\nfloat sum = 0.0;\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 0, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 1, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 2, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 3, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 4, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 5, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 6, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 7, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 8, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 9, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 10, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 11, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 12, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 13, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 14, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 15, randomPatternRotationAngle);\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, 16, randomPatternRotationAngle);\nfloat intensityDivR6 = intensity / pow(radius, 6.0);\nfloat A = max(0.0, 1.0 - sum * intensityDivR6 * (5.0 / float(NUM_SAMPLES)));\nif (abs(dFdx(C.z)) < 0.02) {\nA -= dFdx(A) * (mod(float(ssC.x), 2.0) - 0.5);\n}\nif (abs(dFdy(C.z)) < 0.02) {\nA -= dFdy(A) * (mod(float(ssC.y), 2.0) - 0.5);\n}\ngl_FragColor.r = A;\ngl_FragColor.a = 1.0;\n}"].join("\n")
    })
}
function init_SAOBlurShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.SAOBlurShader && (f.SAOBlurShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            size: {
                type: "v2",
                value: new THREE.Vector2(512,512)
            },
            resolution: {
                type: "v2",
                value: new THREE.Vector2(1 / 512,1 / 512)
            },
            axis: {
                type: "v2",
                value: new THREE.Vector2(1,0)
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "#define EDGE_SHARPNESS     (1.0)\n#define SCALE               (2)\n#define R                   (4)\n#define VALUE_TYPE        float\n#define VALUE_COMPONENTS   r\n#define VALUE_IS_KEY       0\n#define KEY_COMPONENTS     gb\n#if __VERSION__ >= 330\nconst float gaussian[R + 1] =\nfloat[](0.153170, 0.144893, 0.122649, 0.092902, 0.062970);  // stddev = 2.0\n#endif\nuniform sampler2D   tDiffuse;\nuniform vec2 size;\nuniform vec2 resolution;\nuniform vec2       axis;\n#define  result         gl_FragColor.VALUE_COMPONENTS\n#define  keyPassThrough gl_FragColor.KEY_COMPONENTS\nfloat unpackKey(vec2 p) {\nreturn p.x * (256.0 / 257.0) + p.y * (1.0 / 257.0);\n}\nvarying vec2 vUv;\nvoid main() {\n#   if __VERSION__ < 330\nfloat gaussian[R + 1];\n#       if R == 3\ngaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902;  // stddev = 2.0\n#       elif R == 4\ngaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902; gaussian[4] = 0.062970;  // stddev = 2.0\n#       elif R == 6\ngaussian[0] = 0.111220; gaussian[1] = 0.107798; gaussian[2] = 0.098151; gaussian[3] = 0.083953; gaussian[4] = 0.067458; gaussian[5] = 0.050920; gaussian[6] = 0.036108;\n#       endif\n#   endif\nivec2 axisi = ivec2(axis);\nivec2 ssC = ivec2(gl_FragCoord.xy);\nvec4 temp = texture2D(tDiffuse, vUv);\ngl_FragColor.gb = temp.KEY_COMPONENTS;\ngl_FragColor.a = temp.a;\nVALUE_TYPE sum = temp.VALUE_COMPONENTS;\nif (temp.a == 0.0) {\nresult = sum;\nreturn;\n}\nfloat key = unpackKey(keyPassThrough);\nfloat BASE = gaussian[0];\nfloat totalWeight = BASE;\nsum *= totalWeight;\nint r = -4; {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[4];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\nr = -3; {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[3];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\nr = -2; {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[2];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\nr=-1; {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[1];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\nr = 1; {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[1];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\nr = 2; {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[2];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\nr = 3; {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[3];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\nr = 4; {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[4];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\nconst float epsilon = 0.0001;\nresult = sum / (totalWeight + epsilon);\n}"
    })
}
function init_SAOMinifyShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.SAOMinifyFirstShader && (f.SAOMinifyFirstShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            cameraNear: {
                type: "f",
                value: 1
            },
            cameraInvNearFar: {
                type: "f",
                value: 100
            },
            resolution: {
                type: "v2",
                value: new THREE.Vector2(1 / 512,1 / 512)
            }
        },
        vertexShader: "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: ["uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraInvNearFar;", 
        PackDepthShaderChunk, "void main() {\nvec2 ssP = vec2(gl_FragCoord.xy);\nssP = ssP * 2.0 + mod(ssP, 2.0);\nssP = (ssP + 0.5) * resolution * 0.5;\nfloat depth = texture2D(tDiffuse, ssP).z;\nif (depth != 0.0)\ndepth = (depth + cameraNear) * cameraInvNearFar;\ngl_FragColor = packDepth(depth);\n}"].join("\n")
    },
    f.SAOMinifyShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            resolution: {
                type: "v2",
                value: new THREE.Vector2(1 / 512,1 / 512)
            }
        },
        vertexShader: "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvoid main() {\nvec2 ssP = vec2(gl_FragCoord.xy);\nssP = ssP * 2.0 + mod(ssP, 2.0);\nssP = (ssP + 0.5) * resolution * 0.5;\ngl_FragColor = texture2D(tDiffuse, ssP);\n}"
    })
}
function init_FireflyPhongShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.FireflyPhongShader && (f.FireflyPhongShader = {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "f",
                value: 30
            },
            reflMipIndex: {
                type: "f",
                value: 0
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1,1,1)
            },
            texMatrix: {
                type: "m3",
                value: new THREE.Matrix3
            },
            texMatrixBump: {
                type: "m3",
                value: new THREE.Matrix3
            },
            texMatrixAlpha: {
                type: "m3",
                value: new THREE.Matrix3
            },
            irradianceMap: {
                type: "t",
                value: null 
            },
            exposureBias: {
                type: "f",
                value: 1
            },
            envMapExposure: {
                type: "f",
                value: 1
            },
            cutplanes: {
                type: "v4v",
                value: []
            },
            cutplanesOutlineColor: {
                type: "v3",
                value: new THREE.Vector3(0,1,0)
            },
            hatchParams: {
                type: "v2",
                value: new THREE.Vector2(1,10)
            },
            cutplanesOutlineThickness: {
                type: "f",
                value: .001
            },
            dbId: {
                type: "v4",
                value: new THREE.Vector4(0,0,0,0)
            }
        }]),
        vertexShader: ["varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform mat3 texMatrix;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec2 vUvBump;\nuniform mat3 texMatrixBump;\n#endif\n#if defined( USE_ALPHAMAP )\nvarying vec2 vUvAlpha;\nuniform mat3 texMatrixAlpha;\n#endif\n#if defined( USE_ENVMAP )\n#if ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nuniform float refractionRatio;\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\n#endif\nuniform float logDepthBufFC;\n#endif\n#ifdef MRT_NORMALS\nvarying float depth;\n#endif", 
        PackNormalsShaderChunk, "void main() {\n#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\nvUv = (texMatrix * vec3(uv, 1.0)).xy;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvUvBump = (texMatrixBump * vec3(uv, 1.0)).xy;\n#endif\n#if defined( USE_ALPHAMAP )\nvUvAlpha = (texMatrixAlpha * vec3(uv, 1.0)).xy;\n#endif\n#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif\n#ifdef UNPACK_NORMALS\nvec3 objectNormal = decodeNormal(normal);\n#else\nvec3 objectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n#ifndef FLAT_SHADED\nvNormal = normalize( transformedNormal );\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvViewPosition = -mvPosition.xyz;\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\n#endif\n#ifdef USE_LOGDEPTHBUF\nif (projectionMatrix[3][3] == 0.0) {\ngl_Position.z = log2(max(1.0e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth = 1.0 + gl_Position.w;\n#else\ngl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n#endif\n} else {\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth = 1.0 + vViewPosition.z;\n#else\n#endif\n}\n#endif\n#ifdef MRT_NORMALS\ndepth = mvPosition.z;\n#endif\n}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n#ifdef GAMMA_INPUT\nvec3 InputToLinear(vec3 c) {\nreturn c * c;\n}\nfloat InputToLinear(float c) {\nreturn c * c;\n}\n#else\nvec3 InputToLinear(vec3 c) {\nreturn c;\n}\nfloat InputToLinear(float c) {\nreturn c;\n}\n#endif\n#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec2 vUvBump;\n#endif\n#if defined( USE_ALPHAMAP )\nvarying vec2 vUvAlpha;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#if defined(TONEMAP_OUTPUT)\nuniform float exposureBias;", 
        TonemapShaderChunk, "#endif\n#if defined(IRR_RGBM) || defined(ENV_RGBM) || defined(ENV_GAMMA) || defined(IRR_GAMMA)\nuniform float envMapExposure;\n#endif\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\nuniform vec4 dbId;\n#endif\nvec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\nvec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\nret *= ret;\nret *= exposure;\nreturn ret;\n}\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\nreturn vRGBA.xyz * vRGBA.xyz * exposure;\n}\n#ifdef USE_ENVMAP\nuniform float reflMipIndex;\nuniform float reflectivity;\nuniform samplerCube envMap;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform float refractionRatio;\n#endif\nvec3 sampleReflection(vec3 dir, float mipIndex) {\ndir.z = -dir.z;\n#ifdef ENV_GAMMA\n#ifdef HAVE_TEXTURE_LOD\nvec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\nvec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\nreturn GammaDecode(envTexColor, envMapExposure);\n#elif defined(ENV_RGBM)\n#ifdef HAVE_TEXTURE_LOD\nvec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\nvec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\nreturn RGBMDecode(envTexColor, envMapExposure);\n#else\nvec4 envTexColor = textureCube( envMap, dir );\nvec3 cubeColor = envTexColor.xyz;\n#ifdef GAMMA_INPUT\ncubeColor *= cubeColor;\n#endif\nreturn cubeColor;\n#endif\n}\n#endif\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef USE_IRRADIANCEMAP\nuniform samplerCube irradianceMap;\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying highp vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying highp vec3 vViewPosition;\n#ifndef FLAT_SHADED\nvarying highp vec3 vNormal;\n#endif\n#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUvBump );\nvec2 dSTdy = dFdy( vUvBump );\nfloat Hll = bumpScale * GET_BUMPMAP(vUvBump).x;\nfloat dBx = bumpScale * GET_BUMPMAP(vUvBump + dSTdx).x - Hll;\nfloat dBy = bumpScale * GET_BUMPMAP(vUvBump + dSTdy).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif\n#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUvBump.st );\nvec2 st1 = dFdy( vUvBump.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = GET_NORMALMAP(vUvBump).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif\n#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif\n#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif\n#ifdef HATCH_PATTERN\nuniform vec2 hatchParams;\nfloat curveGaussian(float r, float invWidth) {\nfloat amt = clamp(r * invWidth, 0.0, 1.0);\nfloat exponent = amt * 3.5;\nreturn exp(-exponent*exponent);\n}\n#endif\n#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\nvarying highp float depth;\n#define gl_FragColor gl_FragData[0]\n#endif\n#ifdef USE_LOGDEPTHBUF\nuniform float logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\n#extension GL_EXT_frag_depth : enable\nvarying highp float vFragDepth;\n#endif\n#endif\nvec3 Schlick_v3(vec3 v, float cosHV) {\nfloat facing = max(1.0 - cosHV, 0.0);\nfloat facing2 = facing * facing;\nreturn v + (1.0 - v) * facing * facing2 * facing2;\n}\nfloat Schlick_f(float v, float cosHV) {\nfloat facing = max(1.0 - cosHV, 0.0);\nfloat facing2 = facing * facing;\nreturn v + ( 1.0 - v ) * facing2 * facing2 * facing;\n}", 
        CutPlanesShaderChunk, "void main() {\n#if NUM_CUTPLANES > 0\nif (checkCutPlanes(vWorldPosition)) return;\n#endif\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );\n#ifdef USE_MAP\nvec4 texelColor = GET_MAP(vUv);\n#ifdef MAP_INVERT\ntexelColor.xyz = 1.0-texelColor.xyz;\n#endif\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif\n#ifdef USE_ALPHAMAP\nvec4 texelAlpha = GET_ALPHAMAP(vUvAlpha);\ngl_FragColor.a *= texelAlpha.r;\n#endif\n#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif\nfloat specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = GET_SPECULARMAP(vUv);\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif\n#ifndef FLAT_SHADED\nvec3 normal = normalize( vNormal );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#else\nvec3 fdx = dFdx( vViewPosition );\nvec3 fdy = dFdy( vViewPosition );\nvec3 normal = normalize( cross( fdx, fdy ) );\n#endif\nvec3 geomNormal = normal;\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\nvec3 viewDirection;\nif (projectionMatrix[3][3] == 0.0) {\nviewDirection = normalize( vViewPosition );\n} else {\nviewDirection = vec3(0.0, 0.0, 1.0);\n}\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\nfloat shininessB = shininess * 4.0;\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += InputToLinear(diffuse) * InputToLinear(pointLightColor[ i ]) * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewDirection );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininessB ), 0.0 );\nfloat specularNormalization = shininessB * 0.125 + 0.25;\nvec3 schlick = Schlick_v3(InputToLinear(specular), dot( lVector, pointHalfVector ) );\npointSpecular += schlick * InputToLinear(pointLightColor[ i ]) * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization ;\n}\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += InputToLinear(diffuse) * InputToLinear(spotLightColor[ i ]) * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewDirection );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininessB ), 0.0 );\nfloat specularNormalization = shininessB * 0.125 + 0.25;\nvec3 schlick = Schlick_v3(InputToLinear(specular), dot( lVector, spotHalfVector ) );\nspotSpecular += schlick * InputToLinear(spotLightColor[ i ]) * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += InputToLinear(diffuse) * InputToLinear(directionalLightColor[ i ]) * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewDirection );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininessB ), 0.0 );\nfloat specularNormalization = shininessB * 0.125 + 0.25;\nvec3 schlick = Schlick_v3(InputToLinear(specular), dot( dirVector, dirHalfVector ));\ndirSpecular += schlick * InputToLinear(directionalLightColor[ i ]) * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#ifdef USE_IRRADIANCEMAP\nvec3 worldNormal = mat3(viewMatrixInverse) * normal;\nvec4 cubeColor4 = textureCube(irradianceMap, vec3(worldNormal.xy, -worldNormal.z));\n#ifdef IRR_GAMMA\nvec3 indirectDiffuse = GammaDecode(cubeColor4, envMapExposure);\n#elif defined(IRR_RGBM)\nvec3 indirectDiffuse = RGBMDecode(cubeColor4, envMapExposure);\n#else\nvec3 indirectDiffuse = cubeColor4.xyz;\n#ifdef GAMMA_INPUT\nindirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\ntotalDiffuse += InputToLinear(diffuse) * indirectDiffuse;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( InputToLinear(emissive) + totalDiffuse + ambientLightColor * InputToLinear(diffuse) + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( InputToLinear(emissive) + totalDiffuse + ambientLightColor * InputToLinear(diffuse) ) + totalSpecular;\n#endif\n#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif\n#if defined(USE_ENVMAP)\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n#ifdef ENVMAP_MODE_REFLECTION\nreflectVec = reflect( -viewDirection, normal );\n#else \nreflectVec = refract( -viewDirection, normal, refractionRatio );\n#endif\n#else\nreflectVec = reflect( -viewDirection, normal );\n#endif\nreflectVec = mat3(viewMatrixInverse) * reflectVec;\nfloat reflectScale = 1.0;\nvec3 cubeColor = sampleReflection(reflectVec, reflMipIndex);\ncubeColor *= reflectScale;\nfloat facing = dot( viewDirection, geomNormal );\nif (facing < -1e-2)\nfacing = 1.0;\nelse\nfacing = max(1e-6, facing);\nvec3 schlickRefl;\n#ifdef METAL\nschlickRefl = InputToLinear(specular);\n#else\nschlickRefl = Schlick_v3(InputToLinear(specular), facing);\ngl_FragColor.a = mix(gl_FragColor.a, Schlick_f(gl_FragColor.a, facing), reflectivity);\nfloat invSchlick = (1.0 - facing * 0.5);\nfloat invSchlick2 = invSchlick * invSchlick;\nfloat norm_factor = 1.0 - invSchlick * invSchlick2 * invSchlick2;\nnorm_factor = (28.0 / 23.0) * norm_factor;\ngl_FragColor.xyz *= norm_factor * (1.0 - InputToLinear(specular));\n#endif\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl.xyz;\n#ifdef CLEARCOAT\nvec3 reflectVecClearcoat = reflect( -viewDirection, geomNormal );\nreflectVecClearcoat = mat3(viewMatrixInverse) * reflectVecClearcoat;\nvec3 cubeColorClearcoat = sampleReflection(reflectVecClearcoat, 0.0);\nfloat schlickClearcoat = Schlick_f(InputToLinear(reflectivity), facing);\ngl_FragColor.xyz = mix(gl_FragColor.xyz, cubeColorClearcoat * schlickClearcoat, 0.5);\n#endif\n#endif\n#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif\n#ifdef TONEMAP_OUTPUT\ngl_FragColor.xyz = toneMapCanonFilmic_WithGamma( exposureBias * gl_FragColor.xyz );\n#endif\n#ifdef HATCH_PATTERN\nfloat hatchSlope = hatchParams.x;\nfloat hatchPeriod = hatchParams.y;\nif (abs(hatchSlope) <= 1.0) {\nfloat hatchPhase = gl_FragCoord.y - hatchSlope * gl_FragCoord.x;\nfloat dist = abs(mod((hatchPhase), (hatchPeriod)));\nif (dist < 1.0) {\ngl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}\n} else {\nfloat hatchPhase = - gl_FragCoord.y / hatchSlope + gl_FragCoord.x;\nfloat dist = abs(mod((hatchPhase), (hatchPeriod)));\nif (dist < 1.0) {\ngl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}\n}\n#endif\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif\n#ifdef MRT_NORMALS\ngl_FragData[1] = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif\n#ifdef MRT_ID_BUFFER\n#ifdef MRT_NORMALS\nconst int index = 2;\n#else\nconst int index = 1;\n#endif\ngl_FragData[index] = vec4(dbId.rgb, 1.0);\n#elif defined(ID_COLOR)\ngl_FragColor = dbId;\n#endif\n}"].join("\n")
    },
    THREE.ShaderLib.firefly_phong = f.FireflyPhongShader)
}
function init_FireflyPrismShader() {
    function f(a) {
        var b = a + "_invert"
          , c = {};
        c[a] = {
            type: "t",
            value: null 
        };
        c[a + "_texMatrix"] = {
            type: "m3",
            value: new THREE.Matrix3
        };
        c[b] = {
            type: "i",
            value: 0
        };
        return c
    }
    function h(a) {
        var b = a + "_bumpScale"
          , c = a + "_bumpmapType"
          , d = {};
        d[a] = {
            type: "t",
            value: null 
        };
        d[a + "_texMatrix"] = {
            type: "m3",
            value: new THREE.Matrix3
        };
        d[b] = {
            type: "v2",
            value: new THREE.Vector2(1,1)
        };
        d[c] = {
            type: "i",
            value: 0
        };
        return d
    }
    function g(a) {
        return ["#if defined( USE_SURFACE_ALBEDO_MAP ) || defined( USE_SURFACE_ROUGHNESS_MAP ) || defined( USE_SURFACE_CUTOUT_MAP ) || defined( USE_SURFACE_ANISOTROPY_MAP ) || defined( USE_SURFACE_ROTATION_MAP ) || defined( USE_OPAQUE_ALBEDO_MAP ) || defined( USE_OPAQUE_F0_MAP ) || defined( USE_OPAQUE_LUMINANCE_MODIFIER_MAP ) || defined( USE_LAYERED_BOTTOM_F0_MAP ) || defined( USE_LAYERED_F0_MAP ) || defined( USE_LAYERED_DIFFUSE_MAP ) || defined( USE_LAYERED_FRACTION_MAP ) || defined( USE_LAYERED_ROUGHNESS_MAP ) || defined( USE_LAYERED_ANISOTROPY_MAP ) || defined( USE_LAYERED_ROTATION_MAP ) || defined( USE_METAL_F0_MAP ) || defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP )", a, 
        "#endif"].join("\n")
    }
    function d(a, b, c, d) {
        var f = c ? "_v3" : ""
          , g = c ? "vec3 " : "";
        c = c ? b + " = averageOfFloat3(" + b + f + ");" : "";
        d = d ? b + f + " = SRGBToLinear(" + b + f + ");" : "";
        return ["#if defined( USE_" + a.toUpperCase() + "_MAP )", "vec2 uv_" + a + "_map = (" + a + "_map_texMatrix * vec3(vUv, 1.0)).xy;", g + b + f + " = texture2D(" + a + "_map, uv_" + a + "_map).xyz;", d, "if(" + a + "_map_invert) " + b + f + " = vec3(1.0) - " + b + f + ";", c, "#else", b + " = " + a + ";", "#endif"].join("\n")
    }
    function c(a) {
        var b = a + "_texMatrix"
          , c = a + "_invert";
        return ["#if defined( " + ("USE_" + 
        a).toUpperCase() + " )", "uniform sampler2D " + a + ";", "uniform mat3 " + b + ";", "uniform bool " + c + ";", "#endif"].join("\n")
    }
    function a(a) {
        var b = a + "_texMatrix"
          , c = a + "_bumpScale"
          , d = a + "_bumpmapType";
        return ["#if defined( " + ("USE_" + a).toUpperCase() + " )", "uniform sampler2D " + a + ";", "uniform mat3 " + b + ";", "uniform vec2 " + c + ";", "uniform int " + d + ";", "#endif"].join("\n")
    }
    var b = Teratek.Viewing.Shaders
      , k = Teratek.Viewing.Private;
    "undefined" === typeof b.PrismShader && (b.PrismShader = {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, 
        THREE.UniformsLib.lights, f("surface_albedo_map"), f("surface_roughness_map"), f("surface_cutout_map"), f("surface_anisotropy_map"), f("surface_rotation_map"), f("opaque_albedo_map"), f("opaque_f0_map"), f("opaque_luminance_modifier_map"), f("layered_bottom_f0_map"), f("layered_f0_map"), f("layered_diffuse_map"), f("layered_fraction_map"), f("layered_roughness_map"), f("layered_anisotropy_map"), f("layered_rotation_map"), f("metal_f0_map"), h("surface_normal_map"), h("layered_normal_map"), {
            surface_albedo: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            surface_roughness: {
                type: "f",
                value: 1
            },
            surface_anisotropy: {
                type: "f",
                value: 1
            },
            surface_rotation: {
                type: "f",
                value: 1
            },
            opaque_albedo: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            opaque_f0: {
                type: "f",
                value: 1
            },
            opaque_luminance_modifier: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            opaque_luminance: {
                type: "f",
                value: 1
            },
            metal_f0: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            layered_f0: {
                type: "f",
                value: 1
            },
            layered_diffuse: {
                type: "c",
                value: new THREE.Color(0)
            },
            layered_fraction: {
                type: "f",
                value: 1
            },
            layered_bottom_f0: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            layered_roughness: {
                type: "f",
                value: 1
            },
            layered_anisotropy: {
                type: "f",
                value: 1
            },
            layered_rotation: {
                type: "f",
                value: 1
            },
            transparent_ior: {
                type: "f",
                value: 2
            },
            transparent_color: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            transparent_distance: {
                type: "f",
                value: 1
            },
            irradianceMap: {
                type: "t",
                value: null 
            },
            envMap: {
                type: "t",
                value: null 
            },
            exposureBias: {
                type: "f",
                value: 1
            },
            envMapExposure: {
                type: "f",
                value: 1
            },
            envExponentMin: {
                type: "f",
                value: 1
            },
            envExponentMax: {
                type: "f",
                value: 512
            },
            envExponentCount: {
                type: "f",
                value: 10
            },
            cutplanes: {
                type: "v4v",
                value: []
            },
            cutplanesOutlineColor: {
                type: "v3",
                value: new THREE.Vector3(0,1,0)
            },
            hatchParams: {
                type: "v2",
                value: new THREE.Vector2(1,10)
            },
            cutplanesOutlineThickness: {
                type: "f",
                value: .001
            }
        }]),
        vertexShader: ["varying vec3 vViewPosition;\nvarying vec3 vNormal;\nuniform mat4 viewMatrixInverse;\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif", g("varying vec2 vUv;"), "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;\n#endif\nuniform float logDepthBufFC;\n#endif\n#ifdef MRT_NORMALS\nvarying float depth;\n#endif\n#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP ) || MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\nvoid ComputeTangents(vec3 normal, out vec3 u, out vec3 v)\n{\n    float scale = normal.z < 0.0 ? -1.0 : 1.0;\n    vec3 temp = scale * normal;\n    float e    = temp.z;\n    float h    = 1.0/(1.0 + e);\n    float hvx  = h   *  temp.y;\n    float hvxy = hvx * -temp.x;\n    u = vec3(e + hvx * temp.y, hvxy,                -temp.x);\n    v = vec3(hvxy,             e + h * temp.x * temp.x, -temp.y);\n    u *= scale;\n    v *= scale;\n}\n#endif", 
        PackNormalsShaderChunk, "void main() {", g("vUv = uv;"), "#ifdef UNPACK_NORMALS\nvec3 objectNormal = decodeNormal(normal);\n#else\nvec3 objectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\nvNormal = normalize( transformedNormal );\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvViewPosition = -mvPosition.xyz;\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\n#endif\n#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP ) || MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\n vec3 Tu, Tv;\nComputeTangents(vNormal, Tu, Tv);\nvTangent = Tu;\nvBitangent = Tv;\n#endif\n#ifdef USE_LOGDEPTHBUF\nif (projectionMatrix[3][3] == 0.0) {\ngl_Position.z = log2(max(1.0e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth = 1.0 + gl_Position.w;\n#else\ngl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n#endif\n} else {\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth = 1.0 + vViewPosition.z;\n#else\n#endif\n}\n#endif\n#ifdef MRT_NORMALS\ndepth = mvPosition.z;\n#endif\n}"].join("\n"),
        fragmentShader: ["#define PI 3.141592654\nuniform vec3 surface_albedo;\nuniform float surface_roughness;\nuniform float surface_anisotropy;\nuniform float surface_rotation;\n#if defined( PRISMOPAQUE )\nuniform vec3 opaque_albedo;\nuniform float opaque_f0;\nuniform vec3 opaque_luminance_modifier;\nuniform float opaque_luminance;\n#elif defined( PRISMMETAL )\nuniform vec3 metal_f0;\n#elif defined( PRISMLAYERED )\nuniform float layered_f0;\nuniform vec3 layered_diffuse;\nuniform float layered_fraction;\nuniform vec3 layered_bottom_f0;\nuniform float layered_roughness;\nuniform float layered_anisotropy;\nuniform float layered_rotation;\n#elif defined( PRISMTRANSPARENT )\nuniform float transparent_ior;\nuniform vec3 transparent_color;\nuniform float transparent_distance;\n#endif\nuniform float envExponentMin;\nuniform float envExponentMax;\nuniform float envExponentCount;\n#if defined(TONEMAP_OUTPUT)\nuniform float exposureBias;", 
        TonemapShaderChunk, "#endif\n#if defined(MRT_NORMALS) || defined(MRT_ID_BUFFER)\nvarying highp float depth;\n#define gl_FragColor gl_FragData[0]\n#endif\n#if MAX_SPOT_LIGHTS > 0 || NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\n#ifdef USE_LOGDEPTHBUF\nuniform float logDepthBufFC;\n#ifdef USE_LOGDEPTHBUF_EXT\n#extension GL_EXT_frag_depth : enable\nvarying highp float vFragDepth;\n#endif\n#endif\n#if defined(MRT_ID_BUFFER) || defined(ID_COLOR)\nuniform vec4 dbId;\n#endif", g("varying vec2 vUv;"), 
        c("surface_albedo_map"), c("surface_roughness_map"), c("surface_cutout_map"), c("surface_anisotropy_map"), c("surface_rotation_map"), c("opaque_albedo_map"), c("opaque_f0_map"), c("opaque_luminance_modifier_map"), c("layered_bottom_f0_map"), c("layered_f0_map"), c("layered_diffuse_map"), c("layered_fraction_map"), c("layered_roughness_map"), c("layered_anisotropy_map"), c("layered_rotation_map"), c("metal_f0_map"), a("surface_normal_map"), a("layered_normal_map"), "vec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\nvec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\nret *= ret;\nret *= exposure;\nreturn ret;\n}\nvec3 GammaDecode(in vec4 vRGBA, in float exposure) {\nreturn vRGBA.xyz * vRGBA.xyz * exposure;\n}\nfloat SRGBToLinearComponent(float color) {\nfloat result = color;\nif (result<=0.04045)\nresult /= 12.92;\nelse\nresult = pow(abs((result+0.055)/1.055), 2.4);\nreturn result;\n}\nvec3 SRGBToLinear(vec3 color) {\nvec3 result = color;\nresult.x = SRGBToLinearComponent(result.x);\nresult.y = SRGBToLinearComponent(result.y);\nresult.z = SRGBToLinearComponent(result.z);\nreturn result;\n}\n#if defined( USE_ENVMAP )\nuniform float envMapExposure;\nuniform samplerCube envMap;\n#endif\nfloat averageOfFloat3(in vec3 value)\n{ \n    const float oneThird = 1.0 / 3.0; \n    return dot(value, vec3(oneThird, oneThird, oneThird)); \n} \n#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP ) || MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\nvec3 heightMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 Tw, vec3 Bw, vec3 Nw) {\nvec2 st = (transform * vec3(uv, 1.0)).xy;\nmat3 mtxTangent = mat3(Tw, Bw, Nw);\nTw = normalize(mtxTangent * (transform * vec3(1.0, 0.0, 0.0)));\nBw = normalize(mtxTangent * (transform * vec3(0.0, 1.0, 0.0)));\nconst float oneThird = 1.0 / 3.0;\nvec3 avg = vec3(oneThird, oneThird, oneThird);\nvec2 offset = fwidth(st);\nfloat h0 = dot(texture2D(bumpTexture, st).xyz, avg);\nfloat hx = dot(texture2D(bumpTexture, st + vec2(offset.x, 0.0)).xyz, avg);\nfloat hy = dot(texture2D(bumpTexture, st + vec2(0.0, offset.y)).xyz, avg);\nvec2 diff = vec2(h0 - hx, h0 - hy) / offset;\nreturn normalize(Nw + (diff.x * Tw * bumpScale.x + diff.y * Bw * bumpScale.y));\n}\nvec3 normalMapTransform(sampler2D bumpTexture, vec2 uv, mat3 transform, vec2 bumpScale, vec3 Tw, vec3 Bw, vec3 Nw) {\nvec2 st = (transform * vec3(uv, 1.0)).xy;\nvec3 N =  2.0 * texture2D( bumpTexture, st ).xyz - 1.0; \nreturn normalize(bumpScale.x * (N.x * Tw + N.y * Bw) + N.z * Nw);\n}\n#endif\n#if defined( USE_ENVMAP )\nvec3 sampleReflection(vec3 N, vec3 V, float mipIndex) {\nvec3 dir = (2.0 * dot(V, N)) * N - V;\ndir = mat3(viewMatrixInverse) * dir;\ndir.z = -dir.z;\n#ifdef ENV_GAMMA\n#ifdef HAVE_TEXTURE_LOD\nvec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\nvec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\nreturn GammaDecode(envTexColor, envMapExposure);\n#elif defined(ENV_RGBM)\n#ifdef HAVE_TEXTURE_LOD\nvec4 envTexColor = textureCubeLodEXT( envMap, dir, mipIndex );\n#else\nvec4 envTexColor = textureCube( envMap, dir, mipIndex );\n#endif\nreturn RGBMDecode(envTexColor, envMapExposure);\n#else\nvec4 envTexColor = textureCube( envMap, dir );\nvec3 cubeColor = envTexColor.xyz;\n#ifdef GAMMA_INPUT\ncubeColor *= cubeColor;\n#endif\nreturn cubeColor;\n#endif\n}\n#endif\n#ifdef HATCH_PATTERN\nuniform vec2 hatchParams;\nfloat curveGaussian(float r, float invWidth) {\nfloat amt = clamp(r * invWidth, 0.0, 1.0);\nfloat exponent = amt * 3.5;\nreturn exp(-exponent*exponent);\n}\n#endif\n#if defined( USE_ENVMAP ) && defined( USE_IRRADIANCEMAP )\nuniform samplerCube irradianceMap;\nvec3 sampleNormal(vec3 normal) {\nvec3 worldNormal = mat3(viewMatrixInverse) * normal;\nvec4 cubeColor4 = textureCube(irradianceMap, vec3(worldNormal.xy, -worldNormal.z));\n#ifdef IRR_GAMMA\nvec3 indirectDiffuse = GammaDecode(cubeColor4, envMapExposure);\n#elif defined(IRR_RGBM)\nvec3 indirectDiffuse = RGBMDecode(cubeColor4, envMapExposure);\n#else\nvec3 indirectDiffuse = cubeColor4.xyz;\n#ifdef GAMMA_INPUT\nindirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\nreturn indirectDiffuse;}\n#endif\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\nfloat sqr(float x) {return x*x;}\nfloat aSqrd(float maxAlphaSqr, float cosTheta)\n{\n   float tan2 = 1.0/sqr(cosTheta) - 1.0;\n   return maxAlphaSqr * tan2;\n}\nvec3 Fresnel_Schlick(vec3 f0, float cosAngle)\n{\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    return f0 + (1.0 - f0) * x5;\n}\nvec3 Fresnel_Rough(vec3 f0, float cosAngle, float alpha)\n{\n    float x = 1.0 - cosAngle;\n    float x2 = x * x;\n    float x5 = x * x2 * x2;\n    vec3 maxReflectance = mix(vec3(1.0), f0, vec3(min(0.7, alpha)) / 0.7);\n    return f0 + (maxReflectance - f0) * x5;\n}\nfloat IORToReflectance(float ior)\n{\n    return sqr((1.0 - ior)/(1.0 + ior));\n}\nvec2 RoughnessToAlpha(float roughness, float anisotropy)\n{\n    vec2 alpha = roughness * vec2(1.0, 1.0 - anisotropy);\n    alpha = alpha * alpha;\n    alpha = clamp(alpha, 0.001, 1.0);\n    return alpha;\n}\nfloat AlphaToPhong(float alpha)\n{\n    return max(0.0, 2.56/alpha - 7.0);\n}\nfloat ExponentToReflMipIndex(float exponent)\n{\n    float targetLog = log2(exponent);\n    float minLog = log2(envExponentMin); \n    float maxLog = log2(envExponentMax); \n    float deltaLog = clamp(targetLog - minLog, 0.0, maxLog - minLog);  \n    float level = clamp((1.0-(deltaLog + 0.5) / envExponentCount), 0.0, 1.0) * 6.0; \n    return level; \n}\n#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\nvec3 DiffuseLobe(vec3 diffuseColor)\n{\nreturn diffuseColor / PI;\n}\nvec3 Rotate(vec3 vec, float angle)\n{\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec3(vec.x * c - vec.y * s, vec.x * s + vec.y * c, vec.z);\n}\nfloat NDF_GGX(float alphaU, float alphaV, vec3 normal)\n{\nfloat nx2 = sqr(normal.x);\nfloat ny2 = sqr(normal.y);\nfloat nz2 = sqr(normal.z);\nfloat scale = 1.0/(alphaU * alphaV * PI);\nreturn scale/sqr(nx2/sqr(alphaU) + ny2/sqr(alphaV) + nz2);\n}\nfloat G1_GGX(float aSqrd)\n{\n    return 2.0 / (1.0 + sqrt(1.0 + aSqrd));\n}\nvec3 MicrofacetLobe(\nvec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH,\nfloat roughness, float anisotropy, float rotation, vec3 reflectance)\n{\nvec2 alpha = RoughnessToAlpha(roughness, anisotropy);\nHlocal = Rotate(Hlocal, rotation);\nvec3 F = Fresnel_Schlick(reflectance, VdotH);\nfloat D = NDF_GGX(alpha.x, alpha.y, Hlocal);\nfloat alpha2 = max(sqr(alpha.x), sqr(alpha.y));\nfloat alpha2NL = aSqrd(alpha2, NdotL);\nfloat alpha2NV = aSqrd(alpha2, NdotV);\nfloat G = G1_GGX(alpha2NL) * G1_GGX(alpha2NV);\nreturn max(F * D * G / (4.0 * NdotL * NdotV), vec3(0.0));\n}\n#if defined( PRISMOPAQUE )\nvec3 BRDF_Opaque(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n                 vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, \n                 float opaqueF0, vec3 opaqueAlbedo)\n{\n    vec3 diffuse = DiffuseLobe(opaqueAlbedo);\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n        Hlocal, NdotL, NdotH, NdotV, VdotH,\n        surfaceRoughness, surfaceAnisotropy, surfaceRotation, vec3(opaqueF0));\n    return (specular+diffuse)*NdotL;\n}\n#elif defined( PRISMMETAL )\nvec3 BRDF_Metal(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n                vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation, \n                vec3 metalF0)\n{\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n        Hlocal, NdotL, NdotH, NdotV, VdotH,\n        surfaceRoughness, surfaceAnisotropy, surfaceRotation, metalF0);\n    return specular*NdotL;\n}\n#elif defined( PRISMLAYERED )\nvec3 BRDF_Layered(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n                  vec3 Hlocal2, float N2dotL, float N2dotH, float N2dotV, \n                  vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation,\n                  float layeredF0, vec3 layeredDiffuse, float layeredRoughness, float layeredAnisotropy,\n                  float layeredRotation, vec3 bottom_f0, float layeredFraction)\n{\n    vec3 Fl = Fresnel_Schlick(vec3(layeredF0), NdotL);\n    vec3 Fv = Fresnel_Schlick(vec3(layeredF0), NdotV);\n    vec3 amount = (1.0 - Fl) * (1.0 - Fv);\n    vec3 topSpecular = surfaceAlbedo * MicrofacetLobe(\n        Hlocal, NdotL, NdotH, NdotV, VdotH,\n        surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n        vec3(layeredF0));\n    vec3 topDiffuse = DiffuseLobe(layeredDiffuse);\n    vec3 botSpecular = MicrofacetLobe(\n        Hlocal2, N2dotL, N2dotH, N2dotV, VdotH,\n        layeredRoughness, layeredAnisotropy, layeredRotation,\n        bottom_f0);\n    return topSpecular*NdotL + amount * mix(topDiffuse*NdotL, botSpecular*N2dotL, layeredFraction);\n}\n#elif defined( PRISMTRANSPARENT )\nvec3 BRDF_Transparent(vec3 Hlocal, float NdotL, float NdotH, float NdotV, float VdotH, \n                vec3 surfaceAlbedo, float surfaceRoughness, float surfaceAnisotropy, float surfaceRotation)\n{\n    vec3 reflectance = vec3(IORToReflectance(transparent_ior));\n    vec3 specular = surfaceAlbedo * MicrofacetLobe(\n        Hlocal, NdotL, NdotH, NdotV, VdotH,\n        surfaceRoughness, surfaceAnisotropy, surfaceRotation, reflectance);\n    return specular*NdotL;\n}\n#endif\n#endif\n#if defined( USE_ENVMAP )\n#if defined( PRISMOPAQUE )\nvec3 Environment_Opaque(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness,\n                        float opaqueF0, vec3 opaqueAlbedo)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 F = Fresnel_Rough(vec3(opaqueF0), NdotV, alpha);\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 diffuse = (1.0 - F) * opaqueAlbedo * envIrradiance;\n     vec3 luminanceModifier;", 
        d("opaque_luminance_modifier", "luminanceModifier", !1, !0), "    vec3 emission = luminanceModifier * opaque_luminance;\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F* surfaceAlbedo * envSpecular;\n    return diffuse + specular + emission;\n}\n#elif defined( PRISMMETAL )\nvec3 Environment_Metal(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness, vec3 metalF0)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 F = Fresnel_Rough(metalF0, NdotV, alpha);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n    return specular;\n}\n#elif defined( PRISMLAYERED )\nvec3 Environment_Layered(vec3 N, vec3 V, float NdotV, vec3 N2, float N2dotV, vec3 surfaceAlbedo, float surfaceRoughness,\n                         float layeredF0, vec3 layeredDiffuse, float layeredRoughness, float layeredAnisotropy,\n                         float layeredRotation, vec3 bottom_f0, float layeredFraction)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 F = Fresnel_Schlick(vec3(layeredF0), NdotV);\n    vec3 topSpecular = F * surfaceAlbedo * envSpecular;\n    vec3 amount = (1.0 - F);\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 topDiffuse = layeredDiffuse * envIrradiance;\n    alpha = RoughnessToAlpha(layeredRoughness, 0.0).x;\n    exponent = AlphaToPhong(alpha);\n    reflMipIndex = ExponentToReflMipIndex(exponent);\n    envSpecular = sampleReflection(N2, V, reflMipIndex);\n    F = Fresnel_Rough(bottom_f0, N2dotV, alpha);\n    vec3 botSpecular = F * envSpecular;\n    return topSpecular + amount * mix(topDiffuse, botSpecular, layeredFraction);\n}\n#elif defined( PRISMTRANSPARENT )\nvec3 Environment_Transparent(vec3 N, vec3 V, float NdotV, vec3 surfaceAlbedo, float surfaceRoughness)\n{\n    float alpha = RoughnessToAlpha(surfaceRoughness, 0.0).x;\n    float exponent = AlphaToPhong(alpha);\n    float reflMipIndex = ExponentToReflMipIndex(exponent);\n    vec3 reflectance = vec3(IORToReflectance(transparent_ior));\n    vec3 F = Fresnel_Rough(reflectance, NdotV, alpha);\n    vec3 envSpecular = sampleReflection(N, V, reflMipIndex);\n    vec3 specular = F * surfaceAlbedo * envSpecular;\n#if defined( USE_IRRADIANCEMAP )\n    vec3 envIrradiance = sampleNormal(N);\n#else\n    vec3 envIrradiance = vec3(1.0);\n#endif\n    vec3 color = 0.5 * (1.0 - F) * transparent_color * envIrradiance;\n    return specular + color;\n}\n#endif\n#endif\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;", 
        CutPlanesShaderChunk, "void main() {\n#if NUM_CUTPLANES > 0\nif (checkCutPlanes(vWorldPosition)) return;\n#endif\nvec3 N = normalize(vNormal);\n#if defined( USE_SURFACE_NORMAL_MAP ) || defined( USE_LAYERED_NORMAL_MAP ) || MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\nvec3 Tu = normalize(vTangent);\nvec3 Tv = normalize(vBitangent);\n#endif\nvec3 V = normalize(vViewPosition);\nN = faceforward(N, -V, N);\n#if defined(PRISMLAYERED)\nvec3 N2 = N;\n#endif\n#ifndef FLAT_SHADED\nvec3 normal = normalize( vNormal );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#else\nvec3 fdx = dFdx( vViewPosition );\nvec3 fdy = dFdy( vViewPosition );\nvec3 normal = normalize( cross( fdx, fdy ) );\n#endif\nvec3 geomNormal = normal;\n#if defined( USE_SURFACE_NORMAL_MAP )\nif (surface_normal_map_bumpmapType == 0)\n     N = heightMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\nelse\n     N = normalMapTransform(surface_normal_map, vUv, surface_normal_map_texMatrix, surface_normal_map_bumpScale, Tu, Tv, N);\n#endif\n#if defined( USE_LAYERED_NORMAL_MAP )\nif (layered_normal_map_bumpmapType == 0)\n     N2 = heightMapTransform(layered_normal_map, vUv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);\nelse\n     N2 = normalMapTransform(layered_normal_map, vUv, layered_normal_map_texMatrix, layered_normal_map_bumpScale, Tu, Tv, N2);\n#endif\nfloat NdotV = dot(N, V);\n#if defined(PRISMLAYERED)\nfloat N2dotV = dot(N2, V);\n#endif\nvec3 surfaceAlbedo;", 
        d("surface_albedo", "surfaceAlbedo", !1, !0), "float surfaceRoughness;", d("surface_roughness", "surfaceRoughness", !0, !1), "float surfaceAnisotropy;", d("surface_anisotropy", "surfaceAnisotropy", !0, !1), "float surfaceRotation;", d("surface_rotation", "surfaceRotation", !0, !1), "#if defined(PRISMOPAQUE)\nfloat opaqueF0;", d("opaque_f0", "opaqueF0", !0, !1), "vec3 opaqueAlbedo;", d("opaque_albedo", "opaqueAlbedo", !1, !0), "#elif defined(PRISMMETAL)\nvec3 metalF0;", d("metal_f0", "metalF0", !1, !0), "#elif defined(PRISMLAYERED)\nfloat layeredF0;", 
        d("layered_f0", "layeredF0", !0, !1), "vec3 layeredDiffuse;", d("layered_diffuse", "layeredDiffuse", !1, !0), "float layeredRoughness;", d("layered_roughness", "layeredRoughness", !0, !1), "float layeredAnisotropy;", d("layered_anisotropy", "layeredAnisotropy", !0, !1), "float layeredRotation;", d("layered_rotation", "layeredRotation", !0, !1), "vec3 bottom_f0;", d("layered_bottom_f0", "bottom_f0", !1, !0), "float layeredFraction;", d("layered_fraction", "layeredFraction", !0, !1), "#endif\nvec3 outRadianceLight = vec3(0.0);\n#if MAX_DIR_LIGHTS > 0 || MAX_POINT_LIGHTS > 0 || MAX_SPOT_LIGHTS > 0\nvec3 lightDirection[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];\nvec3 lightColor[ MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS ];\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nlightDirection[i] = normalize( lDirection.xyz );\nlightColor[i] = SRGBToLinear(directionalLightColor[ i ]);\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nlightDirection[MAX_DIR_LIGHTS + i] = normalize( lVector );\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlightColor[MAX_DIR_LIGHTS + i] = SRGBToLinear(pointLightColor[ i ]) * lDistance;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nlightDirection[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = normalize( lVector );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] )\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nlightColor[MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + i] = SRGBToLinear(spotLightColor[ i ]) * lDistance * spotEffect;\n}\n#endif\nfor( int i = 0; i < MAX_DIR_LIGHTS + MAX_POINT_LIGHTS + MAX_SPOT_LIGHTS; i ++ ) {\nvec3 L = lightDirection[i];\nfloat NdotL = dot(N, L);\nvec3 H = normalize(L + V);\nfloat NdotH = dot(N, H);\nfloat VdotH = dot(V, H);\nfloat Hu = dot(H, Tu);\nfloat Hv = dot(H, Tv);\nvec3 Hlocal = vec3(Hu, Hv, NdotH);\n#if defined(PRISMLAYERED)\nfloat N2dotL = dot(N2, L);\nfloat N2dotH = dot(N2, H);\nvec3 Hlocal2 = vec3(Hu, Hv, N2dotH);\n#endif\nvec3 brdf = lightColor[i] * \n#if defined(PRISMOPAQUE)\n    BRDF_Opaque(Hlocal, NdotL, NdotH, NdotV, VdotH,\n                surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                opaqueF0, opaqueAlbedo);\n#elif defined(PRISMMETAL)\n    BRDF_Metal(Hlocal, NdotL, NdotH, NdotV, VdotH, \n               surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation, \n               metalF0);\n#elif defined(PRISMLAYERED)\n    BRDF_Layered(Hlocal, NdotL, NdotH, NdotV, VdotH, Hlocal2, N2dotL, N2dotH, N2dotV,\n                 surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation,\n                 layeredF0, layeredDiffuse, layeredRoughness, layeredAnisotropy,\n                 layeredRotation, bottom_f0, layeredFraction);\n#elif defined(PRISMTRANSPARENT)\n    BRDF_Transparent(Hlocal, NdotL, NdotH, NdotV, VdotH, surfaceAlbedo, surfaceRoughness, surfaceAnisotropy, surfaceRotation);\n#endif\noutRadianceLight += max(vec3(0.0), brdf);\n}\n#endif\nvec3 outRadianceEnv = vec3(0.0);\n#if defined( USE_ENVMAP )\noutRadianceEnv =\n#if defined(PRISMOPAQUE)\n    Environment_Opaque(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,\n                        opaqueF0, opaqueAlbedo);\n#elif defined(PRISMMETAL)\n    Environment_Metal(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness, metalF0);\n#elif defined(PRISMLAYERED)\n    Environment_Layered(N, V, clamp(NdotV, 0.0, 1.0), N2, clamp(N2dotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness,\n                layeredF0, layeredDiffuse, layeredRoughness, layeredAnisotropy,\n                layeredRotation, bottom_f0, layeredFraction);\n#elif defined(PRISMTRANSPARENT)\n    Environment_Transparent(N, V, clamp(NdotV, 0.0, 1.0), surfaceAlbedo, surfaceRoughness);\n#endif\n#endif\nfloat opacity = 1.0;\nfloat surface_cutout = 1.0;", 
        d("surface_cutout", "surface_cutout", !0, !1), "#if defined( USE_SURFACE_CUTOUT_MAP )\nif(surface_cutout < 0.01) discard;\n#endif\n#if defined(PRISMTRANSPARENT)\nif (transparent_ior == 1.0 && transparent_color == vec3(1.0,1.0,1.0))\nopacity = 0.0;\nelse\nopacity = max(0.5, mix(1.0, surfaceRoughness, NdotV));\n#endif\ngl_FragColor = vec4( outRadianceLight + outRadianceEnv, opacity*surface_cutout );\n#ifdef TONEMAP_OUTPUT\ngl_FragColor.xyz = toneMapCanonFilmic_WithGamma( exposureBias * gl_FragColor.xyz );\n#endif\n#ifdef HATCH_PATTERN\nfloat hatchSlope = hatchParams.x;\nfloat hatchPeriod = hatchParams.y;\nif (abs(hatchSlope) <= 1.0) {\nfloat hatchPhase = gl_FragCoord.y - hatchSlope * gl_FragCoord.x;\nfloat dist = abs(mod((hatchPhase), (hatchPeriod)));\nif (dist < 1.0) {\ngl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}\n} else {\nfloat hatchPhase = - gl_FragCoord.y / hatchSlope + gl_FragCoord.x;\nfloat dist = abs(mod((hatchPhase), (hatchPeriod)));\nif (dist < 1.0) {\ngl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}\n}\n#endif\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif\n#ifdef MRT_NORMALS\ngl_FragData[1] = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif\n#ifdef MRT_ID_BUFFER\n#ifdef MRT_NORMALS\nconst int index = 2;\n#else\nconst int index = 1;\n#endif\ngl_FragData[index] = vec4(dbId.rgb, 1.0);\n#elif defined(ID_COLOR)\ngl_FragColor = dbId;\n#endif\n}"].join("\n")
    },
    THREE.ShaderLib.prism = b.PrismShader,
    k.createPrismMaterial = function() {
        var a = new THREE.ShaderMaterial({
            uniforms: THREE.UniformsUtils.clone(b.PrismShader.uniforms),
            vertexShader: b.PrismShader.vertexShader,
            fragmentShader: b.PrismShader.fragmentShader
        });
        a.mapList = {};
        a.isPrismMaterial = !0;
        a.color = new THREE.Color(0,0,0);
        a.specular = new THREE.Color(0,0,0);
        return a
    }
    ,
    k.clonePrismMaterial = function(a) {
        var b = k.createPrismMaterial();
        b.mapList = a.mapList;
        b.prismType = a.prismType;
        b.surface_albedo = a.surface_albedo;
        b.surface_albedo_map = 
        a.surface_albedo_map;
        b.surface_roughness = a.surface_roughness;
        b.surface_roughness_map = a.surface_roughness_map;
        b.surface_anisotropy = a.surface_anisotropy;
        b.surface_anisotropy_map = a.surface_anisotropy_map;
        b.surface_rotation = a.surface_rotation;
        b.surface_rotation_map = a.surface_rotation_map;
        b.surface_cutout_map = a.surface_cutout_map;
        b.surface_normal_map = a.surface_normal_map;
        b.color = (new THREE.Color).copy(a.color);
        b.specular = (new THREE.Color).copy(a.specular);
        switch (b.prismType) {
        case "PrismOpaque":
            b.opaque_albedo = 
            (new THREE.Color).copy(a.opaque_albedo);
            b.opaque_luminance_modifier = (new THREE.Color).copy(a.opaque_luminance_modifier);
            b.opaque_f0 = a.opaque_f0;
            b.opaque_luminance = a.opaque_luminance;
            b.opaque_albedo_map = a.opaque_albedo_map;
            b.opaque_luminance_modifier_map = a.opaque_luminance_modifier_map;
            b.opaque_f0_map = a.opaque_f0_map;
            break;
        case "PrismMetal":
            b.metal_f0 = (new THREE.Color).copy(a.metal_f0);
            b.metal_f0_map = a.metal_f0_map;
            break;
        case "PrismLayered":
            b.layered_f0 = a.layered_f0;
            b.layered_diffuse = (new THREE.Color).copy(a.layered_diffuse);
            b.layered_fraction = a.layered_fraction;
            b.layered_bottom_f0 = (new THREE.Color).copy(a.layered_bottom_f0);
            b.layered_roughness = a.layered_roughness;
            b.layered_anisotropy = a.layered_anisotropy;
            b.layered_rotation = a.layered_rotation;
            b.layered_bottom_f0_map = a.layered_bottom_f0_map;
            b.layered_f0_map = a.layered_f0_map;
            b.layered_diffuse_map = a.layered_diffuse_map;
            b.layered_fraction_map = a.layered_fraction_map;
            b.layered_rotationlayered_roughness_map = a.layered_rotationlayered_roughness_map;
            b.layered_anisotropy_map = a.layered_anisotropy_map;
            b.layered_rotation_map = a.layered_rotation_map;
            b.layered_normal_map = a.layered_normal_map;
            break;
        case "PrismTransparent":
            b.transparent_color = (new THREE.Color).copy(a.transparent_color);
            b.transparent_distance = a.transparent_distance;
            b.transparent_ior = a.transparent_ior;
            break;
        default:
            console.warn("Unknown prism type: " + a.prismType)
        }
        b.envExponentMin = a.envExponentMin;
        b.envExponentMax = a.envExponentMax;
        b.envExponentCount = a.envExponentCount;
        b.envMap = a.envMap;
        b.defines = a.defines;
        return b
    }
    )
}
function init_NormalsShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.NormalsShader && (f.NormalsShader = {
        uniforms: {
            cutplanes: {
                type: "v4v",
                value: []
            }
        },
        vertexShader: ["varying vec3 vNormal;\nvarying float depth;\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif", PackNormalsShaderChunk, "void main() {\n#ifdef UNPACK_NORMALS\nvec3 objectNormal = decodeNormal(normal);\n#else\nvec3 objectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\nvNormal = normalize( transformedNormal );\n#if NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ndepth = mvPosition.z;\nvec4 p_Position = projectionMatrix * mvPosition;\ngl_Position = p_Position;\n}"].join("\n"),
        fragmentShader: ["varying highp vec3 vNormal;\nvarying highp float depth;\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif", CutPlanesShaderChunk, "void main() {\n#if NUM_CUTPLANES > 0\nif (checkCutPlanes(vWorldPosition)) return;\n#endif\nvec3 n = vNormal;\nn = n * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nn = normalize( n );\ngl_FragColor = vec4(n.x, n.y, depth, 1.0);\n}"].join("\n")
    })
}
function init_BackgroundShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.BackgroundShader && (f.BackgroundShader = {
        uniforms: {
            color1: {
                type: "v3",
                value: new THREE.Vector3(41 / 255,76 / 255,120 / 255)
            },
            color2: {
                type: "v3",
                value: new THREE.Vector3(1 / 255,2 / 255,3 / 255)
            },
            irradianceMap: {
                type: "t",
                value: 1
            },
            exposure: {
                type: "f",
                value: 1
            },
            uCamDir: {
                type: "v3",
                value: new THREE.Vector3
            },
            uCamUp: {
                type: "v3",
                value: new THREE.Vector3
            },
            uResolution: {
                type: "v2",
                value: new THREE.Vector2(600,400)
            },
            envMapBackground: {
                type: "i",
                value: 0
            }
        },
        vertexShader: "uniform vec3 color1;\nuniform vec3 color2;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvoid main() {\nif (uv.y == 0.0)\nvColor = color2;\nelse\nvColor = color1;\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: ["varying vec3 vColor;\nvarying vec2 vUv;\nuniform samplerCube irradianceMap;\nuniform float exposure;\nuniform vec3 uCamDir;\nuniform vec3 uCamUp;\nuniform vec2 uResolution;\nuniform bool envMapBackground;\nconst int bloomRange = 4;", 
        OrderedDitheringShaderChunk, "vec3 RGBMDecode(in vec4 vRGBM, in float exposure) {\nvec3 ret = vRGBM.rgb * (vRGBM.a * 16.0);\nret *= ret;\nret *= exposure;\nreturn ret;\n}\nvec3 rayDir(in vec2 vUv) {\nvec3 A = (uResolution.x/uResolution.y)*normalize(cross(uCamDir,uCamUp));\nvec3 B = normalize(uCamUp);\nvec3 C = normalize(uCamDir);\nvec3 ray = normalize( C + (2.0*vUv.x-1.0)*A + (2.0*vUv.y-1.0)*B );\nreturn ray;\n}\nvec4 getColor(in vec3 rd) {\nvec4 color = vec4(RGBMDecode(textureCube(irradianceMap, rd), exposure), 1.0);\nreturn color;\n}\nvoid main() {\nvec3 rd = rayDir(vUv);\nif (envMapBackground) {\ngl_FragColor = getColor(rd);\n}\nelse {\ngl_FragColor = vec4(orderedDithering(vColor), 1.0);\n}\n}"].join("\n")
    })
}
function init_FireflyBasicShader(f) {
    THREE.ShaderLib.firefly_basic = {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap, {
            cutplanes: {
                type: "v4v",
                value: []
            },
            cutplanesOutlineColor: {
                type: "v3",
                value: new THREE.Vector3(0,1,0)
            }
        }]),
        vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, 
        THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\nvoid main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "\t#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\t#endif", THREE.ShaderChunk.morphtarget_vertex, 
        THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, "#if NUM_CUTPLANES > 0\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\n#endif", THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, 
        THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "#if NUM_CUTPLANES > 0\nvarying highp vec3 vWorldPosition;\n#endif", CutPlanesShaderChunk, "void main() {\n#if NUM_CUTPLANES > 0\nif (checkCutPlanes(vWorldPosition)) return;\n#endif\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );", 
        THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "\toutgoingLight = diffuseColor.rgb;", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n}"].join("\n")
    }
}
function init_LineShader(f) {
    "undefined" === typeof f.LineShader && (f.LineShader = {
        uniforms: {
            pixelsPerUnit: {
                type: "f",
                value: 1
            },
            aaRange: {
                type: "f",
                value: .5
            },
            tLayerMask: {
                type: "t",
                value: null 
            },
            tLineStyle: {
                type: "t",
                value: null 
            },
            vLineStyleTexSize: {
                type: "v2",
                value: new THREE.Vector2(13,70)
            },
            tRaster: {
                type: "t",
                value: null 
            },
            tSelectionTexture: {
                type: "t",
                value: null 
            },
            vSelTexSize: {
                type: "v2",
                value: new THREE.Vector2(4096,1)
            },
            displayPixelRatio: {
                type: "f",
                value: 1
            }
        },
        attributes: {
            fields1: 0,
            fields2: 0,
            color4b: 0,
            dbId4b: 0,
            flags4b: 0,
            extraParams: 0,
            instFlags4b: 0,
            linetype4b: 0
        },
        defines: {},
        vertexShader: "#define TAU 6.28318530718\n#define PI 3.14159265358979\n#define HALF_PI 1.57079632679\n#define VBB_LINE_SEGMENT     16.0\n#define VBB_ARC_CIRCULAR     32.0\n#define VBB_ARC_ELLIPTICAL   48.0\n#define VBB_TEX_QUAD         64.0\n#define VBB_ONE_TRIANGLE     80.0\n#define VBB_INSTANCED_FLAG   0.0\n#define VBB_SEG_START_RIGHT  1.0\n#define VBB_SEG_START_LEFT   2.0\n#define VBB_SEG_END_RIGHT    3.0\n#define VBB_SEG_END_LEFT     4.0\nattribute vec3 fields1;\nattribute vec3 fields2;\nattribute vec4 color4b;\nattribute vec4 dbId4b;\nattribute vec4 linetype4b;\nattribute vec4 flags4b;\n#ifdef HAS_ELLIPTICALS\nattribute vec3 extraParams;\n#endif\n#ifdef USE_INSTANCING\nattribute vec4 instFlags4b;\n#endif\nuniform mat4 mvpMatrix;\nuniform float pixelsPerUnit;\nuniform float aaRange;\n#ifdef HAS_LAYERS\nuniform sampler2D tLayerMask;\n#endif\n#ifdef SELECTION_RENDERER\nuniform sampler2D tSelectionTexture;\nuniform vec2 vSelTexSize;\n#endif\nvarying vec4 outColor;\nvarying vec4 dbId;\nvec2 centralVertex;\nvec2 offsetPosition;\nvarying vec2 offsetDirection;\nvarying vec4 multipurpose;\nvarying float halfWidth;\nvoid strokeLineSegment(float vertexId) {\nfloat distanceAlong = fields2.x;\nfloat totalDistance = fields2.z;\nfloat isStartCapVertex = (vertexId < VBB_SEG_END_RIGHT) ? -1.0 : 1.0;\nfloat isLeftSide = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? 1.0 : -1.0;\nfloat angleTransverse = fields1.z + isLeftSide * HALF_PI;\nfloat st = sin(angleTransverse);\nfloat ct = cos(angleTransverse);\nfloat lwAdjustment = halfWidth + aaRange;\nvec2 transverseOffset = vec2(ct, st) * lwAdjustment;\noffsetPosition.xy += transverseOffset;\nfloat distanceFromStart = max(isStartCapVertex, 0.0) * distanceAlong;\nvec2 along = distanceFromStart * vec2(cos(fields1.z), sin(fields1.z));\noffsetPosition.xy += along;\ncentralVertex.xy += along;\nvec2 moveOffset = isStartCapVertex * isLeftSide * vec2(-transverseOffset.y, transverseOffset.x);\noffsetPosition.xy -= moveOffset;\ncentralVertex.xy -= moveOffset;\nmultipurpose.x = (isStartCapVertex * lwAdjustment) + distanceFromStart;\nmultipurpose.y = distanceAlong;\nmultipurpose.z = linetype4b.x;\nmultipurpose.w = totalDistance;\nif (fields2.y < 0.0)\nhalfWidth = -halfWidth;\n}\n#ifdef HAS_TRIANGLE_GEOMS\nvoid strokeOneTriangle(float vertexId) {\nhalfWidth = 0.0;\nif (vertexId == VBB_SEG_END_RIGHT)\noffsetPosition.xy = vec2(fields1.z, fields2.x);\nelse if (vertexId == VBB_SEG_END_LEFT)\noffsetPosition.xy = fields2.yz;\n}\n#endif\n#ifdef HAS_RASTER_QUADS\nvoid strokeTexQuad(float vertexId) {\nfloat distanceAlong = fields2.x;\nbool isStartCapVertex = (vertexId < VBB_SEG_END_RIGHT);\nfloat isLeftSide = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? 1.0 : -1.0;\nfloat angleTransverse = fields1.z + isLeftSide * HALF_PI;\nmultipurpose.y = distanceAlong;\nfloat st = sin(angleTransverse);\nfloat ct = cos(angleTransverse);\nfloat moveDist = halfWidth;\nvec2 offset = vec2(ct, st) * moveDist;\noffsetPosition.xy += offset;\nmultipurpose.z = 1.0;\nhalfWidth = 0.0;\nif (isStartCapVertex) {\noffsetPosition.xy += isLeftSide * vec2(0.0, offset.x);\nmultipurpose.x = 0.0;\nmultipurpose.y = max(0.0, isLeftSide);\n}\nelse {\nvec2 along = vec2(cos(fields1.z), sin(fields1.z));\noffsetPosition.xy += distanceAlong * along;\ncentralVertex.xy += distanceAlong * along;\noffsetPosition.xy += isLeftSide * vec2(0.0, -offset.x);\nmultipurpose.x = 1.0;\nmultipurpose.y = max(0.0, isLeftSide);\n}\n}\n#endif\n#ifdef HAS_CIRCLES\nvoid strokeCircularArc(float vertexId) {\nvec2 angles = vec2(fields1.z, fields2.x);\nfloat r = fields2.z;\nif (r * pixelsPerUnit < 0.125)\nr = 0.25 * aaRange;\nfloat isStart = (vertexId < VBB_SEG_END_RIGHT) ? -1.0 : 1.0;\nfloat isLeft = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? -1.0 : 1.0;\nvec2 minPt;\nvec2 maxPt;\nvec2 endsX = vec2(fields1.x) + r * cos(angles);\nvec2 endsY = vec2(fields1.y) + r * sin(angles);\nminPt = maxPt = vec2(endsX.x, endsY.x);\nminPt = min(minPt, vec2(endsX.y, endsY.y));\nmaxPt = max(maxPt, vec2(endsX.y, endsY.y));\nfloat start = angles.x;\nfloat end = angles.y;\nif (end > start) {\nif (start < (0.5 * PI) && end > (0.5 * PI)) {\nminPt = min(minPt, vec2(fields1.x, fields1.y + r));\nmaxPt = max(maxPt, vec2(fields1.x, fields1.y + r));\n}\nif (start < PI && end > PI) {\nminPt = min(minPt, vec2(fields1.x - r, fields1.y));\nmaxPt = max(maxPt, vec2(fields1.x - r, fields1.y));\n}\nif (start < (1.5 * PI) && end > (1.5 * PI)) {\nminPt = min(minPt, vec2(fields1.x, fields1.y - r));\nmaxPt = max(maxPt, vec2(fields1.x, fields1.y - r));\n}\n}\nelse {\nminPt = min(minPt, vec2(fields1.x + r, fields1.y));\nmaxPt = max(maxPt, vec2(fields1.x + r, fields1.y));\nif (start < (0.5 * PI) || end > (0.5 * PI)) {\nminPt = min(minPt, vec2(fields1.x, fields1.y + r));\nmaxPt = max(maxPt, vec2(fields1.x, fields1.y + r));\n}\nif (start < PI || end > PI) {\nminPt = min(minPt, vec2(fields1.x - r, fields1.y));\nmaxPt = max(maxPt, vec2(fields1.x - r, fields1.y));\n}\nif (start < (1.5 * PI) || end > (1.5 * PI)) {\nminPt = min(minPt, vec2(fields1.x, fields1.y - r));\nmaxPt = max(maxPt, vec2(fields1.x, fields1.y - r));\n}\n}\nminPt -= halfWidth + aaRange;\nmaxPt += halfWidth + aaRange;\nif (isStart<0.0)\noffsetPosition.x = minPt.x;\nelse\noffsetPosition.x = maxPt.x;\nif (isLeft<0.0)\noffsetPosition.y = minPt.y;\nelse\noffsetPosition.y = maxPt.y;\nmultipurpose.x = angles.x;\nmultipurpose.y = -r;\nmultipurpose.z = angles.y;\nmultipurpose.w = -r;\n}\n#endif\n#ifdef HAS_ELLIPTICALS\nvoid strokeEllipticalArc(float vertexId) {\nvec2 angles = vec2(fields1.z, fields2.x);\nfloat isStart = (vertexId < VBB_SEG_END_RIGHT) ? -1.0 : 1.0;\nfloat isLeft = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? -1.0 : 1.0;\nfloat major = fields2.z;\nfloat minor = extraParams.x;\nvec2 minPt;\nvec2 maxPt;\nvec2 endsX = vec2(fields1.x) + major * cos(angles);\nvec2 endsY = vec2(fields1.y) + minor * sin(angles);\nminPt = maxPt = vec2(endsX.x, endsY.x);\nminPt = min(minPt, vec2(endsX.y, endsY.y));\nmaxPt = max(maxPt, vec2(endsX.y, endsY.y));\nfloat start = angles.x;\nfloat end = angles.y;\nif (end > start) {\nif (start < (0.5 * PI) && end > (0.5 * PI)) {\nminPt = min(minPt, vec2(fields1.x, fields1.y + minor));\nmaxPt = max(maxPt, vec2(fields1.x, fields1.y + minor));\n}\nif (start < PI && end > PI) {\nminPt = min(minPt, vec2(fields1.x - major, fields1.y));\nmaxPt = max(maxPt, vec2(fields1.x - major, fields1.y));\n}\nif (start < (1.5 * PI) && end > (1.5 * PI)) {\nminPt = min(minPt, vec2(fields1.x, fields1.y - minor));\nmaxPt = max(maxPt, vec2(fields1.x, fields1.y - minor));\n}\n}\nelse {\nminPt = min(minPt, vec2(fields1.x + major, fields1.y));\nmaxPt = max(maxPt, vec2(fields1.x + major, fields1.y));\nif (start < (0.5 * PI) || end > (0.5 * PI)) {\nminPt = min(minPt, vec2(fields1.x, fields1.y + minor));\nmaxPt = max(maxPt, vec2(fields1.x, fields1.y + minor));\n}\nif (start < PI || end > PI) {\nminPt = min(minPt, vec2(fields1.x - major, fields1.y));\nmaxPt = max(maxPt, vec2(fields1.x - major, fields1.y));\n}\nif (start < (1.5 * PI) || end > (1.5 * PI)) {\nminPt = min(minPt, vec2(fields1.x, fields1.y - minor));\nmaxPt = max(maxPt, vec2(fields1.x, fields1.y - minor));\n}\n}\nminPt -= halfWidth + aaRange;\nmaxPt += halfWidth + aaRange;\nif (isStart < 0.0)\noffsetPosition.x = minPt.x;\nelse\noffsetPosition.x = maxPt.x;\nif (isLeft < 0.0)\noffsetPosition.y = minPt.y;\nelse\noffsetPosition.y = maxPt.y;\nmultipurpose.x = angles.x;\nmultipurpose.y = -major;\nmultipurpose.z = angles.y;\nmultipurpose.w = minor;\n}\n#endif\n#ifdef SELECTION_RENDERER\nbool isSelected() {\nvec3 oid = dbId4b.rgb * 255.0;\nfloat id01 = oid.r + oid.g * 256.0;\nfloat t = (id01 + 0.5) * (1.0 / 4096.0);\nfloat flrt = floor(t);\nfloat texU = t - flrt;\nfloat id23 = oid.b * (65536.0 / 4096.0) + flrt;\nt = (id23 + 0.5) / vSelTexSize.y;\nfloat texV = fract(t);\nvec4 selBit = texture2D(tSelectionTexture, vec2(texU, texV));\nreturn selBit.r == 1.0;\n}\n#endif\nbool isLayerOff() {\n#ifdef HAS_LAYERS\nvec4 layerBit = texture2D(tLayerMask, flags4b.ba / 255.0);\nreturn layerBit.r == 0.0;\n#else\nreturn false;\n#endif\n}\nvoid main() {\ncentralVertex = offsetPosition = fields1.xy;\nif (isLayerOff()) {\noutColor = vec4(0.0);\n}\nelse {\nfloat vertexId = mod(flags4b.x, 16.0);\nfloat geomType = flags4b.x - vertexId;\n#ifdef USE_INSTANCING\nvertexId = instFlags4b.x;\n#endif\nfloat lineWeight = fields2.y;\nif (lineWeight > 0.0) {\nif (lineWeight * pixelsPerUnit < 0.5)\nlineWeight = 0.5 / pixelsPerUnit;\n}\nelse {\nlineWeight = abs(lineWeight) / pixelsPerUnit;\n}\n#ifdef SELECTION_RENDERER\nif (isSelected())\noutColor = vec4(0.0,0.0,1.0,1.0);\nelse\noutColor = vec4(0.0);\n#else\noutColor = color4b;\n#endif\nhalfWidth = lineWeight;\ndbId = dbId4b;\nif (geomType == VBB_LINE_SEGMENT)\nstrokeLineSegment(vertexId);\n#ifdef HAS_CIRCLES\nelse if (geomType == VBB_ARC_CIRCULAR)\nstrokeCircularArc(vertexId);\n#endif\n#ifdef HAS_ELLIPTICALS\nelse if (geomType == VBB_ARC_ELLIPTICAL)\nstrokeEllipticalArc(vertexId);\n#endif\n#ifdef HAS_RASTER_QUADS\nelse if (geomType == VBB_TEX_QUAD)\nstrokeTexQuad(vertexId);\n#endif\n#ifdef HAS_TRIANGLE_GEOMS\nelse if (geomType == VBB_ONE_TRIANGLE)\nstrokeOneTriangle(vertexId);\n#endif\nelse {\nhalfWidth = 0.0;\nmultipurpose.z = 0.0;\n}\n}\noffsetDirection = offsetPosition - centralVertex;\ngl_Position = mvpMatrix * modelMatrix * vec4( offsetPosition.xy, 0.0, 1.0 );\n}",
        fragmentShader: "#define TAU 6.28318530717958\n#define PI  3.14159265358979\nuniform highp float pixelsPerUnit;\nuniform highp float aaRange;\n#ifdef HAS_RASTER_QUADS\nuniform sampler2D tRaster;\n#endif\n#ifdef HAS_LINESTYLES\nuniform sampler2D tLineStyle;\nuniform vec2 vLineStyleTexSize;\n#endif\nvarying vec4 outColor;\nvarying vec4 dbId;\nvarying vec2 offsetDirection;\nvarying vec4 multipurpose;\nvarying float halfWidth;\nfloat curveGaussian(float r, float invWidth) {\nfloat amt = clamp(r * invWidth, 0.0, 1.0);\nfloat exponent = amt * 2.0;\nreturn exp(-exponent*exponent);\n}\n#ifdef HAS_LINESTYLES\nfloat getLinePatternPixel(int i, int j) {\nreturn texture2D(tLineStyle, (vec2(i, j) + 0.5) / vLineStyleTexSize).x * 255.0;\n}\nfloat getPatternLength(int whichPattern) {\nfloat p1 = getLinePatternPixel(0, whichPattern);\nfloat p2 = getLinePatternPixel(1, whichPattern);\nreturn (p2 * 256.0 + p1);\n}\n#endif\nvoid fillLineSegment() {\nfloat radius = abs(halfWidth);\nfloat parametricDistance = multipurpose.x;\nfloat segmentLength = multipurpose.y;\nfloat totalDistance = multipurpose.w;\n#ifdef HAS_LINESTYLES\nint whichPattern = int(multipurpose.z);\nif (whichPattern > 0) {\nconst float TEX_TO_UNIT = 1.0 / 96.0;\nfloat LTSCALE = 1.0;\nfloat patternScale;\nif (halfWidth < 0.0) {\npatternScale = LTSCALE;\n} else {\npatternScale = LTSCALE * TEX_TO_UNIT * pixelsPerUnit;\n}\nfloat patLen = patternScale * getPatternLength(whichPattern);\nfloat phase = mod((totalDistance + parametricDistance) * pixelsPerUnit, patLen);\nbool onPixel = true;\nfloat radiusPixels = radius * pixelsPerUnit;\nfor (int i=2; i<MAX_LINESTYLE_LENGTH; i+=2) {\nfloat on = getLinePatternPixel(i, whichPattern);\nif (on == 1.0) on = 0.0;\non *= patternScale;\nonPixel = true;\nphase -= on;\nif (phase < 0.0) {\nbreak;\n}\nelse if (phase <= radiusPixels) {\nonPixel = false;\nbreak;\n}\nfloat off = getLinePatternPixel(i+1, whichPattern);\nif (off <= 1.0) off = 0.0;\noff *= patternScale;\nonPixel = false;\nphase -= off;\nif (phase < -radiusPixels)\ndiscard;\nif (phase <= 0.0)\nbreak;\n}\nif (!onPixel && (abs(phase) <= radiusPixels)) {\nsegmentLength = 0.0;\nparametricDistance = phase / pixelsPerUnit;\n}\n}\n#endif\nfloat dist;\nfloat offsetLength2 = dot(offsetDirection, offsetDirection);\nfloat ltz = max(0.0, sign(-parametricDistance));\nfloat gtsl = max(0.0, sign(parametricDistance - segmentLength));\nfloat d = (ltz + gtsl) * (parametricDistance - gtsl * segmentLength);\ndist = sqrt(max(0.0, offsetLength2 + d*d));\nfloat range =  dist - radius;\nif (range > aaRange) {\ndiscard;\n}\ngl_FragColor = outColor;\ngl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);\n}\n#ifdef HAS_CIRCLES\nvoid fillCircularArc() {\nfloat dist = length(offsetDirection);\nfloat radius = abs(multipurpose.y);\nfloat range =  abs(dist - radius);\nrange -= halfWidth;\nif (range > aaRange) {\ndiscard;\n}\nvec2 angles = multipurpose.xz;\nvec2 direction = offsetDirection;\nfloat angle = atan(direction.y, direction.x);\nif (angles.x > angles.y)\nangles.x -= TAU;\nelse if (angle < 0.0)\nangle += TAU;\nif (angle > angles.x && angle < angles.y) {\ngl_FragColor = outColor;\ngl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);\n}\nelse {\ndiscard;\n}\n}\n#endif\n#ifdef HAS_ELLIPTICALS\nfloat DistancePointEllipseSpecial (vec2 e, vec2 y, out vec2 x, float width, float aaRange) {\nfloat dist;\nvec2 esqr = e * e;\nvec2 ey = e * y;\nfloat t0 = -esqr[1] + ey[1];\nfloat t1 = -esqr[1] + length(ey);\nfloat t;\nvec2 r;\nfor (int i = 0; i < 6; ++i) {\nt = mix(t0, t1, 0.5);//0.5*(t0 + t1);\nr = ey / (vec2(t) + esqr);\nvec2 rsq = r * r;\nfloat f = rsq[0] + rsq[1] - 1.0;\nfloat fsign = sign(f);\nt0 = mix(t0, t, max(0.0, fsign));\nt1 = mix(t1, t, max(0.0, -fsign));\n}\nx = e * r;\ndist = distance(x, y);\nif (dist > max(2.0 * (width + aaRange), e[0] * 0.05))\nreturn dist;\nfor (int i = 0; i < 6; ++i) {\nt = mix(t0, t1, 0.5);//0.5*(t0 + t1);\nr = ey / (vec2(t) + esqr);\nvec2 rsq = r * r;\nfloat f = rsq[0] + rsq[1] - 1.0;\nfloat fsign = sign(f);\nt0 = mix(t0, t, max(0.0, fsign));\nt1 = mix(t1, t, max(0.0, -fsign));\n}\nx = e * r;\ndist = distance(x, y);\nfloat ecc = 1.0 +  0.1 * e[0] / e[1];\nif (dist > max(ecc * (width + aaRange), e[0] * 0.001))\nreturn dist;\nif (dist < (width - aaRange) / ecc)\nreturn dist;\nfor (int i = 0; i < 10; ++i) {\nt = mix(t0, t1, 0.5);//0.5*(t0 + t1);\nr = ey / (vec2(t) + esqr);\nvec2 rsq = r * r;\nfloat f = rsq[0] + rsq[1] - 1.0;\nfloat fsign = sign(f);\nt0 = mix(t0, t, max(0.0, fsign));\nt1 = mix(t1, t, max(0.0, -fsign));\n}\nx = e * r;\ndist = distance(x, y);\nreturn dist;\n}\nfloat DistancePointEllipse(vec2 e, vec2 y, out vec2 locX, float width, float aaRange) {\nvec2 locE, locY;\nfloat diff = sign(e[0] - e[1]);\nvec2 swizzle = vec2(max(diff, 0.0), -min(diff, 0.0));\nlocE.x = dot(e, swizzle.xy);\nlocE.y = dot(e, swizzle.yx);\nlocY.x = dot(y, swizzle.xy);\nlocY.y = dot(y, swizzle.yx);\nvec2 refl = sign(locY);\nlocY *= refl;\nvec2 x;\nfloat distance = DistancePointEllipseSpecial(locE, locY, x, width, aaRange);\nx *= refl;\nlocX.x = dot(x, swizzle.xy);\nlocX.y = dot(x, swizzle.yx);\nreturn distance;\n}\nvoid fillEllipticalArc() {\nvec2 radii = abs(multipurpose.yw);\nvec2 dir = offsetDirection;\nvec2 pos;\nfloat range = DistancePointEllipse(radii, dir, pos, halfWidth, aaRange);\nrange -= halfWidth;\nif (range > aaRange)\ndiscard;\nfloat ar = radii[0] / radii[1];\nvec2 angles = multipurpose.xz;\nfloat angle = atan(ar * pos.y, pos.x);\nif (angles.x > angles.y)\nangles.x -= TAU;\nelse if (angle < 0.0)\nangle += TAU;\nif (angle > angles.x && angle < angles.y) {\ngl_FragColor = outColor;\ngl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);\n}\nelse {\ndiscard;\n}\n}\n#endif\nvoid main() {\nif (outColor.a == 0.0) {\ndiscard;\n}\nif (halfWidth == 0.0) {\n#ifdef HAS_RASTER_QUADS\nif (multipurpose.z != 0.0)\ngl_FragColor = texture2D(tRaster, multipurpose.xy);\nelse\n#endif\ngl_FragColor = outColor;\n}\nelse if (multipurpose.y < 0.0) {\n#ifdef HAS_CIRCLES\n#ifdef HAS_ELLIPTICALS\nif (multipurpose.y == multipurpose.w)\n#endif\nfillCircularArc();\n#endif\n#ifdef HAS_ELLIPTICALS\n#ifdef HAS_CIRCLES\nelse\n#endif\nfillEllipticalArc();\n#endif\n}\nelse\nfillLineSegment();\n#ifdef MRT_NORMALS\ngl_FragData[1] = vec4(0, 0, 0, 0.0);\n#endif\n#ifdef MRT_ID_BUFFER\n#ifdef MRT_NORMALS\nconst int index = 2;\n#else\nconst int index = 1;\n#endif\ngl_FragData[index] = vec4(dbId.rgb, 1.0);\n#elif defined(ID_COLOR)\ngl_FragColor = dbId;\n#endif\n}"
    })
}
FireflyWebGLProgram = function() {
    var f = 0
      , h = function(f, d, c, a, b) {
        a = a ? "1.0-" : "";
        var h = "texture2D(" + f + ", (UV))"
          , l = "";
        b = b || "vec4(0.0)";
        d && c ? l = "((UV).x < 0.0 || (UV).x > 1.0 || (UV).y < 0.0 || (UV).y > 1.0) ? " + b + " : " : d ? l = "((UV).x < 0.0 || (UV).x > 1.0) ? " + b + " : " : c && (l = "((UV).y < 0.0 || (UV).y > 1.0) ? " + b + " : ");
        return "#define GET_" + f.toUpperCase() + "(UV) (" + l + a + h + ")"
    }
    ;
    return function(g, d, c, a) {
        var b = g.context
          , k = c.defines
          , l = c.__webglShader.uniforms
          , n = c.attributes
          , m = c.__webglShader.vertexShader
          , q = c.__webglShader.fragmentShader
          , 
        r = c.index0AttributeName;
        void 0 === r && !0 === a.morphTargets && (r = "position");
        var t = "SHADOWMAP_TYPE_BASIC";
        a.shadowMapType === THREE.PCFShadowMap ? t = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === THREE.PCFSoftShadowMap && (t = "SHADOWMAP_TYPE_PCF_SOFT");
        var w = 0 < g.gammaFactor ? g.gammaFactor : 1, C, E;
        C = [];
        for (var G in k)
            E = k[G],
            !1 !== E && (E = "#define " + G + " " + E,
            C.push(E));
        C = C.join("\n");
        k = b.createProgram();
        c instanceof THREE.RawShaderMaterial ? g = c = "" : (c = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", C, a.supportsVertexTextures ? 
        "#define VERTEX_TEXTURES" : "", g.gammaInput ? "#define GAMMA_INPUT" : "", g.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + w, a.mrtNormals ? "#define MRT_NORMALS" : "", a.mrtIdBuffer ? "#define MRT_ID_BUFFER" : "", "#define MAX_DIR_LIGHTS " + a.maxDirLights, "#define MAX_POINT_LIGHTS " + a.maxPointLights, "#define MAX_SPOT_LIGHTS " + a.maxSpotLights, "#define MAX_HEMI_LIGHTS " + a.maxHemiLights, "#define MAX_SHADOWS " + a.maxShadows, "#define MAX_BONES " + a.maxBones, "#define NUM_CUTPLANES " + a.numCutplanes, a.map ? "#define USE_MAP" : 
        "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define ENVMAP_MODE_REFLECTION" : "", a.irradianceMap ? "#define USE_IRRADIANCEMAP" : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals ? "#define USE_MORPHNORMALS" : 
        "", a.wrapAround ? "#define WRAP_AROUND" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + t : "", a.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", a.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.useFragDepthExt ? "#define USE_LOGDEPTHBUF_EXT" : "", a.packedNormals ? "#define UNPACK_NORMALS" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\n#ifdef UNPACK_NORMALS\nattribute vec2 normal;\n#else\nattribute vec3 normal;\n#endif\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n\tattribute vec3 color;\n#endif\n"].join("\n"),
        g = [a.bumpMap || a.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", !a.mrtIdBuffer && !a.mrtNormals || "undefined" !== typeof _isIE11 && _isIE11 ? "" : "#extension GL_EXT_draw_buffers : enable", a.mrtIdBuffer ? "#define gl_FragColor gl_FragData[0]" : "", a.haveTextureLod ? "#define HAVE_TEXTURE_LOD" : "", C, "#define MAX_DIR_LIGHTS " + a.maxDirLights, "#define MAX_POINT_LIGHTS " + a.maxPointLights, "#define MAX_SPOT_LIGHTS " + a.maxSpotLights, "#define MAX_HEMI_LIGHTS " + a.maxHemiLights, "#define MAX_SHADOWS " + a.maxShadows, 
        "#define NUM_CUTPLANES " + a.numCutplanes, a.alphaTest ? "#define ALPHATEST " + a.alphaTest : "", g.gammaInput ? "#define GAMMA_INPUT" : "", g.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define GAMMA_FACTOR " + w, a.mrtNormals ? "#define MRT_NORMALS" : "", a.mrtIdBuffer ? "#define MRT_ID_BUFFER" : "", a.tonemapOutput ? "#define TONEMAP_OUTPUT" : "", a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define ENVMAP_TYPE_CUBE" : "", a.envMap ? 
        "#define ENVMAP_MODE_REFLECTION" : "", a.envMap ? "#define ENVMAP_BLENDING_MULTIPLY" : "", a.irradianceMap ? "#define USE_IRRADIANCEMAP" : "", a.envGammaEncoded ? "#define ENV_GAMMA" : "", a.irrGammaEncoded ? "#define IRR_GAMMA" : "", a.envRGBM ? "#define ENV_RGBM" : "", a.irrRGBM ? "#define IRR_RGBM" : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : 
        "", a.metal ? "#define METAL" : "", a.clearcoat ? "#define CLEARCOAT" : "", a.wrapAround ? "#define WRAP_AROUND" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + t : "", a.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", a.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.hatchPattern ? "#define HATCH_PATTERN" : "", a.mapInvert ? "#define MAP_INVERT" : "", h("map", a.mapClampS, 
        a.mapClampT, !1, "vec4(vec3(0.0), 1.0)"), h("bumpMap", a.bumpMapClampS, a.bumpMapClampT), h("normalMap", a.normalMapClampS, a.normalMapClampT), h("specularMap", a.specularMapClampS, a.specularMapClampT), h("alphaMap", a.alphaMapClampS, a.alphaMapClampT, a.alphaMapInvert), "#ifdef USE_ENVMAP\n#ifdef HAVE_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#endif\n#extension GL_OES_standard_derivatives : enable", "precision " + a.precisionFragment + " float;", "precision " + a.precisionFragment + " int;", "uniform highp mat4 viewMatrix;\nuniform highp mat4 projectionMatrix;\nuniform highp vec3 cameraPosition;\n#ifdef USE_ENVMAP\nuniform mat4 viewMatrixInverse;\n#endif\n"].join("\n"));
        m = new THREE.WebGLShader(b,b.VERTEX_SHADER,c + m);
        q = new THREE.WebGLShader(b,b.FRAGMENT_SHADER,g + q);
        b.attachShader(k, m);
        b.attachShader(k, q);
        void 0 !== r && b.bindAttribLocation(k, 0, r);
        b.linkProgram(k);
        !1 === b.getProgramParameter(k, b.LINK_STATUS) && (console.error("THREE.WebGLProgram: Could not initialise shader."),
        console.error("gl.VALIDATE_STATUS", b.getProgramParameter(k, b.VALIDATE_STATUS)),
        console.error("gl.getError()", b.getError()));
        "" !== b.getProgramInfoLog(k) && console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", 
        b.getProgramInfoLog(k));
        b.deleteShader(m);
        b.deleteShader(q);
        r = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition viewMatrixInverse mvpMatrix dbId".split(" ");
        a.logarithmicDepthBuffer && r.push("logDepthBufFC");
        for (var B in l)
            r.push(B);
        a = r;
        l = {};
        B = 0;
        for (r = a.length; B < r; B++)
            g = a[B],
            l[g] = b.getUniformLocation(k, g);
        this.uniforms = l;
        var r = "position normal uv uv2 tangent color lineDistance".split(" "), v;
        for (v in n)
            r.push(v);
        n = r;
        v = {};
        a = 0;
        for (l = n.length; a < l; a++)
            B = n[a],
            v[B] = b.getAttribLocation(k, 
            B);
        this.attributes = v;
        this.attributesKeys = Object.keys(this.attributes);
        this.id = f++;
        this.code = d;
        this.usedTimes = 1;
        this.program = k;
        this.vertexShader = m;
        this.fragmentShader = q;
        return this
    }
}
();
FireflyWebGLRenderer = function(f) {
    function h(a, b) {
        return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material
    }
    function g(a) {
        return a instanceof THREE.MeshBasicMaterial && !a.envMap || a instanceof THREE.MeshDepthMaterial ? !1 : a && void 0 !== a.shading && a.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading
    }
    function d(a) {
        return a.map || a.lightMap || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a instanceof THREE.ShaderMaterial ? !0 : !1
    }
    function c(a) {
        if (a.streamingDraw) {
            if (!a.streamingIndex) {
                var b = 
                a.attributes.index;
                b && (b.buffer = A.createBuffer(),
                A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, b.buffer),
                A.bufferData(A.ELEMENT_ARRAY_BUFFER, b.array || a.ib, A.STATIC_DRAW))
            }
        } else {
            a.vb && void 0 === a.vbbuffer && (a.vbbuffer = A.createBuffer(),
            a.vbNeedsUpdate = !0);
            a.ib && void 0 === a.ibbuffer && (a.ibbuffer = A.createBuffer(),
            A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, a.ibbuffer),
            A.bufferData(A.ELEMENT_ARRAY_BUFFER, a.ib, A.STATIC_DRAW));
            for (var b = a.attributes, c = a.attributesKeys, d = 0, f = c.length; d < f; d++) {
                var g = c[d]
                  , h = b[g]
                  , g = "index" === g;
                h.array && void 0 === h.buffer && (h.buffer = A.createBuffer(),
                h.needsUpdate = !0);
                !0 === h.needsUpdate && (g = g ? A.ELEMENT_ARRAY_BUFFER : A.ARRAY_BUFFER,
                A.bindBuffer(g, h.buffer),
                A.bufferData(g, h.array, A.STATIC_DRAW),
                h.needsUpdate = !1)
            }
            a.vbNeedsUpdate && (A.bindBuffer(A.ARRAY_BUFFER, a.vbbuffer),
            A.bufferData(A.ARRAY_BUFFER, a.vb, A.STATIC_DRAW),
            a.vbNeedsUpdate = !1)
        }
    }
    function a(a, b, c) {
        if (c.streamingDraw || c.offsets && 1 < c.offsets.length || !Ka)
            return c.vaos = null ,
            !1;
        void 0 === c.vaos && (c.vaos = []);
        a = Ka.createVertexArrayOES();
        c.vaos.push({
            geomhash: b.id,
            vao: a
        });
        Ka.bindVertexArrayOES(a);
        (a = c.attributes.index) && A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, c.ibbuffer || a.buffer);
        a = null ;
        var d = b.attributes;
        b = b.attributesKeys;
        for (var f = c.vbstride, g = c.offsets && c.offsets.length ? c.offsets[0].index : 0, h = 0, k = b.length; h < k; h++) {
            var m = b[h]
              , l = d[m];
            if (0 <= l)
                if (m = c.attributes[m]) {
                    var n = A.FLOAT
                      , q = m.bytesPerItem || 4;
                    1 === q ? n = A.UNSIGNED_BYTE : 2 === q && (n = A.UNSIGNED_SHORT);
                    A.enableVertexAttribArray(l);
                    void 0 !== m.itemOffset ? (a != c.vbbuffer && (A.bindBuffer(A.ARRAY_BUFFER, c.vbbuffer),
                    a = c.vbbuffer),
                    A.vertexAttribPointer(l, m.itemSize, n, m.normalize, 4 * f, 4 * (m.itemOffset + g * f))) : (A.bindBuffer(A.ARRAY_BUFFER, m.buffer),
                    a = m.buffer,
                    A.vertexAttribPointer(l, m.itemSize, n, m.normalize, 0, g * m.itemSize * q));
                    Sa && c.numInstances && Sa.vertexAttribDivisorANGLE(l, m.divisor || 0)
                } else {
                    Ka.bindVertexArrayOES(null );
                    for (h = 0; h < c.vaos.length; h++)
                        Ka.deleteVertexArrayOES(c.vaos[h].vao);
                    c.vaos = null ;
                    return !1
                }
        }
        return !0
    }
    function b(a, b) {
        var c = ta[a];
        c || (c = A.createBuffer(),
        ta[a] = c);
        A.bindBuffer(A.ARRAY_BUFFER, c);
        A.bufferData(A.ARRAY_BUFFER, 
        b, A.DYNAMIC_DRAW);
        return c
    }
    function k(a, c, d, f, g) {
        var h = c.attributes;
        c = c.attributesKeys;
        var k = 0
          , m = void 0;
        if (g)
            if (!g.buffer && d.streamingDraw) {
                var l = ta.index;
                l || (l = A.createBuffer(),
                ta.index = l);
                A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, l);
                A.bufferData(A.ELEMENT_ARRAY_BUFFER, g.array || d.ib, A.DYNAMIC_DRAW)
            } else
                A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, d.ibbuffer || g.buffer);
        g = 0;
        for (l = c.length; g < l; g++) {
            var n = c[g]
              , q = h[n];
            if (0 <= q) {
                var r = d.attributes[n];
                if (r) {
                    var B = void 0 !== r.itemOffset, K, v;
                    B ? (K = d.vbstride,
                    v = r.itemOffset,
                    k !== m && (d.streamingDraw ? k = b("interleavedVB", d.vb) : (k = d.vbbuffer,
                    A.bindBuffer(A.ARRAY_BUFFER, k)),
                    m = k)) : (K = r.itemSize,
                    v = 0,
                    d.streamingDraw ? k = b(n, r.array) : (k = r.buffer,
                    A.bindBuffer(A.ARRAY_BUFFER, k)));
                    var n = A.FLOAT
                      , t = r.bytesPerItem || 4;
                    1 === t ? n = A.UNSIGNED_BYTE : 2 === t && (n = A.UNSIGNED_SHORT);
                    B && (t = 4);
                    Aa.enableAttribute(q);
                    A.vertexAttribPointer(q, r.itemSize, n, r.normalize, K * t, (v + f * K) * t);
                    Sa && d.numInstances && Sa.vertexAttribDivisorANGLE(q, r.divisor || 0)
                } else
                    a.defaultAttributeValues && ((r = a.defaultAttributeValues[n]) && 
                    2 === r.length ? A.vertexAttrib2fv(q, a.defaultAttributeValues[n]) : r && 3 === r.length && A.vertexAttrib3fv(q, a.defaultAttributeValues[n]))
            }
        }
        Aa.disableUnusedAttributes()
    }
    function l(a, b) {
        return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
    }
    function n(a, b) {
        return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
    }
    function m(a) {
        r(a, 
        !0)
    }
    function q(a) {
        r(a, !1)
    }
    function r(a, b, c) {
        if (c || !1 !== a.visible) {
            if (!(a instanceof THREE.Scene || a instanceof THREE.Group))
                if (a instanceof Teratek.Viewing.Private.RenderBatch)
                    a.forEach(b ? m : q);
                else {
                    void 0 === a.__webglInit && (a.__webglInit = !0,
                    a.addEventListener("removed", Za));
                    var d = a.geometry;
                    if (void 0 !== d && void 0 === d.__webglInit && (d.__webglInit = !0,
                    d.addEventListener("dispose", ob),
                    !(d instanceof THREE.BufferGeometry)))
                        if (a instanceof THREE.Mesh)
                            C(a, d);
                        else if (a instanceof THREE.Line && void 0 === d.__webglVertexBuffer) {
                            d.__webglVertexBuffer = 
                            A.createBuffer();
                            d.__webglColorBuffer = A.createBuffer();
                            d.__webglLineDistanceBuffer = A.createBuffer();
                            ka.info.memory.geometries++;
                            var f = d.vertices.length;
                            d.__vertexArray = new Float32Array(3 * f);
                            d.__colorArray = new Float32Array(3 * f);
                            d.__lineDistanceArray = new Float32Array(1 * f);
                            d.__webglLineCount = f;
                            var f = d.vertices.length
                              , g = a.material;
                            if (g.attributes) {
                                void 0 === d.__webglCustomAttributesList && (d.__webglCustomAttributesList = []);
                                for (var h in g.attributes) {
                                    var k = g.attributes[h];
                                    if (!k.__webglInitialized || k.createUniqueBuffers) {
                                        k.__webglInitialized = 
                                        !0;
                                        var l = 1;
                                        "v2" === k.type ? l = 2 : "v3" === k.type ? l = 3 : "v4" === k.type ? l = 4 : "c" === k.type && (l = 3);
                                        k.size = l;
                                        k.array = new Float32Array(f * l);
                                        k.buffer = A.createBuffer();
                                        k.buffer.belongsToAttribute = h;
                                        k.needsUpdate = !0
                                    }
                                    d.__webglCustomAttributesList.push(k)
                                }
                            }
                            d.verticesNeedUpdate = !0;
                            d.colorsNeedUpdate = !0;
                            d.lineDistancesNeedUpdate = !0
                        }
                    if (void 0 === a.__webglActive)
                        if (a.__webglActive = !0,
                        a instanceof THREE.Mesh)
                            if (d instanceof THREE.BufferGeometry)
                                E(da, d, a);
                            else {
                                if (d instanceof THREE.Geometry)
                                    for (d = ib[d.id],
                                    h = 0,
                                    f = d.length; h < f; h++)
                                        E(da, 
                                        d[h], a)
                            }
                        else
                            a instanceof THREE.Line || a instanceof THREE.PointCloud ? E(da, d, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && na.push({
                                id: null ,
                                object: a,
                                opaque: null ,
                                transparent: null ,
                                z: 0
                            });
                    if (a instanceof THREE.Light)
                        ga.push(a);
                    else if ((d = da[a.id]) && (!1 === a.frustumCulled || !0 === oa.intersectsObject(a)))
                        for (h = 0,
                        f = d.length; h < f; h++) {
                            var k = g = d[h]
                              , n = k.object
                              , l = k.buffer
                              , B = n.geometry
                              , n = n.material;
                            n instanceof THREE.MeshFaceMaterial ? (n = n.materials[B instanceof THREE.BufferGeometry ? 0 : l.materialIndex],
                            k.material = n,
                            n.transparent ? xa.push(k) : Ha.push(k)) : n && (k.material = n,
                            n.transparent ? xa.push(k) : Ha.push(k));
                            g.render = !0;
                            !0 === b && (sa.setFromMatrixPosition(a.matrixWorld),
                            sa.applyProjection(pa),
                            g.z = sa.z)
                        }
                }
            if (a.children)
                for (h = 0,
                f = a.children.length; h < f; h++)
                    r(a.children[h], b, c)
        }
    }
    function t(a, b, c, d, f) {
        for (var g, h = 0, k = a.length; h < k; h++) {
            g = a[h];
            var m = g.object
              , l = g.buffer;
            if (f)
                g = f;
            else {
                g = g.material;
                if (!g)
                    continue;v(g)
            }
            ka.setMaterialFaces(g);
            l instanceof THREE.BufferGeometry ? ka.renderBufferDirect(b, c, d, g, l, m) : ka.renderBuffer(b, 
            c, d, g, l, m)
        }
    }
    function w(a, b) {
        if (a.visible) {
            var c;
            if (lb)
                c = lb;
            else {
                c = a.material;
                if (!c)
                    return;
                v(c)
            }
            ka.setMaterialFaces(c);
            ka.renderBufferDirect(sb, jb, Hb, c, a.geometry, a)
        }
    }
    function C(a, b) {
        var c = a.material
          , f = !1;
        if (void 0 === ib[b.id] || !0 === b.groupsNeedUpdate) {
            delete da[a.id];
            for (var k = ib, m = b.id, c = c instanceof THREE.MeshFaceMaterial, l = ma.get("OES_element_index_uint") ? 4294967296 : 65535, n, f = {}, q = b.morphTargets ? b.morphTargets.length : 0, r = b.morphNormals ? b.morphNormals.length : 0, B, K = {}, v = [], t = 0, w = b.faces.length; t < 
            w; t++) {
                n = b.faces[t];
                var z = c ? n.materialIndex : 0;
                z in f || (f[z] = {
                    hash: z,
                    counter: 0
                });
                n = f[z].hash + "_" + f[z].counter;
                n in K || (B = {
                    id: Gb++,
                    faces3: [],
                    materialIndex: z,
                    vertices: 0,
                    numMorphTargets: q,
                    numMorphNormals: r
                },
                K[n] = B,
                v.push(B));
                K[n].vertices + 3 > l && (f[z].counter += 1,
                n = f[z].hash + "_" + f[z].counter,
                n in K || (B = {
                    id: Gb++,
                    faces3: [],
                    materialIndex: z,
                    vertices: 0,
                    numMorphTargets: q,
                    numMorphNormals: r
                },
                K[n] = B,
                v.push(B)));
                K[n].faces3.push(t);
                K[n].vertices += 3
            }
            k[m] = v;
            b.groupsNeedUpdate = !1
        }
        k = ib[b.id];
        m = 0;
        for (c = k.length; m < c; m++) {
            l = 
            k[m];
            if (void 0 === l.__webglVertexBuffer) {
                f = l;
                f.__webglVertexBuffer = A.createBuffer();
                f.__webglNormalBuffer = A.createBuffer();
                f.__webglTangentBuffer = A.createBuffer();
                f.__webglColorBuffer = A.createBuffer();
                f.__webglUVBuffer = A.createBuffer();
                f.__webglUV2Buffer = A.createBuffer();
                f.__webglSkinIndicesBuffer = A.createBuffer();
                f.__webglSkinWeightsBuffer = A.createBuffer();
                f.__webglFaceBuffer = A.createBuffer();
                f.__webglLineBuffer = A.createBuffer();
                ka.info.memory.geometries++;
                f = l;
                v = a;
                t = v.geometry;
                r = f.faces3;
                q = 3 * r.length;
                K = 1 * r.length;
                w = 3 * r.length;
                r = h(v, f);
                n = d(r);
                B = g(r);
                z = r.vertexColors ? r.vertexColors : !1;
                f.__vertexArray = new Float32Array(3 * q);
                B && (f.__normalArray = new Float32Array(3 * q));
                t.hasTangents && (f.__tangentArray = new Float32Array(4 * q));
                z && (f.__colorArray = new Float32Array(3 * q));
                n && (0 < t.faceVertexUvs.length && (f.__uvArray = new Float32Array(2 * q)),
                1 < t.faceVertexUvs.length && (f.__uv2Array = new Float32Array(2 * q)));
                v.geometry.skinWeights.length && v.geometry.skinIndices.length && (f.__skinIndexArray = new Float32Array(4 * q),
                f.__skinWeightArray = 
                new Float32Array(4 * q));
                v = null  !== ma.get("OES_element_index_uint") && 21845 < K ? Uint32Array : Uint16Array;
                f.__typeArray = v;
                f.__faceArray = new v(3 * K);
                f.__lineArray = new v(2 * w);
                f.__webglFaceCount = 3 * K;
                f.__webglLineCount = 2 * w;
                if (r.attributes)
                    for (K in void 0 === f.__webglCustomAttributesList && (f.__webglCustomAttributesList = []),
                    K = void 0,
                    r.attributes) {
                        var v = r.attributes[K], t = {}, D;
                        for (D in v)
                            t[D] = v[D];
                        if (!t.__webglInitialized || t.createUniqueBuffers)
                            t.__webglInitialized = !0,
                            w = 1,
                            "v2" === t.type ? w = 2 : "v3" === t.type ? w = 3 : "v4" === 
                            t.type ? w = 4 : "c" === t.type && (w = 3),
                            t.size = w,
                            t.array = new Float32Array(q * w),
                            t.buffer = A.createBuffer(),
                            t.buffer.belongsToAttribute = K,
                            v.needsUpdate = !0,
                            t.__original = v;
                        f.__webglCustomAttributesList.push(t)
                    }
                f.__inittedArrays = !0;
                b.verticesNeedUpdate = !0;
                b.morphTargetsNeedUpdate = !0;
                b.elementsNeedUpdate = !0;
                b.uvsNeedUpdate = !0;
                b.normalsNeedUpdate = !0;
                b.tangentsNeedUpdate = !0;
                f = b.colorsNeedUpdate = !0
            } else
                f = !1;
            (f || void 0 === a.__webglActive) && E(da, l, a)
        }
        a.__webglActive = !0
    }
    function E(a, b, c) {
        var d = c.id;
        a[d] = a[d] || [];
        a[d].push({
            id: d,
            buffer: b,
            object: c,
            material: null ,
            z: 0
        })
    }
    function G(a) {
        for (var b in a.attributes)
            if (a.attributes[b].needsUpdate)
                return !0;
        return !1
    }
    function B(a) {
        for (var b in a.attributes)
            a.attributes[b].needsUpdate = !1
    }
    function v(a) {
        !0 === a.transparent && Aa.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha);
        Aa.setDepthTest(a.depthTest);
        Aa.setDepthWrite(a.depthWrite);
        Aa.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
    }
    function D(a, 
    b, c, d, f) {
        var g, h, k, m;
        Na = 0;
        if (d.needsUpdate) {
            d.program && Fb(d);
            d.addEventListener("dispose", zb);
            var l = Ib[d.type];
            l ? (g = THREE.ShaderLib[l],
            d.__webglShader = {
                uniforms: THREE.UniformsUtils.clone(g.uniforms),
                vertexShader: g.vertexShader,
                fragmentShader: g.fragmentShader
            }) : d.__webglShader = {
                uniforms: d.uniforms,
                vertexShader: d.vertexShader,
                fragmentShader: d.fragmentShader
            };
            for (var n = m = k = h = g = 0, q = b.length; n < q; n++) {
                var r = b[n];
                r.onlyShadow || (r instanceof THREE.DirectionalLight && g++,
                r instanceof THREE.PointLight && h++,
                r instanceof THREE.SpotLight && k++,
                r instanceof THREE.HemisphereLight && m++)
            }
            q = n = 0;
            for (r = b.length; q < r; q++) {
                var B = b[q];
                B.castShadow && (B instanceof THREE.SpotLight && n++,
                B instanceof THREE.DirectionalLight && !B.shadowCascade && n++)
            }
            g = {
                precision: V,
                precisionFragment: ea,
                supportsVertexTextures: ab,
                haveTextureLod: !!ma.get("EXT_shader_texture_lod"),
                map: !!d.map,
                envMap: !!d.envMap,
                irradianceMap: !!d.irradianceMap,
                envIsSpherical: d.envMap && d.envMap.mapping == THREE.SphericalReflectionMapping,
                envGammaEncoded: d.envMap && 
                d.envMap.GammaEncoded,
                irrGammaEncoded: d.irradianceMap && d.irradianceMap.GammaEncoded,
                envRGBM: d.envMap && d.envMap.RGBM,
                irrRGBM: d.irradianceMap && d.irradianceMap.RGBM,
                lightMap: !!d.lightMap,
                bumpMap: ma.get("OES_standard_derivatives") && !!d.bumpMap,
                normalMap: ma.get("OES_standard_derivatives") && !!d.normalMap,
                specularMap: !!d.specularMap,
                alphaMap: !!d.alphaMap,
                vertexColors: d.vertexColors,
                fog: c,
                useFog: d.fog,
                fogExp: c instanceof THREE.FogExp2,
                sizeAttenuation: d.sizeAttenuation,
                logarithmicDepthBuffer: ia,
                maxDirLights: g,
                maxPointLights: h,
                maxSpotLights: k,
                maxHemiLights: m,
                maxShadows: n,
                shadowMapEnabled: ka.shadowMapEnabled && f.receiveShadow,
                shadowMapType: ka.shadowMapType,
                shadowMapDebug: ka.shadowMapDebug,
                shadowMapCascade: ka.shadowMapCascade,
                alphaTest: d.alphaTest,
                metal: d.metal,
                clearcoat: d.clearcoat,
                wrapAround: d.wrapAround,
                doubleSided: d.side === THREE.DoubleSide,
                flipSided: d.side === THREE.BackSide,
                mrtNormals: d.mrtNormals,
                mrtIdBuffer: d.mrtIdBuffer,
                tonemapOutput: d.tonemapOutput,
                packedNormals: d.packedNormals,
                hatchPattern: !!d.hatchParams,
                numCutplanes: d.cutplanes ? d.cutplanes.length : 0,
                mapInvert: d.map && d.map.invert,
                mapClampS: d.map && d.map.clampS,
                mapClampT: d.map && d.map.clampT,
                bumpMapClampS: d.bumpMap && d.bumpMap.clampS,
                bumpMapClampT: d.bumpMap && d.bumpMap.clampT,
                normalMapClampS: d.normalMap && d.normalMap.clampS,
                normalMapClampT: d.normalMap && d.normalMap.clampT,
                specularMapClampS: d.specularMap && d.specularMap.clampS,
                specularMapClampT: d.specularMap && d.specularMap.clampT,
                alphaMapInvert: d.alphaMap && d.alphaMap.invert,
                alphaMapClampS: d.alphaMap && d.alphaMap.clampS,
                alphaMapClampT: d.alphaMap && d.alphaMap.clampT
            };
            h = [];
            l ? h.push(l) : (h.push(d.fragmentShader),
            h.push(d.vertexShader));
            for (var v in d.defines)
                h.push(v),
                h.push(d.defines[v]);
            for (var t in g)
                h.push(t),
                h.push(g[t]);
            var l = h.join(), w;
            t = 0;
            for (v = ja.length; t < v; t++)
                if (h = ja[t],
                h.code === l) {
                    w = h;
                    w.usedTimes++;
                    break
                }
            void 0 === w && (w = new FireflyWebGLProgram(ka,l,d,g),
            ja.push(w),
            ka.info.memory.programs = ja.length);
            d.program = w;
            d.uniformsList = [];
            for (u in d.__webglShader.uniforms)
                (t = d.program.uniforms[u]) && d.uniformsList.push([d.__webglShader.uniforms[u], 
                t]);
            d.needsUpdate = !1
        }
        h = g = v = !1;
        t = d.program;
        w = t.uniforms;
        l = d.__webglShader.uniforms;
        t.id !== za && (A.useProgram(t.program),
        za = t.id,
        h = g = v = !0);
        d.id !== qa && (-1 === qa && (h = !0),
        qa = d.id,
        g = !0);
        if (v || a !== La)
            if (A.uniformMatrix4fv(w.projectionMatrix, !1, a.projectionMatrix.elements),
            ia && A.uniform1f(w.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)),
            a !== La && (La = a),
            (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.isPrismMaterial || d.envMap) && null  !== w.cameraPosition && (sa.setFromMatrixPosition(a.matrixWorld),
            A.uniform3f(w.cameraPosition, sa.x, sa.y, sa.z)),
            d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.ShaderMaterial || d.isPrismMaterial || d.skinning)
                null  !== w.viewMatrix && A.uniformMatrix4fv(w.viewMatrix, !1, a.matrixWorldInverse.elements),
                null  !== w.viewMatrixInverse && A.uniformMatrix4fv(w.viewMatrixInverse, !1, Fa.elements),
                w.mvpMatrix && A.uniformMatrix4fv(w.mvpMatrix, !1, pa.elements),
                h ? (H(l, d),
                I(l, !0)) : I(l, !1);
        if (g) {
            c && d.fog && (l.fogColor.value = c.color,
            c instanceof THREE.Fog ? 
            (l.fogNear.value = c.near,
            l.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (l.fogDensity.value = c.density));
            if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.isPrismMaterial || d.lights)
                Oa && (h = !0,
                K(b),
                Oa = !1),
                h ? (c = Pa,
                l.ambientLightColor.value = c.ambient,
                l.directionalLightColor.value = c.directional.colors,
                l.directionalLightDirection.value = c.directional.positions,
                l.pointLightColor.value = c.point.colors,
                l.pointLightPosition.value = c.point.positions,
                l.pointLightDistance.value = 
                c.point.distances,
                l.spotLightColor.value = c.spot.colors,
                l.spotLightPosition.value = c.spot.positions,
                l.spotLightDistance.value = c.spot.distances,
                l.spotLightDirection.value = c.spot.directions,
                l.spotLightAngleCos.value = c.spot.anglesCos,
                l.spotLightExponent.value = c.spot.exponents,
                l.hemisphereLightSkyColor.value = c.hemi.skyColors,
                l.hemisphereLightGroundColor.value = c.hemi.groundColors,
                l.hemisphereLightDirection.value = c.hemi.positions,
                L(l, !0)) : L(l, !1);
            if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || 
            d instanceof THREE.MeshPhongMaterial)
                z(l, d),
                H(l, d);
            d instanceof THREE.LineBasicMaterial ? (l.diffuse.value = d.color,
            l.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (l.diffuse.value = d.color,
            l.opacity.value = d.opacity,
            l.dashSize.value = d.dashSize,
            l.totalSize.value = d.dashSize + d.gapSize,
            l.scale.value = d.scale) : d instanceof THREE.MeshPhongMaterial ? (l.shininess.value = d.shininess,
            c = Math.log(Math.max(1 + 1E-10, d.shininess)),
            l.reflMipIndex.value = Math.max(0, -.72134752 * c + 5.5),
            l.emissive.value.copy(d.emissive),
            l.specular.value.copy(d.specular),
            d.wrapAround && l.wrapRGB.value.copy(d.wrapRGB),
            l.exposureBias.value = d.exposureBias) : d instanceof THREE.MeshLambertMaterial ? (l.emissive.value.copy(d.emissive),
            d.wrapAround && l.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (l.mNear.value = a.near,
            l.mFar.value = a.far,
            l.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial ? l.opacity.value = d.opacity : d.isPrismMaterial && (J(l, d),
            H(l, d));
            if (f.receiveShadow && !d._shadowPass && l.shadowMatrix)
                for (v = c = 
                0,
                g = b.length; v < g; v++)
                    h = b[v],
                    h.castShadow && (h instanceof THREE.SpotLight || h instanceof THREE.DirectionalLight && !h.shadowCascade) && (l.shadowMap.value[c] = h.shadowMap,
                    l.shadowMapSize.value[c] = h.shadowMapSize,
                    l.shadowMatrix.value[c] = h.shadowMatrix,
                    l.shadowDarkness.value[c] = h.shadowDarkness,
                    l.shadowBias.value[c] = h.shadowBias,
                    c++);
            d.cutplanes && 0 < d.cutplanes.length && (l.cutplanes.value = d.cutplanes,
            l.cutplanes._array && l.cutplanes._array.length != 4 * d.cutplanes && (l.cutplanes._array = void 0),
            l.cutplanesOutlineColor && 
            d.cutplanesOutlineColor && (l.cutplanesOutlineColor.value = d.cutplanesOutlineColor),
            l.cutplanesOutlineThickness && d.cutplanesOutlineThickness && (l.cutplanesOutlineThickness.value = d.cutplanesOutlineThickness));
            d.hatchParams && l.hatchParams && l.hatchParams.value.copy(d.hatchParams);
            b = d.uniformsList;
            d = 0;
            for (c = b.length; d < c; d++)
                if (l = b[d][0],
                !1 !== l.needsUpdate)
                    switch (h = l.type,
                    g = l.value,
                    v = b[d][1],
                    h) {
                    case "1i":
                        A.uniform1i(v, g);
                        break;
                    case "1f":
                        A.uniform1f(v, g);
                        break;
                    case "2f":
                        A.uniform2f(v, g[0], g[1]);
                        break;
                    case "3f":
                        A.uniform3f(v, 
                        g[0], g[1], g[2]);
                        break;
                    case "4f":
                        A.uniform4f(v, g[0], g[1], g[2], g[3]);
                        break;
                    case "1iv":
                        A.uniform1iv(v, g);
                        break;
                    case "3iv":
                        A.uniform3iv(v, g);
                        break;
                    case "1fv":
                        A.uniform1fv(v, g);
                        break;
                    case "2fv":
                        A.uniform2fv(v, g);
                        break;
                    case "3fv":
                        A.uniform3fv(v, g);
                        break;
                    case "4fv":
                        A.uniform4fv(v, g);
                        break;
                    case "Matrix3fv":
                        A.uniformMatrix3fv(v, !1, g);
                        break;
                    case "Matrix4fv":
                        A.uniformMatrix4fv(v, !1, g);
                        break;
                    case "i":
                        A.uniform1i(v, g);
                        break;
                    case "f":
                        A.uniform1f(v, g);
                        break;
                    case "v2":
                        A.uniform2f(v, g.x, g.y);
                        break;
                    case "v3":
                        A.uniform3f(v, 
                        g.x, g.y, g.z);
                        break;
                    case "v4":
                        A.uniform4f(v, g.x, g.y, g.z, g.w);
                        break;
                    case "c":
                        A.uniform3f(v, g.r, g.g, g.b);
                        break;
                    case "iv1":
                        A.uniform1iv(v, g);
                        break;
                    case "iv":
                        A.uniform3iv(v, g);
                        break;
                    case "fv1":
                        A.uniform1fv(v, g);
                        break;
                    case "fv":
                        A.uniform3fv(v, g);
                        break;
                    case "v2v":
                        void 0 === l._array && (l._array = new Float32Array(2 * g.length));
                        h = 0;
                        for (k = g.length; h < k; h++)
                            m = 2 * h,
                            l._array[m] = g[h].x,
                            l._array[m + 1] = g[h].y;
                        A.uniform2fv(v, l._array);
                        break;
                    case "v3v":
                        void 0 === l._array && (l._array = new Float32Array(3 * g.length));
                        h = 0;
                        for (k = g.length; h < 
                        k; h++)
                            m = 3 * h,
                            l._array[m] = g[h].x,
                            l._array[m + 1] = g[h].y,
                            l._array[m + 2] = g[h].z;
                        A.uniform3fv(v, l._array);
                        break;
                    case "v4v":
                        void 0 === l._array && (l._array = new Float32Array(4 * g.length));
                        h = 0;
                        for (k = g.length; h < k; h++)
                            m = 4 * h,
                            l._array[m] = g[h].x,
                            l._array[m + 1] = g[h].y,
                            l._array[m + 2] = g[h].z,
                            l._array[m + 3] = g[h].w;
                        A.uniform4fv(v, l._array);
                        break;
                    case "m3":
                        A.uniformMatrix3fv(v, !1, g.elements);
                        break;
                    case "m3v":
                        void 0 === l._array && (l._array = new Float32Array(9 * g.length));
                        h = 0;
                        for (k = g.length; h < k; h++)
                            g[h].flattenToArrayOffset(l._array, 
                            9 * h);
                        A.uniformMatrix3fv(v, !1, l._array);
                        break;
                    case "m4":
                        A.uniformMatrix4fv(v, !1, g.elements);
                        break;
                    case "m4v":
                        void 0 === l._array && (l._array = new Float32Array(16 * g.length));
                        h = 0;
                        for (k = g.length; h < k; h++)
                            g[h].flattenToArrayOffset(l._array, 16 * h);
                        A.uniformMatrix4fv(v, !1, l._array);
                        break;
                    case "t":
                        m = g;
                        g = F();
                        A.uniform1i(v, g);
                        if (!m)
                            continue;if (m instanceof THREE.CubeTexture || m.image instanceof Array && 6 === m.image.length) {
                            if (l = m,
                            v = g,
                            6 === l.image.length)
                                if (l.needsUpdate) {
                                    l.image.__webglTextureCube || (l.addEventListener("dispose", 
                                    pb),
                                    l.image.__webglTextureCube = A.createTexture(),
                                    ka.info.memory.textures++);
                                    A.activeTexture(A.TEXTURE0 + v);
                                    A.bindTexture(A.TEXTURE_CUBE_MAP, l.image.__webglTextureCube);
                                    A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL, l.flipY);
                                    v = l instanceof THREE.CompressedTexture;
                                    g = l.image[0] instanceof THREE.DataTexture;
                                    h = [];
                                    for (k = 0; 6 > k; k++)
                                        h[k] = !ka.autoScaleCubemaps || v || g ? g ? l.image[k].image : l.image[k] : S(l.image[k], kb);
                                    k = h[0];
                                    m = THREE.Math.isPowerOfTwo(k.width) && THREE.Math.isPowerOfTwo(k.height);
                                    n = P(l.format);
                                    q = P(l.type);
                                    M(A.TEXTURE_CUBE_MAP, 
                                    l, m);
                                    for (k = 0; 6 > k; k++)
                                        if (v)
                                            for (var B = h[k].mipmaps, D = 0, C = B.length; D < C; D++)
                                                r = B[D],
                                                l.format !== THREE.RGBAFormat && l.format !== THREE.RGBFormat ? -1 < Va().indexOf(n) ? A.compressedTexImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + k, D, n, r.width, r.height, 0, r.data) : console.warn("Attempt to load unsupported compressed texture format") : A.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + k, D, n, r.width, r.height, 0, n, q, r.data);
                                        else
                                            g ? A.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + k, 0, n, h[k].width, h[k].height, 0, n, q, h[k].data) : A.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X + 
                                            k, 0, n, n, q, h[k]);
                                    l.generateMipmaps && m && A.generateMipmap(A.TEXTURE_CUBE_MAP);
                                    l.needsUpdate = !1;
                                    if (l.onUpdate)
                                        l.onUpdate()
                                } else
                                    A.activeTexture(A.TEXTURE0 + v),
                                    A.bindTexture(A.TEXTURE_CUBE_MAP, l.image.__webglTextureCube)
                        } else
                            m instanceof THREE.WebGLRenderTargetCube ? (l = m,
                            A.activeTexture(A.TEXTURE0 + g),
                            A.bindTexture(A.TEXTURE_CUBE_MAP, l.__webglTexture)) : ka.setTexture(m, g);
                        break;
                    case "tv":
                        void 0 === l._array && (l._array = []);
                        h = 0;
                        for (k = l.value.length; h < k; h++)
                            l._array[h] = F();
                        A.uniform1iv(v, l._array);
                        h = 0;
                        for (k = l.value.length; h < 
                        k; h++)
                            m = l.value[h],
                            g = l._array[h],
                            m && ka.setTexture(m, g);
                        break;
                    default:
                        console.warn("THREE.WebGLRenderer: Unknown uniform type: " + h)
                    }
        }
        Y.multiplyMatrices(a.matrixWorldInverse, f.matrixWorld);
        A.uniformMatrix4fv(w.modelViewMatrix, !1, Y.elements);
        w.normalMatrix && (Ia.getNormalMatrix(Y),
        A.uniformMatrix3fv(w.normalMatrix, !1, Ia.elements));
        null  !== w.modelMatrix && A.uniformMatrix4fv(w.modelMatrix, !1, f.matrixWorld.elements);
        null  !== w.dbId && (a = f.dbId || f.fragId || 0,
        A.uniform4f(w.dbId, (a & 255) / 255, (a >> 8 & 255) / 255, (a >> 16 & 
        255) / 255, (a >> 24 & 255) / 255));
        return t
    }
    function z(a, b) {
        function c(a, b, d) {
            var f = d.offset
              , g = d.repeat;
            b ? (a = b.value,
            d.matrix ? a.copy(d.matrix) : a.identity(),
            a.elements[6] += f.x,
            a.elements[7] += f.y,
            a.elements[0] *= g.x,
            a.elements[3] *= g.x,
            a.elements[1] *= g.y,
            a.elements[4] *= g.y) : a.offsetRepeat.value.set(f.x, f.y, g.x, g.y)
        }
        a.opacity.value = b.opacity;
        a.diffuse.value.copy(b.color);
        a.map.value = b.map;
        a.lightMap.value = b.lightMap;
        a.specularMap.value = b.specularMap;
        a.alphaMap.value = b.alphaMap;
        b.bumpMap && (a.bumpMap.value = b.bumpMap,
        a.bumpScale.value = b.bumpScale);
        b.normalMap && (a.normalMap.value = b.normalMap,
        a.normalScale.value.copy(b.normalScale));
        b.alphaMap && c(a, a.texMatrixAlpha, b.alphaMap);
        var d;
        b.normalMap ? d = b.normalMap : b.bumpMap && (d = b.bumpMap);
        void 0 !== d && c(a, a.texMatrixBump, d);
        var f;
        b.map ? f = b.map : b.specularMap && (f = b.specularMap);
        void 0 !== f && c(a, a.texMatrix, f);
        a.envMap.value = b.envMap;
        a.irradianceMap && (a.irradianceMap.value = b.irradianceMap);
        a.reflectivity.value = b.reflectivity;
        a.refractionRatio.value = b.refractionRatio
    }
    function H(a, 
    b) {
        a.envMap && (a.envMap.value = b.envMap);
        a.irradianceMap && (a.irradianceMap.value = b.irradianceMap);
        a.envMapExposure && (a.envMapExposure.value = b.envMapExposure)
    }
    function I(a, b) {
        a.envMap && (a.envMap.needsUpdate = b);
        a.irradianceMap && (a.irradianceMap.needsUpdate = b);
        a.envMapExposure && (a.envMapExposure.needsUpdate = b)
    }
    function J(a, b) {
        function c(a, b, d) {
            a[d].value = b[d];
            null  != b[d] && (a[d + "_texMatrix"].value = (new THREE.Matrix3).copy(b[d].matrix),
            a[d + "_invert"].value = b[d].invert)
        }
        function d(a, b, c) {
            a[c].value = b[c];
            null  != 
            b[c] && (a[c + "_texMatrix"].value = (new THREE.Matrix3).copy(b[c].matrix),
            a[c + "_bumpScale"].value = (new THREE.Vector2).copy(b[c].bumpScale),
            a[c + "_bumpmapType"].value = b[c].bumpmapType)
        }
        a.exposureBias.value = b.exposureBias;
        a.surface_albedo.value = (new THREE.Color).copy(b.surface_albedo);
        a.surface_roughness.value = b.surface_roughness;
        a.surface_anisotropy.value = b.surface_anisotropy;
        a.surface_rotation.value = b.surface_rotation;
        c(a, b, "surface_albedo_map");
        c(a, b, "surface_roughness_map");
        c(a, b, "surface_cutout_map");
        c(a, b, "surface_anisotropy_map");
        c(a, b, "surface_rotation_map");
        d(a, b, "surface_normal_map");
        switch (b.prismType) {
        case "PrismOpaque":
            a.opaque_albedo.value = (new THREE.Color).copy(b.opaque_albedo);
            a.opaque_luminance_modifier.value = (new THREE.Color).copy(b.opaque_luminance_modifier);
            a.opaque_f0.value = b.opaque_f0;
            a.opaque_luminance.value = b.opaque_luminance;
            c(a, b, "opaque_albedo_map");
            c(a, b, "opaque_luminance_modifier_map");
            c(a, b, "opaque_f0_map");
            break;
        case "PrismMetal":
            a.metal_f0.value = (new THREE.Color).copy(b.metal_f0);
            c(a, b, "metal_f0_map");
            break;
        case "PrismLayered":
            a.layered_f0.value = b.layered_f0;
            a.layered_diffuse.value = (new THREE.Color).copy(b.layered_diffuse);
            a.layered_fraction.value = b.layered_fraction;
            a.layered_bottom_f0.value = (new THREE.Color).copy(b.layered_bottom_f0);
            a.layered_roughness.value = b.layered_roughness;
            a.layered_anisotropy.value = b.layered_anisotropy;
            a.layered_rotation.value = b.layered_rotation;
            c(a, b, "layered_bottom_f0_map");
            c(a, b, "layered_f0_map");
            c(a, b, "layered_diffuse_map");
            c(a, b, "layered_fraction_map");
            c(a, b, "layered_roughness_map");
            c(a, b, "layered_anisotropy_map");
            c(a, b, "layered_rotation_map");
            d(a, b, "layered_normal_map");
            break;
        case "PrismTransparent":
            a.transparent_color.value = (new THREE.Color).copy(b.transparent_color);
            a.transparent_distance.value = b.transparent_distance;
            a.transparent_ior.value = b.transparent_ior;
            break;
        default:
            console.warn("Unknown prism type: " + b.prismType)
        }
        a.envExponentMin.value = b.envExponentMin;
        a.envExponentMax.value = b.envExponentMax;
        a.envExponentCount.value = b.envExponentCount
    }
    function L(a, b) {
        a.ambientLightColor.needsUpdate = b;
        a.directionalLightColor.needsUpdate = b;
        a.directionalLightDirection.needsUpdate = b;
        a.pointLightColor.needsUpdate = b;
        a.pointLightPosition.needsUpdate = b;
        a.pointLightDistance.needsUpdate = b;
        a.spotLightColor.needsUpdate = b;
        a.spotLightPosition.needsUpdate = b;
        a.spotLightDistance.needsUpdate = b;
        a.spotLightDirection.needsUpdate = b;
        a.spotLightAngleCos.needsUpdate = b;
        a.spotLightExponent.needsUpdate = b;
        a.hemisphereLightSkyColor.needsUpdate = b;
        a.hemisphereLightGroundColor.needsUpdate = 
        b;
        a.hemisphereLightDirection.needsUpdate = b
    }
    function F() {
        var a = Na;
        a >= fb && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + fb);
        Na += 1;
        return a
    }
    function N(a, b, c, d) {
        a[b] = c.r * d;
        a[b + 1] = c.g * d;
        a[b + 2] = c.b * d
    }
    function K(a) {
        var b, c, d, f = 0, g = 0, h = 0, k, l, m, n = Pa, q = n.directional.colors, r = n.directional.positions, B = n.point.colors, v = n.point.positions, K = n.point.distances, t = n.spot.colors, w = n.spot.positions, z = n.spot.distances, D = n.spot.directions, C = n.spot.anglesCos, J = n.spot.exponents, 
        G = n.hemi.skyColors, F = n.hemi.groundColors, M = n.hemi.positions, ka = 0, L = 0, A = 0, H = 0, I = 0, xa = 0, E = 0, Y = 0, da = d = 0;
        b = m = da = 0;
        for (c = a.length; b < c; b++)
            d = a[b],
            d.onlyShadow || (k = d.color,
            l = d.intensity,
            m = d.distance,
            d instanceof THREE.AmbientLight ? d.visible && (f += k.r,
            g += k.g,
            h += k.b) : d instanceof THREE.DirectionalLight ? (I += 1,
            d.visible && (va.setFromMatrixPosition(d.matrixWorld),
            sa.setFromMatrixPosition(d.target.matrixWorld),
            va.sub(sa),
            va.normalize(),
            d = 3 * ka,
            r[d] = va.x,
            r[d + 1] = va.y,
            r[d + 2] = va.z,
            N(q, d, k, l),
            ka += 1)) : d instanceof THREE.PointLight ? 
            (xa += 1,
            d.visible && (da = 3 * L,
            N(B, da, k, l),
            sa.setFromMatrixPosition(d.matrixWorld),
            v[da] = sa.x,
            v[da + 1] = sa.y,
            v[da + 2] = sa.z,
            K[L] = m,
            L += 1)) : d instanceof THREE.SpotLight ? (E += 1,
            d.visible && (da = 3 * A,
            N(t, da, k, l),
            sa.setFromMatrixPosition(d.matrixWorld),
            w[da] = sa.x,
            w[da + 1] = sa.y,
            w[da + 2] = sa.z,
            z[A] = m,
            va.copy(sa),
            sa.setFromMatrixPosition(d.target.matrixWorld),
            va.sub(sa),
            va.normalize(),
            D[da] = va.x,
            D[da + 1] = va.y,
            D[da + 2] = va.z,
            C[A] = Math.cos(d.angle),
            J[A] = d.exponent,
            A += 1)) : d instanceof THREE.HemisphereLight && (Y += 1,
            d.visible && (va.setFromMatrixPosition(d.matrixWorld),
            va.normalize(),
            m = 3 * H,
            M[m] = va.x,
            M[m + 1] = va.y,
            M[m + 2] = va.z,
            k = d.color,
            d = d.groundColor,
            N(G, m, k, l),
            N(F, m, d, l),
            H += 1)));
        b = 3 * ka;
        for (c = Math.max(q.length, 3 * I); b < c; b++)
            q[b] = 0;
        b = 3 * L;
        for (c = Math.max(B.length, 3 * xa); b < c; b++)
            B[b] = 0;
        b = 3 * A;
        for (c = Math.max(t.length, 3 * E); b < c; b++)
            t[b] = 0;
        b = 3 * H;
        for (c = Math.max(G.length, 3 * Y); b < c; b++)
            G[b] = 0;
        b = 3 * H;
        for (c = Math.max(F.length, 3 * Y); b < c; b++)
            F[b] = 0;
        n.directional.length = ka;
        n.point.length = L;
        n.spot.length = A;
        n.hemi.length = H;
        n.ambient[0] = f;
        n.ambient[1] = g;
        n.ambient[2] = h
    }
    function M(a, b, c) {
        c ? 
        (A.texParameteri(a, A.TEXTURE_WRAP_S, P(b.wrapS)),
        A.texParameteri(a, A.TEXTURE_WRAP_T, P(b.wrapT)),
        A.texParameteri(a, A.TEXTURE_MAG_FILTER, P(b.magFilter)),
        A.texParameteri(a, A.TEXTURE_MIN_FILTER, P(b.minFilter))) : (A.texParameteri(a, A.TEXTURE_WRAP_S, A.CLAMP_TO_EDGE),
        A.texParameteri(a, A.TEXTURE_WRAP_T, A.CLAMP_TO_EDGE),
        b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( " + 
        b.sourceFile + " )"),
        A.texParameteri(a, A.TEXTURE_MAG_FILTER, ba(b.magFilter)),
        A.texParameteri(a, A.TEXTURE_MIN_FILTER, ba(b.minFilter)),
        b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( " + b.sourceFile + " )"));
        (c = ma.get("EXT_texture_filter_anisotropic")) && b.type !== THREE.FloatType && b.type !== THREE.HalfFloatType && (1 < b.anisotropy || b.__oldAnisotropy) && 
        (A.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, ka.getMaxAnisotropy())),
        b.__oldAnisotropy = b.anisotropy)
    }
    function S(a, b) {
        if (a.width <= b && a.height <= b)
            return a;
        var c = Math.max(a.width, a.height)
          , d = Math.floor(a.width * b / c)
          , c = Math.floor(a.height * b / c)
          , f = document.createElement("canvas");
        f.width = d;
        f.height = c;
        f.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d, c);
        return f
    }
    function ba(a) {
        return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? 
        A.NEAREST : A.LINEAR
    }
    function P(a) {
        var b;
        if (a === THREE.RepeatWrapping)
            return A.REPEAT;
        if (a === THREE.ClampToEdgeWrapping)
            return A.CLAMP_TO_EDGE;
        if (a === THREE.MirroredRepeatWrapping)
            return A.MIRRORED_REPEAT;
        if (a === THREE.NearestFilter)
            return A.NEAREST;
        if (a === THREE.NearestMipMapNearestFilter)
            return A.NEAREST_MIPMAP_NEAREST;
        if (a === THREE.NearestMipMapLinearFilter)
            return A.NEAREST_MIPMAP_LINEAR;
        if (a === THREE.LinearFilter)
            return A.LINEAR;
        if (a === THREE.LinearMipMapNearestFilter)
            return A.LINEAR_MIPMAP_NEAREST;
        if (a === 
        THREE.LinearMipMapLinearFilter)
            return A.LINEAR_MIPMAP_LINEAR;
        if (a === THREE.UnsignedByteType)
            return A.UNSIGNED_BYTE;
        if (a === THREE.UnsignedShort4444Type)
            return A.UNSIGNED_SHORT_4_4_4_4;
        if (a === THREE.UnsignedShort5551Type)
            return A.UNSIGNED_SHORT_5_5_5_1;
        if (a === THREE.UnsignedShort565Type)
            return A.UNSIGNED_SHORT_5_6_5;
        if (a === THREE.ByteType)
            return A.BYTE;
        if (a === THREE.ShortType)
            return A.SHORT;
        if (a === THREE.UnsignedShortType)
            return A.UNSIGNED_SHORT;
        if (a === THREE.IntType)
            return A.INT;
        if (a === THREE.UnsignedIntType)
            return A.UNSIGNED_INT;
        if (a === THREE.FloatType)
            return A.FLOAT;
        if (a === THREE.HalfFloatType)
            return 36193;
        if (a === THREE.AlphaFormat)
            return A.ALPHA;
        if (a === THREE.RGBFormat)
            return A.RGB;
        if (a === THREE.RGBAFormat)
            return A.RGBA;
        if (a === THREE.LuminanceFormat)
            return A.LUMINANCE;
        if (a === THREE.LuminanceAlphaFormat)
            return A.LUMINANCE_ALPHA;
        if (a === THREE.AddEquation)
            return A.FUNC_ADD;
        if (a === THREE.SubtractEquation)
            return A.FUNC_SUBTRACT;
        if (a === THREE.ReverseSubtractEquation)
            return A.FUNC_REVERSE_SUBTRACT;
        if (a === THREE.ZeroFactor)
            return A.ZERO;
        if (a === THREE.OneFactor)
            return A.ONE;
        if (a === THREE.SrcColorFactor)
            return A.SRC_COLOR;
        if (a === THREE.OneMinusSrcColorFactor)
            return A.ONE_MINUS_SRC_COLOR;
        if (a === THREE.SrcAlphaFactor)
            return A.SRC_ALPHA;
        if (a === THREE.OneMinusSrcAlphaFactor)
            return A.ONE_MINUS_SRC_ALPHA;
        if (a === THREE.DstAlphaFactor)
            return A.DST_ALPHA;
        if (a === THREE.OneMinusDstAlphaFactor)
            return A.ONE_MINUS_DST_ALPHA;
        if (a === THREE.DstColorFactor)
            return A.DST_COLOR;
        if (a === THREE.OneMinusDstColorFactor)
            return A.ONE_MINUS_DST_COLOR;
        if (a === THREE.SrcAlphaSaturateFactor)
            return A.SRC_ALPHA_SATURATE;
        b = ma.get("WEBGL_compressed_texture_s3tc");
        if (null  !== b) {
            if (a === THREE.RGB_S3TC_DXT1_Format)
                return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT1_Format)
                return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT3_Format)
                return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === THREE.RGBA_S3TC_DXT5_Format)
                return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
        b = ma.get("WEBGL_compressed_texture_pvrtc");
        if (null  !== b) {
            if (a === THREE.RGB_PVRTC_4BPPV1_Format)
                return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGB_PVRTC_2BPPV1_Format)
                return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_4BPPV1_Format)
                return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (a === THREE.RGBA_PVRTC_2BPPV1_Format)
                return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        }
        b = ma.get("EXT_blend_minmax");
        if (null  !== b) {
            if (a === THREE.MinEquation)
                return b.MIN_EXT;
            if (a === THREE.MaxEquation)
                return b.MAX_EXT
        }
        return 0
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION);
    f = f || {};
    var aa = void 0 !== f.canvas ? f.canvas : document.createElement("canvas")
      , Z = window.devicePixelRatio || 1
      , V = void 0 !== f.precision ? f.precision : "highp"
      , ea = void 0 !== 
    f.precision ? f.precision : isMobileDevice() ? "mediump" : "highp"
      , X = void 0 !== f.alpha ? f.alpha : !1
      , R = void 0 !== f.premultipliedAlpha ? f.premultipliedAlpha : !0
      , T = void 0 !== f.antialias ? f.antialias : !1
      , O = void 0 !== f.stencil ? f.stencil : !0
      , ca = void 0 !== f.preserveDrawingBuffer ? f.preserveDrawingBuffer : !0
      , ia = void 0 !== f.logarithmicDepthBuffer ? f.logarithmicDepthBuffer : !1
      , fa = new THREE.Color(0)
      , W = 0
      , ga = []
      , da = {}
      , na = []
      , Y = new THREE.Matrix4
      , Ia = new THREE.Matrix3
      , Ha = []
      , xa = [];
    this.domElement = aa;
    this.context = null ;
    this.sortObjects = this.autoClearStencil = 
    this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
    this.shadowMapAutoUpdate = !0;
    this.shadowMapType = THREE.PCFShadowMap;
    this.shadowMapCullFace = THREE.CullFaceFront;
    this.shadowMapCascade = this.shadowMapDebug = !1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    this.autoScaleCubemaps = !0;
    this.info = {
        memory: {
            programs: 0,
            geometries: 0,
            textures: 0
        },
        render: {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        }
    };
    var ka = this
      , ja = []
      , za = null 
      , ha = null 
      , qa = -1
      , La = null 
      , Ja = "";
    new THREE.Frustum;
    new THREE.Matrix4;
    new THREE.Matrix4;
    var Na = 0, Ma = 0, Ea = 0, ya = aa.width, la = aa.height, ta = {}, oa = new THREE.Frustum, pa = new THREE.Matrix4, Fa = new THREE.Matrix4, sa = new THREE.Vector3, va = new THREE.Vector3, Oa = !0, Pa = {
        ambient: [0, 0, 0],
        directional: {
            length: 0,
            colors: [],
            positions: []
        },
        point: {
            length: 0,
            colors: [],
            positions: [],
            distances: []
        },
        spot: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            directions: [],
            anglesCos: [],
            exponents: []
        },
        hemi: {
            length: 0,
            skyColors: [],
            groundColors: [],
            positions: []
        }
    }, A, Da, Sa, Ka;
    try {
        var $a = {
            alpha: X,
            premultipliedAlpha: R,
            antialias: T,
            stencil: O,
            preserveDrawingBuffer: ca
        };
        A = aa.getContext("webgl", $a) || aa.getContext("experimental-webgl", $a);
        if (null  === A) {
            if (null  !== aa.getContext("webgl"))
                throw "Error creating WebGL context with your selected attributes.";
            throw "Error creating WebGL context.";
        }
        aa.addEventListener("webglcontextlost", function(a) {
            a.preventDefault();
            Xa();
            db();
            da = {}
        }
        , !1)
    } catch (tb) {
        console.error(tb)
    }
    var Aa = new THREE.WebGLState(A,P);
    void 0 === A.getShaderPrecisionFormat && (A.getShaderPrecisionFormat = function() {
        return {
            rangeMin: 1,
            rangeMax: 1,
            precision: 1
        }
    }
    );
    var ma = new THREE.WebGLExtensions(A);
    ma.get("OES_texture_float");
    ma.get("OES_texture_float_linear");
    ma.get("OES_texture_half_float");
    ma.get("OES_texture_half_float_linear");
    ma.get("OES_standard_derivatives");
    ma.get("EXT_shader_texture_lod");
    ma.get("EXT_texture_filter_anisotropic");
    ma.get("WEBGL_compressed_texture_s3tc");
    Da = ma.get("WEBGL_draw_buffers");
    Sa = null ;
    Ka = ma.get("OES_vertex_array_object");
    ia && ma.get("EXT_frag_depth");
    var Wa = function(a, b, c, d) {
        !0 === R && (a *= d,
        b *= d,
        c *= d);
        A.clearColor(a, b, c, d)
    }
      , db = function() {
        A.clearColor(0, 0, 0, 1);
        A.clearDepth(1);
        A.clearStencil(0);
        A.enable(A.DEPTH_TEST);
        A.depthFunc(A.LEQUAL);
        A.frontFace(A.CCW);
        A.cullFace(A.BACK);
        A.enable(A.CULL_FACE);
        A.enable(A.BLEND);
        A.blendEquation(A.FUNC_ADD);
        A.blendFunc(A.SRC_ALPHA, A.ONE_MINUS_SRC_ALPHA);
        A.viewport(Ma, Ea, ya, la);
        Wa(fa.r, fa.g, fa.b, W)
    }
      , Xa = function() {
        La = za = null ;
        Ja = "";
        qa = -1;
        Oa = !0;
        Aa.reset()
    }
    ;
    db();
    this.context = A;
    this.state = Aa;
    var fb = A.getParameter(A.MAX_TEXTURE_IMAGE_UNITS)
      , ub = A.getParameter(A.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , 
    eb = A.getParameter(A.MAX_TEXTURE_SIZE)
      , kb = A.getParameter(A.MAX_CUBE_MAP_TEXTURE_SIZE)
      , ab = 0 < ub;
    ab && ma.get("OES_texture_float");
    var gb = A.getShaderPrecisionFormat(A.VERTEX_SHADER, A.HIGH_FLOAT)
      , hb = A.getShaderPrecisionFormat(A.VERTEX_SHADER, A.MEDIUM_FLOAT)
      , Ya = A.getShaderPrecisionFormat(A.FRAGMENT_SHADER, A.HIGH_FLOAT)
      , bb = A.getShaderPrecisionFormat(A.FRAGMENT_SHADER, A.MEDIUM_FLOAT)
      , Va = function() {
        var a;
        return function() {
            if (void 0 !== a)
                return a;
            a = [];
            if (ma.get("WEBGL_compressed_texture_pvrtc") || ma.get("WEBGL_compressed_texture_s3tc"))
                for (var b = 
                A.getParameter(A.COMPRESSED_TEXTURE_FORMATS), c = 0; c < b.length; c++)
                    a.push(b[c]);
            return a
        }
    }
    ()
      , Ta = 0 < gb.precision
      , Qa = 0 < hb.precision;
    "highp" !== V || Ta || (Qa ? (V = "mediump",
    console.warn("WebGLRenderer: highp not supported, using mediump")) : (V = "lowp",
    console.warn("WebGLRenderer: highp and mediump not supported, using lowp")));
    "mediump" !== V || Qa || (V = "lowp",
    console.warn("WebGLRenderer: mediump not supported, using lowp"));
    Ta = 0 < Ya.precision;
    Qa = 0 < bb.precision;
    "highp" !== ea || Ta || (Qa ? (ea = "mediump",
    console.warn("WebGLRenderer: highp not supported, using mediump")) : 
    (ea = "lowp",
    console.warn("WebGLRenderer: highp and mediump not supported, using lowp")));
    "mediump" !== ea || Qa || (ea = "lowp",
    console.warn("WebGLRenderer: mediump not supported, using lowp"));
    this.getContext = function() {
        return A
    }
    ;
    this.forceContextLoss = function() {
        ma.get("WEBGL_lose_context").loseContext()
    }
    ;
    this.supportsVertexTextures = function() {
        return ab
    }
    ;
    this.supportsFloatTextures = function() {
        return ma.get("OES_texture_float")
    }
    ;
    this.supportsHalfFloatTextures = function() {
        return ma.get("OES_texture_half_float_linear")
    }
    ;
    this.supportsStandardDerivatives = function() {
        return ma.get("OES_standard_derivatives")
    }
    ;
    this.supportsCompressedTextureS3TC = function() {
        return ma.get("WEBGL_compressed_texture_s3tc")
    }
    ;
    this.supportsMRT = function() {
        return Da
    }
    ;
    this.supportsBlendMinMax = function() {
        return ma.get("EXT_blend_minmax")
    }
    ;
    this.getMaxAnisotropy = function() {
        var a;
        return function() {
            if (void 0 !== a)
                return a;
            var b = ma.get("EXT_texture_filter_anisotropic");
            return a = null  !== b ? A.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
        }
    }
    ();
    this.getPrecision = 
    function() {
        return _precision
    }
    ;
    this.getPixelRatio = function() {
        return Z
    }
    ;
    this.setPixelRatio = function(a) {
        Z = a
    }
    ;
    this.setSize = function(a, b, c) {
        aa.width = a * Z;
        aa.height = b * Z;
        !1 !== c && (aa.style.width = a + "px",
        aa.style.height = b + "px");
        this.setViewport(0, 0, a, b)
    }
    ;
    this.setViewport = function(a, b, c, d) {
        Ma = a * Z;
        Ea = b * Z;
        ya = c * Z;
        la = d * Z;
        A.viewport(Ma, Ea, ya, la)
    }
    ;
    this.setScissor = function(a, b, c, d) {
        A.scissor(a * Z, b * Z, c * Z, d * Z)
    }
    ;
    this.enableScissorTest = function(a) {
        a ? A.enable(A.SCISSOR_TEST) : A.disable(A.SCISSOR_TEST)
    }
    ;
    this.getClearColor = 
    function() {
        return fa
    }
    ;
    this.setClearColor = function(a, b) {
        fa.set(a);
        W = void 0 !== b ? b : 1;
        Wa(fa.r, fa.g, fa.b, W)
    }
    ;
    this.getClearAlpha = function() {
        return W
    }
    ;
    this.setClearAlpha = function(a) {
        W = a;
        Wa(fa.r, fa.g, fa.b, W)
    }
    ;
    this.clear = function(a, b, c) {
        var d = 0;
        if (void 0 === a || a)
            d |= A.COLOR_BUFFER_BIT;
        if (void 0 === b || b)
            d |= A.DEPTH_BUFFER_BIT;
        if (void 0 === c || c)
            d |= A.STENCIL_BUFFER_BIT;
        A.clear(d)
    }
    ;
    this.clearColor = function() {
        A.clear(A.COLOR_BUFFER_BIT)
    }
    ;
    this.clearDepth = function() {
        A.clear(A.DEPTH_BUFFER_BIT)
    }
    ;
    this.clearStencil = function() {
        A.clear(A.STENCIL_BUFFER_BIT)
    }
    ;
    this.clearTarget = function(a, b, c, d) {
        this.setRenderTarget(a);
        this.clear(b, c, d)
    }
    ;
    this.resetGLState = Xa;
    this.updateShadowMap = function(a, b) {
        za = null ;
        _oldDepthWrite = _oldDepthTest = _oldBlending = -1;
        Ja = "";
        qa = -1;
        Oa = !0;
        _oldFlipSided = _oldDoubleSided = -1;
        initObjects(a)
    }
    ;
    var Za = function(a) {
        a.target.traverse(function(a) {
            a.removeEventListener("remove", Za);
            if (a instanceof THREE.Mesh || a instanceof THREE.PointCloud || a instanceof THREE.Line)
                delete da[a.id];
            else if (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback)
                for (var b = 
                na, c = b.length - 1; 0 <= c; c--)
                    b[c].object === a && b.splice(c, 1);
            delete a.__webglInit;
            delete a.__webglActive
        }
        )
    }
      , ob = function(a) {
        a = a.target;
        a.removeEventListener("dispose", ob);
        Ab(a)
    }
      , pb = function(a) {
        a = a.target;
        a.removeEventListener("dispose", pb);
        a.image && a.image.__webglTextureCube ? A.deleteTexture(a.image.__webglTextureCube) : a.__webglInit && (a.__webglInit = !1,
        A.deleteTexture(a.__webglTexture));
        ka.info.memory.textures--
    }
      , qb = function(a) {
        a = a.target;
        a.removeEventListener("dispose", qb);
        a && a.__webglTexture && (A.deleteTexture(a.__webglTexture),
        A.deleteFramebuffer(a.__webglFramebuffer),
        A.deleteRenderbuffer(a.__webglRenderbuffer));
        ka.info.memory.textures--
    }
      , zb = function(a) {
        a = a.target;
        a.removeEventListener("dispose", zb);
        Fb(a)
    }
      , rb = function(a) {
        void 0 !== a.__webglVertexBuffer && A.deleteBuffer(a.__webglVertexBuffer);
        void 0 !== a.__webglNormalBuffer && A.deleteBuffer(a.__webglNormalBuffer);
        void 0 !== a.__webglTangentBuffer && A.deleteBuffer(a.__webglTangentBuffer);
        void 0 !== a.__webglColorBuffer && A.deleteBuffer(a.__webglColorBuffer);
        void 0 !== a.__webglUVBuffer && 
        A.deleteBuffer(a.__webglUVBuffer);
        void 0 !== a.__webglUV2Buffer && A.deleteBuffer(a.__webglUV2Buffer);
        void 0 !== a.__webglSkinIndicesBuffer && A.deleteBuffer(a.__webglSkinIndicesBuffer);
        void 0 !== a.__webglSkinWeightsBuffer && A.deleteBuffer(a.__webglSkinWeightsBuffer);
        void 0 !== a.__webglFaceBuffer && A.deleteBuffer(a.__webglFaceBuffer);
        void 0 !== a.__webglLineBuffer && A.deleteBuffer(a.__webglLineBuffer);
        void 0 !== a.__webglLineDistanceBuffer && A.deleteBuffer(a.__webglLineDistanceBuffer);
        if (void 0 !== a.__webglCustomAttributesList)
            for (var b in a.__webglCustomAttributesList)
                A.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
        ka.info.memory.geometries--
    }
      , Ab = function(a) {
        a.__webglInit = void 0;
        if (a instanceof THREE.BufferGeometry) {
            void 0 !== a.vbbuffer && A.deleteBuffer(a.vbbuffer);
            void 0 !== a.ibbuffer && A.deleteBuffer(a.ibbuffer);
            if (a.vaos)
                for (var b = 0; b < a.vaos.length; b++)
                    Ka.deleteVertexArrayOES(a.vaos[b].vao);
            a = a.attributes;
            for (var c in a)
                void 0 !== a[c].buffer && A.deleteBuffer(a[c].buffer);
            ka.info.memory.geometries--
        } else if (c = ib[a.id],
        void 0 !== c) {
            for (var b = 0, d = c.length; b < d; b++) {
                var f = c[b];
                if (void 0 !== f.numMorphTargets) {
                    for (var g = 
                    0, h = f.numMorphTargets; g < h; g++)
                        A.deleteBuffer(f.__webglMorphTargetsBuffers[g]);
                    delete f.__webglMorphTargetsBuffers
                }
                if (void 0 !== f.numMorphNormals) {
                    g = 0;
                    for (h = f.numMorphNormals; g < h; g++)
                        A.deleteBuffer(f.__webglMorphNormalsBuffers[g]);
                    delete f.__webglMorphNormalsBuffers
                }
                rb(f)
            }
            delete ib[a.id]
        } else
            rb(a)
    }
    ;
    this.deallocateGeometry = Ab;
    var Fb = function(a) {
        var b = a.program.program;
        if (void 0 !== b) {
            a.program = void 0;
            var c, d, f = !1;
            a = 0;
            for (c = ja.length; a < c; a++)
                if (d = ja[a],
                d.program === b) {
                    d.usedTimes--;
                    0 === d.usedTimes && (f = 
                    !0);
                    break
                }
            if (!0 === f) {
                f = [];
                a = 0;
                for (c = ja.length; a < c; a++)
                    d = ja[a],
                    d.program !== b && f.push(d);
                ja = f;
                A.deleteProgram(b);
                ka.info.memory.programs--
            }
        }
    }
    ;
    this.renderBufferDirect = function(b, d, f, g, h, l) {
        if (!1 !== g.visible) {
            c(l.geometry);
            b = D(b, d, f, g, l);
            var m = h.attributes;
            d = !1;
            f = "direct_" + h.id + "_" + b.id + "_" + (g.wireframe ? 1 : 0);
            f !== Ja && (Ja = f,
            d = !0);
            a: {
                if (f = h.vaos)
                    for (var n = 0; n < f.length; n++) {
                        if (f[n].geomhash === b.id) {
                            Ka.bindVertexArrayOES(f[n].vao);
                            f = !0;
                            break a
                        }
                    }
                else if (null  === f) {
                    f = !1;
                    break a
                }
                f = a(g, b, h)
            }
            (d = d && !f) && Aa.initAttributes();
            if (l instanceof THREE.Mesh)
                if (l = m.index) {
                    var q = l.array ? l.array : h.ib;
                    q instanceof Uint32Array && ma.get("OES_element_index_uint") ? (m = A.UNSIGNED_INT,
                    n = 4) : (m = A.UNSIGNED_SHORT,
                    n = 2);
                    var r = h.offsets;
                    r && 1 < r.length && (d = !0);
                    var B = 0;
                    do {
                        var v, K, t;
                        r && r.length ? (v = r[B].index,
                        K = r[B].start,
                        t = r[B].count) : (K = v = 0,
                        t = q.length);
                        d && k(g, b, h, v, l);
                        h.numInstances ? Sa.drawElementsInstancedANGLE(h.isLines ? A.LINES : A.TRIANGLES, t, m, K * n, h.numInstances) : A.drawElements(h.isLines ? A.LINES : A.TRIANGLES, t, m, K * n)
                    } while (r && ++B < r.length)
                } else
                    d && 
                    k(g, b, h, v),
                    g = h.attributes.position,
                    h.numInstances ? Sa.drawArraysInstancedANGLE(h.isLines ? A.LINE_STRIP : A.TRIANGLES, 0, g.array.length / 3, h.numInstances) : A.drawArrays(h.isLines ? A.LINE_STRIP : A.TRIANGLES, 0, g.array.length / g.itemSize);
            else
                console.log("Only THREE.Mesh can be rendered by the Firefly renderer. Use THREE.Mesh to draw lines.");
            f && Ka.bindVertexArrayOES(null )
        }
    }
    ;
    this.renderBuffer = function(a, b, f, k, l, m) {
        if (!1 !== k.visible) {
            var n = m.geometry, q, r;
            if (n instanceof THREE.BufferGeometry)
                c(n);
            else if (m instanceof 
            THREE.Mesh) {
                !0 === n.groupsNeedUpdate && C(m, n);
                for (var v = ib[n.id], K = 0, t = v.length; K < t; K++) {
                    var w = v[K];
                    r = h(m, w);
                    q = r.attributes && G(r);
                    if (n.verticesNeedUpdate || n.morphTargetsNeedUpdate || n.elementsNeedUpdate || n.uvsNeedUpdate || n.normalsNeedUpdate || n.colorsNeedUpdate || n.tangentsNeedUpdate || q) {
                        var z = w
                          , J = m
                          , F = A.DYNAMIC_DRAW
                          , M = !n.dynamic
                          , ka = r;
                        if (z.__inittedArrays) {
                            var L = g(ka)
                              , H = ka.vertexColors ? ka.vertexColors : !1
                              , I = d(ka)
                              , xa = L === THREE.SmoothShading
                              , E = void 0
                              , Y = void 0
                              , da = void 0
                              , ja = void 0
                              , na = void 0
                              , aa = void 0
                              , Ia = void 0
                              , 
                            za = void 0
                              , N = void 0
                              , S = void 0
                              , ba = void 0
                              , P = void 0
                              , V = void 0
                              , ha = void 0
                              , ea = void 0
                              , Ha = void 0
                              , X = void 0
                              , R = void 0
                              , O = void 0
                              , T = void 0
                              , qa = void 0
                              , La = void 0
                              , W = void 0
                              , ca = void 0
                              , Na = void 0
                              , ia = 0
                              , fa = 0
                              , va = 0
                              , ga = 0
                              , Ma = 0
                              , la = 0
                              , ya = 0
                              , ta = 0
                              , pa = 0
                              , U = 0
                              , Ea = void 0
                              , oa = z.__vertexArray
                              , sa = z.__uvArray
                              , Oa = z.__uv2Array
                              , ma = z.__normalArray
                              , Fa = z.__tangentArray
                              , Da = z.__colorArray
                              , Ka = z.__webglCustomAttributesList
                              , Q = void 0
                              , Qa = z.__faceArray
                              , Pa = z.__lineArray
                              , Ua = J.geometry
                              , Sa = Ua.elementsNeedUpdate
                              , Ta = Ua.uvsNeedUpdate
                              , Va = Ua.normalsNeedUpdate
                              , Za = Ua.tangentsNeedUpdate
                              , 
                            db = Ua.colorsNeedUpdate
                              , Xa = Ua.vertices
                              , ra = z.faces3
                              , cb = Ua.faces
                              , ab = Ua.faceVertexUvs[0]
                              , bb = Ua.faceVertexUvs[1];
                            if (Ua.verticesNeedUpdate) {
                                E = 0;
                                for (Y = ra.length; E < Y; E++)
                                    ja = cb[ra[E]],
                                    P = Xa[ja.a],
                                    V = Xa[ja.b],
                                    ha = Xa[ja.c],
                                    oa[fa] = P.x,
                                    oa[fa + 1] = P.y,
                                    oa[fa + 2] = P.z,
                                    oa[fa + 3] = V.x,
                                    oa[fa + 4] = V.y,
                                    oa[fa + 5] = V.z,
                                    oa[fa + 6] = ha.x,
                                    oa[fa + 7] = ha.y,
                                    oa[fa + 8] = ha.z,
                                    fa += 9;
                                A.bindBuffer(A.ARRAY_BUFFER, z.__webglVertexBuffer);
                                A.bufferData(A.ARRAY_BUFFER, oa, F)
                            }
                            if (db && H) {
                                E = 0;
                                for (Y = ra.length; E < Y; E++)
                                    ja = cb[ra[E]],
                                    Ia = ja.vertexColors,
                                    za = ja.color,
                                    3 === 
                                    Ia.length && H === THREE.VertexColors ? (R = Ia[0],
                                    O = Ia[1],
                                    T = Ia[2]) : T = O = R = za,
                                    Da[pa] = R.r,
                                    Da[pa + 1] = R.g,
                                    Da[pa + 2] = R.b,
                                    Da[pa + 3] = O.r,
                                    Da[pa + 4] = O.g,
                                    Da[pa + 5] = O.b,
                                    Da[pa + 6] = T.r,
                                    Da[pa + 7] = T.g,
                                    Da[pa + 8] = T.b,
                                    pa += 9;
                                0 < pa && (A.bindBuffer(A.ARRAY_BUFFER, z.__webglColorBuffer),
                                A.bufferData(A.ARRAY_BUFFER, Da, F))
                            }
                            if (Za && Ua.hasTangents) {
                                E = 0;
                                for (Y = ra.length; E < Y; E++)
                                    ja = cb[ra[E]],
                                    N = ja.vertexTangents,
                                    ea = N[0],
                                    Ha = N[1],
                                    X = N[2],
                                    Fa[ya] = ea.x,
                                    Fa[ya + 1] = ea.y,
                                    Fa[ya + 2] = ea.z,
                                    Fa[ya + 3] = ea.w,
                                    Fa[ya + 4] = Ha.x,
                                    Fa[ya + 5] = Ha.y,
                                    Fa[ya + 6] = Ha.z,
                                    Fa[ya + 7] = Ha.w,
                                    Fa[ya + 
                                    8] = X.x,
                                    Fa[ya + 9] = X.y,
                                    Fa[ya + 10] = X.z,
                                    Fa[ya + 11] = X.w,
                                    ya += 12;
                                A.bindBuffer(A.ARRAY_BUFFER, z.__webglTangentBuffer);
                                A.bufferData(A.ARRAY_BUFFER, Fa, F)
                            }
                            if (Va && L) {
                                E = 0;
                                for (Y = ra.length; E < Y; E++)
                                    if (ja = cb[ra[E]],
                                    na = ja.vertexNormals,
                                    aa = ja.normal,
                                    3 === na.length && xa)
                                        for (qa = 0; 3 > qa; qa++)
                                            W = na[qa],
                                            ma[la] = W.x,
                                            ma[la + 1] = W.y,
                                            ma[la + 2] = W.z,
                                            la += 3;
                                    else
                                        for (qa = 0; 3 > qa; qa++)
                                            ma[la] = aa.x,
                                            ma[la + 1] = aa.y,
                                            ma[la + 2] = aa.z,
                                            la += 3;
                                A.bindBuffer(A.ARRAY_BUFFER, z.__webglNormalBuffer);
                                A.bufferData(A.ARRAY_BUFFER, ma, F)
                            }
                            if (Ta && ab && I) {
                                E = 0;
                                for (Y = ra.length; E < 
                                Y; E++)
                                    if (da = ra[E],
                                    S = ab[da],
                                    void 0 !== S)
                                        for (qa = 0; 3 > qa; qa++)
                                            ca = S[qa],
                                            sa[va] = ca.x,
                                            sa[va + 1] = ca.y,
                                            va += 2;
                                0 < va && (A.bindBuffer(A.ARRAY_BUFFER, z.__webglUVBuffer),
                                A.bufferData(A.ARRAY_BUFFER, sa, F))
                            }
                            if (Ta && bb && I) {
                                E = 0;
                                for (Y = ra.length; E < Y; E++)
                                    if (da = ra[E],
                                    ba = bb[da],
                                    void 0 !== ba)
                                        for (qa = 0; 3 > qa; qa++)
                                            Na = ba[qa],
                                            Oa[ga] = Na.x,
                                            Oa[ga + 1] = Na.y,
                                            ga += 2;
                                0 < ga && (A.bindBuffer(A.ARRAY_BUFFER, z.__webglUV2Buffer),
                                A.bufferData(A.ARRAY_BUFFER, Oa, F))
                            }
                            if (Sa) {
                                E = 0;
                                for (Y = ra.length; E < Y; E++)
                                    Qa[Ma] = ia,
                                    Qa[Ma + 1] = ia + 1,
                                    Qa[Ma + 2] = ia + 2,
                                    Ma += 3,
                                    Pa[ta] = ia,
                                    Pa[ta + 1] = ia + 1,
                                    Pa[ta + 2] = ia,
                                    Pa[ta + 3] = ia + 2,
                                    Pa[ta + 4] = ia + 1,
                                    Pa[ta + 5] = ia + 2,
                                    ta += 6,
                                    ia += 3;
                                A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, z.__webglFaceBuffer);
                                A.bufferData(A.ELEMENT_ARRAY_BUFFER, Qa, F);
                                A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, z.__webglLineBuffer);
                                A.bufferData(A.ELEMENT_ARRAY_BUFFER, Pa, F)
                            }
                            if (Ka)
                                for (qa = 0,
                                La = Ka.length; qa < La; qa++)
                                    if (Q = Ka[qa],
                                    Q.__original.needsUpdate) {
                                        U = 0;
                                        if (1 === Q.size)
                                            if (void 0 === Q.boundTo || "vertices" === Q.boundTo)
                                                for (E = 0,
                                                Y = ra.length; E < Y; E++)
                                                    ja = cb[ra[E]],
                                                    Q.array[U] = Q.value[ja.a],
                                                    Q.array[U + 1] = Q.value[ja.b],
                                                    Q.array[U + 2] = Q.value[ja.c],
                                                    U += 3;
                                            else {
                                                if ("faces" === Q.boundTo)
                                                    for (E = 0,
                                                    Y = ra.length; E < Y; E++)
                                                        Ea = Q.value[ra[E]],
                                                        Q.array[U] = Ea,
                                                        Q.array[U + 1] = Ea,
                                                        Q.array[U + 2] = Ea,
                                                        U += 3
                                            }
                                        else if (2 === Q.size)
                                            if (void 0 === Q.boundTo || "vertices" === Q.boundTo)
                                                for (E = 0,
                                                Y = ra.length; E < Y; E++)
                                                    ja = cb[ra[E]],
                                                    P = Q.value[ja.a],
                                                    V = Q.value[ja.b],
                                                    ha = Q.value[ja.c],
                                                    Q.array[U] = P.x,
                                                    Q.array[U + 1] = P.y,
                                                    Q.array[U + 2] = V.x,
                                                    Q.array[U + 3] = V.y,
                                                    Q.array[U + 4] = ha.x,
                                                    Q.array[U + 5] = ha.y,
                                                    U += 6;
                                            else {
                                                if ("faces" === Q.boundTo)
                                                    for (E = 0,
                                                    Y = ra.length; E < Y; E++)
                                                        ha = V = P = Ea = Q.value[ra[E]],
                                                        Q.array[U] = 
                                                        P.x,
                                                        Q.array[U + 1] = P.y,
                                                        Q.array[U + 2] = V.x,
                                                        Q.array[U + 3] = V.y,
                                                        Q.array[U + 4] = ha.x,
                                                        Q.array[U + 5] = ha.y,
                                                        U += 6
                                            }
                                        else if (3 === Q.size) {
                                            var Ba;
                                            Ba = "c" === Q.type ? ["r", "g", "b"] : ["x", "y", "z"];
                                            if (void 0 === Q.boundTo || "vertices" === Q.boundTo)
                                                for (E = 0,
                                                Y = ra.length; E < Y; E++)
                                                    ja = cb[ra[E]],
                                                    P = Q.value[ja.a],
                                                    V = Q.value[ja.b],
                                                    ha = Q.value[ja.c],
                                                    Q.array[U] = P[Ba[0]],
                                                    Q.array[U + 1] = P[Ba[1]],
                                                    Q.array[U + 2] = P[Ba[2]],
                                                    Q.array[U + 3] = V[Ba[0]],
                                                    Q.array[U + 4] = V[Ba[1]],
                                                    Q.array[U + 5] = V[Ba[2]],
                                                    Q.array[U + 6] = ha[Ba[0]],
                                                    Q.array[U + 7] = ha[Ba[1]],
                                                    Q.array[U + 8] = ha[Ba[2]],
                                                    U += 9;
                                            else if ("faces" === Q.boundTo)
                                                for (E = 0,
                                                Y = ra.length; E < Y; E++)
                                                    ha = V = P = Ea = Q.value[ra[E]],
                                                    Q.array[U] = P[Ba[0]],
                                                    Q.array[U + 1] = P[Ba[1]],
                                                    Q.array[U + 2] = P[Ba[2]],
                                                    Q.array[U + 3] = V[Ba[0]],
                                                    Q.array[U + 4] = V[Ba[1]],
                                                    Q.array[U + 5] = V[Ba[2]],
                                                    Q.array[U + 6] = ha[Ba[0]],
                                                    Q.array[U + 7] = ha[Ba[1]],
                                                    Q.array[U + 8] = ha[Ba[2]],
                                                    U += 9;
                                            else if ("faceVertices" === Q.boundTo)
                                                for (E = 0,
                                                Y = ra.length; E < Y; E++)
                                                    Ea = Q.value[ra[E]],
                                                    P = Ea[0],
                                                    V = Ea[1],
                                                    ha = Ea[2],
                                                    Q.array[U] = P[Ba[0]],
                                                    Q.array[U + 1] = P[Ba[1]],
                                                    Q.array[U + 2] = P[Ba[2]],
                                                    Q.array[U + 3] = V[Ba[0]],
                                                    Q.array[U + 4] = V[Ba[1]],
                                                    Q.array[U + 5] = V[Ba[2]],
                                                    Q.array[U + 6] = ha[Ba[0]],
                                                    Q.array[U + 7] = ha[Ba[1]],
                                                    Q.array[U + 8] = ha[Ba[2]],
                                                    U += 9
                                        } else if (4 === Q.size)
                                            if (void 0 === Q.boundTo || "vertices" === Q.boundTo)
                                                for (E = 0,
                                                Y = ra.length; E < Y; E++)
                                                    ja = cb[ra[E]],
                                                    P = Q.value[ja.a],
                                                    V = Q.value[ja.b],
                                                    ha = Q.value[ja.c],
                                                    Q.array[U] = P.x,
                                                    Q.array[U + 1] = P.y,
                                                    Q.array[U + 2] = P.z,
                                                    Q.array[U + 3] = P.w,
                                                    Q.array[U + 4] = V.x,
                                                    Q.array[U + 5] = V.y,
                                                    Q.array[U + 6] = V.z,
                                                    Q.array[U + 7] = V.w,
                                                    Q.array[U + 8] = ha.x,
                                                    Q.array[U + 9] = ha.y,
                                                    Q.array[U + 10] = ha.z,
                                                    Q.array[U + 11] = ha.w,
                                                    U += 12;
                                            else if ("faces" === Q.boundTo)
                                                for (E = 0,
                                                Y = ra.length; E < Y; E++)
                                                    ha = V = P = Ea = Q.value[ra[E]],
                                                    Q.array[U] = P.x,
                                                    Q.array[U + 1] = P.y,
                                                    Q.array[U + 2] = P.z,
                                                    Q.array[U + 3] = P.w,
                                                    Q.array[U + 4] = V.x,
                                                    Q.array[U + 5] = V.y,
                                                    Q.array[U + 6] = V.z,
                                                    Q.array[U + 7] = V.w,
                                                    Q.array[U + 8] = ha.x,
                                                    Q.array[U + 9] = ha.y,
                                                    Q.array[U + 10] = ha.z,
                                                    Q.array[U + 11] = ha.w,
                                                    U += 12;
                                            else if ("faceVertices" === Q.boundTo)
                                                for (E = 0,
                                                Y = ra.length; E < Y; E++)
                                                    Ea = Q.value[ra[E]],
                                                    P = Ea[0],
                                                    V = Ea[1],
                                                    ha = Ea[2],
                                                    Q.array[U] = P.x,
                                                    Q.array[U + 1] = P.y,
                                                    Q.array[U + 2] = P.z,
                                                    Q.array[U + 3] = P.w,
                                                    Q.array[U + 4] = V.x,
                                                    Q.array[U + 5] = V.y,
                                                    Q.array[U + 6] = V.z,
                                                    Q.array[U + 7] = V.w,
                                                    Q.array[U + 
                                                    8] = ha.x,
                                                    Q.array[U + 9] = ha.y,
                                                    Q.array[U + 10] = ha.z,
                                                    Q.array[U + 11] = ha.w,
                                                    U += 12;
                                        A.bindBuffer(A.ARRAY_BUFFER, Q.buffer);
                                        A.bufferData(A.ARRAY_BUFFER, Q.array, F)
                                    }
                            M && (delete z.__inittedArrays,
                            delete z.__colorArray,
                            delete z.__normalArray,
                            delete z.__tangentArray,
                            delete z.__uvArray,
                            delete z.__uv2Array,
                            delete z.__faceArray,
                            delete z.__vertexArray,
                            delete z.__lineArray,
                            delete z.__skinIndexArray,
                            delete z.__skinWeightArray)
                        }
                    }
                }
                n.verticesNeedUpdate = !1;
                n.morphTargetsNeedUpdate = !1;
                n.elementsNeedUpdate = !1;
                n.uvsNeedUpdate = !1;
                n.normalsNeedUpdate = 
                !1;
                n.colorsNeedUpdate = !1;
                n.tangentsNeedUpdate = !1;
                r.attributes && B(r)
            } else if (m instanceof THREE.Line) {
                r = h(m, n);
                q = r.attributes && G(r);
                if (n.verticesNeedUpdate || n.colorsNeedUpdate || n.lineDistancesNeedUpdate || q) {
                    var Wa = A.DYNAMIC_DRAW, vb, wb, xb, Ya, wa, $a, fb = n.vertices, gb = n.colors, hb = n.lineDistances, lb = fb.length, pb = gb.length, sb = hb.length, Bb = n.__vertexArray, Cb = n.__colorArray, jb = n.__lineDistanceArray, tb = n.colorsNeedUpdate, ub = n.lineDistancesNeedUpdate, eb = n.__webglCustomAttributesList, Db, kb, Ga, mb, Ra, ua;
                    if (n.verticesNeedUpdate) {
                        for (vb = 
                        0; vb < lb; vb++)
                            Ya = fb[vb],
                            wa = 3 * vb,
                            Bb[wa] = Ya.x,
                            Bb[wa + 1] = Ya.y,
                            Bb[wa + 2] = Ya.z;
                        A.bindBuffer(A.ARRAY_BUFFER, n.__webglVertexBuffer);
                        A.bufferData(A.ARRAY_BUFFER, Bb, Wa)
                    }
                    if (tb) {
                        for (wb = 0; wb < pb; wb++)
                            $a = gb[wb],
                            wa = 3 * wb,
                            Cb[wa] = $a.r,
                            Cb[wa + 1] = $a.g,
                            Cb[wa + 2] = $a.b;
                        A.bindBuffer(A.ARRAY_BUFFER, n.__webglColorBuffer);
                        A.bufferData(A.ARRAY_BUFFER, Cb, Wa)
                    }
                    if (ub) {
                        for (xb = 0; xb < sb; xb++)
                            jb[xb] = hb[xb];
                        A.bindBuffer(A.ARRAY_BUFFER, n.__webglLineDistanceBuffer);
                        A.bufferData(A.ARRAY_BUFFER, jb, Wa)
                    }
                    if (eb)
                        for (Db = 0,
                        kb = eb.length; Db < kb; Db++)
                            if (ua = 
                            eb[Db],
                            ua.needsUpdate && (void 0 === ua.boundTo || "vertices" === ua.boundTo)) {
                                wa = 0;
                                mb = ua.value.length;
                                if (1 === ua.size)
                                    for (Ga = 0; Ga < mb; Ga++)
                                        ua.array[Ga] = ua.value[Ga];
                                else if (2 === ua.size)
                                    for (Ga = 0; Ga < mb; Ga++)
                                        Ra = ua.value[Ga],
                                        ua.array[wa] = Ra.x,
                                        ua.array[wa + 1] = Ra.y,
                                        wa += 2;
                                else if (3 === ua.size)
                                    if ("c" === ua.type)
                                        for (Ga = 0; Ga < mb; Ga++)
                                            Ra = ua.value[Ga],
                                            ua.array[wa] = Ra.r,
                                            ua.array[wa + 1] = Ra.g,
                                            ua.array[wa + 2] = Ra.b,
                                            wa += 3;
                                    else
                                        for (Ga = 0; Ga < mb; Ga++)
                                            Ra = ua.value[Ga],
                                            ua.array[wa] = Ra.x,
                                            ua.array[wa + 1] = Ra.y,
                                            ua.array[wa + 2] = Ra.z,
                                            wa += 3;
                                else if (4 === 
                                ua.size)
                                    for (Ga = 0; Ga < mb; Ga++)
                                        Ra = ua.value[Ga],
                                        ua.array[wa] = Ra.x,
                                        ua.array[wa + 1] = Ra.y,
                                        ua.array[wa + 2] = Ra.z,
                                        ua.array[wa + 3] = Ra.w,
                                        wa += 4;
                                A.bindBuffer(A.ARRAY_BUFFER, ua.buffer);
                                A.bufferData(A.ARRAY_BUFFER, ua.array, Wa)
                            }
                }
                n.verticesNeedUpdate = !1;
                n.colorsNeedUpdate = !1;
                n.lineDistancesNeedUpdate = !1;
                r.attributes && B(r)
            }
            var ob = D(a, b, f, k, m)
              , Ca = ob.attributes
              , nb = !1
              , qb = l.id + "_" + ob.id + "_" + (k.wireframe ? 1 : 0);
            qb !== Ja && (Ja = qb,
            nb = !0);
            nb && Aa.initAttributes();
            !k.morphTargets && 0 <= Ca.position && nb && (A.bindBuffer(A.ARRAY_BUFFER, l.__webglVertexBuffer),
            Aa.enableAttribute(Ca.position),
            A.vertexAttribPointer(Ca.position, 3, A.FLOAT, !1, 0, 0));
            if (nb) {
                if (l.__webglCustomAttributesList)
                    for (var Eb = 0, zb = l.__webglCustomAttributesList.length; Eb < zb; Eb++) {
                        var yb = l.__webglCustomAttributesList[Eb];
                        0 <= Ca[yb.buffer.belongsToAttribute] && (A.bindBuffer(A.ARRAY_BUFFER, yb.buffer),
                        Aa.enableAttribute(Ca[yb.buffer.belongsToAttribute]),
                        A.vertexAttribPointer(Ca[yb.buffer.belongsToAttribute], yb.size, A.FLOAT, !1, 0, 0))
                    }
                0 <= Ca.color && (0 < m.geometry.colors.length || 0 < m.geometry.faces.length ? 
                (A.bindBuffer(A.ARRAY_BUFFER, l.__webglColorBuffer),
                Aa.enableAttribute(Ca.color),
                A.vertexAttribPointer(Ca.color, 3, A.FLOAT, !1, 0, 0)) : k.defaultAttributeValues && A.vertexAttrib3fv(Ca.color, k.defaultAttributeValues.color));
                0 <= Ca.normal && (A.bindBuffer(A.ARRAY_BUFFER, l.__webglNormalBuffer),
                Aa.enableAttribute(Ca.normal),
                A.vertexAttribPointer(Ca.normal, 3, A.FLOAT, !1, 0, 0));
                0 <= Ca.tangent && (A.bindBuffer(A.ARRAY_BUFFER, l.__webglTangentBuffer),
                Aa.enableAttribute(Ca.tangent),
                A.vertexAttribPointer(Ca.tangent, 4, A.FLOAT, 
                !1, 0, 0));
                0 <= Ca.uv && (m.geometry.faceVertexUvs[0] ? (A.bindBuffer(A.ARRAY_BUFFER, l.__webglUVBuffer),
                Aa.enableAttribute(Ca.uv),
                A.vertexAttribPointer(Ca.uv, 2, A.FLOAT, !1, 0, 0)) : k.defaultAttributeValues && A.vertexAttrib2fv(Ca.uv, k.defaultAttributeValues.uv));
                0 <= Ca.uv2 && (m.geometry.faceVertexUvs[1] ? (A.bindBuffer(A.ARRAY_BUFFER, l.__webglUV2Buffer),
                Aa.enableAttribute(Ca.uv2),
                A.vertexAttribPointer(Ca.uv2, 2, A.FLOAT, !1, 0, 0)) : k.defaultAttributeValues && A.vertexAttrib2fv(Ca.uv2, k.defaultAttributeValues.uv2));
                0 <= Ca.lineDistance && 
                (A.bindBuffer(A.ARRAY_BUFFER, l.__webglLineDistanceBuffer),
                Aa.enableAttribute(Ca.lineDistance),
                A.vertexAttribPointer(Ca.lineDistance, 1, A.FLOAT, !1, 0, 0))
            }
            Aa.disableUnusedAttributes();
            if (m instanceof THREE.Mesh) {
                var rb = l.__typeArray === Uint32Array ? A.UNSIGNED_INT : A.UNSIGNED_SHORT;
                k.wireframe ? (Aa.setLineWidth(k.wireframeLinewidth * Z),
                nb && A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, l.__webglLineBuffer),
                A.drawElements(A.LINES, l.__webglLineCount, rb, 0)) : (nb && A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, l.__webglFaceBuffer),
                A.drawElements(A.TRIANGLES, 
                l.__webglFaceCount, rb, 0))
            } else if (m instanceof THREE.Line) {
                var Ab = m.mode === THREE.LineStrip ? A.LINE_STRIP : A.LINES;
                Aa.setLineWidth(k.linewidth * Z);
                A.drawArrays(Ab, 0, l.__webglLineCount)
            }
        }
    }
    ;
    this.render = function(a, b, c, d, f) {
        if (!1 === b instanceof THREE.Camera)
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        else {
            Ja = "";
            qa = -1;
            La = null ;
            void 0 !== f && (ga.length = 0,
            Oa = !0);
            var g = a.fog;
            !0 === a.autoUpdate && a.updateMatrixWorld();
            void 0 === b.parent && b.updateMatrixWorld();
            b.matrixWorldInverse.getInverse(b.matrixWorld);
            b.worldUpTransform ? Fa.multiplyMatrices(b.worldUpTransform, b.matrixWorld) : Fa.copy(b.matrixWorld);
            pa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
            oa.setFromMatrix(pa);
            var h = a instanceof Teratek.Viewing.Private.RenderBatch && a.renderImmediate;
            h || (Ha.length = 0,
            xa.length = 0,
            r(a, !0 === ka.sortObjects, !0 === a.forceVisible),
            !0 === ka.sortObjects && (Ha.sort(n),
            xa.sort(l)));
            Oa && (f && f.length && (ga = f.slice()),
            K(ga));
            this.resetGLState();
            this.setRenderTarget(c);
            (this.autoClear || d) && this.clear(this.autoClearColor, 
            this.autoClearDepth, this.autoClearStencil);
            if (a.overrideMaterial) {
                var k = a.overrideMaterial;
                v(k);
                h ? (d = ga,
                sb = b,
                jb = d,
                lb = k || null ,
                a.forEach(w, a.forceVisible ? 1 : 128, !1)) : (t(Ha, b, ga, g, k),
                t(xa, b, ga, g, k))
            } else
                h ? (d = ga,
                sb = b,
                jb = d,
                lb = k || null ,
                a.forEach(w, a.forceVisible ? 1 : 128, !1)) : (Aa.setBlending(THREE.NoBlending),
                t(Ha, b, ga, g, null ),
                t(xa, b, ga, g, null ));
            this.resetGLState();
            c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && (A.bindTexture(A.TEXTURE_2D, c.__webglTexture),
            A.generateMipmap(A.TEXTURE_2D),
            A.bindTexture(A.TEXTURE_2D, null ));
            Aa.setDepthTest(!0);
            Aa.setDepthWrite(!0)
        }
    }
    ;
    var sb, jb, Hb, lb, ib = {}, Gb = 0, Ib = {
        MeshDepthMaterial: "depth",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "firefly_basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "firefly_phong",
        LineBasicMaterial: "firefly_basic",
        LineDashedMaterial: "dashed",
        PointCloudMaterial: "particle_basic"
    };
    this.setFaceCulling = function(a, b) {
        a === THREE.CullFaceNone ? A.disable(A.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? A.frontFace(A.CW) : A.frontFace(A.CCW),
        a === THREE.CullFaceBack ? A.cullFace(A.BACK) : a === THREE.CullFaceFront ? A.cullFace(A.FRONT) : A.cullFace(A.FRONT_AND_BACK),
        A.enable(A.CULL_FACE))
    }
    ;
    this.setMaterialFaces = function(a) {
        Aa.setDoubleSided(a.side === THREE.DoubleSide);
        Aa.setFlipSided(a.side === THREE.BackSide)
    }
    ;
    this.uploadTexture = function(a) {
        void 0 === a.__webglInit && (a.__webglInit = !0,
        a.addEventListener("dispose", pb),
        a.__webglTexture = A.createTexture(),
        ka.info.memory.textures++);
        A.bindTexture(A.TEXTURE_2D, a.__webglTexture);
        A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL, 
        a.flipY);
        A.pixelStorei(A.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
        A.pixelStorei(A.UNPACK_ALIGNMENT, a.unpackAlignment);
        a.image = S(a.image, eb);
        var b = a.image
          , c = THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height)
          , d = P(a.format)
          , f = P(a.type);
        M(A.TEXTURE_2D, a, c);
        var g = a.mipmaps;
        if (a instanceof THREE.DataTexture)
            if (0 < g.length && c) {
                for (var h = 0, k = g.length; h < k; h++)
                    b = g[h],
                    A.texImage2D(A.TEXTURE_2D, h, d, b.width, b.height, 0, d, f, b.data);
                a.generateMipmaps = !1
            } else
                A.texImage2D(A.TEXTURE_2D, 0, 
                d, b.width, b.height, 0, d, f, b.data);
        else if (a instanceof THREE.CompressedTexture)
            for (h = 0,
            k = g.length; h < k; h++)
                b = g[h],
                a.format !== THREE.RGBAFormat && a.format !== THREE.RGBFormat ? -1 < Va().indexOf(d) ? A.compressedTexImage2D(A.TEXTURE_2D, h, d, b.width, b.height, 0, b.data) : console.warn("Attempt to load unsupported compressed texture format") : A.texImage2D(A.TEXTURE_2D, h, d, b.width, b.height, 0, d, f, b.data);
        else if (0 < g.length && c) {
            h = 0;
            for (k = g.length; h < k; h++)
                b = g[h],
                A.texImage2D(A.TEXTURE_2D, h, d, d, f, b);
            a.generateMipmaps = !1
        } else
            A.texImage2D(A.TEXTURE_2D, 
            0, d, d, f, a.image);
        a.generateMipmaps && c && A.generateMipmap(A.TEXTURE_2D);
        a.needsUpdate = !1;
        if (a.onUpdate)
            a.onUpdate()
    }
    ;
    this.setTexture = function(a, b) {
        A.activeTexture(A.TEXTURE0 + b);
        a.needsUpdate ? ka.uploadTexture(a) : A.bindTexture(A.TEXTURE_2D, a.__webglTexture)
    }
    ;
    this.initFrameBufferMRT = function(a, b) {
        var c = a[0]
          , d = !1;
        if (c && !c.__webglFramebuffer) {
            void 0 === c.depthBuffer && (c.depthBuffer = !0);
            void 0 === c.stencilBuffer && (c.stencilBuffer = !0);
            c.__webglFramebuffer = A.createFramebuffer();
            A.bindFramebuffer(A.FRAMEBUFFER, 
            c.__webglFramebuffer);
            var f;
            c.shareDepthFrom ? f = c.__webglRenderbuffer = c.shareDepthFrom.__webglRenderbuffer : c.depthBuffer && !c.stencilBuffer ? (f = c.__webglRenderbuffer = A.createRenderbuffer(),
            A.bindRenderbuffer(A.RENDERBUFFER, f),
            A.renderbufferStorage(A.RENDERBUFFER, A.DEPTH_COMPONENT16, c.width, c.height)) : c.depthBuffer && c.stencilBuffer && (f = c.__webglRenderbuffer = A.createRenderbuffer(),
            A.bindRenderbuffer(A.RENDERBUFFER, f),
            A.renderbufferStorage(A.RENDERBUFFER, A.DEPTH_STENCIL, c.width, c.height));
            c.depthBuffer && 
            !c.stencilBuffer ? A.framebufferRenderbuffer(A.FRAMEBUFFER, A.DEPTH_ATTACHMENT, A.RENDERBUFFER, f) : c.depthBuffer && c.stencilBuffer && A.framebufferRenderbuffer(A.FRAMEBUFFER, A.DEPTH_STENCIL_ATTACHMENT, A.RENDERBUFFER, f);
            d = !0
        }
        f = ha;
        A.bindFramebuffer(A.FRAMEBUFFER, c.__webglFramebuffer);
        for (var g = 0; g < a.length; g++) {
            var h = a[g];
            if (!h.__webglTexture) {
                var k = THREE.Math.isPowerOfTwo(h.width) && THREE.Math.isPowerOfTwo(h.height)
                  , l = P(h.format)
                  , m = P(h.type);
                h.addEventListener("dispose", qb);
                h.__webglTexture = A.createTexture();
                ka.info.memory.textures++;
                A.bindTexture(A.TEXTURE_2D, h.__webglTexture);
                M(A.TEXTURE_2D, h, k);
                A.texImage2D(A.TEXTURE_2D, 0, l, h.width, h.height, 0, l, m, null );
                k && h.generateMipmaps && A.generateMipmap(A.TEXTURE_2D)
            }
            A.framebufferTexture2D(A.FRAMEBUFFER, A.COLOR_ATTACHMENT0 + g, A.TEXTURE_2D, h.__webglTexture, 0)
        }
        if (Da) {
            h = [Da.COLOR_ATTACHMENT0_WEBGL];
            for (g = 1; g < a.length; g++)
                h.push(Da.COLOR_ATTACHMENT0_WEBGL + g);
            Da.drawBuffersWEBGL(h)
        }
        b && (g = A.checkFramebufferStatus(A.FRAMEBUFFER),
        g !== A.FRAMEBUFFER_COMPLETE && (console.log("Can't use multiple render targets. Falling back to two passes. " + 
        g),
        delete c.__webglFramebuffer,
        b = !1));
        A.bindFramebuffer(A.FRAMEBUFFER, f);
        d && (A.bindTexture(A.TEXTURE_2D, null ),
        A.bindRenderbuffer(A.RENDERBUFFER, null ),
        A.bindFramebuffer(A.FRAMEBUFFER, null ));
        return b
    }
    ;
    this.setRenderTarget = function(a) {
        var b;
        if (Array.isArray(a))
            this.initFrameBufferMRT(a),
            b = a[0];
        else if (a) {
            var c = a.__webglFramebuffer;
            c && ha === c || this.initFrameBufferMRT([a]);
            b = a
        }
        var d, f;
        b ? (a = b.__webglFramebuffer,
        c = b.width,
        b = b.height,
        f = d = 0) : (a = null ,
        c = ya,
        b = la,
        d = Ma,
        f = Ea);
        a !== ha && (A.bindFramebuffer(A.FRAMEBUFFER, 
        a),
        A.viewport(d, f, c, b),
        ha = a)
    }
    ;
    this.verifyMRTWorks = function(a) {
        return Da ? this.initFrameBufferMRT(a, !0) : !1
    }
    ;
    this.readRenderTargetPixels = function(a, b, c, d, f, g) {
        if (!(a instanceof THREE.WebGLRenderTarget))
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        else if (a.__webglFramebuffer) {
            var h = !1;
            a.__webglFramebuffer !== ha && (A.bindFramebuffer(A.FRAMEBUFFER, a.__webglFramebuffer),
            h = !0);
            A.checkFramebufferStatus(A.FRAMEBUFFER) === A.FRAMEBUFFER_COMPLETE ? A.readPixels(b, 
            c, d, f, A.RGBA, A.UNSIGNED_BYTE, g) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            h && A.bindFramebuffer(A.FRAMEBUFFER, ha)
        }
    }
}
;
TeratekNamespace("Teratek.Viewing.Private");
(function() {
    function f(d) {
        c[0] = d;
        var f = a[0];
        d = 0;
        if (0 == (f & 2147483647))
            k[d++] = f >> 16;
        else {
            var g = f & 2147483648
              , h = f & 2139095040
              , f = f & 8388607;
            if (0 == h)
                k[d++] = g >> 16;
            else if (2139095040 == h)
                0 == f ? k[d++] = g >> 16 | 31744 : k[d++] = 65024;
            else {
                var l = g >> 16
                  , h = (0 | h >> 23) - 127 + 15;
                31 <= h ? k[d++] = g >> 16 | 31744 : 0 >= h ? (24 < 14 - h ? g = 0 : (f |= 8388608,
                b[0] = f >> 14 - h,
                g = b[0],
                f >> 13 - h & 1 && (g += 1)),
                k[d++] = l | g) : (b[0] = h << 10,
                h = b[0],
                b[0] = f >> 13,
                g = b[0],
                f & 4096 ? k[d++] = (l | h | g) + 1 : k[d++] = l | h | g)
            }
        }
        return k[0]
    }
    var h = Teratek.Viewing.Private;
    h.BackgroundPresets = {
        "Fusion Grey": [230, 
        230, 230, 150, 150, 150],
        "Sky Blue": [226, 244, 255, 156, 172, 180],
        Midnight: [41, 76, 120, 1, 2, 3],
        White: [255, 255, 255, 255, 255, 255],
        AutoCADModel: [30, 40, 48, 30, 40, 48],
        "Dark Grey": [51, 51, 51, 51, 51, 51],
        "Infinity Pool": [164, 175, 179, 164, 175, 179],
        Tranquility: [0, 84, 166, 0, 84, 166],
        "Grey Room": [129, 129, 129, 129, 129, 129],
        "Photo Booth": [237, 237, 237, 237, 237, 237],
        "RaaS SBS": [1, 1, 1, 90, 90, 90],
        Plaza: [79, 102, 130, 79, 102, 130],
        Custom: [230, 230, 230, 150, 150, 150]
    };
    var g = h.BackgroundPresets;
    h.LightPresets = [{
        name: "Simple Grey",
        path: null ,
        tonemap: 0,
        E_bias: 0,
        directLightColor: [1, .84, .67],
        ambientColor: [.8, .9, 1],
        lightMultiplier: 1,
        bgColorGradient: g["Fusion Grey"],
        darkerFade: !1
    }, {
        name: "Sharp Highlights",
        path: "SharpHighlights",
        type: "logluv",
        tonemap: 1,
        E_bias: -7.145705069544681,
        directLightColor: [.5, .5, .5],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: 0,
        bgColorGradient: g["Photo Booth"],
        darkerFade: !0
    }, {
        name: "Dark Sky",
        path: "DarkSky",
        type: "logluv",
        tonemap: 1,
        E_bias: -1,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: 1,
        lightDirection: [.1, 
        -.55, -1],
        bgColorGradient: g["Dark Grey"],
        darkerFade: !1
    }, {
        name: "Grey Room",
        path: "GreyRoom",
        type: "logluv",
        tonemap: 1,
        E_bias: -1,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: .5,
        lightDirection: [.1, -.55, -1],
        bgColorGradient: g["Grey Room"],
        darkerFade: !0
    }, {
        name: "Photo Booth",
        path: "PhotoBooth",
        type: "logluv",
        tonemap: 1,
        E_bias: 0,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: .5,
        lightDirection: [.1, -.55, -1],
        bgColorGradient: g["Photo Booth"],
        darkerFade: !0
    }, 
    {
        name: "Tranquility",
        path: "TranquilityBlue",
        type: "logluv",
        tonemap: 1,
        E_bias: -1,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: .5,
        lightDirection: [.1, -.55, -1],
        bgColorGradient: g.Tranquility,
        darkerFade: !1
    }, {
        name: "Infinity Pool",
        path: "InfinityPool",
        type: "logluv",
        tonemap: 1,
        E_bias: -1,
        directLightColor: [1, .84, .67],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: .5,
        lightDirection: [.1, -.55, -1],
        bgColorGradient: g["Infinity Pool"],
        darkerFade: !1
    }, {
        name: "Simple White",
        path: null ,
        tonemap: 0,
        E_bias: 0,
        directLightColor: [1, 1, 1],
        ambientColor: [.9, .9, .9],
        lightMultiplier: 1,
        bgColorGradient: g.White,
        saoRadius: .06,
        saoIntensity: .15,
        darkerFade: !0
    }, {
        name: "Riverbank",
        path: "riverbank",
        type: "logluv",
        tonemap: 1,
        E_bias: -5.7,
        directLightColor: [1, 1, 1],
        lightMultiplier: 0,
        bgColorGradient: g["Sky Blue"],
        darkerFade: !1
    }, {
        name: "Contrast",
        path: "IDViz",
        type: "logluv",
        tonemap: 1,
        E_bias: 0,
        directLightColor: [1, 1, 1],
        lightMultiplier: 0,
        bgColorGradient: g.Midnight,
        darkerFade: !1
    }, {
        name: "Rim Highlights",
        path: "RimHighlights",
        type: "logluv",
        tonemap: 1,
        E_bias: -8.133084111281999,
        directLightColor: [.5, .5, .5],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: 0,
        bgColorGradient: g["Photo Booth"],
        darkerFade: !0
    }, {
        name: "Cool Light",
        path: "CoolLight",
        type: "logluv",
        tonemap: 1,
        E_bias: -8.152868970258611,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: 0,
        bgColorGradient: g["Fusion Grey"],
        darkerFade: !0
    }, {
        name: "Warm Light",
        path: "WarmLight",
        type: "logluv",
        tonemap: 1,
        E_bias: -8.152965210880433,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, 
        .03125, .03125],
        lightMultiplier: 0,
        bgColorGradient: g["Fusion Grey"],
        darkerFade: !0
    }, {
        name: "Soft Light",
        path: "SoftLight",
        type: "logluv",
        tonemap: 1,
        E_bias: -8.092194064376047,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: 0,
        bgColorGradient: g["Fusion Grey"],
        darkerFade: !0
    }, {
        name: "Grid Light",
        path: "GridLight",
        type: "logluv",
        tonemap: 1,
        E_bias: -7.8601965561109175,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: 0,
        bgColorGradient: g["Fusion Grey"],
        darkerFade: !0
    }, 
    {
        name: "Plaza",
        path: "Plaza",
        type: "logluv",
        tonemap: 1,
        E_bias: -13,
        directLightColor: [.9, .9, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: 0,
        bgColorGradient: g.Plaza,
        darkerFade: !1
    }, {
        name: "Snow Field",
        path: "SnowField",
        type: "logluv",
        tonemap: 1,
        E_bias: -11.5,
        directLightColor: [1, 1, 1],
        ambientColor: [.03125, .03125, .03125],
        lightMultiplier: 0,
        bgColorGradient: g["Sky Blue"],
        darkerFade: !1
    }];
    h.DebugEnvironments = [{
        name: "Field",
        path: "field",
        type: "logluv",
        tonemap: 1,
        E_bias: -2.9,
        directLightColor: [1, 1, 1],
        lightMultiplier: 0,
        bgColorGradient: g["Sky Blue"],
        darkerFade: !1
    }, {
        name: "Crossroads",
        path: "crossroads",
        type: "logluv",
        tonemap: 1,
        E_bias: -5.5,
        directLightColor: [1, 1, 1],
        lightMultiplier: 0,
        bgColorGradient: g["Sky Blue"],
        darkerFade: !1
    }, {
        name: "Seaport",
        path: "seaport",
        type: "logluv",
        tonemap: 1,
        E_bias: -6.5,
        directLightColor: [1, 1, 1],
        lightMultiplier: 0,
        bgColorGradient: g["Sky Blue"],
        darkerFade: !1
    }, {
        name: "Glacier",
        path: "glacier",
        type: "logluv",
        tonemap: 1,
        E_bias: 0,
        directLightColor: [1, 1, 1],
        lightMultiplier: 0,
        bgColorGradient: g.Midnight,
        darkerFade: !1
    }, 
    {
        name: "Boardwalk",
        path: "boardwalk",
        type: "logluv",
        tonemap: 1,
        E_bias: -7,
        directLightColor: [1, 1, 1],
        lightMultiplier: 0,
        bgColorGradient: g["Sky Blue"],
        darkerFade: !1
    }, {
        name: "RaaS Test Env",
        path: "Reflection",
        type: "logluv",
        tonemap: 2,
        E_bias: -1.5,
        directLightColor: [1, 1, 1],
        lightMultiplier: 0,
        bgColorGradient: g["RaaS SBS"],
        darkerFade: !1
    }];
    ENABLE_DEBUG && (h.LightPresets = h.LightPresets.concat(h.DebugEnvironments));
    h.CreateCubeMapFromColors = function(a, b) {
        for (var c = 255 * a.x, d = 255 * a.y, f = 255 * a.z, g = 255 * b.x, h = 255 * b.y, k = 255 * b.z, 
        l = new Uint8Array(16), n = new Uint8Array(16), D = new Uint8Array(16), z = 0; 4 > z; z++)
            l[4 * z] = c,
            l[4 * z + 1] = d,
            l[4 * z + 2] = f,
            l[4 * z + 3] = 255,
            n[4 * z] = g,
            n[4 * z + 1] = h,
            n[4 * z + 2] = k,
            n[4 * z + 3] = 255,
            0 | z / 2 ? (D[4 * z] = c,
            D[4 * z + 1] = d,
            D[4 * z + 2] = f) : (D[4 * z] = g,
            D[4 * z + 1] = h,
            D[4 * z + 2] = k),
            D[4 * z + 3] = 255;
        c = new THREE.DataTexture(D,2,2,THREE.RGBAFormat);
        d = new THREE.DataTexture(D,2,2,THREE.RGBAFormat);
        n = new THREE.DataTexture(n,2,2,THREE.RGBAFormat);
        l = new THREE.DataTexture(l,2,2,THREE.RGBAFormat);
        f = new THREE.DataTexture(D,2,2,THREE.RGBAFormat);
        D = new THREE.DataTexture(D,
        2,2,THREE.RGBAFormat);
        g = new THREE.Texture(null ,THREE.CubeReflectionMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.LinearFilter,THREE.LinearFilter,THREE.RGBAFormat);
        g.image = [d, c, l, n, D, f];
        g.needsUpdate = !0;
        return g
    }
    ;
    var d = [6.0014, -2.7008, -1.7996, -1.332, 3.1029, -5.7721, .3008, -1.0882, 5.6268]
      , c = new Float32Array(1)
      , a = new Uint32Array(c.buffer)
      , b = new Uint16Array(1)
      , k = new Uint16Array(1)
      , l = new Float32Array(4)
      , n = new Float32Array(4);
    h.DecodeEnvMap = function(a, b, c) {
        if (a.LogLuv) {
            b = Math.pow(2, b);
            for (var g = 
            Array.isArray(a.image) ? a.image : [k], h = 0; h < g.length; h++)
                for (var k = g[h], E = 0; E < k.mipmaps.length; E++) {
                    var G = k.mipmaps[E], B = G.data, v;
                    c ? (v = new Uint16Array(B.length / 4 * 3),
                    G.data = v) : v = B.buffer;
                    for (var D = G = 0; D < B.length; D += 4) {
                        l[0] = B[D] / 255;
                        l[1] = B[D + 1] / 255;
                        l[2] = B[D + 2] / 255;
                        l[3] = B[D + 3] / 255;
                        var z = n
                          , H = l
                          , I = Math.pow(2, (255 * H[2] + H[3] - 127) / 2)
                          , J = I / H[1]
                          , L = H[0] * J
                          , H = d[0] * L + d[3] * I + d[6] * J
                          , F = d[1] * L + d[4] * I + d[7] * J
                          , I = d[2] * L + d[5] * I + d[8] * J;
                        0 > H && (H = 0);
                        0 > F && (F = 0);
                        0 > I && (I = 0);
                        z[0] = H;
                        z[1] = F;
                        z[2] = I;
                        c ? (z = l,
                        H = n,
                        F = b,
                        I = Math.sqrt(H[0] * F),
                        J = 
                        Math.sqrt(H[1] * F),
                        H = Math.sqrt(H[2] * F),
                        65504 < I && (I = 65504),
                        65504 < J && (J = 65504),
                        65504 < H && (H = 65504),
                        z[0] = I,
                        z[1] = J,
                        z[2] = H,
                        v[G++] = f(l[0]),
                        v[G++] = f(l[1]),
                        v[G++] = f(l[2])) : (z = l,
                        H = n,
                        F = b,
                        I = .0625 * Math.sqrt(H[0] * F),
                        J = .0625 * Math.sqrt(H[1] * F),
                        H = .0625 * Math.sqrt(H[2] * F),
                        F = Math.max(Math.max(I, J), Math.max(H, 1E-6)),
                        1 < F && (F = 1),
                        F = Math.ceil(255 * F) / 255,
                        1 < I && (I = 1),
                        1 < J && (J = 1),
                        1 < H && (H = 1),
                        z[3] = F,
                        F = 1 / F,
                        z[0] = I * F,
                        z[1] = J * F,
                        z[2] = H * F,
                        B[D] = Math.round(255 * l[0]),
                        B[D + 1] = Math.round(255 * l[1]),
                        B[D + 2] = Math.round(255 * l[2]),
                        B[D + 3] = Math.round(255 * 
                        l[3]))
                    }
                }
            a.LogLuv = !1;
            c ? (a.type = THREE.HalfFloatType,
            a.format = THREE.RGBFormat,
            a.RGBM = !1,
            a.GammaEncoded = !0) : a.RGBM = !0
        } else
            stderr("Environment map expected to be in LogLuv format.")
    }
    ;
    h.DefaultLightPreset = 8;
    h.DefaultLightPreset2d = 0
}
)();
(function(f) {
    var h = [{
        id: "SOLID",
        name: "Solid",
        ascii_art: "_______________________________________",
        def: [1]
    }, {
        id: "BORDER",
        name: "Border",
        ascii_art: "__ __ . __ __ . __ __ . __ __ . __ __ .",
        def: [.5, -.25, .5, -.25, 0, -.25]
    }, {
        id: "BORDER2",
        name: "Border (.5x)",
        ascii_art: "__ __ . __ __ . __ __ . __ __ . __ __ .",
        def: [.25, -.125, .25, -.125, 0, -.125]
    }, {
        id: "BORDERX2",
        name: "Border (2x)",
        ascii_art: "____  ____  .  ____  ____  .  ___",
        def: [1, -.5, 1, -.5, 0, -.5]
    }, {
        id: "CENTER",
        name: "Center",
        ascii_art: "____ _ ____ _ ____ _ ____ _ ____ _ ____",
        def: [1.25, -.25, .25, -.25]
    }, {
        id: "CENTER2",
        name: "Center (.5x)",
        ascii_art: "___ _ ___ _ ___ _ ___ _ ___ _ ___",
        def: [.75, -.125, .125, -.125]
    }, {
        id: "CENTERX2",
        name: "Center (2x)",
        ascii_art: "________  __  ________  __  _____",
        def: [2.5, -.5, .5, -.5]
    }, {
        id: "DASHDOT",
        name: "Dash dot",
        ascii_art: "__ . __ . __ . __ . __ . __ . __ . __",
        def: [.5, -.25, 0, -.25]
    }, {
        id: "DASHDOT2",
        name: "Dash dot (.5x)",
        ascii_art: "_._._._._._._._._._._._._._._.",
        def: [.25, -.125, 0, -.125]
    }, {
        id: "DASHDOTX2",
        name: "Dash dot (2x)",
        ascii_art: "____  .  ____  .  ____  .  ___",
        def: [1, -.5, 0, -.5]
    }, {
        id: "DASHED",
        name: "Dashed",
        ascii_art: "__ __ __ __ __ __ __ __ __ __ __ __ __ _",
        def: [.5, -.25]
    }, {
        id: "DASHED2",
        name: "Dashed (.5x)",
        ascii_art: "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
        def: [.25, -.125]
    }, {
        id: "DASHEDX2",
        name: "Dashed (2x)",
        ascii_art: "____  ____  ____  ____  ____  ___",
        def: [1, -.5]
    }, {
        id: "DIVIDE",
        name: "Divide",
        ascii_art: "____ . . ____ . . ____ . . ____ . . ____",
        def: [.5, -.25, 0, -.25, 0, -.25]
    }, {
        id: "DIVIDE2",
        name: "Divide (.5x)",
        ascii_art: "__..__..__..__..__..__..__..__.._",
        def: [.25, 
        -.125, 0, -.125, 0, -.125]
    }, {
        id: "DIVIDEX2",
        name: "Divide (2x)",
        ascii_art: "________  .  .  ________  .  .  _",
        def: [1, -.5, 0, -.5, 0, -.5]
    }, {
        id: "DOT",
        name: "Dot",
        ascii_art: ". . . . . . . . . . . . . . . . . . . . . . . .",
        def: [0, -.25]
    }, {
        id: "DOT2",
        name: "Dot (.5x)",
        ascii_art: "........................................",
        def: [0, -.125]
    }, {
        id: "DOTX2",
        name: "Dot (2x)",
        ascii_art: ".  .  .  .  .  .  .  .  .  .  .  .  .  .",
        def: [0, -.5]
    }, {
        id: "HIDDEN",
        name: "Hidden",
        ascii_art: "__ __ __ __ __ __ __ __ __ __ __ __ __ __",
        def: [.25, 
        -.125]
    }, {
        id: "HIDDEN2",
        name: "Hidden (.5x)",
        ascii_art: "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
        def: [.125, -.0625]
    }, {
        id: "HIDDENX2",
        name: "Hidden (2x)",
        ascii_art: "____ ____ ____ ____ ____ ____ ____",
        def: [.5, -.25]
    }, {
        id: "PHANTOM",
        name: "Phantom",
        ascii_art: "______  __  __  ______  __  __  ______",
        def: [1.25, -.25, .25, -.25, .25, -.25]
    }, {
        id: "PHANTOM2",
        name: "Phantom (.5x)",
        ascii_art: "___ _ _ ___ _ _ ___ _ _ ___ _ _",
        def: [.625, -.125, .125, -.125, .125, -.125]
    }, {
        id: "PHANTOMX2",
        name: "Phantom (2x)",
        ascii_art: "____________    ____    ____   _",
        def: [2.5, -.5, .5, -.5, .5, -.5]
    }, {
        id: "ACAD_ISO02W100",
        name: "ISO dash",
        ascii_art: "__ __ __ __ __ __ __ __ __ __ __ __ __",
        def: [12, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO03W100",
        name: "ISO dash space",
        ascii_art: "__    __    __    __    __    __",
        def: [12, -18],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO04W100",
        name: "ISO long-dash dot",
        ascii_art: "____ . ____ . ____ . ____ . _",
        def: [24, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO05W100",
        name: "ISO long-dash double-dot",
        ascii_art: "____ .. ____ .. ____ .",
        def: [24, 
        -3, .5, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO06W100",
        name: "ISO long-dash triple-dot",
        ascii_art: "____ ... ____ ... ____",
        def: [24, -3, .5, -3, .5, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO07W100",
        name: "ISO dot",
        ascii_art: ". . . . . . . . . . . . . . . . . . . .",
        def: [.5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO08W100",
        name: "ISO long-dash short-dash",
        ascii_art: "____ __ ____ __ ____ _",
        def: [24, -3, 6, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO09W100",
        name: "ISO long-dash double-short-dash",
        ascii_art: "____ __ __ ____",
        def: [24, -3, 6, -3, 6, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO10W100",
        name: "ISO dash dot",
        ascii_art: "__ . __ . __ . __ . __ . __ . __ . ",
        def: [12, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO11W100",
        name: "ISO double-dash dot",
        ascii_art: "__ __ . __ __ . __ __ . __ _",
        def: [12, -3, 12, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO12W100",
        name: "ISO dash double-dot",
        ascii_art: "__ . . __ . . __ . . __ . .",
        def: [12, -3, .5, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO13W100",
        name: "ISO double-dash double-dot",
        ascii_art: "__ __ . . __ __ . . _",
        def: [12, -3, 12, -3, .5, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO14W100",
        name: "ISO dash triple-dot",
        ascii_art: "__ . . . __ . . . __ . . . _",
        def: [12, -3, .5, -3, .5, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "ACAD_ISO15W100",
        name: "ISO double-dash triple-dot",
        ascii_art: "__ __ . . . __ __ . .",
        def: [12, -3, 12, -3, .5, -3, .5, -3, .5, -3],
        pen_width: 1,
        unit: "mm"
    }, {
        id: "FENCELINE1",
        name: "Fenceline circle",
        ascii_art: "----0-----0----0-----0----0-----0--",
        def: [.25, -.1, ["CIRC1", "ltypeshp.shx", 
        "x=-.1", "s=.1"], -.1, 1]
    }, {
        id: "FENCELINE2",
        name: "Fenceline square",
        ascii_art: "----[]-----[]----[]-----[]----[]---",
        def: [.25, -.1, ["BOX", "ltypeshp.shx", "x=-.1", "s=.1"], -.1, 1]
    }, {
        id: "TRACKS",
        name: "Tracks",
        ascii_art: "-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-",
        def: [.15, ["TRACK1", "ltypeshp.shx", "s=.25"], .15]
    }, {
        id: "BATTING",
        name: "Batting",
        ascii_art: "SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS",
        def: [1E-4, -.1, ["BAT", "ltypeshp.shx", "x=-.1", "s=.1"], -.2, ["BAT", "ltypeshp.shx", "r=180", "x=.1", "s=.1"], -.1]
    }, 
    {
        id: "HOT_WATER_SUPPLY",
        name: "Hot water supply",
        ascii_art: "---- HW ---- HW ---- HW ----",
        def: [.5, -.2, "HW STANDARD S=.1 R=0.0 X=-0.1 Y=-.05".split(" "), -.2]
    }, {
        id: "GAS_LINE",
        name: "Gas line",
        ascii_art: "----GAS----GAS----GAS----GAS----GAS----GAS--",
        def: [.5, -.2, "GAS STANDARD S=.1 R=0.0 X=-0.1 Y=-.05".split(" "), -.25]
    }, {
        id: "ZIGZAG",
        name: "Zig zag",
        ascii_art: "/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/",
        def: [1E-4, -.2, ["ZIG", "ltypeshp.shx", "x=-.2", "s=.2"], -.4, ["ZIG", "ltypeshp.shx", 
        "r=180", "x=.2", "s=.2"], -.2]
    }];
    f.LineStyleDefs = h;
    f.CreateLinePatternTexture = function() {
        for (var f = h.length, d = 0, c = 0; c < f; c++) {
            var a = h[c];
            a.def.length > d && (d = a.def.length)
        }
        for (var d = d + 3, b = f, c = 1; c < d; )
            c *= 2;
        d = c;
        for (c = 1; c < b; )
            c *= 2;
        for (var b = c, k = new Uint8Array(d * b), l = 0; l < f; l++) {
            for (var n = l * d, a = h[l], m = a.unit && "mm" == a.unit ? 1 / 25.4 : 1, q = a.pen_width || 0, a = a.def, r = 0, c = 0; c < a.length; c++) {
                var t = Math.abs(a[c]);
                t <= .5 * q && (t = 0);
                t = 0 | 96 * t * m;
                r += t;
                k[n + c + 2] = t ? t : 1
            }
            k[n] = r % 256;
            k[n + 1] = r / 256;
            k[n + a.length + 2] = 0
        }
        f = new THREE.DataTexture(k,
        d,b,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.NearestFilter,THREE.NearestFilter,0);
        f.generateMipmaps = !1;
        f.flipY = !1;
        f.needsUpdate = !0;
        return f
    }
}
)(Teratek.Viewing.Private);
(function() {
    function f(a, b) {
        if (!a || !a.colors)
            return new THREE.Color(1,0,0);
        var c = a.colors[b];
        if (!c)
            return new THREE.Color(0,0,0);
        c = c.values;
        if (!c || !c.length)
            return new THREE.Color(1,0,0);
        c = c[0];
        return new THREE.Color(c.r,c.g,c.b)
    }
    function h(a, b, c) {
        return a && a.scalars ? (a = a.scalars[b]) ? a.values[0] : c : c
    }
    function g(a, b, c) {
        return a && a.booleans ? (a = a.booleans) ? a[b] : c : c
    }
    function d(a, b, c, d) {
        return a && a[b] ? (a = a[b][c]) ? a.values[0] : d : d
    }
    function c(a, b, c, d) {
        if (!a || !a.scalars)
            return d;
        a = a.scalars[b];
        if (!a)
            return d;
        d = a.values[0];
        a = a.units;
        b = 1;
        switch (c) {
        case ELengthUnit.MilliMeter:
            b = 1E3;
            break;
        case ELengthUnit.DeciMeter:
            b = 10;
            break;
        case ELengthUnit.CentiMeter:
            b = 100;
            break;
        case ELengthUnit.Meter:
            b = 1;
            break;
        case ELengthUnit.KiloMeter:
            b = .001;
            break;
        case ELengthUnit.Inch:
            b = 39.37008;
            break;
        case ELengthUnit.Foot:
            b = 3.28084;
            break;
        case ELengthUnit.Mile:
            b = 6.2137E-4;
            break;
        case ELengthUnit.Yard:
            b = 1.09361;
            break;
        default:
            console.warn("Unsupported unit: " + c)
        }
        if ("number" === typeof a)
            switch (a) {
            case ELengthUnit.MilliMeter:
                b *= .001;
                break;
            case ELengthUnit.DeciMeter:
                b *= .1;
                break;
            case ELengthUnit.CentiMeter:
                b *= .01;
                break;
            case ELengthUnit.Meter:
                break;
            case ELengthUnit.KiloMeter:
                b *= 1E3;
                break;
            case ELengthUnit.Inch:
                b *= .0254;
                break;
            case ELengthUnit.Foot:
                b *= .3048;
                break;
            case ELengthUnit.Mile:
                b *= 1609.344;
                break;
            case ELengthUnit.Yard:
                b *= .9144;
                break;
            default:
                console.warn("Unsupported unit: " + a),
                b = 1
            }
        else
            switch (a) {
            case "MilliMeter":
            case "mm":
                b *= .001;
                break;
            case "DeciMeter":
            case "dm":
                b *= .1;
                break;
            case "CentiMeter":
            case "cm":
                b *= .01;
                break;
            case "Meter":
            case "m":
                break;
            case "KiloMeter":
            case "km":
                b *= 1E3;
                break;
            case "Inch":
            case "in":
                b *= .0254;
                break;
            case "Foot":
            case "ft":
                b *= .3048;
                break;
            case "Mile":
            case "mi":
                b *= 1609.344;
                break;
            case "Yard":
            case "yard":
                b *= .9144;
                break;
            default:
                console.warn("Unsupported unit: " + a),
                b = 1
            }
        return d * b
    }
    function a(a, b, c, d) {
        return a && a[b] ? (a = a[b][c]) && a.connections ? a.connections[0] : d : d
    }
    function b(a) {
        return a = .04045 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4)
    }
    function k(a) {
        var c, d;
        c = b(a.r);
        d = b(a.g);
        a = b(a.b);
        return new THREE.Color(c,d,a)
    }
    function l(a, b, f) {
        if (0 == 
        b) {
            b = c(a, "bumpmap_Depth", f, 0);
            var g = 1
              , h = 1;
            null  != d(a, "scalars", "texture_RealWorldScale") ? g = h = c(a, "texture_RealWorldScale", f, 1) : (g = c(a, "texture_RealWorldScaleX", f, 1),
            h = c(a, "texture_RealWorldScaleY", f, 1));
            return new THREE.Vector2((0 == g ? 1 : 1 / g) * b,(0 == h ? 1 : 1 / h) * b)
        }
        (a = d(a, "scalars", "bumpmap_NormalScale", 1)) && 1 <= a && (a = .03);
        return new THREE.Vector2(a,a)
    }
    function n(a, b) {
        var f = c(a, "texture_RealWorldOffsetX", b, 0)
          , g = c(a, "texture_RealWorldOffsetY", b, 0)
          , h = d(a, "scalars", "texture_UOffset", 0)
          , k = d(a, "scalars", "texture_VOffset", 
        0)
          , f = f + h
          , g = g + k
          , k = h = 1;
        null  != d(a, "scalars", "texture_RealWorldScale") ? h = k = c(a, "texture_RealWorldScale", b, 1) : (h = c(a, "texture_RealWorldScaleX", b, 1),
        k = c(a, "texture_RealWorldScaleY", b, 1));
        var h = 0 == h ? 1 : 1 / h
          , k = 0 == k ? 1 : 1 / k
          , l = d(a, "scalars", "texture_UScale", 1)
          , m = d(a, "scalars", "texture_VScale", 1)
          , h = h * l
          , k = k * m
          , l = d(a, "scalars", "texture_WAngle", 1)
          , l = Math.PI / 180 * l;
        return {
            elements: [Math.cos(l) * h, Math.sin(l) * k, 0, -Math.sin(l) * h, Math.cos(l) * k, 0, f, g, 1]
        }
    }
    function m(b, c) {
        var l = b.materials[b.userassets[0]]
          , m = l.properties
          , n = 
        c ? t.createPrismMaterial() : new THREE.MeshPhongMaterial;
        n.proteinMat = b;
        n.packedNormals = !0;
        if (l && c) {
            n.tag = l.tag;
            n.prismType = l.definition;
            void 0 === n.prismType && (n.prismType = "");
            l = n.mapList;
            n.transparent = !1;
            n.envExponentMin = 1;
            n.envExponentMax = 512;
            n.envExponentCount = 10;
            n.surface_albedo = k(f(m, "surface_albedo", new THREE.Color(1,0,0)));
            l.surface_albedo_map = a(m, "colors", "surface_albedo", null );
            n.surface_anisotropy = d(m, "scalars", "surface_anisotropy", 0);
            l.surface_anisotropy_map = a(m, "scalars", "surface_anisotropy", 
            null );
            n.surface_rotation = d(m, "scalars", "surface_rotation", 0);
            l.surface_rotation_map = a(m, "scalars", "surface_rotation", null );
            n.surface_roughness = d(m, "scalars", "surface_roughness", 0);
            l.surface_roughness_map = a(m, "scalars", "surface_roughness", null );
            l.surface_cutout_map = a(m, "textures", "surface_cutout", null );
            l.surface_normal_map = a(m, "textures", "surface_normal", null );
            n.specular = (new THREE.Color).copy(n.surface_albedo);
            switch (n.prismType) {
            case "PrismOpaque":
                n.opaque_albedo = k(f(m, "opaque_albedo", new THREE.Color(1,
                0,0)));
                l.opaque_albedo_map = a(m, "colors", "opaque_albedo", null );
                n.opaque_luminance_modifier = k(f(m, "opaque_luminance_modifier", new THREE.Color(0,0,0)));
                l.opaque_luminance_modifier_map = a(m, "colors", "opaque_luminance_modifier", null );
                n.opaque_f0 = d(m, "scalars", "opaque_f0", 0);
                l.opaque_f0_map = a(m, "scalars", "opaque_f0", null );
                n.opaque_luminance = d(m, "scalars", "opaque_luminance", 0);
                n.color = (new THREE.Color).copy(n.opaque_albedo);
                break;
            case "PrismMetal":
                n.metal_f0 = k(f(m, "metal_f0", new THREE.Color(1,0,0)));
                l.metal_f0_map = 
                a(m, "colors", "metal_f0", null );
                break;
            case "PrismLayered":
                n.layered_bottom_f0 = k(f(m, "layered_bottom_f0", new THREE.Color(1,1,1)));
                l.layered_bottom_f0_map = a(m, "colors", "layered_bottom_f0", null );
                n.layered_diffuse = k(f(m, "layered_diffuse", new THREE.Color(1,0,0)));
                l.layered_diffuse_map = a(m, "colors", "layered_diffuse", null );
                n.layered_anisotropy = d(m, "scalars", "layered_anisotropy", 0);
                l.layered_anisotropy_map = a(m, "scalars", "layered_anisotropy", null );
                n.layered_f0 = d(m, "scalars", "layered_f0", 0);
                l.layered_f0_map = 
                a(m, "scalars", "layered_f0", null );
                n.layered_fraction = d(m, "scalars", "layered_fraction", 0);
                l.layered_fraction_map = a(m, "scalars", "layered_fraction", null );
                n.layered_rotation = d(m, "scalars", "layered_rotation", 0);
                l.layered_rotation_map = a(m, "scalars", "layered_rotation", null );
                n.layered_roughness = d(m, "scalars", "layered_roughness", 0);
                l.layered_roughness_map = a(m, "scalars", "layered_roughness", null );
                l.layered_normal_map = a(m, "textures", "layered_normal", null );
                n.color = (new THREE.Color).copy(n.layered_diffuse);
                break;
            case "PrismTransparent":
                n.transparent_color = k(f(m, "transparent_color", new THREE.Color(1,0,0)));
                n.transparent_distance = d(m, "scalars", "transparent_distance", 0);
                n.transparent_ior = d(m, "scalars", "transparent_ior", 0);
                n.transparent = !0;
                n.color = (new THREE.Color).copy(n.transparent_color);
                break;
            default:
                console.warn("Unknown prism type: " + n.prismType)
            }
            var m = {}, q;
            for (q in l)
                null  != l[q] && (m["USE_" + q.toUpperCase()] = "");
            m[n.prismType.toUpperCase()] = "";
            n.defines = m
        } else if (l && !c && "SimplePhong" == l.definition) {
            n.tag = 
            l.tag;
            n.proteinType = l.proteinType;
            void 0 === n.proteinType && (n.proteinType = null );
            q = n.ambient = f(m, "generic_ambient");
            var r = n.color = f(m, "generic_diffuse")
              , z = n.specular = f(m, "generic_specular")
              , H = n.emissive = f(m, "generic_emissive");
            0 == r.r && 0 == r.g && 0 == r.b && 0 == z.r && 0 == z.g && 0 == z.b && 0 == q.r && 0 == q.g && 0 == q.b && 0 == H.r && 0 == H.g && 0 == H.b && (r.r = r.g = r.b = .4);
            n.shininess = h(m, "generic_glossiness", 30);
            n.opacity = 1 - h(m, "generic_transparency", 0);
            n.reflectivity = h(m, "generic_reflectivity_at_0deg", 0);
            q = g(m, "generic_is_metal");
            void 0 !== 
            q && (n.metal = q);
            m = g(m, "generic_backface_cull");
            void 0 === m || m || (n.side = THREE.DoubleSide);
            n.transparent = l.transparent
        } else
            n.ambient = 197379,
            n.color = 7829367,
            n.specular = 3355443,
            n.shininess = 30,
            n.shading = THREE.SmoothShading;
        return n
    }
    function q(a, b, c) {
        auth && (-1 != a.indexOf("/items/") ? THREE.ImageUtils.crossOrigin = "use-credentials" : THREE.ImageUtils.crossOrigin = "");
        var d = a.indexOf("urn:");
        -1 != d && (a = a.substr(0, d) + encodeURIComponent(a.substr(d)),
        a += "?domain=" + encodeURIComponent(window.location.origin),
        Teratek.Viewing.ACM_SESSION_ID && 
        (a += "&acmsession=" + Teratek.Viewing.ACM_SESSION_ID));
        return THREE.ImageUtils.loadTexture(a, b, c)
    }
    function r(a) {
        var b = a.width
          , c = a.height;
        if (0 === (b & b - 1) && 0 === (c & c - 1))
            return a;
        for (var d = 1; 2 * d < b; )
            d *= 2;
        for (b = 1; 2 * b < c; )
            b *= 2;
        var c = document.createElement("canvas")
          , f = c.getContext("2d");
        c.width = d;
        c.height = b;
        f.drawImage(a, 0, 0, d, b);
        return c
    }
    var t = Teratek.Viewing.Private;
    ELengthUnit = {
        MilliMeter: 8206,
        DeciMeter: 8204,
        CentiMeter: 8205,
        Meter: 8193,
        KiloMeter: 8201,
        Inch: 8214,
        Foot: 8215,
        Mile: 8225,
        Yard: 8221
    };
    Teratek.Viewing.Private.MaterialManager = 
    function(a) {
        function b(a) {
            return -1 != a.indexOf("__lineMaterial__")
        }
        function c(a, d) {
            return b(d) ? d : a.basePath + "|mat|" + d
        }
        this.viewer = a;
        var f = this
          , k = this.materials = {}
          , v = this.materialsNonHDR = {};
        this.textures = {};
        this.irradianceMap = this.reflectionCube = this.layerMaskTex = null ;
        var D = 1
          , z = [];
        this.hasPrism = !1;
        this.renderPrism = !0;
        var H = []
          , I = new THREE.Vector3(0,1,0);
        this.defaultMaterial = new THREE.MeshPhongMaterial({
            ambient: 197379,
            color: 7829367,
            specular: 3355443,
            shininess: 30,
            shading: THREE.SmoothShading,
            reflectivity: 0
        });
        this.dtor = function() {
            this.cleanup();
            THREE.Cache.clear();
            f = this.viewer = null 
        }
        ;
        this.findMaterial = function(a, b) {
            var d = k[c(a, b)];
            d || (stderr("Unknown material " + b + ". Using default."),
            d = this.defaultMaterial);
            return d
        }
        ;
        this.setRenderPrism = function(a) {
            this.renderPrism = a
        }
        ;
        this.convertMaterials = function(a) {
            if (a.materials) {
                var b = a.materials.materials, d = a.proteinMaterials ? a.proteinMaterials.materials : null , f;
                for (f in b) {
                    var g = !1;
                    if (d) {
                        var h = d[f].materials[d[f].userassets[0]];
                        this.renderPrism && h && (g = h.definition,
                        g = "PrismLayered" == g || "PrismMetal" == g || "PrismOpaque" == g || "PrismTransparent" == g)
                    }
                    h = m(g ? d[f] : b[f], g);
                    !_isIE11 && a.doubleSided && (h.side = THREE.DoubleSide);
                    var k = c(a, f);
                    this.addMaterial(k, h, g)
                }
            }
        }
        ;
        this.updateMaterials = function() {
            for (; z.length; )
                for (var a = z.pop(), b = 0; b < a.mats.length; b++)
                    a.mats[b][a.slot] = a.tex,
                    a.mats[b].needsUpdate = !0,
                    this.viewer.invalidate(!0, !1, !1)
        }
        ;
        this.loadTexture = function(a, b) {
            if (a && a.proteinMat) {
                var c = a.proteinMat.materials
                  , k = c[a.proteinMat.userassets[0]]
                  , m = function(a, b) {
                    return q(b, THREE.UVMapping, 
                    function(b) {
                        if (f) {
                            b.image = r(b.image);
                            var c = f.textures[a];
                            if (c) {
                                c.tex || (c.tex = b);
                                for (var d = 0; d < c.mats.length; d++)
                                    c.mats[d][c.slots[d]] = b;
                                z.push(c)
                            }
                        }
                    }
                    )
                }
                ;
                if (a.isPrismMaterial) {
                    var v = a.mapList;
                    for (p in v)
                        if (null  != v[p]) {
                            var B = c[v[p]]
                              , k = B.properties
                              , D = k.uris["BumpMap" == B.definition ? "bumpmap_Bitmap" : "unifiedbitmap_Bitmap"].values[0];
                            if (D) {
                                var w = b.basePath + D + B.definition
                                  , C = f.textures[w];
                                if (C)
                                    C.tex ? (a[p] = C.tex,
                                    a.needsUpdate = !0) : (f.textures[w].mats.push(a),
                                    f.textures[w].slots.push(p));
                                else {
                                    C = null ;
                                    C = !PRISM_ROOT || 
                                    0 !== D.indexOf("1/Mats") && 0 !== D.indexOf("2/Mats") && 0 !== D.indexOf("3/Mats") ? t.pathToURL(b.basePath + D) : PRISM_ROOT + D;
                                    D = {
                                        mats: [a],
                                        slots: [p],
                                        tex: null 
                                    };
                                    f.textures[w] = D;
                                    D = m(w, C);
                                    D.flipY = !0;
                                    D.invert = !1;
                                    D.wrapS = THREE.RepeatWrapping;
                                    D.wrapT = THREE.RepeatWrapping;
                                    D.wrapS = d(k, "booleans", "texture_URepeat", !1) ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                                    D.wrapT = d(k, "booleans", "texture_VRepeat", !1) ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                                    var H = b.proteinMaterials.scene.SceneUnit;
                                    D.matrix = n(k, H);
                                    "UnifiedBitmap" == 
                                    B.definition && (D.invert = d(k, "booleans", "unifiedbitmap_Invert", !1));
                                    "BumpMap" == B.definition && (D.bumpmapType = d(k, "choicelists", "bumpmap_Type", 0),
                                    D.bumpScale = l(k, D.bumpmapType, H))
                                }
                            }
                        }
                } else if (k && "SimplePhong" === k.definition)
                    for (B in v = k.properties,
                    H = k.textures,
                    H)
                        if (k = c[H[B].connections[0]].properties,
                        D = k.uris.unifiedbitmap_Bitmap.values[0]) {
                            var I;
                            if ("generic_diffuse" == B)
                                I = "map",
                                (!a.color || 0 == a.color.r && 0 == a.color.g && 0 == a.color.b) && a.color.setRGB(1, 1, 1);
                            else if ("generic_bump" == B)
                                I = g(v, "generic_bump_is_normal") ? 
                                "normalMap" : "bumpMap",
                                a.bumpScale = h(v, "generic_bump_amount", 0),
                                a.bumpScale && 1 <= a.bumpScale && (a.bumpScale = .03);
                            else if ("generic_specular" == B)
                                I = "specularMap";
                            else if ("generic_alpha" == B)
                                I = "alphaMap",
                                a.transparent = !0;
                            else
                                continue;var E = (w = a.proteinType && a.proteinType.length) && 0 === a.proteinType.indexOf("Prism")
                              , X = (E && PRISM_ROOT || w && PROTEIN_ROOT) && (0 === D.indexOf("1/Mats") || 0 === D.indexOf("2/Mats") || 0 === D.indexOf("3/Mats"))
                              , w = b.basePath + D;
                            if (C = f.textures[w])
                                C.tex ? (a[I] = C.tex,
                                a.needsUpdate = !0) : (f.textures[w].mats.push(a),
                                f.textures[w].slots.push(I));
                            else {
                                C = null ;
                                if (X)
                                    C = E ? PRISM_ROOT + D : PROTEIN_ROOT + D;
                                else {
                                    for (E = 0; E < b.manifest.assets.length; ++E)
                                        if (X = b.manifest.assets[E],
                                        X.id == D) {
                                            C = t.pathToURL(b.basePath + X.URI);
                                            break
                                        }
                                    C || (C = t.pathToURL(w))
                                }
                                D = {
                                    mats: [a],
                                    slots: [I],
                                    tex: null 
                                };
                                f.textures[w] = D;
                                D = m(w, C);
                                "alphaMap" == I && (a.transparent = !0);
                                D.anisotropy = "bumpMap" == I || "normalMap" == I ? 0 : this.viewer.renderer().getMaxAnisotropy();
                                D.flipY = !0;
                                D.wrapS = THREE.RepeatWrapping;
                                D.wrapT = THREE.RepeatWrapping;
                                D.invert = g(k, "unifiedbitmap_Invert");
                                D.clampS = 
                                !g(k, "texture_URepeat", !0);
                                D.clampT = !g(k, "texture_VRepeat", !0);
                                w = h(k, "texture_UScale", 1);
                                I = h(k, "texture_VScale", 1);
                                C = h(k, "texture_UOffset", 0);
                                E = h(k, "texture_VOffset", 0);
                                k = h(k, "texture_WAngle", 0);
                                D.matrix = {
                                    elements: [Math.cos(k) * w, Math.sin(k) * I, 0, -Math.sin(k) * w, Math.cos(k) * I, 0, C, E, 1]
                                }
                            }
                        }
            }
        }
        ;
        this.loadTextures = function(a) {
            for (var b in k)
                -1 != b.indexOf(a.basePath) && this.loadTexture(k[b], a)
        }
        ;
        this.create2DMaterial = function(a, b, d, g) {
            var h = "__lineMaterial__";
            b.image && (h += "|image:" + b.image.name);
            b.clip && (h += "|clip:" + 
            JSON.stringify(b.clip));
            d && (h += "|id");
            g && (h += "|selection");
            b.skipEllipticals && (h += "|skipEllipticals");
            b.skipCircles && (h += "|skipCircles");
            b.skipTriangleGeoms && (h += "|skipTriangleGeoms");
            b.useInstancing && (h += "|useInstancing");
            a && (h += "|" + a ? a.basePath : "runtime");
            h = c(null , h);
            if (!k.hasOwnProperty(h)) {
                a = Teratek.Viewing.Shaders;
                var l = new THREE.ShaderMaterial({
                    fragmentShader: a.LineShader.fragmentShader,
                    vertexShader: a.LineShader.vertexShader,
                    uniforms: THREE.UniformsUtils.clone(a.LineShader.uniforms),
                    attributes: a.LineShader.attributes,
                    defines: THREE.UniformsUtils.clone(a.LineShader.defines),
                    transparent: !0
                });
                l.depthWrite = !1;
                l.depthTest = !1;
                l.side = THREE.DoubleSide;
                l.blending = THREE.NormalBlending;
                d ? (l.defines.ID_COLOR = 1,
                l.blending = THREE.NoBlending) : g ? l.defines.SELECTION_RENDERER = 1 : this.viewer.renderer().hasMRT() && (l.mrtIdBuffer = 1);
                b.skipEllipticals || (l.defines.HAS_ELLIPTICALS = 1);
                b.skipCircles || (l.defines.HAS_CIRCLES = 1);
                b.skipTriangleGeoms || (l.defines.HAS_TRIANGLE_GEOMS = 1);
                b.useInstancing && (l.defines.USE_INSTANCING = 1);
                this.layerMaskTex && 
                (l.defines.HAS_LAYERS = 1,
                l.uniforms.tLayerMask.value = f.layerMaskTex);
                this.lineStyleTex && (l.defines.HAS_LINESTYLES = 1,
                l.defines.MAX_LINESTYLE_LENGTH = f.lineStyleTex.image.width,
                l.uniforms.tLineStyle.value = f.lineStyleTex,
                l.uniforms.vLineStyleTexSize.value.set(f.lineStyleTex.image.width, f.lineStyleTex.image.height));
                if (b.image) {
                    var m = this;
                    q(b.image.dataURI, THREE.UVMapping, function(a) {
                        m.viewer && (a.image = r(a.image),
                        a.wrapS = THREE.ClampToEdgeWrapping,
                        a.wrapT = THREE.ClampToEdgeWrapping,
                        a.minFilter = THREE.LinearMipMapLinearFilter,
                        a.magFilter = THREE.LinearFilter,
                        a.anisotropy = 1,
                        a.flipY = !0,
                        a.generateMipmaps = !0,
                        a.needsUpdate = !0,
                        l.defines.HAS_RASTER_QUADS = 1,
                        l.uniforms.tRaster.value = a,
                        -1 != b.image.dataURI.indexOf("png") && (l.transparent = !0),
                        l.needsUpdate = !0,
                        m.viewer.invalidate(!1, !0, !1))
                    }
                    )
                }
                k[h] = l
            }
            return h
        }
        ;
        this.addMaterial = function(a, b, c) {
            function d(a) {
                return .299 * a.r + .587 * a.g + .114 * a.b
            }
            var g = b.proteinMat ? b.proteinMat : null 
              , h = b.proteinType && -1 != b.proteinType.indexOf("Prism");
            this.hasPrism = h || this.hasPrism;
            if (!c) {
                if (b.metal) {
                    if (b.reflectivity || 
                    (b.reflectivity = d(b.specular)),
                    g && (1 === b.reflectivity && (b.reflectivity = d(b.specular)),
                    0 !== b.color.r || 0 !== b.color.g || 0 !== b.color.b))
                        b.color.r *= .1,
                        b.color.g *= .1,
                        b.color.b *= .1
                } else
                    g ? h ? (c = !1,
                    "PrismLayered" == b.proteinType && (b.clearcoat = !0,
                    b.reflectivity = .06,
                    g && (g = g.materials[g.userassets[0]].categories) && g.length && -1 != g[0].indexOf("Metal") && (c = !0)),
                    b.reflectivity = Math.sqrt(b.reflectivity),
                    c ? b.specular.copy(b.color) : (b.specular.r = b.reflectivity,
                    b.specular.g = b.reflectivity,
                    b.specular.b = b.reflectivity)) : 
                    (b.reflectivity || (b.reflectivity = .01 + .06 * d(b.specular)),
                    b.specular.r *= b.reflectivity,
                    b.specular.g *= b.reflectivity,
                    b.specular.b *= b.reflectivity,
                    1 > b.opacity && (b.reflectivity = 1)) : b.reflectivity ? (b.metal = !0,
                    b.specular.r = b.color.r * b.reflectivity,
                    b.specular.g = b.color.g * b.reflectivity,
                    b.specular.b = b.color.b * b.reflectivity,
                    b.color.r *= .1,
                    b.color.g *= .1,
                    b.color.b *= .1) : 1 !== b.color.r || 1 !== b.color.g || 1 !== b.color.b || 1 !== b.specular.r || 1 !== b.specular.g || 1 !== b.specular.b || b.uri_map || b.uri_specularMap || (b.metal = !0,
                    b.reflectivity = .7,
                    b.specular.r = b.specular.g = b.specular.b = b.reflectivity,
                    b.color.r *= .1,
                    b.color.g *= .1,
                    b.color.b *= .1);
                if (b.transparent || b.uri_map && -1 != b.uri_map.toLowerCase().indexOf(".png") || b.uri_opacityMap)
                    b.alphaTest = .01
            }
            if (b.uri_normalMap) {
                g = b.bumpScale;
                if (void 0 === g || 1 <= g)
                    g = 1;
                b.normalScale = new THREE.Vector2(g,g)
            } else
                void 0 === b.bumpScale && (b.uri_map || b.uri_bumpMap) ? b.bumpScale = .03 : 1 <= b.bumpScale && (b.bumpScale = .03);
            b.shininess *= .25;
            f.reflectionCube && (b.envMap = f.reflectionCube);
            f.irradianceMap && 
            (b.irradianceMap = f.irradianceMap);
            b.exposureBias = Math.pow(2, this.viewer.renderer().getExposureBias());
            b.tonemapOutput = this.viewer.renderer().getToneMapMethod();
            b.envMapExposure = D;
            this.viewer.renderer().applyMRTFlags(b);
            b.side == THREE.DoubleSide && this.viewer.renderer().toggleTwoSided(!0);
            b.cutplanes = H;
            b.cutplanesOutlineColor = I;
            k[a] = b
        }
        ;
        this.addMaterialNonHDR = function(a, b) {
            b.cutplanes = H;
            b.cutplanesOutlineColor = I;
            v[a] = b
        }
        ;
        this.togglePolygonOffset = function(a) {
            for (var b in k) {
                var c = k[b];
                c instanceof THREE.MeshPhongMaterial && 
                (c.polygonOffset = !0,
                c.polygonOffsetFactor = a ? 1 : 0,
                c.polygonOffsetUnits = a ? 1 : 0,
                c.needsUpdate = !0)
            }
        }
        ;
        this.applyGeometryFlagsToMaterial = function(a, b) {
            b.attributes.color && (a.vertexColors = THREE.VertexColors,
            a.needsUpdate = !0);
            !a.proteinType && b.attributes.uv && b.attributes.uv.isPattern && (a.map && !a.bumpMap && (a.bumpMap = a.map,
            a.needsUpdate = !0),
            a.uri_map && !a.uri_bumpMap && (a.uri_bumpMap = a.uri_map,
            a.needsUpdate = !0))
        }
        ;
        this.toggleMRTSetting = function() {
            for (var a in k) {
                var c = k[a];
                b(a) || this.viewer.renderer().applyMRTFlags(c)
            }
        }
        ;
        this.updatePixelScale = function(a) {
            var c = k, d;
            for (d in c)
                b(d) && (c[d].uniforms.aaRange.value = .5 / a,
                c[d].uniforms.pixelsPerUnit.value = a)
        }
        ;
        this.setCubeMapFromColors = function(a, b) {
            var c = t.CreateCubeMapFromColors(a, b);
            f.reflectionCube = c;
            f.reflectionCube.isBgColor = !0;
            for (var d in k) {
                var g = k[d];
                g.envMap = c;
                g.needsUpdate = !0
            }
            this.viewer.invalidate(!0)
        }
        ;
        this.setCubeMap = function(a, b) {
            var c = this
              , d = function(d) {
                d && (d.mapping = THREE.CubeReflectionMapping,
                d.LogLuv = -1 != a.indexOf("logluv"),
                d.RGBM = -1 != a.indexOf("rgbm"),
                t.DecodeEnvMap(d, b, !1));
                c.reflectionCube = d;
                if (c.reflectionCube)
                    for (var g in k)
                        d = k[g],
                        d.envMap = f.reflectionCube,
                        d.needsUpdate = !0;
                else
                    c.setCubeMapFromColors(c.viewer.clearColorTop, c.viewer.clearColorBottom);
                c.viewer.invalidate(!0)
            }
            ;
            Array.isArray(a) ? (this.reflectionCube = THREE.ImageUtils.loadTextureCube(a, THREE.CubeReflectionMapping, d),
            this.reflectionCube.format = THREE.RGBFormat) : "string" == typeof a ? -1 != a.toLowerCase().indexOf(".dds") ? this.reflectionCube = (new THREE.DDSLoader).load(a, d) : (this.reflectionCube = 
            THREE.ImageUtils.loadTexture(a, THREE.SphericalReflectionMapping, d),
            this.reflectionCube.format = THREE.RGBFormat) : a ? d(a) : d(null )
        }
        ;
        this.setIrradianceMap = function(a, b) {
            var c = this
              , d = function(d) {
                if (d) {
                    d.mapping = THREE.CubeReflectionMapping;
                    d.LogLuv = -1 != a.indexOf("logluv");
                    d.RGBM = -1 != a.indexOf("rgbm");
                    t.DecodeEnvMap(d, b, !1);
                    for (var f in k) {
                        var g = k[f];
                        g.irradianceMap = d;
                        g.needsUpdate = !0
                    }
                    c.irradianceMap = d
                } else if (c.irradianceMap) {
                    for (f in k)
                        g = k[f],
                        g.irradianceMap = null ,
                        g.needsUpdate = !0;
                    c.irradianceMap = null 
                }
                c.viewer.invalidate(!0)
            }
            ;
            THREE.ImageUtils.crossOrigin = "";
            Array.isArray(a) ? (f.irradianceMap = THREE.ImageUtils.loadTextureCube(a, THREE.CubeReflectionMapping, d),
            f.irradianceMap.format = THREE.RGBFormat) : "string" == typeof a ? -1 != a.toLowerCase().indexOf(".dds") && (f.irradianceMap = (new THREE.DDSLoader).load(a, d)) : a ? d(a) : d(null )
        }
        ;
        this.setTonemapMethod = function(a) {
            for (var b in k) {
                var c = k[b];
                c.tonemapOutput = a;
                c.needsUpdate = !0
            }
        }
        ;
        this.setEnvExposure = function(a) {
            D = a = Math.pow(2, a);
            for (var b in k) {
                var c = k[b];
                c.envMapExposure = a;
                c.needsUpdate = 
                !0
            }
        }
        ;
        this.setTonemapExposureBias = function(a) {
            a = Math.pow(2, a);
            for (var b in k) {
                var c = k[b];
                c.exposureBias = a;
                c.needsUpdate = !0
            }
        }
        ;
        this.initLayersTexture = function(a) {
            for (var b = a.getData().layerCount, c = new Uint8Array(65536), d = 0; d < b; d++)
                c[d] = 255;
            b = new THREE.DataTexture(c,256,256,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.NearestFilter,THREE.NearestFilter,0);
            b.generateMipmaps = !1;
            b.flipY = !1;
            b.needsUpdate = !0;
            this.layerMaskTex = b;
            this.layersMap = 
            a.getData().layersMap
        }
        ;
        this.initLineStyleTexture = function() {
            this.lineStyleTex = t.CreateLinePatternTexture()
        }
        ;
        this.init2DSelectionMaterial = function(a) {
            for (var b = a.myData.maxObjectNumber || 1, c = 0 | Math.ceil(b / 4096), d = 1; d < c; )
                d *= 2;
            for (var c = d, d = new Uint8Array(4096 * c), f = 0; f < b; f++)
                d[f] = 0;
            b = new THREE.DataTexture(d,4096,c,THREE.LuminanceFormat,THREE.UnsignedByteType,THREE.UVMapping,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.NearestFilter,THREE.NearestFilter,0);
            b.generateMipmaps = !1;
            b.flipY = !1;
            b.needsUpdate = 
            !0;
            this.selectionTex = b;
            a = this.create2DMaterial(a.getData(), {}, !1, !0);
            a = k[a];
            a.uniforms.tSelectionTexture.value = this.selectionTex;
            a.uniforms.vSelTexSize.value.set(4096, c);
            a.needsUpdate = !0;
            return a
        }
        ;
        this.setLayerVisible = function(a, c) {
            for (var d = this.layerMaskTex, f = d.image.data, g = this.layersMap, h = c ? 255 : 0, l = 0; l < a.length; ++l)
                f[g[a[l]]] = h;
            d.needsUpdate = !0;
            for (var m in k)
                b(m) && (k[m].needsUpdate = !0);
            this.viewer.invalidate(!0)
        }
        ;
        this.isLayerVisible = function(a) {
            return !!this.layerMaskTex.image.data[this.layersMap[a]]
        }
        ;
        this.highlightObject2D = function(a, b) {
            this.selectionTex.image.data[a] = b ? 255 : 0;
            this.selectionTex.needsUpdate = !0;
            this.viewer.invalidate(!1, !1, !0)
        }
        ;
        this.cloneMaterial = function(a) {
            var b = a.isPrismMaterial ? t.clonePrismMaterial(a) : a.clone();
            if (b instanceof THREE.MeshPhongMaterial || b.isPrismMaterial)
                b.packedNormals = a.packedNormals,
                b.exposureBias = a.exposureBias,
                b.irradianceMap = a.irradianceMap,
                b.envMapExposure = a.envMapExposure,
                b.proteinType = a.proteinType,
                b.proteinMat = a.proteinMat,
                b.tonemapOutput = a.tonemapOutput,
                b.cutplanes = a.cutplanes,
                b.cutplanesOutlineColor = a.cutplanesOutlineColor,
                b.cutplanesOutlineThickness = a.cutplanesOutlineThickness;
            this.viewer.renderer().applyMRTFlags(b);
            return b
        }
        ;
        this.getCutPlanes = function() {
            return H.slice()
        }
        ;
        this.getCutPlanesRaw = function() {
            return H
        }
        ;
        this.setCutPlanes = function(a) {
            if (H.length !== (a ? a.length || 0 : 0)) {
                for (var b in k)
                    k[b].needsUpdate = !0,
                    a && 0 < a.length && (k[b].side = THREE.DoubleSide);
                for (b in v)
                    v[b].needsUpdate = !0
            }
            for (; 0 < H.length; )
                H.pop();
            if (a)
                for (b = 0; b < a.length; b++)
                    H.push(a[b].clone())
        }
        ;
        this.setCutPlanesOutlineColor = function(a) {
            I.set(a.r, a.g, a.b)
        }
        ;
        this.setCutPlanesOutlineThickness = function(a) {
            for (var b in k)
                k[b].cutplanesOutlineThickness = a;
            for (b in v)
                v[b].cutplanesOutlineThickness = a
        }
        ;
        this.cleanup = function(a) {
            var b = {}, c;
            for (c in this.textures) {
                var d = this.textures[c];
                -1 === c.indexOf(a.basePath) ? b[c] = d : d.tex && d.tex.dispose()
            }
            this.textures = b;
            b = {};
            c = {
                type: "dispose"
            };
            for (var f in k)
                a && -1 === f.indexOf(a.basePath) ? b[f] = k[f] : (d = k[f],
                d.dispatchEvent(c),
                d.needsUpdate = !0);
            k = this.materials = b
        }
        ;
        this.addSimpleMaterial = function(a, b, d) {
            b = m(b);
            a = c(d, a);
            this.addMaterial(a, b);
            this.loadTexture(b, d)
        }
        ;
        this.addMaterial("__defaultMaterial__", this.defaultMaterial)
    }
}
)();
function init_GroundShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.GroundDepthShader && (f.GroundDepthShader = {
        uniforms: {
            cutplanes: {
                type: "v4v",
                value: []
            }
        },
        vertexShader: "#ifdef USE_LOGDEPTHBUF\n    #ifdef USE_LOGDEPTHBUF_EXT\n        varying float vFragDepth;\n    #endif\n    uniform float logDepthBufFC;\n#endif\n#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );;\n#if NUM_CUTPLANES > 0\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n#endif\n#ifdef USE_LOGDEPTHBUF\n    gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n    #ifdef USE_LOGDEPTHBUF_EXT\n        vFragDepth = 1.0 + gl_Position.w;\n    #else\n        gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n    #endif\n#endif\n}",
        fragmentShader: ["#ifdef USE_LOGDEPTHBUF\n    uniform float logDepthBufFC;\n    #ifdef USE_LOGDEPTHBUF_EXT\n        #extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n    #endif\n#endif", 
        PackDepthShaderChunk, "#if NUM_CUTPLANES > 0\nvarying vec3 vWorldPosition;\n#endif", CutPlanesShaderChunk, "void main() {\n#if NUM_CUTPLANES > 0\nif (checkCutPlanes(vWorldPosition)) return;\n#endif\n#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif\n#ifdef USE_LOGDEPTHBUF_EXT\nfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n#else\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#endif\ndepth = 1.0 - depth;\ngl_FragColor = packDepth(depth);\n}"].join("\n")
    },
    f.GroundShadowAOShader = {
        uniforms: {
            tDepth: {
                type: "t",
                value: null 
            },
            worldSize: {
                type: "v3",
                value: new THREE.Vector3(1,1,1)
            }
        },
        defines: {},
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = vec2(uv.x, uv.y);\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
        fragmentShader: ["#define NUM_SAMPLES 29.0\n#define NUM_SPIRAL_TURNS 7.0\nuniform sampler2D tDepth;\nuniform vec3 worldSize;\nvarying vec2 vUv;\n#ifdef PRESET_2\n#define SAMPLE_RADIUS 0.3\n#define AO_GAMMA 1.0\n#define AO_INTENSITY 1.0\n#else\n#define SAMPLE_RADIUS 0.2\n#define AO_GAMMA 3.0\n#define AO_INTENSITY 0.8\n#endif", 
        PackDepthShaderChunk, "#define PI 3.14159265358979\nfloat rand(vec2 co) {\nreturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat getRandomAngle(vec2 pos) {\nreturn rand(pos) * (2.0 * PI);\n}\nvec2 tapLocation(float sampleNumber, float spinAngle, out float ssR){\nfloat alpha = float(sampleNumber + 0.5) * (1.0 / NUM_SAMPLES);\nfloat angle = alpha * (NUM_SPIRAL_TURNS * PI * 2.0) + spinAngle;\nssR = alpha;\nreturn vec2(cos(angle), sin(angle));\n}\nvec2 sampleAO(vec2 unitDirection, float radius) {\nvec2 sampleOffset = unitDirection * radius;\nfloat idepth = unpackDepth(texture2D(tDepth, vUv + sampleOffset));\nfloat depth = 1.0 - idepth;\nif (depth < 1e-6) {\nif (radius == 0.0)\nreturn vec2(1.0, 1.0);\nelse\nreturn vec2(0.0, 1.0);\n}\nvec3 dir = vec3(sampleOffset.x, depth, sampleOffset.y) * worldSize;\nfloat distance2 = dot(dir,dir);\nfloat idistance = 1.0 / sqrt(distance2);\nvec3 ndir = dir * idistance;\n#ifdef PRESET_2\nfloat importance = ndir.y * idistance;\n#else\nfloat importance = ndir.y / distance2;\n#endif\nvec2 ret;\nret.x = (idepth == 0.0) ? 0.0 : importance;\nret.y = importance;\nreturn ret;\n}\nvoid main() {\nvec2 sum = vec2(0.0);\nfloat angle = getRandomAngle(vUv);\nfor (float i = 0.0; i<NUM_SAMPLES; i+= 1.0) {\nfloat ssR;\nvec2 uv = tapLocation(i, angle, ssR);\nsum += sampleAO(uv, ssR * SAMPLE_RADIUS);\n}\nfloat ao = sum.x / sum.y;\ngl_FragColor = packDepth(AO_INTENSITY * clamp(pow(ao, AO_GAMMA), 0.0, 0.9999));\n}"].join("\n")
    },
    f.GroundShadowBlurShader = {
        uniforms: {
            tDepth: {
                type: "t",
                value: null 
            }
        },
        defines: {},
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = vec2(uv.x, uv.y);\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
        fragmentShader: ["uniform sampler2D tDepth;\nvarying vec2 vUv;\n#ifdef HORIZONTAL\n#define GET_UV(X) vec2(vUv.x + KERNEL_SCALE*(X), vUv.y)\n#else\n#define GET_UV(Y) vec2(vUv.x, vUv.y + KERNEL_SCALE*(Y))\n#endif", PackDepthShaderChunk, "#define PI 3.14159265358979\n#define SIGMA ((2.0 * KERNEL_RADIUS+1.0) / 6.0)\n#define SIGMASQ2 (2.0 * SIGMA * SIGMA)\n#ifdef BOX\n#define KERNEL_VAL(X) 1.0\n#else\n#define KERNEL_VAL(X) ( (1.0 / sqrt(PI * SIGMASQ2)) * exp(-(X)*(X)/SIGMASQ2) )\n#endif\nvoid main() {\nfloat depthVal = 0.0;\nfloat sum = 0.0;\nfor (float x=-KERNEL_RADIUS; x<=KERNEL_RADIUS; x+=1.0) {\ndepthVal += unpackDepth(texture2D(tDepth, GET_UV(x))) * KERNEL_VAL(x);\nsum += KERNEL_VAL(x);\n}\ngl_FragColor = packDepth(depthVal/sum);\n}"].join("\n")
    },
    f.GroundShadowColorShader = {
        uniforms: {
            tDepth: {
                type: "t",
                value: null 
            },
            uShadowColor: {
                type: "v4",
                value: new THREE.Vector4(0,0,0,1)
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\n    vUv = vec2(uv.x, uv.y);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
        fragmentShader: ["uniform sampler2D tDepth;\nuniform vec4 uShadowColor;\nvarying vec2 vUv;", PackDepthShaderChunk, "void main() {\nfloat depthVal = unpackDepth(texture2D(tDepth, vUv));\ngl_FragColor = vec4(uShadowColor.rgb, uShadowColor.a * depthVal);\n}"].join("\n")
    })
}
(function() {
    var f = Teratek.Viewing.Shaders
      , h = function(g, d) {
        function c(a) {
            return new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(a.uniforms),
                vertexShader: a.vertexShader,
                fragmentShader: a.fragmentShader,
                defines: THREE.UniformsUtils.clone(a.defines)
            })
        }
        init_GroundShader();
        var a, b, h, l, n, m, q, r, t, w, C, E, G = !1, B = {
            texSize: 64,
            pixScale: 1,
            blurRadius: 7,
            debug: !1
        };
        this.setTransform = function(b, c, d, f) {
            a.left = -c.z / 2;
            a.right = c.z / 2;
            a.top = c.x / 2;
            a.bottom = -c.x / 2;
            a.near = 1;
            a.far = c.y + a.near;
            a.updateProjectionMatrix();
            a.position.addVectors(b, d.clone().multiplyScalar(-c.y / 2 - a.near));
            f && a.up.set(f.x, f.y, f.z);
            a.lookAt(b);
            h.position.set(b.x, b.y, b.z);
            h.rotation.set(a.rotation.x, a.rotation.y, a.rotation.z);
            h.scale.set(c.z, c.x, c.y);
            B.debug && (E.position.set(b.x, b.y, b.z),
            E.rotation.set(a.rotation.x, a.rotation.y, a.rotation.z),
            E.scale.set(c.z, c.x, c.y));
            C.uniforms.worldSize.value.copy(c)
        }
        ;
        this.renderIntoShadow = function(b) {
            if (!b.overrideMaterial || !b.overrideMaterial.transparent) {
                var c = b.overrideMaterial;
                b.overrideMaterial = q;
                g.render(b, a, n, !1);
                b.overrideMaterial = c
            }
        }
        ;
        this.renderShadow = function(a, c) {
            G && (c ? g.render(b, a, c, !1) : g.render(b, a))
        }
        ;
        this.postprocess = function() {
            w.render(g, m, n);
            t.render(g, n, m);
            G = !0
        }
        ;
        this.clear = function() {
            var a = g.getClearColor().getHex()
              , b = g.getClearAlpha();
            g.setClearColor(0, 0);
            g.clearTarget(n, !0, !0, !1);
            g.setClearColor(a, b);
            G = !1
        }
        ;
        this.setColor = function(a) {
            r.uniforms.uShadowColor.value.x = a.r;
            r.uniforms.uShadowColor.value.y = a.g;
            r.uniforms.uShadowColor.value.z = a.b
        }
        ;
        this.getColor = function() {
            return new THREE.Color(r.uniforms.uShadowColor.value.x,
            r.uniforms.uShadowColor.value.y,r.uniforms.uShadowColor.value.z)
        }
        ;
        this.setAlpha = function(a) {
            r.uniforms.uShadowColor.value.w = a
        }
        ;
        this.getAlpha = function() {
            return r.uniforms.uShadowColor.value.w
        }
        ;
        this.isValid = function() {
            return G
        }
        ;
        this.getDepthMaterial = function() {
            return q
        }
        ;
        if (d)
            for (l in B)
                B[l] = d[l] || B[l];
        b = new THREE.Scene;
        a = new THREE.OrthographicCamera;
        n = new THREE.WebGLRenderTarget(B.texSize,B.texSize,{
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: !1
        });
        n.generateMipmaps = !1;
        m = new THREE.WebGLRenderTarget(B.texSize,B.texSize,{
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: !1
        });
        m.generateMipmaps = !1;
        q = c(f.GroundDepthShader);
        q.side = THREE.DoubleSide;
        q.blending = THREE.NoBlending;
        t = new f.LmvShaderPass(f.GroundShadowBlurShader,"tDepth");
        w = new f.LmvShaderPass(f.GroundShadowBlurShader,"tDepth");
        C = new f.LmvShaderPass(f.GroundShadowAOShader,"tDepth");
        t.material.defines.KERNEL_SCALE = w.material.defines.KERNEL_SCALE = 
        (B.pixScale / B.texSize).toFixed(4);
        t.material.defines.KERNEL_RADIUS = w.material.defines.KERNEL_RADIUS = B.blurRadius.toFixed(2);
        C.material.blending = t.material.blending = w.material.blending = THREE.NoBlending;
        C.material.depthWrite = t.material.depthWrite = w.material.depthWrite = !1;
        C.material.depthTest = t.material.depthTest = w.material.depthTest = !1;
        t.material.defines.HORIZONTAL = 1;
        r = c(f.GroundShadowColorShader);
        r.uniforms.tDepth.value = n;
        r.depthWrite = !1;
        r.transparent = !0;
        l = new THREE.BufferGeometry;
        l.addAttribute("position", 
        new THREE.BufferAttribute(new Float32Array([-.5, -.5, .5, -.5, .5, .5, .5, .5, .5, .5, -.5, .5]),3));
        l.addAttribute("uv", new THREE.BufferAttribute(new Float32Array([0, 0, 0, 1, 1, 1, 1, 0]),2));
        l.addAttribute("index", new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 3, 0]),1));
        h = new THREE.Mesh(l,r);
        b.add(h);
        B.debug && (E = new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshBasicMaterial({
            color: 65280,
            wireframe: !0
        })),
        b.add(E));
        this.setTransform(new THREE.Vector3(0,0,0), new THREE.Vector3(1,1,1), new THREE.Vector3(0,
        1,0))
    }
    ;
    h.prototype.constructor = h;
    f.GroundShadow = h
}
)();
function init_GroundReflectionShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.GroundReflectionCompShader && (f.GroundReflectionCompShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            tBackground: {
                type: "t",
                value: null 
            },
            uColor: {
                type: "v4",
                value: new THREE.Vector4(1,1,1,1)
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D tDiffuse;\nuniform sampler2D tBackground;\nuniform vec4 uColor;\nvarying vec2 vUv;\nvoid main() {\nvec4 bgCol = texture2D( tBackground, vUv );\nvec4 diffCol = uColor * texture2D( tDiffuse, vUv );\ngl_FragColor = mix(bgCol, diffCol, diffCol.a);\n}"
    },
    f.GroundReflectionDrawShader = 
    {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\ngl_FragColor = texel;\n}"
    })
}
(function() {
    var f = Teratek.Viewing.Shaders
      , h = function(g, d, c, a) {
        init_GroundReflectionShader();
        var b = g.getContext(), h = d || 512, l = c || 512, n, m, q, r, t, w = !1, C = new THREE.Color(0,0,0), E, G = !1, B = !1;
        this.outTarget = this.inTarget = void 0;
        var v = {
            color: new THREE.Color(1,1,1),
            alpha: .3,
            texScale: .5,
            blurRadius: 2,
            blurTexScale: .5,
            fadeAngle: Math.PI / 18
        };
        this.setTransform = function(a, b, c) {
            r = a;
            q.normal = b;
            q.constant = -a.dot(b)
        }
        ;
        this.cleanup = function() {
            n && n.cleanup();
            this.inTarget && this.inTarget.dispose();
            this.outTarget && this.outTarget.dispose()
        }
        ;
        this.setSize = function(a, b) {
            h = a;
            l = b;
            this.cleanup();
            this.inTarget = new THREE.WebGLRenderTarget(h * v.texScale,l * v.texScale,{
                magFilter: THREE.LinearFilter,
                minFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: !1
            });
            this.inTarget.generateMipmaps = !1;
            this.outTarget = new THREE.WebGLRenderTarget(h * v.texScale,l * v.texScale,{
                magFilter: THREE.LinearFilter,
                minFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: !1
            });
            this.outTarget.generateMipmaps = !1;
            n ? n.setSize(h * v.texScale * v.blurTexScale, l * v.texScale * 
            v.blurTexScale) : n = new f.GaussianPass(h * v.texScale * v.blurTexScale,l * v.texScale * v.blurTexScale,v.blurRadius,1,{
                hasAlpha: !0,
                blending: !0,
                flipUV: !0
            })
        }
        ;
        this.updateCamera = function(a) {
            var b = a.position.clone().sub(r).normalize()
              , b = Math.PI / 2 - b.angleTo(q.normal);
            w = 0 > b;
            if (!w) {
                0 < v.fadeAngle && (b = Math.min(v.fadeAngle, b) / v.fadeAngle,
                n.setAlpha(b * v.alpha));
                var b = q.normal
                  , c = q.constant
                  , b = (new THREE.Matrix4).set(1 - 2 * b.x * b.x, -2 * b.y * b.x, -2 * b.x * b.z, -2 * c * b.x, -2 * b.x * b.y, 1 - 2 * b.y * b.y, -2 * b.y * b.z, -2 * c * b.y, -2 * b.x * b.z, -2 * b.y * b.z, 
                1 - 2 * b.z * b.z, -2 * c * b.z, 0, 0, 0, 1);
                t = a.clone();
                t.applyMatrix(b);
                t.projectionMatrix.elements[5] *= -1;
                t.matrixWorldNeedsUpdate = !0;
                t.worldUpTransform = a.worldUpTransform ? a.worldUpTransform.clone() : new THREE.Matrix4
            }
        }
        ;
        this.renderIntoReflection = function(a) {
            w || g.render(a, t, this.inTarget)
        }
        ;
        this.renderReflection = function(a, c) {
            w || (b.depthRange(.9999, 1),
            m.render(g, c, this.outTarget),
            b.depthRange(0, 1))
        }
        ;
        this.toggleEnvMapBackground = function(a) {
            B = a;
            E.uniforms.envMapBackground.value = a
        }
        ;
        this.postprocess = function(a) {
            w || 
            (G || B ? (E.uniforms.uCamDir.value = a.getWorldDirection(),
            E.uniforms.uCamUp.value = a.up,
            E.uniforms.uResolution.value.set(h, l),
            E.render(g, this.outTarget),
            g.clearTarget(this.outTarget, !1, !0, !1)) : (g.setClearColor(C, 1),
            g.clearTarget(this.outTarget, !0, !0, !1)),
            n.render(g, this.outTarget, this.inTarget))
        }
        ;
        this.clear = function() {
            g.setClearColor(C, 0);
            g.clearTarget(this.inTarget, !0, !0, !1)
        }
        ;
        this.setClearColors = function(a, b) {
            b ? (C.setRGB(.5 * (a.x + b.x), .5 * (a.y + b.y), .5 * (a.z + b.z)),
            G = !a.equals(b) && !isAndroidDevice() && !isIOSDevice()) : 
            (C.copy(a),
            G = !1);
            G && (E.uniforms.color1.value.copy(a),
            E.uniforms.color2.value.copy(b))
        }
        ;
        this.isGroundCulled = function() {
            return w
        }
        ;
        this.setColor = function(a) {
            n.setColor(v.color);
            v.color.set(a)
        }
        ;
        this.setAlpha = function(a) {
            n.setAlpha(v.alpha);
            v.alpha = a
        }
        ;
        if (a)
            for (var D in v)
                v[D] = void 0 !== a[D] ? a[D] : v[D];
        m = new f.LmvShaderPass(f.GroundReflectionDrawShader);
        m.material.blending = THREE.NoBlending;
        m.material.depthTest = !0;
        m.material.depthWrite = !1;
        E = new f.LmvShaderPass(f.BackgroundShader);
        E.material.blending = THREE.NoBlending;
        E.material.depthWrite = !1;
        E.material.depthTest = !1;
        this.setSize(h, l);
        n.setAlpha(v.color);
        n.setAlpha(v.alpha);
        q = new THREE.Plane(new THREE.Vector3(0,1,0),0);
        r = new THREE.Vector3(0,0,0)
    }
    ;
    h.prototype.constructor = h;
    f.GroundReflection = h
}
)();
function init_GaussianShader() {
    var f = Teratek.Viewing.Shaders;
    "undefined" === typeof f.GaussianShader && (f.GaussianShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            uColor: {
                type: "v4",
                value: new THREE.Vector4(1,1,1,1)
            }
        },
        vertexShader: "varying vec2 vUv;\nvoid main() {\n#if defined(HORIZONTAL) && defined(FLIP_UV)\n    vUv = vec2(uv.x, 1.0-uv.y);\n#else\n    vUv = vec2(uv.x, uv.y);\n#endif\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
        fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec4 uColor;\nvarying vec2 vUv;\n#ifdef HORIZONTAL\n    #define GET_UV(X) vec2(vUv.x + KERNEL_SCALE_H*(X), vUv.y)\n#else\n    #define GET_UV(Y) vec2(vUv.x, vUv.y + KERNEL_SCALE_V*(Y))\n#endif\n#define PI 3.14159265358979\n#define SIGMA ((KERNEL_RADIUS+KERNEL_RADIUS+1.0) / 6.0)\n#define SIGMASQ2 (2.0 * SIGMA * SIGMA)\n#define GAUSSIAN(X) ( (1.0 / sqrt(PI * SIGMASQ2)) * exp(-(X)*(X)/SIGMASQ2) )\nvoid main() {\n    vec4 texColSum = vec4(0.0);\n    float gaussSum = 0.0;\n    for (float x=-KERNEL_RADIUS; x<=KERNEL_RADIUS; x+=1.0) {\n        float gauss = GAUSSIAN(x);\n        vec4 texCol = texture2D(tDiffuse, GET_UV(x));\n        #ifdef HAS_ALPHA\n            texCol.rgb *= texCol.a;\n        #endif\n        texColSum += texCol * gauss;\n        gaussSum += gauss;\n    }\n    #ifdef HAS_ALPHA\n        texColSum.rgb /= texColSum.a;\n    #endif\n#ifdef HORIZONTAL\n    gl_FragColor = texColSum/gaussSum;\n#else\n    gl_FragColor = texColSum/gaussSum * uColor;\n#endif\n}"
    })
}
(function() {
    var f = Teratek.Viewing.Shaders;
    f.GaussianPass = function(h, g, d, c, a) {
        init_GaussianShader();
        var b = h
          , k = g;
        d = d || 3;
        var l = c || 1, n, m, q;
        c = a.hasAlpha || !1;
        var r = a.blending || !1;
        a = a.flipUV || !1;
        this.render = function(a, b, c) {
            n.render(a, q, c);
            m.render(a, b, q)
        }
        ;
        this.setSize = function(a, c) {
            this.cleanup();
            b = a;
            k = c;
            q = new THREE.WebGLRenderTarget(a,c,{
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: !1
            });
            q.generateMipmaps = !1;
            n.material.defines.KERNEL_SCALE_H = m.material.defines.KERNEL_SCALE_H = 
            (l / b).toFixed(4);
            n.material.defines.KERNEL_SCALE_V = m.material.defines.KERNEL_SCALE_V = (l / k).toFixed(4);
            n.material.needsUpdate = m.material.needsUpdate = !0
        }
        ;
        this.cleanup = function() {
            q && q.dispose()
        }
        ;
        this.setColor = function(a) {
            m.material.uniforms.uColor.value.x = a.r;
            m.material.uniforms.uColor.value.y = a.g;
            m.material.uniforms.uColor.value.z = a.b
        }
        ;
        this.setAlpha = function(a) {
            m.material.uniforms.uColor.value.w = a
        }
        ;
        n = new f.LmvShaderPass(f.GaussianShader);
        m = new f.LmvShaderPass(f.GaussianShader);
        this.setSize(h, g);
        n.material.blending = 
        m.material.blending = THREE.NoBlending;
        n.material.depthWrite = m.material.depthWrite = !1;
        n.material.depthTest = m.material.depthTest = !1;
        n.material.defines.HORIZONTAL = 1;
        n.material.defines.KERNEL_RADIUS = m.material.defines.KERNEL_RADIUS = d.toFixed(1);
        r && (m.material.transparent = !0,
        m.material.blending = THREE.NormalBlending);
        c && (n.material.defines.HAS_ALPHA = m.material.defines.HAS_ALPHA = "");
        a && (n.material.defines.FLIP_UV = "")
    }
}
)();
(function() {
    function f(a, b) {
        function c(a, b, d, f, g, h, k) {
            a = .5 * (d - a);
            f = .5 * (f - b);
            return (2 * (b - d) + a + f) * k + (-3 * (b - d) - 2 * a - f) * h + a * g + b
        }
        var d = [], f = [], g, h, k, l, B, v;
        g = (a.length - 1) * b;
        h = Math.floor(g);
        g -= h;
        d[0] = 0 === h ? h : h - 1;
        d[1] = h;
        d[2] = h > a.length - 2 ? h : h + 1;
        d[3] = h > a.length - 3 ? h : h + 2;
        h = a[d[0]];
        l = a[d[1]];
        B = a[d[2]];
        v = a[d[3]];
        d = g * g;
        k = g * d;
        f[0] = c(h[0], l[0], B[0], v[0], g, d, k);
        f[1] = c(h[1], l[1], B[1], v[1], g, d, k);
        f[2] = c(h[2], l[2], B[2], v[2], g, d, k);
        return f
    }
    var h = Teratek.Viewing.Private
      , g = function() {
        this.animations = []
    }
    ;
    g.prototype.init = 
    function(a) {
        if (!0 === a.initialized)
            return a;
        for (var b = 0; b < a.hierarchy.length; b++) {
            for (var c = 0; c < a.hierarchy[b].keys.length; c++)
                if (0 > a.hierarchy[b].keys[c].time && (a.hierarchy[b].keys[c].time = 0),
                void 0 !== a.hierarchy[b].keys[c].rot && !(a.hierarchy[b].keys[c].rot instanceof THREE.Quaternion)) {
                    var d = a.hierarchy[b].keys[c].rot;
                    Array.isArray(d) || (d = [d._x, d._y, d._z, d._w]);
                    a.hierarchy[b].keys[c].rot = (new THREE.Quaternion).fromArray(d)
                }
            for (c = 1; c < a.hierarchy[b].keys.length; c++)
                a.hierarchy[b].keys[c].time === a.hierarchy[b].keys[c - 
                1].time && (a.hierarchy[b].keys.splice(c, 1),
                c--);
            for (c = 0; c < a.hierarchy[b].keys.length; c++)
                a.hierarchy[b].keys[c].index = c
        }
        a.initialized = !0;
        return a
    }
    ;
    g.prototype.parse = function(a) {
        function b(a, c) {
            c.push(a);
            if (a.children && !(a instanceof THREE.Camera))
                for (var d = 0; d < a.children.length; d++)
                    b(a.children[d], c)
        }
        var c = [];
        b(a, c);
        return c
    }
    ;
    g.prototype.play = function(a) {
        -1 === this.animations.indexOf(a) && this.animations.push(a)
    }
    ;
    g.prototype.stop = function(a) {
        a = this.animations.indexOf(a);
        -1 !== a && this.animations.splice(a, 
        1)
    }
    ;
    g.prototype.update = function(a) {
        for (var b = 0; b < this.animations.length; b++)
            this.animations[b].update(a)
    }
    ;
    var d = function(a, b, c) {
        this.root = a;
        this.handler = c.animationHandler;
        this.data = this.handler.init(b);
        this.hierarchy = this.handler.parse(a);
        this.viewer = c.viewer;
        this.animator = c;
        this.currentTime = 0;
        this.timeScale = 1;
        this.isPlaying = !1;
        this.isPaused = !0;
        this.loop = !1;
        this.delta = .5;
        this.interpolationType = 0;
        this.setStartAndEndKeyTime()
    }
    ;
    d.prototype.setStartAndEndKeyTime = function() {
        if (0 < this.data.hierarchy.length) {
            var a = 
            this.data.hierarchy[0].keys;
            this.startKeyTime = a[0].time;
            this.endKeyTime = a[a.length - 1].time
        } else
            this.startKeyTime = this.endKeyTime = 0
    }
    ;
    d.prototype.keyTypes = [];
    d.prototype.defaultKey = {};
    d.prototype.play = function(a) {
        this.currentTime = void 0 !== a ? a : 0;
        this.isPlaying = !0;
        this.isPaused = !1;
        this.reset();
        this.handler.play(this)
    }
    ;
    d.prototype.pause = function() {
        !0 === this.isPaused ? this.handler.play(this) : this.handler.stop(this);
        this.isPaused = !this.isPaused
    }
    ;
    d.prototype.stop = function() {
        this.isPaused = this.isPlaying = !1;
        this.handler.stop(this)
    }
    ;
    d.prototype.goto = function(a) {
        this.isPlaying || this.play();
        this.isPaused || this.pause();
        this.update(a - this.currentTime)
    }
    ;
    d.prototype.reset = function() {
        for (var a = 0, b = this.hierarchy.length; a < b; a++) {
            var c = this.hierarchy[a];
            void 0 === c.animationCache && (c.animationCache = {});
            void 0 === c.animationCache[this.data.name] && (c.animationCache[this.data.name] = {
                prevKey: this.defaultKey,
                nextKey: this.defaultKey,
                originalMatrix: c.matrix
            });
            for (var c = c.animationCache[this.data.name], d = 0; d < this.keyTypes.length; d++) {
                for (var f = 
                this.keyTypes[d], g = this.data.hierarchy[a].keys[0], h = this.getNextKeyWith(f, a, 1); h.time < this.currentTime && h.index > g.index; )
                    g = h,
                    h = this.getNextKeyWith(f, a, h.index + 1);
                c.prevKey[f] = g;
                c.nextKey[f] = h
            }
        }
        this.setStartAndEndKeyTime()
    }
    ;
    d.prototype.getNextKeyWith = function(a, b, c) {
        var d = this.data.hierarchy[b].keys;
        for (c = 1 === this.interpolationType || 2 === this.interpolationType ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++)
            if (void 0 !== d[c][a])
                return d[c];
        return this.data.hierarchy[b].keys[0]
    }
    ;
    d.prototype.getPrevKeyWith = 
    function(a, b, c) {
        var d = this.data.hierarchy[b].keys;
        for (c = 1 === this.interpolationType || 2 === this.interpolationType ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--)
            if (void 0 !== d[c][a])
                return d[c];
        return this.data.hierarchy[b].keys[d.length - 1]
    }
    ;
    d.prototype.isPlayingOutOfRange = function() {
        return !1 === this.isPaused && (this.currentTime < this.startKeyTime - this.delta || this.currentTime > this.endKeyTime + this.delta)
    }
    ;
    d.prototype.resetIfLooped = function() {
        !0 === this.loop && this.currentTime > this.endKeyTime && (this.currentTime %= this.endKeyTime,
        this.reset())
    }
    ;
    var c = function(a, b, c) {
        d.call(this, a, b, c);
        this.localMatrix = new THREE.Matrix4;
        this.root.getAnimTransform();
        this.relativeTransform = b.custom && b.custom.transform && "abs" === b.custom.transform ? !1 : !0
    }
    ;
    c.prototype = Object.create(d.prototype);
    c.prototype.constructor = c;
    c.prototype.keyTypes = ["pos", "rot", "scl"];
    c.prototype.defaultKey = {
        pos: 0,
        rot: 0,
        scl: 0
    };
    c.prototype.update = function() {
        var a = [], b, c, d;
        return function(g) {
            if (!1 !== this.isPlaying && (this.currentTime += g * this.timeScale,
            b || (b = new THREE.Vector3,
            c = new THREE.Vector3,
            d = new THREE.Quaternion),
            this.resetIfLooped(),
            !this.isPlayingOutOfRange())) {
                g = 0;
                for (var h = this.hierarchy.length; g < h; g++) {
                    for (var k = this.hierarchy[g], l = k.animationCache[this.data.name], G = 0; G < this.keyTypes.length; G++) {
                        var B = this.keyTypes[G]
                          , v = l.prevKey[B]
                          , D = l.nextKey[B];
                        if (D.time <= this.currentTime || v.time >= this.currentTime) {
                            v = this.data.hierarchy[g].keys[0];
                            for (D = this.getNextKeyWith(B, g, 1); D.time < this.currentTime && D.index > v.index; )
                                v = D,
                                D = this.getNextKeyWith(B, g, D.index + 1);
                            l.prevKey[B] = 
                            v;
                            l.nextKey[B] = D
                        }
                        var z = v[B]
                          , H = D[B];
                        if (D.time !== v.time && void 0 !== z && void 0 !== H) {
                            var I = (this.currentTime - v.time) / (D.time - v.time);
                            0 > I && (I = 0);
                            1 < I && (I = 1);
                            "pos" === B ? 0 === this.interpolationType ? (c.x = z[0] + (H[0] - z[0]) * I,
                            c.y = z[1] + (H[1] - z[1]) * I,
                            c.z = z[2] + (H[2] - z[2]) * I,
                            k.position.copy(c)) : (a[0] = this.getPrevKeyWith("pos", g, v.index - 1).pos,
                            a[1] = z,
                            a[2] = H,
                            a[3] = this.getNextKeyWith("pos", g, D.index + 1).pos,
                            I = .33 * I + .33,
                            B = f(a, I),
                            c.x = B[0],
                            c.y = B[1],
                            c.z = B[2],
                            k.position.copy(c),
                            2 === this.interpolationType && (I = f(a, 1.01 * I),
                            b.set(I[0], 
                            I[1], I[2]),
                            b.sub(vector),
                            b.y = 0,
                            b.normalize(),
                            I = Math.atan2(b.x, b.z),
                            k.rotation.set(0, I, 0))) : "rot" === B ? (THREE.Quaternion.slerp(z, H, d, I),
                            k.quaternion.copy(d)) : "scl" === B && (c.x = z[0] + (H[0] - z[0]) * I,
                            c.y = z[1] + (H[1] - z[1]) * I,
                            c.z = z[2] + (H[2] - z[2]) * I,
                            k.scale.copy(c))
                        }
                    }
                    this.relativeTransform && k.updateAnimTransform()
                }
            }
        }
    }
    ();
    var a = function(a, b, c) {
        d.call(this, a, b, c)
    }
    ;
    a.prototype = Object.create(d.prototype);
    a.prototype.constructor = a;
    a.prototype.keyTypes = ["pos", "up", "target", "fov", "perspective"];
    a.prototype.defaultKey = 
    {
        pos: 0,
        up: 0,
        target: 0,
        fov: 0,
        perspective: 0
    };
    a.prototype.update = function() {
        var a = [], b, c;
        return function(d) {
            if (!1 !== this.isPlaying && (this.currentTime += d * this.timeScale,
            b || (b = new THREE.Vector3,
            c = new THREE.Vector3),
            this.resetIfLooped(),
            !this.isPlayingOutOfRange())) {
                d = 0;
                for (var g = this.hierarchy.length; d < g; d++) {
                    for (var h = this.hierarchy[d], k = h.animationCache[this.data.name], l = 0; l < this.keyTypes.length; l++) {
                        var G = this.keyTypes[l]
                          , B = k.prevKey[G]
                          , v = k.nextKey[G];
                        if (v.time <= this.currentTime || B.time >= this.currentTime) {
                            B = 
                            this.data.hierarchy[d].keys[0];
                            for (v = this.getNextKeyWith(G, d, 1); v.time < this.currentTime && v.index > B.index; )
                                B = v,
                                v = this.getNextKeyWith(G, d, v.index + 1);
                            k.prevKey[G] = B;
                            k.nextKey[G] = v
                        }
                        var D = B[G]
                          , z = v[G];
                        if (v.time !== B.time && void 0 !== D && void 0 !== z) {
                            var H = (this.currentTime - B.time) / (v.time - B.time);
                            0 > H && (H = 0);
                            1 < H && (H = 1);
                            var I;
                            if ("pos" === G)
                                I = h.position;
                            else if ("up" === G)
                                I = h.up;
                            else if ("target" === G)
                                I = h.target;
                            else if ("fov" === G) {
                                h.setFov(D + (z - D) * H);
                                continue
                            } else if ("perspective" === G) {
                                (.5 < H ? z : D) ? h.toPerspective() : 
                                h.toOrthographic();
                                continue
                            }
                            0 === this.interpolationType ? (c.x = D[0] + (z[0] - D[0]) * H,
                            c.y = D[1] + (z[1] - D[1]) * H,
                            c.z = D[2] + (z[2] - D[2]) * H,
                            I.copy(c)) : (a[0] = this.getPrevKeyWith(G, d, B.index - 1)[G],
                            a[1] = D,
                            a[2] = z,
                            a[3] = this.getNextKeyWith(G, d, v.index + 1)[G],
                            H = .33 * H + .33,
                            G = f(a, H),
                            c.x = G[0],
                            c.y = G[1],
                            c.z = G[2],
                            I.copy(c),
                            2 === this.interpolationType && (H = f(a, 1.01 * H),
                            b.set(H[0], H[1], H[2]),
                            b.sub(I),
                            b.y = 0,
                            b.normalize(),
                            H = Math.atan2(b.x, b.z),
                            h.rotation.set(0, H, 0)))
                        }
                    }
                    h.matrixAutoUpdate = !0;
                    h.matrixWorldNeedsUpdate = !0
                }
                h.lookAt(h.target);
                this.animator.updateFlag |= this.animator.UPDATE_CAMERA
            }
        }
    }
    ();
    var b = function(a, b, c, f) {
        d.call(this, a, b, f);
        this.nodeId = c;
        this.epsilon = .1;
        this.root.setMaterial(this.viewer.matman().cloneMaterial(a.getMaterial()))
    }
    ;
    b.prototype = Object.create(d.prototype);
    b.prototype.constructor = b;
    b.prototype.keyTypes = ["vis", "opa"];
    b.prototype.defaultKey = {
        viz: 1,
        opa: 1
    };
    b.prototype.update = function() {
        return function(a) {
            if (!1 !== this.isPlaying && (this.currentTime += a * this.timeScale,
            this.resetIfLooped(),
            !this.isPlayingOutOfRange())) {
                a = 
                0;
                for (var b = this.hierarchy.length; a < b; a++)
                    for (var c = this.hierarchy[a], d = c.animationCache[this.data.name], f = 0; f < this.keyTypes.length; f++) {
                        var g = this.keyTypes[f]
                          , h = d.prevKey[g]
                          , k = d.nextKey[g];
                        if (k.time <= this.currentTime || h.time >= this.currentTime) {
                            h = this.data.hierarchy[a].keys[0];
                            for (k = this.getNextKeyWith(g, a, 1); k.time < this.currentTime && k.index > h.index; )
                                h = k,
                                k = this.getNextKeyWith(g, a, k.index + 1);
                            d.prevKey[g] = h;
                            d.nextKey[g] = k
                        }
                        var l = h[g]
                          , B = k[g];
                        if (k.time !== h.time && void 0 !== l && void 0 !== B) {
                            var v = c.getMaterial();
                            "vis" === g ? (h = (g = Math.abs(this.currentTime - k.time) < this.epsilon) ? k : h,
                            l = g ? B : l,
                            1 === l && void 0 === h.opa && (v.transparent = !1,
                            v.opacity = 1),
                            this.viewer.visibilityManager.setNodeOff(this.nodeId, !l)) : "opa" === g && (h = (this.currentTime - h.time) / (k.time - h.time),
                            0 > h && (h = 0),
                            1 < h && (h = 1),
                            l += (B - l) * h,
                            v.transparent = 1 !== l,
                            v.opacity = l,
                            0 < l && this.viewer.visibilityManager.setNodeOff(this.nodeId, !1))
                        }
                    }
            }
        }
    }
    ();
    var k = function(a, b, c) {
        function f(a, b, c) {
            var d = g.container = document.createElement("div")
              , h = a.name;
            d.id = h;
            d.style.cursor = "pointer";
            d.style.visibility = c;
            var k = document.createElement("div");
            k.id = h + "-txt";
            k.style.cssText = "display: none;position: absolute;z-index: 1;";
            d.appendChild(k);
            c = document.createElement("img");
            c.src = a.custom && a.custom.att && 1 === a.custom.att ? "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAABv1BMVEUAAAAAAAAAAAAAAAABAwEAAAAAAAAjSRkAAAAFDASJqnZhg1IqTyAjSRkpTx8hRxggRRcAAAAhRRcKFwgAAACau4R9mnFmiFUhSBgbOhMZNhIAAAAECQMgQxcAAAAAAAAAAAAHDwXB2q2jw4yfvoivyJ6fuI6mv5eSr4KAoWu2trZpiV3Nzc0wVSUhRxhNT01vb28AAAAgRBcAAAAAAAAAAAAhRxgeQBYAAAAAAAAAAAAfQRbP5MC0zqCqyJKpyJJBYje3z6WxyKOFpXF9nmkrTiG+wb5xkGVcf0xYfEg1WSpNTU0hRhgfQhYfQhZVVVVAQEAXMREcOhQcHBwSJw0AAAAAAAAWLxAVLQ8AAAAAAAAfQhYIEgYAAACbvn+DsGCGsmSUunaItGXc6dStypelxY2ZvX2Ntm2JtGnS48fB17G40aWNuWucxH6ny4mUvnPF27aPuHCEsGHV5czI3Lq52KGvzJqz1JmqyJOqzY6ew4OYwHiGs2OEsWHb29vL4LvM5bnD3q2+3KWkyoaLtWuKtmfOzs7IyMi21pyawXqPuG/g4ODX68fI4rTG4LCu0ZKszJKlx4qZwHuBnXR2iXENcZskAAAAXnRSTlMAEAIBCAsF6BUn+vPu7erjsZyBEwP99/TRk3JgRUQ1IxwO/v79/Pv6+fn09PPq08q7sqWDe2xrY01AMBj+/v7+/v37+fn59fXz8u/c1cbFxLWonZiIcm1lYVdSQT8de/EoFwAAAgVJREFUOMutklVz21AQRiNFlswYs+M6DTdN0kCDZWZmuAKDZFtgiO2YYm6TlOEHV53ptGs5j93Xc+a7e3d36P/W9prdZ/PZ17aPxphz3mR0x91G07wTG8TDo5R3HLGH3S6fGPdSo8Na/to6W2HZBEqwPCNULlu1BkFdQSyKx4qxOMoyDDJSRB/HnTcqWbSbTmVS6V3E57hvXicOBZd1gmfj6Z1kPrmTjrMMfRizumDA+k3UTcRSyWg0mkzFEgLNlU3rIIJcns0KqJjJq0I+U0SqUJlZJv8JugU3J/QnHEwu6MCMqPN1pq+H3sFxCgOC7RyT48Ev6qLUL/gmeJrJ/p0DzSnyxTtAGLMbv9dohv8zSbomSqUpOxB0AdNXsUbnGEEQmJzKq3JrLgCaJAzms5LI1enfVefEamc/YzYQYFB6/1xBUsQex3E9UZHkUvO6X48PwQjLTKEjVRVFqUqd8v6naQsMUCNcL8xTrVJZluXyl1K7OW1+7sL71x15cvVH43O7UGi3mmc8lkCE0ByMbvXazwueycbHxiXPrUdv3hLDGiF8au/d4sO7Novtnj9k0BO45uRGTp98f2JlK/RqYzN8TK8bGTjZLTXgfvDp6rMNA0ZADAOWHI6VTYwE4WAZjz/s3V5yvIxADosIPlh0BNXHSdA8LFIfDgE8WDg5hmmx9h/40fgXth2SDk3yjP4AAAAASUVORK5CYII=" : 
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAABvFBMVEUAAAAAAAADAAAAAAAAAAACAAAAAAAAAAC5PznHVE8BAAAAAADbc27NXVeUDQaZDQaRBwAAAAAAAACHBgDuhoHVa2W9RD2QCAKYCAGPBgB0BQAAAAAAAACMBgAAAAADAAD2jonWb2n2jYjYbWfmeXPNzc3RYFqzODKfFA1RUVGKBgCVBwBvb2+WBwCBBgCFBgCWBwCLBgAAAAAAAACMBgCTBwByBQCTBwBbBACEBgAAAAAAAAAoAgBSBADgeHOoOzXmfnnofnjieHPGvr63t7e0tLTidW/ebmnba2XWZWDAT0qRHBfBSkRNTU2aFxGOBgBYTEsAAACNBgBAQEAAAABbBQAcHBxyBQBKBAAAAABfBAAAAAAAAAAsAgAkAgCJBgDZRT3MOTHQPDTVQjrlUkrjUEjRPjbOOjP/bGTvXFTqV0/fTETNOjL5Zl7eS0PzYFjxXlbiT0fUQTn0e3T7aGDWXFXbSEDTRj/PQTrOPjbb29vgamTxY1zoVE3STETTQjvSPzfOzs7IyMj5g3zzaWLXY13XYVrsXlbbU0zg4OD8lZD4gXq0eHXqd3HscWv2b2jrZmDQZWDdWVLkV1C5y9+5AAAAYHRSTlMAAgUBDggMEeDsIBj+8NHJxpxAEP754tDDtIFsYDkvI/78+/j08/DfycfHxbuvr5mTjYN0bWxkWVZTTDUjEfz8+/n59fT08vHw8PDw5NzV0Mq5uLWrm5iLfX1hV0g/ODZEwKduAAACAklEQVQ4y62SVXPbQBzEa1mWZYaY49ihBhtmKjMzw92JLLBsyxxT2mCZvnCVmU59VpO37Ms97G929nb+p05WXUvTE5GJ6aWuY+yFEdoVdAZd9MjCEYi5J0L3FZutSqVZdIYiPWaj/85j2yszAACGVyq7Lo+RIMZtxRaQOZaTwZZSLbrGLR2+aX54twVykpgVpRzgYbVGz5twYMPTV2ZkKZMupDOSzAiwfNazgQesDO9VASemU6lUWuQAgnyNXsEiiBlbEwE2W9CBQpbVAfRraIZoA5ZosII6EpB6MYrVpLxOQejowKsBL9UGSK+zCnnsF4omB7wkBkQHylDZ+rcDROD3hYcYQE0NHQhQ4f8uCQVG/XF9isJKLtI1TYBQQAgdPlqJzYcWMYBYd58/YJACD6UgpsTVA+51AhvKGgt9zQGN1xN4Dajs/vbtmBXf2mIP3/jGqiW9Q0nlGtn8tXBSnwGPWHYP5PcbLMs2JHFn+6p7WQ/ARTie3/rZm9+pZ+rfP/fawi8dhOFgqLlLX87dHOz/1D9ou/vsrcNiNgBrZzbf338yOXZvbDL2xm4ljCdn6j794cpswr/62p+wWy2m/042oQeMxudedK8mSdzGAy4/9vlm/STRtjGRTz9u3nnge2U3+O2h4o9GfXG7lcLKGWZY8ycduG3sQJCk0Tb+w3S0/Qemc4+eJchuZgAAAABJRU5ErkJggg==";
            c.id = h + "-img";
            c.style.cssText = "display: block;position: absolute;z-index: 1;";
            d.appendChild(c);
            b.api.container.appendChild(d);
            d.addEventListener("click", function() {
                k.style.display = "none" === k.style.display ? "block" : "none"
            }
            );
            a = new THREE.SphereGeometry(.01);
            d = new THREE.MeshPhongMaterial({
                color: 32512,
                ambient: 32512,
                opacity: .6,
                transparent: !0
            });
            a = new THREE.Mesh(a,d);
            a.visible = !1;
            void 0 === b.overlayScenes.annotation && b.createOverlayScene("annotation");
            b.addOverlay("annotation", a);
            return a
        }
        var g = this;
        null  === 
        a && (a = f(b, c.viewer, "hidden"));
        d.call(this, a, b, c);
        this.id = b.name;
        this.text = "";
        this.state = "hidden";
        this.epsilon = .1;
        this.viewer.api.addEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, function(b) {
            g.updateText(a.position, g.text)
        }
        )
    }
    ;
    k.prototype = Object.create(d.prototype);
    k.prototype.constructor = k;
    k.prototype.keyTypes = ["pos", "text", "vis"];
    k.prototype.defaultKey = {
        pos: 0,
        text: "",
        vis: 1
    };
    k.prototype.stop = function() {
        d.prototype.stop.call(this);
        this.container.parentNode.removeChild(this.container);
        this.viewer.removeOverlay("annotation", 
        this.root);
        this.root = null 
    }
    ;
    k.prototype.updateText = function(a, b) {
        var c;
        c = this.viewer.camera;
        var d = this.viewer.canvas
          , f = a.clone()
          , g = new THREE.Matrix4;
        c.updateMatrixWorld();
        c.matrixWorldInverse.getInverse(c.matrixWorld);
        g.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse);
        f.applyProjection(g);
        c = {
            x: (f.x + 1) * d.width / 2 + d.offsetLeft,
            y: (-f.y + 1) * d.height / 2 + d.offsetTop
        };
        if (d = document.getElementById(this.id + "-txt"))
            d.innerHTML = b,
            d.style.left = c.x + "px",
            d.style.top = c.y + "px",
            this.text = b;
        if (d = document.getElementById(this.id + 
        "-img"))
            d.style.left = c.x + "px",
            d.style.top = c.y - 24 + "px"
    }
    ;
    k.prototype.update = function() {
        var a = [], b, c;
        return function(d) {
            if (!1 !== this.isPlaying && (this.currentTime += d * this.timeScale,
            b || (b = new THREE.Vector3,
            c = new THREE.Vector3),
            this.resetIfLooped(),
            !this.isPlayingOutOfRange()))
                if (this.isPaused && this.currentTime < this.startKeyTime) {
                    var g = document.getElementById(this.id);
                    g && (g.style.visibility = this.state)
                } else {
                    d = 0;
                    for (var h = this.hierarchy.length; d < h; d++) {
                        for (var k = this.hierarchy[d], l = k.animationCache[this.data.name], 
                        G = 0; G < this.keyTypes.length; G++) {
                            var B = this.keyTypes[G]
                              , v = l.prevKey[B]
                              , D = l.nextKey[B];
                            if (D.time <= this.currentTime || v.time >= this.currentTime) {
                                v = this.data.hierarchy[d].keys[0];
                                for (D = this.getNextKeyWith(B, d, 1); D.time < this.currentTime && D.index > v.index; )
                                    v = D,
                                    D = this.getNextKeyWith(B, d, D.index + 1);
                                l.prevKey[B] = v;
                                l.nextKey[B] = D
                            }
                            var z = v[B]
                              , H = D[B];
                            if (D.time !== v.time && void 0 !== z && void 0 !== H)
                                if (g = (this.currentTime - v.time) / (D.time - v.time),
                                0 > g && (g = 0),
                                1 < g && (g = 1),
                                "pos" === B)
                                    if (0 === this.interpolationType)
                                        c.x = z[0] + (H[0] - 
                                        z[0]) * g,
                                        c.y = z[1] + (H[1] - z[1]) * g,
                                        c.z = z[2] + (H[2] - z[2]) * g,
                                        k.position.copy(c);
                                    else {
                                        if (1 === this.interpolationType || 2 === this.interpolationType)
                                            a[0] = this.getPrevKeyWith("pos", d, v.index - 1).pos,
                                            a[1] = z,
                                            a[2] = H,
                                            a[3] = this.getNextKeyWith("pos", d, D.index + 1).pos,
                                            g = .33 * g + .33,
                                            D = f(a, g),
                                            c.x = D[0],
                                            c.y = D[1],
                                            c.z = D[2],
                                            k.position.copy(c),
                                            2 === this.interpolationType && (D = f(a, 1.01 * g),
                                            b.set(D[0], D[1], D[2]),
                                            b.sub(vector),
                                            b.y = 0,
                                            b.normalize(),
                                            D = Math.atan2(b.x, b.z),
                                            k.rotation.set(0, D, 0))
                                    }
                                else
                                    "text" === B ? (D = Math.abs(this.currentTime - 
                                    D.time) < this.epsilon ? H : z,
                                    this.updateText(k.position, D)) : "vis" === B && (g = document.getElementById(this.id)) && (D = Math.abs(this.currentTime - D.time) < this.epsilon ? H : z,
                                    g.style.visibility = D ? "visible" : "hidden")
                        }
                        k.matrixAutoUpdate = !0;
                        k.matrixWorldNeedsUpdate = !0
                    }
                }
        }
    }
    ();
    var l = function(a, b, c) {
        this.viewer = c.viewer;
        null  === a && (a = this.createPolyline([]));
        d.call(this, a, b, c);
        this.epsilon = .1
    }
    ;
    l.prototype = Object.create(d.prototype);
    l.prototype.constructor = l;
    l.prototype.keyTypes = ["points", "vis"];
    l.prototype.defaultKey = {
        points: [],
        vis: 1
    };
    l.prototype.stop = function() {
        d.prototype.stop.call(this);
        this.viewer.removeOverlay("polyline", this.root);
        this.root = null 
    }
    ;
    l.prototype.update = function() {
        function a(b) {
            b.root && (b.viewer.removeOverlay("polyline", b.root),
            b.root = null )
        }
        return function(b) {
            if (!1 !== this.isPlaying && (this.currentTime += b * this.timeScale,
            this.resetIfLooped(),
            !this.isPlayingOutOfRange()))
                if (this.isPaused && this.currentTime < this.startKeyTime)
                    a(this);
                else {
                    b = 0;
                    for (var c = this.hierarchy.length; b < c; b++)
                        for (var d = this.hierarchy[b].animationCache[this.data.name], 
                        f = 0; f < this.keyTypes.length; f++) {
                            var g = this.keyTypes[f]
                              , h = d.prevKey[g]
                              , k = d.nextKey[g];
                            if (k.time <= this.currentTime || h.time >= this.currentTime) {
                                h = this.data.hierarchy[b].keys[0];
                                for (k = this.getNextKeyWith(g, b, 1); k.time < this.currentTime && k.index > h.index; )
                                    h = k,
                                    k = this.getNextKeyWith(g, b, k.index + 1);
                                d.prevKey[g] = h;
                                d.nextKey[g] = k
                            }
                            var l = h[g]
                              , B = k[g];
                            if (k.time !== h.time && void 0 !== l && void 0 !== B)
                                if (h = (this.currentTime - h.time) / (k.time - h.time),
                                0 > h && (h = 0),
                                1 < h && (h = 1),
                                "points" === g) {
                                    g = .5 > h ? l : B;
                                    this.viewer.removeOverlay("polyline", 
                                    this.root);
                                    this.root = null ;
                                    for (var k = [], v = 0; v < g.length; v++) {
                                        var D = g[v].slice();
                                        if (0 === v)
                                            D[0] = l[v][0] + (B[v][0] - l[v][0]) * h,
                                            D[1] = l[v][1] + (B[v][1] - l[v][1]) * h,
                                            D[2] = l[v][2] + (B[v][2] - l[v][2]) * h;
                                        else if (v === g.length - 1) {
                                            var z = l.length - 1
                                              , H = B.length - 1;
                                            D[0] = l[z][0] + (B[H][0] - l[z][0]) * h;
                                            D[1] = l[z][1] + (B[H][1] - l[z][1]) * h;
                                            D[2] = l[z][2] + (B[H][2] - l[z][2]) * h
                                        }
                                        D = new THREE.Vector3(D[0],D[1],D[2]);
                                        k.push(D)
                                    }
                                    this.root = this.createPolyline(k)
                                } else
                                    "vis" === g && (l = Math.abs(this.currentTime - k.time) < this.epsilon ? B : l,
                                    (this.root.visible = 
                                    l) || a(this))
                        }
                }
        }
    }
    ();
    l.prototype.createPolyline = function(a) {
        for (var b = new THREE.Geometry, c = 0; c < a.length; c++)
            b.vertices.push(a[c]);
        b.computeLineDistances();
        a = new THREE.LineDashedMaterial({
            color: 0,
            dashSize: 1,
            gapSize: .5,
            linewidth: 1
        });
        b = new THREE.Line(b,a,THREE.LineStrip);
        void 0 === this.viewer.overlayScenes.polyline && this.viewer.createOverlayScene("polyline");
        this.viewer.addOverlay("polyline", b);
        return b
    }
    ;
    h.Animation = d;
    h.AnimationHandler = g;
    h.MeshAnimation = c;
    h.CameraAnimation = a;
    h.PolylineAnimation = l;
    h.VisibilityAnimation = 
    b;
    h.AnnotationAnimation = k
}
)();
(function() {
    var f = Teratek.Viewing.Private
      , h = function(f, d) {
        this.animations = [];
        this.viewer = f;
        this.keys = [];
        this.isPlaying = !1;
        this.isPaused = !0;
        this.updateFlag = 0;
        this.duration = d;
        this.currentTime = 0;
        this.onPlayCallback = null ;
        this.animationHandler = new Teratek.Viewing.Private.AnimationHandler;
        this.areCameraAnimationsPaused = !1;
        this.UPDATE_SCENE = 1;
        this.UPDATE_CAMERA = 2
    }
    ;
    h.prototype.add = function(g) {
        function d(a) {
            a.sort(function(a, b) {
                return a - b
            }
            );
            (function(a, b, c) {
                for (b = a.length; c = --b; )
                    for (; c--; )
                        a[b] !== a[c] || a.splice(c, 
                        1)
            }
            )(a)
        }
        if (!(!g.hierarchy || 1 > g.hierarchy.length || !g.hierarchy[0].keys || 2 > g.hierarchy[0].keys.length)) {
            var c = null 
              , a = this;
            "camera" === g.type ? (c = new f.CameraAnimation(a.viewer.camera,g,a),
            a.animations.push(c)) : "annotation" === g.type ? (c = new f.AnnotationAnimation(null ,g,a),
            a.animations.push(c)) : "polyline" === g.type ? (c = new f.PolylineAnimation(null ,g,a),
            a.animations.push(c)) : "mesh" !== g.type && "visibility" !== g.type || a.viewer.model.getData().instanceTree.enumNodeFragments(g.id, function(b) {
                if (b = a.viewer.getFragmentProxy(a.viewer.model, 
                b))
                    c = "mesh" === g.type ? new f.MeshAnimation(b,g,a) : new f.VisibilityAnimation(b,g,g.id,a),
                    a.animations.push(c)
            }
            , !0);
            if (c) {
                for (var b = 0, h = g.hierarchy.length; b < h; b++)
                    for (var l = g.hierarchy[b].keys, n = 0; n < l.length; n++)
                        void 0 === l[n].xk && a.keys.push(l[n].time);
                d(a.keys)
            }
            this.updateFlag |= this.UPDATE_SCENE
        }
    }
    ;
    h.prototype.update = function(f) {
        this.animationHandler.update(f);
        var d = this.updateFlag;
        if (this.isPlaying && !this.isPaused) {
            this.currentTime += f;
            this.currentTime = Math.min(this.currentTime, this.duration);
            if (this.onPlayCallback)
                this.onPlayCallback(0 < 
                this.duration ? this.currentTime / this.duration * 100 : 0);
            this.currentTime >= this.duration && this.pause();
            d |= this.UPDATE_SCENE
        }
        this.updateFlag = 0;
        return d
    }
    ;
    h.prototype.play = function(f, d) {
        this.onPlayCallback = d;
        this.currentTime >= this.duration && this.goto(0);
        if (this.isPlaying)
            this.pause();
        else {
            for (var c = 0; c < this.animations.length; c++)
                this.animations[c].play(f);
            this.isPlaying = !0;
            this.isPaused = !1
        }
    }
    ;
    h.prototype.pause = function() {
        for (var f = 0; f < this.animations.length; f++) {
            var d = this.animations[f];
            d.isPaused === this.isPaused && 
            d.pause()
        }
        this.areCameraAnimationsPaused = this.isPaused = !this.isPaused
    }
    ;
    h.prototype.pauseCameraAnimations = function() {
        for (var f = 0; f < this.animations.length; f++) {
            var d = this.animations[f];
            d instanceof Teratek.Viewing.Private.CameraAnimation && d.pause()
        }
        this.areCameraAnimationsPaused = !this.areCameraAnimationsPaused
    }
    ;
    h.prototype.stop = function() {
        for (var f = 0; f < this.animations.length; f++)
            this.animations[f].stop();
        this.isPaused = this.isPlaying = !1
    }
    ;
    h.prototype.goto = function(f) {
        if (void 0 !== f) {
            for (var d = 0; d < this.animations.length; d++)
                this.animations[d].goto(f);
            this.isPaused = this.isPlaying = !0;
            this.currentTime = f;
            this.updateFlag |= this.UPDATE_SCENE
        }
    }
    ;
    h.prototype.next = function() {
        for (var f = this.keys, d = -1, c = 0; c < f.length; c++)
            if (f[c] > this.currentTime) {
                d = f[c];
                break
            }
        this.goto(0 > d ? f[f.length - 1] : d)
    }
    ;
    h.prototype.prev = function() {
        for (var f = this.keys, d = -1, c = f.length - 1; -1 < c; c--)
            if (f[c] < this.currentTime) {
                d = f[c];
                break
            }
        this.goto(0 > d ? f[0] : d)
    }
    ;
    f.KeyFrameAnimator = h
}
)();
void 0 === ENABLE_DEBUG && (ENABLE_DEBUG = !0);
void 0 === ENABLE_TRACE && (ENABLE_TRACE = !0);
var RENDER_NORMAL = 0
  , RENDER_HIGHLIGHTED = 1
  , RENDER_HIDDEN = 2
  , RENDER_FINISHED = 3;
(function() {
    function f(d, c) {
        function a(a) {
            var b = w
              , c = b == RENDER_NORMAL
              , d = F.settings.idbuffer && b != RENDER_HIDDEN;
            b == RENDER_HIDDEN ? a.overrideMaterial = m.fadeMaterial : b == RENDER_HIGHLIGHTED && (a.overrideMaterial = m.highlightMaterial);
            F.renderScenePart(a, !0, c, d);
            a.overrideMaterial = null 
        }
        function b(a) {
            0 < V && (ea = .8 * ea + .2 * (a - V));
            m.fpsCallback && m.fpsCallback(m.fps())
        }
        function f() {
            if ((R.enabled || T) && !m.is2d) {
                var a;
                if (a = m.model && !m.model.isLoadDone() ? m.model.getData().bbox : m.getVisibleBounds(!0, !1)) {
                    R.needClear = !0;
                    var b = m.camera
                      , c = a.clone()
                      , d = new THREE.Vector3(1,0,0)
                      , g = c.center();
                    a = c.size();
                    b.worldUpTransform && (d.applyMatrix4(b.worldUpTransform),
                    c.applyMatrix4(b.worldUpTransform),
                    a = c.size());
                    a.multiply(new THREE.Vector3(1.25,1.01,1.25));
                    a.x = a.z = Math.max(a.x, a.z);
                    R.setTransform(g, a, b.worldup, d);
                    T && (c = (new THREE.Vector3).subVectors(g, b.worldup.clone().multiplyScalar(a.y / 2)),
                    T.setTransform(c, b.worldup, a))
                }
            }
        }
        function l(a, b) {
            b.updateMatrixWorld(!0);
            b.traverse(function(b) {
                var c = b.geometry;
                void 0 !== c && (c.boundingBox || 
                c.computeBoundingBox(),
                W.copy(c.boundingBox),
                W.applyMatrix4(b.matrixWorld),
                a.union(W))
            }
            )
        }
        function n(a) {
            if (-1 == a.indexOf(";base64,")) {
                var b = a.split(",");
                a = b[0].split(":")[1];
                b = decodeURIComponent(b[1]);
                return new Blob([b],{
                    type: a
                })
            }
            b = a.split(";base64,");
            a = b[0].split(":")[1];
            for (var b = window.atob(b[1]), c = b.length, d = new Uint8Array(c), f = 0; f < c; ++f)
                d[f] = b.charCodeAt(f);
            return new Blob([d],{
                type: a
            })
        }
        var m = this, q = 1E3 / 15, r = 1E3 / 30, t = 1E3 / 120, w = RENDER_NORMAL, C = -1, E = -1, G = !1, B = new THREE.Vector3(0,1,0), v = "y", D, z, 
        H, I, J, L, F, N = !1, K = !1, M = !1, S = !1, ba, P = 0, aa = 0, Z = 0, V = 0, ea = 1E3 / 60, X = !0, R, T, O = !1, ca = new g.RenderScene, ia = function() {
            var a, b = 0, c = 0, d = 0;
            return function(f) {
                if (!R.enabled || m.is2d || ca.isEmpty() || X)
                    return !1;
                f && (R.rendered = !1);
                a != ca.getGeomScenes() && (R.needClear = !0);
                R.needClear && (R.clear(),
                R.needClear = !1,
                a = ca.getGeomScenes(),
                b = a.length,
                c = 0,
                d = Math.max(Math.ceil(b / 10), 10));
                if (R.isValid())
                    R.rendered || T && T.progressive || (R.renderShadow(m.camera, F.getColorTarget()),
                    R.rendered = !0);
                else {
                    for (f = 0; f < d && c < b; ) {
                        var g = a[c];
                        g && 
                        (g.forceVisible = !0,
                        R.renderIntoShadow(g),
                        g.forceVisible = !1,
                        f++);
                        c++
                    }
                    if (c >= b)
                        return R.postprocess(),
                        R.rendered || T && T.progressive || (R.renderShadow(m.camera, F.getColorTarget()),
                        R.rendered = !0),
                        !0
                }
                return !1
            }
        }
        (), fa = function() {
            var a, b = 0, c = 0, d = 0;
            return function(f) {
                if (!(!T || T.finished && !f || m.is2d || ca.isEmpty() || X)) {
                    if (f) {
                        T.clear();
                        T.updateCamera(m.camera);
                        T.rendered = !1;
                        T.finished = !1;
                        if (T.isGroundCulled())
                            return;
                        a = ca.getGeomScenes();
                        b = a.length;
                        c = 0;
                        d = Math.max(Math.ceil(b / 20), 1)
                    }
                    if (!T.isGroundCulled()) {
                        for (f = 
                        0; f < d && c < b; ) {
                            var g = a[c];
                            g && (g.forceVisible = !0,
                            T.renderIntoReflection(g),
                            g.forceVisible = !1,
                            f++);
                            c++
                        }
                        c < b ? T.rendered = !1 : T.finished = !0;
                        T.rendered || T.isGroundCulled() || !(T.finished || T.progressive && !ca.isDone()) || (T.postprocess(m.camera, J),
                        R.enabled && R.isValid() && (R.renderShadow(m.camera, T.outTarget),
                        R.rendered = !0),
                        T.renderReflection(m.camera, F.getColorTarget()),
                        T.rendered = !0,
                        ca.isDone() && (m.showGhosting && !ca.areAllVisible() ? (w = RENDER_HIDDEN,
                        ca.reset(m.camera, w)) : F.presentBuffer()))
                    }
                }
            }
        }
        ();
        this.run = function() {
            D = 
            0;
            (function na(c) {
                D = window.requestAnimationFrame(na);
                z && z && (m.camera.aspect = H / I,
                m.camera.clientWidth = H,
                m.camera.clientHeight = I,
                F.setSize(H, I),
                m.controls.handleResize(),
                T && T.setSize(H, I),
                m.invalidate(!0, !0, !0),
                z = !1,
                m.api.fireEvent({
                    type: Teratek.Viewing.VIEWER_RESIZE_EVENT
                }));
                J.updateMaterials();
                var d;
                if (m.keyFrameAnimator)
                    a: {
                        if (m.keyFrameAnimator && (d = m.keyFrameAnimator.update(0 < V ? (c - V) / 1E3 : 0)) && (m.sceneUpdated(!0),
                        d & m.keyFrameAnimator.UPDATE_CAMERA)) {
                            d = !0;
                            break a
                        }
                        d = !1
                    }
                else
                    d = !1;
                d = m.controls.update(c) || 
                d || ba;
                N = N || d;
                if (M = M || d)
                    for (var g in m.selectionMeshes) {
                        var h = m.selectionMeshes[g];
                        h.model.getFragmentList().getWorldMatrix(h.fragId, h.matrix)
                    }
                M = M || F.overlayUpdate(c);
                g = m.model && (m.model.isLoadDone() || 1 == m.model.myData.partPacksLoadDone);
                var l = m.progressiveRender ? m.targetFrameTime : 1E10
                  , h = l
                  , n = ca;
                S && S && (f(),
                S = !1);
                N || K ? (g && m.signalProgress(0, null ),
                0 < aa && (Z = .75 * Z + .25 * (c - aa)),
                aa = c,
                Z < r && l < q ? m.targetFrameTime += 1 : Z > r && l > t && --m.targetFrameTime,
                m.updateCameraMatrices(),
                F.beginScene(m.scene, m.camera, m.lights, 
                N),
                d && m.api.fireEvent(m.cameraChangedEvent),
                n && (w = n.hasHighlighted() ? RENDER_HIGHLIGHTED : RENDER_NORMAL,
                n.reset(m.camera, w, d | N))) : aa = -1;
                l = ia(N);
                M = M || l;
                fa(N);
                if (!n.isEmpty() && !n.isDone())
                    if (h = n.renderSome(a, h),
                    n.isDone() && w === RENDER_HIGHLIGHTED && (w = RENDER_NORMAL,
                    n.reset(m.camera, w),
                    n.renderSome(a, h)),
                    d || M || (b(c),
                    F.composeFinalFrame()),
                    n.isDone()) {
                        if (w === RENDER_NORMAL && !n.areAllVisible() && m.showGhosting) {
                            if (!T || T.finished)
                                w = RENDER_HIDDEN,
                                n.reset(m.camera, w)
                        } else
                            w = RENDER_FINISHED,
                            F.renderScenePart(m.sceneAfter, 
                            !0, !0, !0),
                            F.composeFinalFrame(d && m.skipAOWhenMoving, !0);
                        g && m.signalProgress(100, null )
                    } else
                        g && m.signalProgress(100 * n.getRenderProgress(), null );
                M && (!n.isEmpty() && n.isDone() || m.showOverlaysWhileMoving ? (m.renderOverlays(),
                n.isEmpty() || n.isDone() || (M = !0)) : F.clearAllOverlays(),
                F.renderScenePart(m.sceneAfter, !0, !0, !0),
                F.composeFinalFrame((d || n.isEmpty() || !n.isDone()) && m.skipAOWhenMoving, n && n.isDone()),
                b(c));
                G && !d && m.skipAOWhenMoving && F.composeFinalFrame();
                G = d;
                V = c;
                n && n.needsRender() ? (K = !0,
                n.resetNeedsRender()) : 
                K = !1;
                ba = N = !1
            }
            )()
        }
        ;
        this.toggleProgressive = function(a) {
            this.progressiveRender = a;
            N = !0
        }
        ;
        this.toggleGhosting = function(a) {
            this.showGhosting = a;
            N = !0
        }
        ;
        this.toggleOverlaysWhileMoving = function(a) {
            this.showOverlaysWhileMoving = a
        }
        ;
        this.togglePostProcess = function(a, b) {
            F.initPostPipeline(a, b);
            this.fireRenderOptionChanged();
            N = !0
        }
        ;
        this.toggleCelShading = function(a) {
            F.toggleCelShading(a);
            this.fireRenderOptionChanged();
            N = !0
        }
        ;
        this.toggleGroundShadow = function(a) {
            R.enabled !== a && (R.enabled = a,
            R.needClear = !0,
            f(),
            this.fireRenderOptionChanged(),
            this.invalidate(!0, !1, !1))
        }
        ;
        this.setGroundShadowColor = function(a) {
            R.enabled && (R.setColor(a),
            this.invalidate(!0, !1, !1))
        }
        ;
        this.setGroundShadowAlpha = function(a) {
            R.enabled && (R.setAlpha(a),
            this.invalidate(!0, !1, !1))
        }
        ;
        this.toggleGroundReflection = function(a) {
            a && T || !a && !T || (a ? (T = new Teratek.Viewing.Shaders.GroundReflection(L,this.canvas.clientWidth,this.canvas.clientHeight),
            T.setClearColors(this.clearColorTop, this.clearColorBottom),
            T.progressive = !0,
            T.toggleEnvMapBackground(O),
            f()) : (T.cleanup(),
            T = void 0),
            this.fireRenderOptionChanged(),
            this.invalidate(!0, !1, !1))
        }
        ;
        this.setGroundReflectionColor = function(a) {
            T && (T.setColor(a),
            this.invalidate(!0, !1, !1))
        }
        ;
        this.setGroundReflectionAlpha = function(a) {
            T && (T.setAlpha(a),
            this.invalidate(!0, !1, !1))
        }
        ;
        this.toggleEnvMapBackground = function(a) {
            O = a;
            F.toggleEnvMapBackground(a);
            T && T.toggleEnvMapBackground(a);
            N = !0
        }
        ;
        this.toggleRenderPrism = function(a) {
            J.setRenderPrism(a)
        }
        ;
        this.setOptimizeNavigation = function(a) {
            this.skipAOWhenMoving = a
        }
        ;
        this.renderOverlays = function() {
            var a = 
            this.lightsOn;
            a || this.toggleLights(!0, !0);
            var b;
            this.dir_light1 && (b = this.dir_light1.intensity,
            this.dir_light1.intensity = 1);
            F.renderOverlays(this.overlayScenes, this.lights);
            a || this.toggleLights(!1, !0);
            this.dir_light1 && (this.dir_light1.intensity = b);
            M = !1
        }
        ;
        this.setLayerVisible = function(a, b) {
            this.matman().setLayerVisible(a, b)
        }
        ;
        this.isLayerVisible = function(a) {
            return this.matman().isLayerVisible(a)
        }
        ;
        this.updateCameraMatrices = function() {
            var a = new THREE.Matrix4
              , b = new THREE.Matrix4
              , c = new THREE.Box3;
            return function() {
                var d = 
                this.camera;
                a.compose(d.position, d.quaternion, d.scale);
                b.getInverse(a);
                d.worldup && this.setWorldUp(d.worldup);
                if (this.model) {
                    var f = this.getVisibleBounds(!0, M);
                    c.copy(f);
                    c.applyMatrix4(b);
                    var g = 1E-5 * (c.max.z - c.min.z)
                      , h = .5 * (c.max.y - c.min.y)
                      , k = -(c.max.z + g) - h
                      , g = -(c.min.z - g) + h;
                    d.isPerspective && (k = Math.max(k, Math.min(1, 1E-4 * Math.abs(g - k))));
                    g = Math.max(g, k);
                    d.near = k;
                    d.far = g;
                    d.updateProjectionMatrix();
                    this.model.is2d() ? (f = (k = this.intersectGroundViewport(new THREE.Vector3(0,0,1))) ? d.position.distanceTo(k) : 
                    d.position.distanceTo(f.center()),
                    d = F.settings.deviceHeight / (2 * f * Math.tan(THREE.Math.degToRad(.5 * d.fov)))) : ((k = J.getCutPlanesRaw()) && k.length ? (g = k[0],
                    k = d.target.clone().sub(d.position).normalize(),
                    h = k.dot(g),
                    0 === h ? f = f.center() : (f = -(d.position.clone().dot(g) + g.w) / h,
                    f = k.multiplyScalar(f).add(d.position))) : f = f.center(),
                    f = d.position.distanceTo(f),
                    d = F.settings.deviceHeight / (2 * f * Math.tan(THREE.Math.degToRad(.5 * d.fov))),
                    d *= .5);
                    J.updatePixelScale(d)
                }
            }
        }
        ();
        this.initLights = function(a) {
            var b = g.LightPresets[C].lightMultiplier;
            this.lightNode = new THREE.Object3D;
            this.dir_light1 = new THREE.DirectionalLight((new THREE.Color).setRGB(1, 1, 1),b);
            this.dir_light1.position.set(-1, 0, 1);
            this.dir_light1.position.multiplyScalar(1E3 * a);
            this.lightNode.add(this.dir_light1);
            this.amb_light = new THREE.AmbientLight((new THREE.Color).setRGB(1, 1, 1));
            this.camera.add(this.lightNode);
            this.toggleLights(0 !== b)
        }
        ;
        this.toggleLights = function(a, b) {
            if (this.amb_light && this.lightNode) {
                a && !this.lightsOn ? (this.lights = [this.dir_light1, this.amb_light],
                this.lightsOn = 
                !0) : !a && this.lightsOn && (this.lightsOn = !1,
                this.lights = []);
                var c = g.LightPresets[C]
                  , d = c.ambientLightColor
                  , c = c.directLightColor;
                this.lightsOn ? (b && this.amb_light ? this.amb_light.color.setRGB(.5 * c[0], .5 * c[1], .5 * c[2]) : d && this.amb_light && this.amb_light.color.setRGB(d[0], d[1], d[2]),
                c && this.dir_light1 && this.dir_light1.color.setRGB(c[0], c[1], c[2])) : d && this.amb_light && b && this.amb_light.color.setRGB(d[0], d[1], d[2])
            }
        }
        ;
        this.syncCamera = function(a) {
            this.camera.updateProjectionMatrix();
            a && this.setWorldUp(this.api.navigation.getWorldUpVector());
            ba = !0
        }
        ;
        this.setViewFromFile = function(a, b) {
            var c;
            c = a.getDefaultCamera();
            if (!c) {
                c = {};
                var d = a.getBoundingBox()
                  , f = d.size();
                c.target = d.center();
                a.is2d() ? (c.isPerspective = !1,
                d = this.camera.aspect,
                c.orthoScale = d > f.x / f.y ? f.y : f.x / d,
                c.up = new THREE.Vector3(0,0,1),
                c.position = c.target.clone(),
                c.position.z += c.orthoScale,
                c.target.y += 1E-6 * f.y) : (c.isPerspective = !0,
                c.fov = this.camera.fov,
                c.up = this.camera.up.clone(),
                c.position = c.target.clone(),
                c.position.z += 1.5 * Math.max(f.x, f.y, f.z))
            }
            this.setViewFromCamera(c, b)
        }
        ;
        this.adjustOrthoCamera = 
        function(a) {
            if (!a.isPerspective && this.model) {
                var b = this.model.getBoundingBox()
                  , c = b.size()
                  , d = a.target.clone().sub(a.position);
                d.length() > 1E3 * c.length() ? (b = a.position.distanceTo(b.center()),
                a.target.copy(a.position).add(d.normalize().multiplyScalar(b))) : a.position.copy(a.target).add(d.normalize().multiplyScalar(-a.orthoScale))
            }
        }
        ;
        this.setViewFromCamera = function(a, b) {
            this.adjustOrthoCamera(a);
            var c = this.model ? this.model.getUpVector() : null ;
            this.model && -1 != this.model.getData().basePath.indexOf("SaRang") && 
            (c = [0, 0, 1]);
            var d;
            d = c ? (new THREE.Vector3).fromArray(c) : Teratek.Viewing.Navigation.snapToAxis(a.up.clone());
            a.up = d;
            c = this.api.navigation;
            b ? (d = this.camera,
            d.up.copy(a.up),
            d.position.copy(a.position),
            d.target.copy(a.target),
            a.isPerspective ? d.fov = a.fov : (d.saveFov = a.fov,
            d.fov = Teratek.Viewing.UnifiedCamera.ORTHO_FOV),
            d.isPerspective = a.isPerspective,
            d.orthoScale = a.orthoScale,
            d.dirty = !0,
            c.setWorldUpVector(d.up),
            c.setView(d.position, d.target),
            c.setPivotPoint(d.target),
            this.syncCamera(!0)) : (this.camera.isPerspective = 
            a.isPerspective,
            d = c.computeOrthogonalUp(a.position, a.target),
            c.setRequestTransitionWithUp(!0, a.position, a.target, a.fov, d, a.up));
            ba = !0
        }
        ;
        this.setViewFromViewBox = function(a, b, c, d) {
            if (a.is2d()) {
                c = {};
                a = a.getBoundingBox();
                var f = b[2] - b[0], g = b[3] - b[1], h;
                h = b[0] + f / 2;
                b = b[1] + g / 2;
                var k = this.camera.aspect;
                c.orthoScale = k > f / g ? g : f / k;
                c.isPerspective = !1;
                c.position = new THREE.Vector3(h,b,a.center().z + c.orthoScale);
                c.target = new THREE.Vector3(h,b,a.center().z);
                c.target.y += 1E-6 * g;
                c.up = new THREE.Vector3(0,0,1);
                this.setViewFromCamera(c, 
                d)
            }
        }
        ;
        this.setWorldUp = function(a) {
            if (!B.equals(a)) {
                B.copy(a);
                var b = Math.abs(a.x);
                v = "x";
                Math.abs(a.y) > b && (v = "y",
                b = Math.abs(a.y));
                Math.abs(a.z) > b && (v = "z");
                var c = new THREE.Vector3(0,1,0)
                  , b = m.camera
                  , d = (new THREE.Vector3).crossVectors(a, c).normalize();
                a = Math.acos(c.dot(a));
                a = (new THREE.Matrix4).makeRotationAxis(d, a);
                b.worldUpTransform = a;
                this.sceneUpdated(!1)
            }
        }
        ;
        this.addModel = function(a) {
            if (a) {
                this.model = a;
                this.selector.addModel(a);
                this.visibilityManager.addModel(a);
                var b = a.getBoundingBox();
                F.setUnitScale(a.getUnitScale());
                var c = a.is2d();
                c && this.enter2DMode(a);
                this.api.navigation.setIs2D(c);
                this.api.setActiveNavigationTool();
                ca.addModel(a);
                this.setViewFromFile(a, !0);
                this.controls.recordHomeView();
                b = .5 * b.size().length();
                this.initLights(b);
                c || this.setLightPresetFromFile(a) || this.setLightPreset(C, !0);
                this.invalidate(!0)
            }
        }
        ;
        this.getSvfMaterialId = function(a) {
            return this.model.getFragmentList().getSvfMaterialId(a)
        }
        ;
        this.getMaterials = function() {
            return J
        }
        ;
        this.createThreeMesh = function(a, b, c, d) {
            a = a.getData();
            var f;
            if (b.isLines) {
                var g = 
                !!b.attributes.color;
                f = new THREE.LineBasicMaterial({
                    vertexColors: g
                });
                g || (g = J.findMaterial(a, c),
                f.color = g.color);
                J.addMaterialNonHDR(a.basePath + c + "_line_" + f.id, f);
                f = new THREE.Mesh(b,f,!a.animations);
                f.isLine = !0;
                a.hasLines = !0
            } else {
                if (f = J.findMaterial(a, c))
                    f.svfMatId = c;
                J.applyGeometryFlagsToMaterial(f, b);
                f = new THREE.Mesh(b,f,!a.animations);
                f.materialId = parseInt(c);
                b.is2d && (f.is2d = !0)
            }
            d && (f.matrix && f.matrix.copy(d),
            f.matrixWorld.copy(d));
            f.matrixAutoUpdate = !1;
            f.frustumCulled = !1;
            return f
        }
        ;
        this.onLoadComplete = 
        function() {
            function a() {
                if (b.animations) {
                    c.keyFrameAnimator = new Teratek.Viewing.Private.KeyFrameAnimator(c,b.animations.duration);
                    for (var d in b.animations.animations)
                        c.keyFrameAnimator.add(b.animations.animations[d]);
                    c.keyFrameAnimator.goto(0);
                    c.api.fireEvent({
                        type: Teratek.Viewing.ANIMATION_READY_EVENT
                    })
                }
                c.api.removeEventListener(Teratek.Viewing.OBJECT_TREE_CREATED_EVENT, a)
            }
            X = !1;
            this.signalProgress(100, "");
            this.sceneUpdated(!1);
            this.is2d && (this.selectionMaterial2d = J.init2DSelectionMaterial(this.model),
            this.createOverlayScene("selection2d", this.selectionMaterial2d));
            var b = this.model.getData();
            ca.getGeometryList().printStats();
            b.hasLines && J.togglePolygonOffset(!0);
            var c = this;
            this.model.isObjectTreeCreated() ? a() : this.api.addEventListener(Teratek.Viewing.OBJECT_TREE_CREATED_EVENT, a);
            this.api.fireEvent({
                type: Teratek.Viewing.GEOMETRY_LOADED_EVENT
            })
        }
        ;
        this.signalProgress = function(a, b) {
            this.api.fireEvent({
                type: Teratek.Viewing.PROGRESS_UPDATE_EVENT,
                percent: a,
                message: b
            })
        }
        ;
        this.resize = function(a, b) {
            z = !0;
            H = a;
            I = b
        }
        ;
        this.enter2DMode = function(a) {
            this.is2d = !0;
            J.initLayersTexture(a);
            var b = J.create2DMaterial(a.getData(), {}, !0)
              , b = J.findMaterial(a.getData(), b);
            F.enter2DMode(b);
            E = C;
            this.setLightPreset(g.DefaultLightPreset2d);
            a = a.getData();
            if (a.hidePaper) {
                var c = a.bgColor;
                a = c >> 16 & 255;
                b = c >> 8 & 255;
                c &= 255;
                this.setClearColors(a, b, c, a, b, c)
            }
            this.fireRenderOptionChanged();
            this.invalidate(!0)
        }
        ;
        this.unloadCurrentModel = function() {
            this.is2d && (this.is2d = void 0,
            this.selectionMaterial2d = null ,
            this.removeOverlay("selection2d"),
            F.exit2DMode());
            F.beginScene(this.scene, this.camera, this.lights, !0);
            F.composeFinalFrame();
            this.model && (ca.removeModel(this.model),
            this.model.dtor(this.glrenderer()),
            J.cleanup(this.model.getData()),
            this.model.getData().propWorker.dtor(),
            this.model.loader && this.model.loader.dtor(),
            this.selector.removeModel(this.model),
            this.visibilityManager.removeModel(this.model),
            this.model = null );
            0 <= E && (C = E)
        }
        ;
        this.createOverlayScene = function(a, b, c, d) {
            b && J.addMaterialNonHDR(a + "_pre", b);
            c && J.addMaterialNonHDR(a + "_post", 
            c);
            var f = new THREE.Scene;
            f.__lights = this.scene.__lights;
            this.overlayScenes[a] = {
                scene: f,
                camera: d,
                materialPre: b,
                materialPost: c
            }
        }
        ;
        this.removeOverlayScene = function(a) {
            this.overlayScenes[a] && (delete this.overlayScenes[a],
            this.invalidate(!1, !1, !0))
        }
        ;
        this.addOverlay = function(a, b) {
            this.overlayScenes[a].scene.add(b);
            this.invalidate(!1, !1, !0)
        }
        ;
        this.addMultipleOverlays = function(a, b) {
            for (var c in b)
                this.addOverlay(a, b[c])
        }
        ;
        this.removeOverlay = function(a, b) {
            this.overlayScenes[a].scene.remove(b);
            this.invalidate(!1, 
            !1, !0)
        }
        ;
        this.removeMultipleOverlays = function(a, b) {
            for (var c in b)
                this.removeOverlay(a, b[c])
        }
        ;
        this.clearOverlay = function(a) {
            if (this.overlayScenes[a]) {
                a = this.overlayScenes[a].scene;
                var b, c;
                for (c = a.children.length - 1; 0 <= c; --c)
                    (b = a.children[c]) && a.remove(b);
                this.invalidate(!1, !1, !0)
            }
        }
        ;
        this.setClearColors = function(a, b, c, d, f, g) {
            this.clearColorTop = new THREE.Vector3(a / 255,b / 255,c / 255);
            this.clearColorBottom = new THREE.Vector3(d / 255,f / 255,g / 255);
            J.reflectionCube && !J.reflectionCube.isBgColor || J.setCubeMapFromColors(this.clearColorTop, 
            this.clearColorBottom);
            F.setClearColors(this.clearColorTop, this.clearColorBottom);
            T && T.setClearColors(this.clearColorTop, this.clearColorBottom);
            N = !0;
            this.fireRenderOptionChanged()
        }
        ;
        var W = new THREE.Box3;
        this.getVisibleBounds = function(a, b) {
            var c = new THREE.Box3;
            if (!ca.isEmpty() && (l(c, this.scene),
            c = ca.getVisibleBounds(a).union(c),
            b)) {
                var d = new THREE.Box3, f = m.overlayScenes, g;
                for (g in f)
                    f.hasOwnProperty(g) && l(d, f[g].scene);
                l(d, m.scene);
                c = d.union(c)
            }
            return c
        }
        ;
        this.getFitBounds = function(a) {
            var b;
            this.is2d && 
            (a = !0);
            a || null  === this.selector || (b = this.selector.getSelectionBounds());
            if (!b || b.empty())
                b = this.getVisibleBounds();
            return b
        }
        ;
        this.getRenderProxy = function(a, b) {
            return a.getFragmentList().getVizmesh(b)
        }
        ;
        this.getFragmentProxy = function(a, b) {
            return new g.FragmentPointer(a.getFragmentList(),b)
        }
        ;
        this.getRenderProxyCount = function(a) {
            return a.getFragmentList().getCount()
        }
        ;
        this.getRenderProxyDbIds = function(a, b) {
            return a.getFragmentList().getDbIds(b)
        }
        ;
        this.isWholeModelVisible = function(a) {
            return ca ? ca.areAllVisible() : 
            !0
        }
        ;
        this.highlightObjectNode = function(a, b, c, d) {
            a.is2d() && J.highlightObject2D(b, c);
            var f = this
              , g = a.getData().instanceTree;
            if (g && !a.is2d())
                g.enumNodeFragments(b, function(b) {
                    f.highlightFragment(a, b, c, d)
                }
                , !1);
            else if (g = b,
            a.is2d() && (g = a.getData().fragments.dbId2fragId[b]),
            Array.isArray(g))
                for (b = 0; b < g.length; b++)
                    f.highlightFragment(a, g[b], c, d);
            else
                f.highlightFragment(a, g, c, d)
        }
        ;
        this.highlightFragment = function(a, b, c, d) {
            var f = this.getRenderProxy(a, b);
            if (f) {
                d = !d || f.is2d;
                var g = a.id + ":" + b;
                if (d) {
                    var h = a.is2d() ? 
                    "selection2d" : "selection";
                    if (c) {
                        var k = new THREE.Mesh(f.geometry,f.material);
                        k.matrix.copy(f.matrixWorld);
                        k.matrixAutoUpdate = !1;
                        k.matrixWorldNeedsUpdate = !0;
                        k.frustumCulled = !1;
                        k.model = a;
                        k.fragId = b;
                        this.addOverlay(h, k);
                        this.selectionMeshes[g] = k
                    } else
                        this.selectionMeshes[g] && (this.removeOverlay(h, this.selectionMeshes[g]),
                        delete this.selectionMeshes[g])
                }
                d && c || a.setHighlighted(b, c) && this.invalidate(!0)
            }
        }
        ;
        this.explode = function(a) {
            a != P && (P = a,
            ca.explode(a),
            this.sceneUpdated(!0),
            this.api.fireEvent({
                type: h.EXPLODE_CHANGE_EVENT
            }))
        }
        ;
        this.getExplodeScale = function() {
            return P
        }
        ;
        this.setGhostingBrightness = function(a) {
            this.fadeMaterial.color = a ? new THREE.Color(1052688) : new THREE.Color(16777215);
            this.fadeMaterial.needsUpdate = !0
        }
        ;
        this.setLightPreset = function(a, b) {
            if (C != a || b) {
                if (0 > a || g.LightPresets.length <= a)
                    a = g.DefaultLightPreset;
                C = a;
                var c = g.LightPresets[a];
                if (c && c.path) {
                    var d = "res/environments/" + c.path
                      , f = g.getResourceUrl(d + "_mipdrop." + (c.type || "") + ".dds")
                      , d = g.getResourceUrl(d + "_irr." + (c.type || "") + ".dds");
                    J.setIrradianceMap(d, c.E_bias);
                    J.setCubeMap(f, c.E_bias);
                    J.setEnvExposure(-c.E_bias);
                    this.setTonemapExposureBias(c.E_bias);
                    this.setTonemapMethod(c.tonemap);
                    this.setGhostingBrightness(c.darkerFade)
                } else
                    J.setIrradianceMap(null ),
                    J.setCubeMap(null ),
                    J.setEnvExposure(0),
                    this.setTonemapExposureBias(0),
                    this.setTonemapMethod(0),
                    this.setGhostingBrightness(!1);
                f = Teratek.Viewing.Shaders.SAOShader.uniforms.radius.value;
                d = Teratek.Viewing.Shaders.SAOShader.uniforms.intensity.value;
                c.hasOwnProperty("saoRadius") && (f = c.saoRadius);
                c.hasOwnProperty("saoIntensity") && 
                (d = c.saoIntensity);
                F.setAOOptions(f, d);
                (f = c.bgColorGradient) || (f = g.BackgroundPresets.Custom);
                this.setClearColors(f[0], f[1], f[2], f[3], f[4], f[5]);
                f = 1;
                null  !== c.lightMultiplier && void 0 !== c.lightMultiplier && (f = c.lightMultiplier);
                this.dir_light1 && (this.toggleLights(0 !== f),
                this.dir_light1.intensity = f,
                c.lightDirection && (this.dir_light1.position.set(-c.lightDirection[0], -c.lightDirection[1], -c.lightDirection[2]),
                this.dir_light1.position.multiplyScalar(1E3 * this.model.getData().bbox.size().length())));
                this.invalidate(!0, 
                !1, !0);
                this.fireRenderOptionChanged()
            }
        }
        ;
        this.setLightPresetFromFile = function(a) {
            var b = a.getMetadata("renderEnvironmentStyle", "value", null );
            if (null  === b || "" === b)
                return !1;
            var c = a.getMetadata("renderEnvironmentExposureBias", "value", null );
            a = a.getMetadata("renderEnvironmentExposureBase", "value", null );
            for (var d = 0; d < g.LightPresets.length; d++)
                if (b === g.LightPresets[d].name)
                    return null  !== c && null  !== a && (g.LightPresets[d].E_bias = c + a),
                    this.setLightPreset(d),
                    !0;
            return !1
        }
        ;
        this.setTonemapMethod = function(a) {
            a != F.getToneMapMethod() && 
            (F.setTonemapMethod(a),
            J.setTonemapMethod(a),
            this.fireRenderOptionChanged(),
            this.invalidate(!0))
        }
        ;
        this.setTonemapExposureBias = function(a) {
            a != F.getExposureBias() && (F.setTonemapExposureBias(a),
            J.setTonemapExposureBias(a),
            this.fireRenderOptionChanged(),
            this.invalidate(!0))
        }
        ;
        this.dtor = function() {
            window.cancelAnimationFrame(D);
            this.unloadCurrentModel();
            this.loader = this.canvas = this.controls = null ;
            this.selector.dtor();
            F = ca = this.visibilityManager = this.model = this.selector = null ;
            J.dtor();
            J = null 
        }
        ;
        this.hideLines = 
        function(a) {
            return ca ? (ca.hideLines(a),
            this.sceneUpdated(!0),
            !0) : !1
        }
        ;
        this.getCutPlanes = function() {
            return J.getCutPlanes()
        }
        ;
        this.setCutPlanes = function(a) {
            J.setCutPlanes(a);
            this.sceneUpdated();
            this.api.fireEvent({
                type: Teratek.Viewing.CUTPLANES_CHANGE_EVENT
            })
        }
        ;
        this.setCutPlanesOutlineColor = function(a) {
            J.setCutPlanesOutlineColor(a);
            this.invalidate(!0, !1, !1);
            this.api.fireEvent({
                type: Teratek.Viewing.CUTPLANES_CHANGE_EVENT
            })
        }
        ;
        this.setCutPlanesOutlineThickness = function(a) {
            J.setCutPlanesOutlineThickness(a);
            this.invalidate(!0, !1, !1);
            this.api.fireEvent({
                type: Teratek.Viewing.CUTPLANES_CHANGE_EVENT
            })
        }
        ;
        this.fireRenderOptionChanged = function() {
            J.toggleMRTSetting();
            this.api.fireEvent({
                type: Teratek.Viewing.RENDER_OPTION_CHANGED_EVENT
            })
        }
        ;
        this.viewportToRay = function(a, b) {
            var c = this.camera;
            a.z = -1;
            var d = new THREE.Vector3(a.x,a.y,1);
            a = a.unproject(c);
            d = d.unproject(c);
            d.sub(a).normalize();
            b || (b = new THREE.Ray);
            b.set(c.isPerspective ? c.position : a, d);
            return b
        }
        ;
        this.rayIntersect = function(a, b, c) {
            b = ca.rayIntersect(a.origin, 
            a.direction, b, c);
            if (this.sceneAfter.children.length && (a = new THREE.Raycaster(a.origin,a.direction,this.camera.near,this.camera.far),
            c = [],
            VBIntersector.intersectObject(this.sceneAfter, a, c, !0),
            c.length))
                for (; 0 < c.length && !(c[0].distance > b.distance); ) {
                    b = c[0];
                    break
                }
            if (!b)
                return null ;
            a = b.fragId;
            c = b.point;
            var d = b.face
              , f = b.model;
            b = b.dbId;
            void 0 === b && void 0 !== a && (b = f.getFragmentList().getDbIds(a),
            f.getData().instanceTree || (b = a));
            return {
                dbId: b,
                fragId: a,
                intersectPoint: c,
                face: d,
                model: f
            }
        }
        ;
        this.castRayViewport = 
        function() {
            var a = new THREE.Ray;
            return function(b, c, d) {
                if (!ca)
                    return {};
                this.viewportToRay(b, a);
                return this.rayIntersect(a, c, d)
            }
        }
        ();
        this.clientToViewport = function(a, b) {
            var c = m.canvas.getBoundingClientRect();
            return new THREE.Vector3((a + .5) / c.width * 2 - 1,2 * -((b + .5) / c.height) + 1,1)
        }
        ;
        this.viewportToClient = function(a, b) {
            var c = m.canvas.getBoundingClientRect();
            return new THREE.Vector3(.5 * (a + 1) * c.width - .5,-.5 * (b - 1) * c.height - .5,0)
        }
        ;
        this.castRay = function(a, b, c) {
            return this.castRayViewport(this.clientToViewport(a, 
            b), c)
        }
        ;
        this.intersectGroundViewport = function(a) {
            var b = this.camera
              , c = "z";
            this.is2d || (c = v);
            var d = a;
            d.z = -1;
            a = new THREE.Vector3(d.x,d.y,1);
            d = d.unproject(b);
            a = a.unproject(b);
            a.sub(d).normalize();
            if (1E-6 > Math.abs(a[c]))
                return null ;
            b = b.isPerspective ? b.position : d;
            c = ((this.model ? this.model.getBoundingBox().min[c] : 0) - b[c]) / a[c];
            a.multiplyScalar(c);
            a.add(b);
            return a
        }
        ;
        this.intersectGround = function(a, b) {
            return this.intersectGroundViewport(this.clientToViewport(a, b))
        }
        ;
        this.hitTestViewport = function(a, b) {
            var c;
            if (m.is2d) {
                c = 
                F.idAtPixel(a.x, a.y);
                if (0 >= c)
                    return null ;
                c = {
                    intersectPoint: this.intersectGroundViewport(a),
                    dbId: c,
                    fragId: m.model.getData().fragments.dbId2fragId[c],
                    model: m.model
                }
            } else
                c = this.castRayViewport(a, b);
            return c
        }
        ;
        this.hitTest = function(a, b, c) {
            return m.hitTestViewport(this.clientToViewport(a, b), c)
        }
        ;
        this.snappingHitTestViewport = function(a, b) {
            var c;
            if (m.is2d) {
                c = F.idAtPixel(a.x, a.y);
                if (0 > c)
                    return null ;
                c = {
                    intersectPoint: this.intersectGroundViewport(a),
                    dbId: c,
                    fragId: m.model.getData().fragments.dbId2fragId[c]
                }
            } else {
                c = 
                F.idAtPixel(a.x, a.y);
                var d;
                0 <= c && (d = [],
                this.model.getData().instanceTree.enumNodeFragments(c, function(a) {
                    d.push(a)
                }
                , !0));
                c = this.castRayViewport(a, b, d)
            }
            return c
        }
        ;
        this.snappingHitTest = function(a, b, c) {
            return this.snappingHitTestViewport(this.clientToViewport(a, b), c)
        }
        ;
        this.rolloverObjectViewport = function(a) {
            F.rolloverObjectViewport(a.x, a.y) && this.invalidate(!1, !1, !0)
        }
        ;
        this.rolloverObject = function(a, b) {
            this.rolloverObjectViewport(this.clientToViewport(a, b))
        }
        ;
        this.getScreenShot = function(a, b, c) {
            F.presentBuffer();
            var d = window.URL.createObjectURL(n(m.canvas.toDataURL("image/png")));
            if (!a || !b)
                return d;
            var f, g, h = 0, k = 0;
            a > b || H / I < a / b ? (f = a,
            g = I / H * a,
            k = b / 2 - g / 2) : (g = b,
            f = H / I * b,
            h = a / 2 - f / 2);
            var l = new Image;
            l.src = d;
            var q = document.createElement("canvas")
              , r = q.getContext("2d");
            q.width = a;
            q.height = b;
            l.onload = function() {
                r.drawImage(l, h, k, f, g);
                var a = window.URL.createObjectURL(n(q.toDataURL("image/png")));
                c ? c(a) : window.open(a)
            }
        }
        ;
        this.modelQueue = function() {
            return ca
        }
        ;
        this.glrenderer = function() {
            return L
        }
        ;
        this.renderer = function() {
            return F
        }
        ;
        this.worldUp = function() {
            return B
        }
        ;
        this.worldUpName = function() {
            return v
        }
        ;
        this.setUserRenderContext = function(a) {
            F = a ? a : new RenderContext;
            F.init(L, this.canvas.clientWidth, this.canvas.clientHeight);
            F.setClearColors(this.clearColorTop, this.clearColorBottom);
            this.invalidate(!0);
            this.sceneUpdated(!1)
        }
        ;
        this.invalidate = function(a, b, c) {
            N = N || a;
            K = K || b;
            M = M || c
        }
        ;
        this.sceneUpdated = function(a) {
            this.invalidate(!0, !1, !0);
            ca && a && ca.invalidateVisibleBounds();
            S = !0
        }
        ;
        this.currentLightPreset = function() {
            return C
        }
        ;
        this.matman = 
        function() {
            return J
        }
        ;
        this.fps = function() {
            return 1E3 / ea
        }
        ;
        this.api = c;
        this.canvas = d;
        this.loader = null ;
        L = function(a) {
            var b = window.devicePixelRatio;
            b || (b = 1);
            a = new FireflyWebGLRenderer({
                canvas: a,
                antialias: !1,
                alpha: !1,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !1,
                stencil: !1,
                depth: !1,
                devicePixelRatio: b
            });
            a.autoClear = !1;
            a.sortObjects = !1;
            return a
        }
        (d);
        F = new RenderContext;
        F.init(L, d.clientWidth, d.clientHeight);
        J = new g.MaterialManager(this);
        init_UnifiedCamera();
        this.camera = new Teratek.Viewing.UnifiedCamera(d.clientWidth,
        d.clientHeight);
        this.lights = [];
        this.cameraChangedEvent = this.camera.getCameraChangedEvent();
        this.scene = new THREE.Scene;
        this.sceneAfter = new THREE.Scene;
        this.sceneAfter.sortObjects = !1;
        this.overlayScenes = {};
        this.selectionMaterial2d = null ;
        this.selectionMaterialBase = new THREE.MeshPhongMaterial({
            color: 6724095,
            specular: 526344,
            emissive: 3361911,
            ambient: 0,
            opacity: 1,
            transparent: !1
        });
        this.selectionMaterialTop = new THREE.MeshPhongMaterial({
            color: 6724095,
            specular: 526344,
            emissive: 3361911,
            ambient: 0,
            opacity: .15,
            transparent: !0
        });
        this.selectionMaterialTop.packedNormals = !0;
        this.selectionMaterialBase.packedNormals = !0;
        (function(a, b, c) {
            b.depthWrite = !1;
            b.depthTest = !0;
            b.side = THREE.DoubleSide;
            c.depthWrite = !1;
            c.depthTest = !0;
            c.side = THREE.DoubleSide;
            m.createOverlayScene(a, b, c)
        }
        )("selection", this.selectionMaterialBase, this.selectionMaterialTop);
        this.selectionMeshes = {};
        this.fadeMaterial = new THREE.MeshPhongMaterial({
            color: 16777215,
            opacity: .1,
            reflectivity: 0,
            transparent: !0,
            depthWrite: !1
        });
        this.fadeMaterial.packedNormals = !0;
        J.addMaterial("__fadeMaterial__", 
        this.fadeMaterial, !0);
        this.highlightMaterial = new THREE.MeshPhongMaterial({
            color: 6724095,
            specular: 526344,
            emissive: 3361911,
            ambient: 0,
            opacity: 1,
            transparent: !1
        });
        this.highlightMaterial.packedNormals = !0;
        J.addMaterial("__highlightMaterial__", this.highlightMaterial, !0);
        this.progressiveRender = !0;
        if (isAndroidDevice() || isIOSDevice())
            q *= 2,
            t *= 2,
            r *= 2;
        this.targetFrameTime = r;
        this.controls = {
            update: function(a) {},
            handleResize: function() {},
            recordHomeView: function() {},
            uninitialize: function() {}
        };
        this.selector = new g.MultiModelSelector(this);
        this.visibilityManager = new g.MultiModelVisibilityManager(this);
        this.showOverlaysWhileMoving = this.showGhosting = !0;
        this.skipAOWhenMoving = !1;
        this.keyFrameAnimator = null ;
        var ga = g.LightPresets[g.DefaultLightPreset].bgColorGradient;
        this.setClearColors(ga[0], ga[1], ga[2], ga[3], ga[4], ga[5]);
        R = new Teratek.Viewing.Shaders.GroundShadow(L);
        R.enabled = !0;
        J.addMaterialNonHDR("groundShadowDepthMaterial", R.getDepthMaterial());
        J.addMaterialNonHDR("normalsMaterial", F.getDepthMaterial());
        F.beginScene(this.scene, this.camera, 
        this.lights, !0);
        F.composeFinalFrame();
        this.interceptor = this.viewtx = this.p2p = this.presenceChannelId = this.messageClient = null ;
        this.joinLiveReviewSession = function(a) {
            (function() {
                var a = Teratek.Viewing
                  , b = a.Private;
                b.InteractionInterceptor = function(a) {
                    this.getNames = function() {
                        return ["intercept"]
                    }
                    ;
                    this.getName = function() {
                        return "intercept"
                    }
                    ;
                    this.activate = function(a) {}
                    ;
                    this.deactivate = function(a) {}
                    ;
                    this.update = function(a) {
                        return !1
                    }
                    ;
                    this.handleSingleClick = function(a, b) {
                        return !1
                    }
                    ;
                    this.handleDoubleClick = function(a, 
                    b) {
                        return !1
                    }
                    ;
                    this.handleSingleTap = function(a) {
                        return !1
                    }
                    ;
                    this.handleDoubleTap = function(a, b) {
                        return !1
                    }
                    ;
                    this.handleKeyDown = function(a, b) {
                        return !1
                    }
                    ;
                    this.handleKeyUp = function(a, b) {
                        return !1
                    }
                    ;
                    this.handleWheelInput = function(b) {
                        a.takeControl();
                        return !1
                    }
                    ;
                    this.handleButtonDown = function(b, c) {
                        a.takeControl();
                        return !1
                    }
                    ;
                    this.handleButtonUp = function(a, b) {
                        return !1
                    }
                    ;
                    this.handleMouseMove = function(b) {
                        a.updatePointer(b);
                        return !1
                    }
                    ;
                    this.handleGesture = function(b) {
                        a.takeControl();
                        return !1
                    }
                    ;
                    this.handleBlur = function(a) {
                        return !1
                    }
                    ;
                    this.handleResize = function() {}
                }
                ;
                b.ViewTransceiver = function(c) {
                    function d(a) {
                        r = !0;
                        a = JSON.parse(a.data.msg);
                        I.restoreState(a);
                        q.impl.invalidate(!0, !1, !0);
                        r = !1
                    }
                    function f(a) {
                        for (var b = 0; b < a.length; b++)
                            a[b] = Math.round(1E3 * a[b]) / 1E3
                    }
                    function g(a) {
                        var b = a.data.msg;
                        !0 === b[1] || B || (b[0] != K && (K = b[0],
                        a.data.lastInControl = b[0],
                        n.dispatchEvent({
                            type: "controlChange",
                            channelId: n.channelId,
                            data: a.data
                        })),
                        v = !1,
                        q.navigation.setView((new THREE.Vector3).set(b[2], b[3], b[4]), (new THREE.Vector3).set(b[5], b[6], b[7])),
                        q.navigation.setCameraUpVector((new THREE.Vector3).set(b[8], 
                        b[9], b[10])))
                    }
                    function h(a) {
                        if (v || B)
                            a = a.camera,
                            a = [a.position.x, a.position.y, a.position.z, a.target.x, a.target.y, a.target.z, a.up.x, a.up.y, a.up.z],
                            f(a),
                            a.unshift(B),
                            a.unshift(c.getLocalId()),
                            z.sendMessage("camera", a, n.channelId),
                            K != a[0] && (K = a[0],
                            n.dispatchEvent({
                                type: "controlChange",
                                channelId: n.channelId,
                                data: {
                                    lastInControl: K
                                }
                            }))
                    }
                    function k(a, b, c) {
                        a && !D && (D = document.createElement("div"),
                        D.classList.add("collabPointer"));
                        a && !w ? (q.container.appendChild(D),
                        w = !0) : !a && w && (q.container.removeChild(D),
                        w = !1);
                        a && (D.style.left = b - 6 + "px",
                        D.style.top = c - 6 + "px")
                    }
                    function l(a) {
                        v || B || (a = a.data.msg,
                        t.origin.set(a[1], a[2], a[3]),
                        t.direction.set(a[4], a[5], a[6]),
                        a = t.at(q.getCamera().near),
                        a.project(q.getCamera()),
                        a = q.impl.viewportToClient(a.x, a.y),
                        k(!0, a.x, a.y))
                    }
                    function m(a) {
                        r || (a = I.getState(M),
                        c.sendMessage("state", JSON.stringify(a), n.channelId))
                    }
                    var n = this, q = this.viewer = null , r = !1, v = !1, B = !1, K, z = this.client = c, t = new THREE.Ray, D = null , w = !1;
                    this.channelId = null ;
                    var I, M = {
                        seedURN: !1,
                        objectSet: !0,
                        viewport: !1,
                        cutplanes: !0,
                        renderOptions: {
                            environment: !1,
                            ambientOcclusion: !1,
                            toneMap: {
                                exposure: !1
                            },
                            appearance: !1
                        }
                    };
                    this.takeControl = function() {
                        v = !0;
                        k(!1)
                    }
                    ;
                    this.updatePointer = function(a) {
                        v && (a = q.impl.clientToViewport(a.canvasX, a.canvasY),
                        q.impl.viewportToRay(a, t),
                        a = [t.origin.x, t.origin.y, t.origin.z, t.direction.x, t.direction.y, t.direction.z],
                        f(a),
                        a.unshift(c.getLocalId()),
                        z.sendMessage("pointer", a, n.channelId))
                    }
                    ;
                    this.connectCamera = function(a) {
                        B = !a
                    }
                    ;
                    this.attach = function(c) {
                        q && this.detach();
                        this.viewer = q = c;
                        I = new b.ViewerState(q);
                        z.addEventListener("cameraChange", g);
                        z.addEventListener("pointerMove", l);
                        z.addEventListener("viewerState", d);
                        q.hasEventListener(a.CAMERA_CHANGE_EVENT, h) || q.addEventListener(a.CAMERA_CHANGE_EVENT, h);
                        q.hasEventListener(a.SELECTION_CHANGED_EVENT, m) || (q.addEventListener(a.SELECTION_CHANGED_EVENT, m),
                        q.addEventListener(a.ISOLATE_EVENT, m),
                        q.addEventListener(a.HIDE_EVENT, m),
                        q.addEventListener(a.SHOW_EVENT, m),
                        q.addEventListener(a.HIGHLIGHT_EVENT, m),
                        q.addEventListener(a.EXPLODE_CHANGE_EVENT, m),
                        q.addEventListener(a.LAYER_VISIBILITY_CHANGED_EVENT, 
                        m),
                        q.addEventListener(a.CUTPLANES_CHANGE_EVENT, m))
                    }
                    ;
                    this.detach = function() {
                        z && (z.removeEventListener("cameraChange", g),
                        z.removeEventListener("viewerState", d));
                        q && (q.removeEventListener(a.CAMERA_CHANGE_EVENT, h),
                        q.removeEventListener(a.SELECTION_CHANGED_EVENT, m),
                        q.removeEventListener(a.ISOLATE_EVENT, m),
                        q.removeEventListener(a.HIDE_EVENT, m),
                        q.removeEventListener(a.SHOW_EVENT, m),
                        q.removeEventListener(a.HIGHLIGHT_EVENT, m),
                        q.removeEventListener(a.EXPLODE_CHANGE_EVENT, m),
                        q.removeEventListener(a.LAYER_VISIBILITY_CHANGED_EVENT, 
                        m),
                        q.removeEventListener(a.CUTPLANES_CHANGE_EVENT, m),
                        I = this.viewer = q = null )
                    }
                }
                ;
                b.ViewTransceiver.prototype.constructor = b.ViewTransceiver;
                Teratek.Viewing.EventDispatcher.prototype.apply(b.ViewTransceiver.prototype)
            }
            )();
            this.messageClient || (this.messageClient = g.MessageClient.GetInstance());
            this.presenceChannelId || (this.presenceChannelId = window.location.host);
            this.messageClient.isConnected() || this.messageClient.connect(a);
            this.viewtx || (this.viewtx = new g.ViewTransceiver(this.messageClient));
            this.viewtx.channelId = 
            a;
            this.viewtx.attach(global_viewer_instance);
            this.p2p || (this.p2p = new g.P2PClient(this.messageClient));
            this.messageClient.join(this.viewtx.channelId);
            this.interceptor || (this.interceptor = new g.InteractionInterceptor(this.viewtx));
            c.toolController.registerTool(this.interceptor);
            c.toolController.activateTool(this.interceptor.getName())
        }
        ;
        this.leaveLiveReviewSession = function() {
            this.p2p.hangup();
            this.viewtx.detach(c);
            this.messageClient.disconnect()
        }
    }
    var h = Teratek.Viewing
      , g = h.Private;
    f.prototype.constructor = 
    f;
    Teratek.Viewing.Private.Viewer3DImpl = f
}
)();
Teratek.Viewing.Private.ViewerState = function(f) {
    this.getState = function(h) {
        var g = f.navigation, d = Teratek.Viewing.Private, c = {}, a;
        a = Math.round(4294967295 * Math.random());
        var b = Date.now();
        a = a.toString(16) + b.toString(16);
        c.guid = a;
        c.seedURN = this.getSeedUrn();
        c.overrides = this.getTransformsOverrides();
        a = c.objectSet;
        Array.isArray(a) || (c.objectSet = a = []);
        f.model && !f.model.is2d() && (a[0] = {
            id: this.getSelectedNodes(),
            isolated: f.getIsolatedNodes(),
            hidden: f.getHiddenNodes(),
            explodeScale: f.getExplodeScale(),
            idType: "lmv"
        });
        f.model && f.model.is2d() && (a[0] = {
            id: this.getSelectedNodes(),
            isolated: this.getVisibleLayers2d(),
            hidden: [],
            idType: "lmv"
        });
        (a = c.viewport) || (a = c.viewport = {});
        b = g.getCamera().isPerspective;
        a.name = "";
        a.eye = g.getPosition().toArray();
        a.target = g.getTarget().toArray();
        a.up = g.getCamera().up.toArray();
        a.worldUpVector = g.getWorldUpVector().toArray();
        a.pivotPoint = g.getPivotPoint().toArray();
        a.distanceToOrbit = g.getPivotPlaneDistance();
        a.aspectRatio = this.getAspectRatio();
        a.projection = b ? "perspective" : "orthographic";
        a.isOrthographic = !b;
        b ? a.fieldOfView = g.getVerticalFov() : a.orthographicHeight = this.getOrthographicHeight();
        (g = c.renderOptions) || (g = c.renderOptions = {});
        g.environment = d.LightPresets[f.impl.currentLightPreset()].name;
        g.ambientOcclusion = {
            enabled: f.impl.renderer().settings.sao,
            radius: f.impl.renderer().getAORadius(),
            intensity: f.impl.renderer().getAOIntensity()
        };
        g.toneMap = {
            method: f.impl.renderer().getToneMapMethod(),
            exposure: f.impl.renderer().getExposureBias(),
            lightMultiplier: this.getToneMapIntensity()
        };
        g.appearance = 
        {
            ghostHidden: f.impl.showGhosting,
            ambientShadow: f.prefs.ambientShadows,
            antiAliasing: f.impl.renderer().settings.antialias,
            progressiveDisplay: f.prefs.progressiveRendering,
            displayLines: f.prefs.lineRendering
        };
        if (f.model && !f.model.is2d())
            for (d = c.cutplanes = [],
            g = f.getCutPlanes(),
            a = 0; a < g.length; a++)
                d.push(g[a].toArray());
        for (var k in f.loadedExtensions)
            f.loadedExtensions[k].getState(c);
        h && !0 !== h && this.applyFilter(c, h);
        return c
    }
    ;
    this.restoreState = function(h, g, d) {
        if (!h)
            return stderr("restoreState has no viewer state to restore from."),
            !1;
        if (!f || !f.model)
            return stderr("restoreState has no viewer or model to restore."),
            !1;
        g && !0 !== g && (h = JSON.parse(JSON.stringify(h)),
        this.applyFilter(h, g));
        g = f.navigation;
        if (g.getTransitionActive())
            return stderr("Abort restoreState, animation in progress..."),
            !1;
        if (f.model && Array.isArray(h.objectSet) && 0 < h.objectSet.length) {
            var c = h.objectSet[0]
              , a = f.impl ? f.impl.selector : null ;
            if (f.model.getRootId()) {
                var b = c.id;
                b && a && (b = this.toIntArray(b),
                a.setSelection(b));
                b = c.isolated || [];
                b = this.toIntArray(b);
                f.isolate(b);
                0 === b.length && (b = c.hidden || null ) && 0 < b.length && (b = this.toIntArray(b),
                f.hide(b));
                "explodeScale" in c && (b = parseFloat(c.explodeScale),
                f.explode && (f.explode(b),
                f.explodeSlider && (f.explodeSlider.value = b)))
            }
            f.model.is2d() && (b = c.id || [],
            a && (b = b.map(function(a) {
                return {
                    dbId: a,
                    fragIds: 0
                }
            }
            ),
            a.setSelection(b)),
            c = c.isolated,
            Array.isArray(c) && 0 < c.length ? (f.setLayerVisible(null , !1),
            f.impl.setLayerVisible(c, !0)) : f.setLayerVisible(null , !0))
        }
        if (c = h.viewport) {
            var a = this.getVector3FromArray(c.eye, g.getPosition())
              , b = this.getVector3FromArray(c.up, 
            g.getCamera().up)
              , k = this.getVector3FromArray(c.target, g.getTarget())
              , l = "fieldOfView" in c ? parseFloat(c.fieldOfView) : g.getVerticalFov()
              , n = this.getVector3FromArray(c.worldUpVector, null );
            n || (n = (n = f.model ? f.model.getUpVector() : null ) ? (new THREE.Vector3).fromArray(n) : new THREE.Vector3(0,1,0));
            g = g.getCamera().isPerspective;
            "isOrthographic" in c && (g = !c.isOrthographic);
            var m = this.getOrthographicHeight();
            "orthographicHeight" in c && (m = Number(c.orthographicHeight));
            this.restoreCameraState({
                position: a,
                target: k,
                up: b,
                worldup: n,
                aspect: f.impl.camera.aspect,
                fov: l,
                orthoScale: m,
                isPerspective: g
            }, d)
        }
        if (a = h.renderOptions) {
            g = f.prefs.ambientShadows;
            c = f.prefs.antialiasing;
            if (k = a.ambientOcclusion)
                "enabled" in k && (g = k.enabled),
                b = "radius" in k ? k.radius : null ,
                k = "intensity" in k ? k.intensity : null ,
                null  !== b && null  !== k && (f.impl.renderer().setAOOptions(b, k),
                f.impl.renderer().composeFinalFrame(!1));
            "environment" in a && (b = this.getLightPresetIndex(a.environment),
            -1 !== b && f.setLightPreset(b));
            if (k = a.toneMap)
                b = "lightMultiplier" in k ? k.lightMultiplier : 
                null ,
                k = "exposure" in k ? k.exposure : null ,
                null  !== b && null  !== k && (f.impl.dir_light1 && (f.impl.dir_light1.intensity = Math.pow(2, b)),
                f.impl.renderer().setTonemapExposureBias(k, b),
                f.impl.invalidate(!0));
            if (a = a.appearance)
                "antiAliasing" in a && (c = a.antiAliasing),
                "progressiveDisplay" in a && f.setProgressiveRendering(a.progressiveDisplay),
                "ghostHidden" in a && f.setGhosting(a.ghostHidden),
                "displayLines" in a && f.hideLines(!a.displayLines);
            f.setQualityLevel(g, c)
        }
        if (Array.isArray(h.cutplanes) && f.model && !f.model.is2d()) {
            g = 
            [];
            for (c = 0; c < h.cutplanes.length; c++)
                a = h.cutplanes[c],
                Array.isArray(a) && 4 <= a.length && g.push(new THREE.Vector4(a[0],a[1],a[2],a[3]));
            f.setCutPlanes(g)
        }
        for (var q in f.loadedExtensions)
            f.loadedExtensions[q].restoreState(h, d);
        return !0
    }
    ;
    this.restoreCameraState = function(h, g) {
        f.impl.adjustOrthoCamera(h);
        var d = f.navigation;
        g ? (h.isPerspective ? d.toPerspective() : d.toOrthographic(),
        d.setCameraUpVector(h.up),
        d.setWorldUpVector(h.worldup),
        d.setView(h.position, h.target),
        d.setPivotPoint(h.target),
        d.setVerticalFov(h.fov, 
        !1),
        f.impl.syncCamera(!0)) : (f.impl.camera.isPerspective = h.isPerspective,
        d.setRequestTransitionWithUp(!0, h.position, h.target, h.fov, h.up, h.worldup))
    }
    ;
    this.toIntArray = function(f) {
        var g = [];
        if (Array.isArray(f))
            for (var d = 0, c = f.length; d < c; ++d)
                g.push(parseInt(f[d]));
        return g
    }
    ;
    this.extractSelectedNodeIds = function(f) {
        return f && Array.isArray(f.objectSet) && 0 < f.objectSet.length ? this.toIntArray(f.objectSet[0].id) : []
    }
    ;
    this.extractIsolatedNodeIds = function(f) {
        return f && Array.isArray(f.objectSet) && 0 < f.objectSet.length ? 
        this.toIntArray(f.objectSet[0].isolated) : []
    }
    ;
    this.getVector3FromArray = function(f, g) {
        return f instanceof Array && 2 < f.length ? (f[0] = parseFloat(f[0]),
        f[1] = parseFloat(f[1]),
        f[2] = parseFloat(f[2]),
        (new THREE.Vector3).fromArray(f)) : g
    }
    ;
    this.getSelectedNodes = function() {
        return f.impl && f.impl.selector ? f.impl.selector.getSelection() : []
    }
    ;
    this.getVisibleLayers2d = function() {
        var h = [], g = f.impl.matman(), d = g.layersMap, c;
        for (c in d)
            d.hasOwnProperty(c) && g.isLayerVisible(c) && h.push(c);
        return h
    }
    ;
    this.getAspectRatio = function() {
        var h = 
        f.navigation.getScreenViewport();
        return h.width / h.height
    }
    ;
    this.getOrthographicHeight = function() {
        var h = f.navigation.getCamera();
        return h.isPerspective ? 0 : Math.abs(2 * h.orthographicCamera.top)
    }
    ;
    this.getSeedUrn = function() {
        return f.model.loader.svfUrn
    }
    ;
    this.getTransformsOverrides = function() {
        return {
            transformations: []
        }
    }
    ;
    this.getToneMapIntensity = function() {
        var h = 0;
        f.impl.dir_light1 && (h = 0 != f.impl.dir_light1.intensity ? Math.log(f.impl.dir_light1.intensity) / Math.log(2) : -1E-20);
        return h
    }
    ;
    this.getLightPresetIndex = 
    function(f) {
        for (var g = Teratek.Viewing.Private, d = 0; d < g.LightPresets.length; d++)
            if (g.LightPresets[d].name === f)
                return d;
        return -1
    }
    ;
    this.applyFilter = function(f, g) {
        if (!0 !== g)
            for (var d in f)
                if (f.hasOwnProperty(d)) {
                    var c = g[d];
                    void 0 === c ? (delete f[d],
                    stderr("[applyFilter] C - skipping key [" + d + "] from viewerState; unspecified in filter.")) : "boolean" === typeof c ? !1 === c && (delete f[d],
                    stderr("[applyFilter] D - skipping key [" + d + "] from viewerState; explicit filtering.")) : c instanceof Object ? f[d] instanceof Object ? 
                    this.applyFilter(f[d], g[d]) : stderr("[applyFilter] A - Invalid filter Object for key [" + d + "]") : stderr("[applyFilter] B - Invalid filter value for key [" + d + "]")
                }
    }
}
;
Teratek.Viewing.Private.ViewerState.prototype.constructor = Teratek.Viewing.Private.ViewerState;
TeratekNamespace("Teratek.Viewing.i18n");
(function() {
    function f(a, b) {
        if (!b || "function" === typeof b)
            return a;
        for (var c in b)
            a[c] = b[c];
        return a
    }
    function h(a, b, c) {
        var d, f = 0, g = a.length, h = void 0 === g || "[object Array]" !== Object.prototype.toString.apply(a) || "function" === typeof a;
        if (c)
            if (h)
                for (d in a) {
                    if (!1 === b.apply(a[d], c))
                        break
                }
            else
                for (; f < g && !1 !== b.apply(a[f++], c); )
                    ;
        else if (h)
            for (d in a) {
                if (!1 === b.call(a[d], d, a[d]))
                    break
            }
        else
            for (; f < g && !1 !== b.call(a[f], f, a[f++]); )
                ;
        return a
    }
    function g(a) {
        var b = function(a) {
            if (window.XMLHttpRequest)
                return a(null , 
                new XMLHttpRequest);
            if (window.ActiveXObject)
                try {
                    return a(null , new ActiveXObject("Msxml2.XMLHTTP"))
                } catch (b) {
                    return a(null , new ActiveXObject("Microsoft.XMLHTTP"))
                }
            return a(Error())
        }
          , c = function(a) {
            if ("string" === typeof a)
                return a;
            var b = [], c;
            for (c in a)
                a.hasOwnProperty(c) && b.push(encodeURIComponent(c) + "=" + encodeURIComponent(a[c]));
            return b.join("&")
        }
          , d = function() {
            for (var a = arguments[0], b = 1; b < arguments.length; b++) {
                var c = arguments[b], d;
                for (d in c)
                    c.hasOwnProperty(d) && (a[d] = c[d])
            }
            return a
        }
          , f = function(a, 
        g, h, k) {
            "function" === typeof h && (k = h,
            h = {});
            h.doNotCache = h.doNotCache || !1;
            h.data = h.data || {};
            h.headers = h.headers || {};
            h.jsonp = h.jsonp || !1;
            h.async = void 0 === h.async ? !0 : h.async;
            var l = d({
                accept: "*/*",
                "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
            }, f.headers, h.headers), m;
            m = "application/json" === l["content-type"] ? JSON.stringify(h.data) : c(h.data);
            if ("GET" === a) {
                var n = [];
                m && (n.push(m),
                m = null );
                h.doNotCache && n.push("_=" + (new Date).getTime());
                h.jsonp && (n.push("callback=" + h.jsonp),
                n.push("jsonp=" + 
                h.jsonp));
                n = n.join("&");
                1 < n.length && (g = -1 < g.indexOf("?") ? g + ("&" + n) : g + ("?" + n));
                if (h.jsonp) {
                    var n = document.getElementsByTagName("head")[0]
                      , q = document.createElement("script");
                    q.type = "text/javascript";
                    q.src = g;
                    n.appendChild(q);
                    return
                }
            }
            b(function(b, c) {
                if (b)
                    return k(b);
                c.open(a, g, h.async);
                for (var d in l)
                    l.hasOwnProperty(d) && c.setRequestHeader(d, l[d]);
                c.onreadystatechange = function() {
                    if (4 === c.readyState) {
                        var a = c.responseText || "";
                        k && k(c.status, a)
                    }
                }
                ;
                c.send(m)
            }
            )
        }
        ;
        ({
            authBasic: function(a, b) {
                var c = f.headers, d;
                d = 
                a + ":" + b;
                d = d.replace(/\r\n/g, "\n");
                for (var g = "", h = 0; h < d.length; h++) {
                    var k = d.charCodeAt(h);
                    128 > k ? g += String.fromCharCode(k) : (127 < k && 2048 > k ? g += String.fromCharCode(k >> 6 | 192) : (g += String.fromCharCode(k >> 12 | 224),
                    g += String.fromCharCode(k >> 6 & 63 | 128)),
                    g += String.fromCharCode(k & 63 | 128))
                }
                d = g;
                var g = "", l, m, n, q, r = 0;
                do
                    l = d.charCodeAt(r++),
                    h = d.charCodeAt(r++),
                    k = d.charCodeAt(r++),
                    m = l >> 2,
                    l = (l & 3) << 4 | h >> 4,
                    n = (h & 15) << 2 | k >> 6,
                    q = k & 63,
                    isNaN(h) ? n = q = 64 : isNaN(k) && (q = 64),
                    g += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(m) + 
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(l) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(n) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(q);
                while (r < d.length);c.Authorization = "Basic " + g
            },
            connect: function(a, b, c) {
                return f("CONNECT", a, b, c)
            },
            del: function(a, b, c) {
                return f("DELETE", a, b, c)
            },
            get: function(a, b, c) {
                return f("GET", a, b, c)
            },
            head: function(a, b, c) {
                return f("HEAD", a, b, c)
            },
            headers: function(a) {
                f.headers = a || {}
            },
            isAllowed: function(a, b, c) {
                this.options(a, function(a, d) {
                    c(-1 !== d.text().indexOf(b))
                }
                )
            },
            options: function(a, b, c) {
                return f("OPTIONS", a, b, c)
            },
            patch: function(a, b, c) {
                return f("PATCH", a, b, c)
            },
            post: function(a, b, c) {
                return f("POST", a, b, c)
            },
            put: function(a, b, c) {
                return f("PUT", a, b, c)
            },
            trace: function(a, b, c) {
                return f("TRACE", a, b, c)
            }
        })[a.type ? a.type.toLowerCase() : "get"](a.url, a, function(b, c) {
            200 === b ? a.success(c, b, null ) : a.error(c, b, null )
        }
        )
    }
    function d(a, b) {
        "function" === typeof a && (b = a,
        a = {});
        a = a || {};
        I.extend(v, a);
        delete v.fixLng;
        "string" == typeof v.ns && (v.ns = {
            namespaces: [v.ns],
            defaultNs: v.ns
        });
        "string" == typeof v.fallbackNS && (v.fallbackNS = [v.fallbackNS]);
        if ("string" == typeof v.fallbackLng || "boolean" == typeof v.fallbackLng)
            v.fallbackLng = [v.fallbackLng];
        v.interpolationPrefixEscaped = I.regexEscape(v.interpolationPrefix);
        v.interpolationSuffixEscaped = I.regexEscape(v.interpolationSuffix);
        v.lng || (v.lng = I.detectLanguage());
        v.lng ? v.useCookie && I.cookie.create(v.cookieName, v.lng, v.cookieExpirationTime, v.cookieDomain) : (v.lng = v.fallbackLng[0],
        v.useCookie && I.cookie.remove(v.cookieName));
        G = I.toLanguages(v.lng);
        C = G[0];
        I.log("currentLng set to: " + C);
        var c = l;
        a.fixLng && (c = function(a, b) {
            b = b || {};
            b.lng = b.lng || c.lng;
            return l(a, b)
        }
        ,
        c.lng = C);
        L.setCurrentLng(C);
        if (v.resStore)
            w = v.resStore,
            B = !0,
            b && b(c);
        else {
            var d = I.toLanguages(v.lng);
            "string" === typeof v.preload && (v.preload = [v.preload]);
            for (var f = 0, g = v.preload.length; f < g; f++)
                for (var h = I.toLanguages(v.preload[f]), k = 0, m = h.length; k < m; k++)
                    0 > d.indexOf(h[k]) && d.push(h[k]);
            Teratek.Viewing.i18n.sync.load(d, 
            v, function(a, d) {
                w = d;
                B = !0;
                b && b(c)
            }
            )
        }
    }
    function c(a, b) {
        var c = {
            dynamicLoad: v.dynamicLoad,
            resGetPath: v.resGetPath,
            getAsync: v.getAsync,
            customLoad: v.customLoad,
            ns: {
                namespaces: a,
                defaultNs: ""
            }
        }
          , d = I.toLanguages(v.lng);
        "string" === typeof v.preload && (v.preload = [v.preload]);
        for (var f = 0, g = v.preload.length; f < g; f++)
            for (var h = I.toLanguages(v.preload[f]), k = 0, l = h.length; k < l; k++)
                0 > d.indexOf(h[k]) && d.push(h[k]);
        for (var m = [], f = 0, g = d.length; f < g; f++) {
            h = !1;
            if (k = w[d[f]])
                for (var l = 0, n = a.length; l < n; l++)
                    k[a[l]] || (h = !0);
            else
                h = 
                !0;
            h && m.push(d[f])
        }
        m.length ? t.sync._fetch(m, c, function(c, d) {
            var f = a.length * m.length;
            I.each(a, function(a, c) {
                0 > v.ns.namespaces.indexOf(c) && v.ns.namespaces.push(c);
                I.each(m, function(a, g) {
                    w[g] = w[g] || {};
                    w[g][c] = d[g][c];
                    f--;
                    0 === f && b && (v.useLocalStorage && t.sync._storeLocal(w),
                    b())
                }
                )
            }
            )
        }
        ) : b && b()
    }
    function a(b, c, d, f) {
        if (!b)
            return b;
        f = f || c;
        if (0 > b.indexOf(f.interpolationPrefix || v.interpolationPrefix))
            return b;
        var g = f.interpolationPrefix ? I.regexEscape(f.interpolationPrefix) : v.interpolationPrefixEscaped
          , h = f.interpolationSuffix ? 
        I.regexEscape(f.interpolationSuffix) : v.interpolationSuffixEscaped
          , k = "HTML" + h;
        I.each(c, function(c, l) {
            var m = d ? d + v.keyseparator + c : c;
            "object" === typeof l && null  !== l ? b = a(b, l, m, f) : f.escapeInterpolation || v.escapeInterpolation ? (b = b.replace(new RegExp([g, m, k].join(""),"g"), l),
            b = b.replace(new RegExp([g, m, h].join(""),"g"), I.escape(l))) : b = b.replace(new RegExp([g, m, h].join(""),"g"), l)
        }
        );
        return b
    }
    function b(a, b) {
        var c = I.extend({}, b);
        for (delete c.postProcess; -1 != a.indexOf(v.reusePrefix); ) {
            E++;
            if (E > v.maxRecursion)
                break;
            var d = a.lastIndexOf(v.reusePrefix)
              , f = a.indexOf(v.reuseSuffix, d) + v.reuseSuffix.length
              , d = a.substring(d, f)
              , f = d.replace(v.reusePrefix, "").replace(v.reuseSuffix, "");
            if (-1 != f.indexOf(",")) {
                var g = f.indexOf(",");
                if (-1 != f.indexOf("{", g) && -1 != f.indexOf("}", g)) {
                    var h = f.indexOf("{", g)
                      , k = f.indexOf("}", h) + 1;
                    try {
                        c = I.extend(c, JSON.parse(f.substring(h, k))),
                        f = f.substring(0, g)
                    } catch (l) {}
                }
            }
            f = m(f, c);
            a = a.replace(d, f)
        }
        return a
    }
    function k(a, b) {
        b = b || {};
        var c = void 0 !== b.defaultValue ? b.defaultValue : a
          , d = q(a, b);
        return void 0 !== 
        d || d === c
    }
    function l(b, c) {
        c = c || {};
        if (!B) {
            I.log("i18next not finished initialization. you might have called t function before loading resources finished.");
            var d = b.indexOf(":");
            0 > d ? d = 0 : d++;
            (d = c.defaultValue || b.substr(d)) && (d = a(d, c));
            return d
        }
        E = 0;
        return m.apply(null , arguments)
    }
    function n() {
        for (var a = [], b = 1; b < arguments.length; b++)
            a.push(arguments[b]);
        return {
            postProcess: "sprintf",
            sprintf: a
        }
    }
    function m(c, d) {
        d && "object" !== typeof d ? "sprintf" === v.shortcutFunction ? d = n.apply(null , arguments) : "defaultValue" === 
        v.shortcutFunction && (d = {
            defaultValue: d
        }) : d = d || {};
        if (void 0 === c || null  === c)
            return "";
        "string" == typeof c && (c = [c]);
        var f = c[0];
        if (1 < c.length)
            for (var g = 0; g < c.length && (f = c[g],
            !k(f, d)); g++)
                ;
        var g = void 0 !== d.defaultValue ? d.defaultValue : f, h = q(f, d), l = d.lng ? I.toLanguages(d.lng) : G, m = d.ns || v.ns.defaultNs, r;
        -1 < f.indexOf(v.nsseparator) && (r = f.split(v.nsseparator),
        m = r[0],
        f = r[1]);
        void 0 === h && v.sendMissing && (d.lng ? J.postMissing(l[0], m, f, g, l) : J.postMissing(v.lng, m, f, g, l));
        l = d.postProcess || v.postProcess;
        void 0 !== h && l && 
        F[l] && (h = F[l](h, f, d));
        r = g;
        -1 < g.indexOf(v.nsseparator) && (r = g.split(v.nsseparator),
        r = r[1]);
        r === f && v.parseMissingKey && (g = v.parseMissingKey(g));
        void 0 === h && (g = a(g, d),
        g = b(g, d),
        l && F[l] && (h = F[l](void 0 !== d.defaultValue ? d.defaultValue : f, f, d)));
        return void 0 !== h ? h : g
    }
    function q(c, d) {
        d = d || {};
        var f, g = void 0 !== d.defaultValue ? d.defaultValue : c, h = G;
        if (!w || "cimode" === h[0].toLowerCase())
            return g;
        if (d.lng && (h = I.toLanguages(d.lng),
        !w[h[0]])) {
            var k = v.getAsync;
            v.getAsync = !1;
            Teratek.Viewing.i18n.sync.load(h, v, function(a, 
            b) {
                I.extend(w, b);
                v.getAsync = k
            }
            )
        }
        var n = d.ns || v.ns.defaultNs;
        -1 < c.indexOf(v.nsseparator) && (f = c.split(v.nsseparator),
        n = f[0],
        c = f[1]);
        if (d.context && ("string" == typeof d.context || "number" == typeof d.context) && (f = I.extend({}, d),
        delete f.context,
        f.defaultValue = v.contextNotFound,
        f = l(n + v.nsseparator + c + "_" + d.context, f),
        f != v.contextNotFound))
            return a(f, {
                context: d.context
            });
        if (void 0 !== d.count && "string" != typeof d.count && 1 !== d.count) {
            f = I.extend({}, d);
            delete f.count;
            f.defaultValue = v.pluralNotFound;
            var r = n + v.nsseparator + 
            c + v.pluralSuffix
              , B = L.get(h[0], d.count);
            0 <= B ? r = r + "_" + B : 1 === B && (r = n + v.nsseparator + c);
            f = l(r, f);
            if (f != v.pluralNotFound)
                return a(f, {
                    count: d.count,
                    interpolationPrefix: d.interpolationPrefix,
                    interpolationSuffix: d.interpolationSuffix
                })
        }
        var z;
        f = c.split(v.keyseparator);
        r = 0;
        for (B = h.length; r < B && void 0 === z; r++) {
            for (var t = h[r], D = 0, F = w[t] && w[t][n]; f[D]; )
                F = F && F[f[D]],
                D++;
            if (void 0 !== F) {
                z = Object.prototype.toString.apply(F);
                if ("string" === typeof F)
                    F = a(F, d),
                    F = b(F, d);
                else if ("[object Array]" === z && !v.returnObjectTrees && 
                !d.returnObjectTrees)
                    F = F.join("\n"),
                    F = a(F, d),
                    F = b(F, d);
                else if (null  === F && !0 === v.fallbackOnNull)
                    F = void 0;
                else if (null  !== F)
                    if (!v.returnObjectTrees && !d.returnObjectTrees)
                        v.objectTreeKeyHandler && "function" == typeof v.objectTreeKeyHandler ? F = v.objectTreeKeyHandler(c, F, t, n, d) : (F = "key '" + n + ":" + c + " (" + t + ")' returned an object instead of string.",
                        I.log(F));
                    else if ("[object Number]" !== z && "[object Function]" !== z && "[object RegExp]" !== z) {
                        var C = "[object Array]" === z ? [] : {};
                        I.each(F, function(a) {
                            C[a] = m(n + v.nsseparator + 
                            c + v.keyseparator + a, d)
                        }
                        );
                        F = C
                    }
                "string" === typeof F && "" === F.trim() && !0 === v.fallbackOnEmpty && (F = void 0);
                z = F
            }
        }
        if (void 0 === z && !d.isFallbackLookup && (!0 === v.fallbackToDefaultNS || v.fallbackNS && 0 < v.fallbackNS.length))
            if (d.isFallbackLookup = !0,
            v.fallbackNS.length)
                for (h = 0,
                f = v.fallbackNS.length; h < f; h++) {
                    if (z = q(v.fallbackNS[h] + v.nsseparator + c, d))
                        if (r = -1 < z.indexOf(v.nsseparator) ? z.split(v.nsseparator)[1] : z,
                        B = -1 < g.indexOf(v.nsseparator) ? g.split(v.nsseparator)[1] : g,
                        r !== B)
                            break
                }
            else
                z = q(c, d);
        return z
    }
    Array.prototype.indexOf || 
    (Array.prototype.indexOf = function(a) {
        if (null  == this)
            throw new TypeError;
        var b = Object(this)
          , c = b.length >>> 0;
        if (0 === c)
            return -1;
        var d = 0;
        0 < arguments.length && (d = Number(arguments[1]),
        d != d ? d = 0 : 0 != d && Infinity != d && -Infinity != d && (d = (0 < d || -1) * Math.floor(Math.abs(d))));
        if (d >= c)
            return -1;
        for (d = 0 <= d ? d : Math.max(c - Math.abs(d), 0); d < c; d++)
            if (d in b && b[d] === a)
                return d;
        return -1
    }
    );
    Array.prototype.lastIndexOf || (Array.prototype.lastIndexOf = function(a) {
        if (null  == this)
            throw new TypeError;
        var b = Object(this)
          , c = b.length >>> 0;
        if (0 === 
        c)
            return -1;
        var d = c;
        1 < arguments.length && (d = Number(arguments[1]),
        d != d ? d = 0 : 0 != d && d != 1 / 0 && d != -(1 / 0) && (d = (0 < d || -1) * Math.floor(Math.abs(d))));
        for (c = 0 <= d ? Math.min(d, c - 1) : c - Math.abs(d); 0 <= c; c--)
            if (c in b && b[c] === a)
                return c;
        return -1
    }
    );
    "function" !== typeof String.prototype.trim && (String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g, "")
    }
    );
    var r = this.jQuery || this.Zepto, t = {}, w = {}, C, E = 0, G = [], B = !1;
    "undefined" !== typeof module && module.exports ? module.exports = t : (r && (r.i18n = r.i18n || t),
    this.i18n = this.i18n || 
    t);
    var v = {
        lng: void 0,
        load: "current",
        preload: [],
        lowerCaseLng: !1,
        returnObjectTrees: !1,
        fallbackLng: ["dev"],
        fallbackNS: [],
        detectLngQS: "setLng",
        ns: "translation",
        fallbackOnNull: !0,
        fallbackOnEmpty: !1,
        fallbackToDefaultNS: !1,
        nsseparator: ":",
        keyseparator: ".",
        selectorAttr: "data-i18n",
        debug: !1,
        resGetPath: "res/locales/__lng__/__ns__.json",
        resPostPath: "res/locales/add/__lng__/__ns__",
        getAsync: !0,
        postAsync: !0,
        resStore: void 0,
        useLocalStorage: !1,
        localStorageExpirationTime: 6048E5,
        dynamicLoad: !1,
        sendMissing: !1,
        sendMissingTo: "fallback",
        sendType: "POST",
        interpolationPrefix: "__",
        interpolationSuffix: "__",
        reusePrefix: "$t(",
        reuseSuffix: ")",
        pluralSuffix: "_plural",
        pluralNotFound: ["plural_not_found", Math.random()].join(""),
        contextNotFound: ["context_not_found", Math.random()].join(""),
        escapeInterpolation: !1,
        defaultValueFromContent: !0,
        useDataAttrOptions: !1,
        cookieExpirationTime: void 0,
        useCookie: !0,
        cookieName: "i18next",
        cookieDomain: void 0,
        objectTreeKeyHandler: void 0,
        postProcess: void 0,
        parseMissingKey: void 0,
        shortcutFunction: "sprintf"
    }
      , D = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;"
    }
      , z = {
        create: function(a, b, c, d) {
            if (c) {
                var f = new Date;
                f.setTime(f.getTime() + 6E4 * c);
                c = "; expires=" + f.toGMTString()
            } else
                c = "";
            document.cookie = a + "=" + b + c + ";" + (d ? "domain=" + d + ";" : "") + "path=/"
        },
        read: function(a) {
            a += "=";
            for (var b = document.cookie.split(";"), c = 0; c < b.length; c++) {
                for (var d = b[c]; " " == d.charAt(0); )
                    d = d.substring(1, d.length);
                if (0 === d.indexOf(a))
                    return d.substring(a.length, d.length)
            }
            return null 
        },
        remove: function(a) {
            this.create(a, "", -1)
        }
    }
      , H = {
        create: function(a, 
        b, c, d) {},
        read: function(a) {
            return null 
        },
        remove: function(a) {}
    }
      , I = {
        extend: r ? r.extend : f,
        each: r ? r.each : h,
        ajax: r ? r.ajax : "undefined" !== typeof document ? g : function() {}
        ,
        cookie: "undefined" !== typeof document ? z : H,
        detectLanguage: function() {
            var a, b = [];
            if ("undefined" !== typeof window) {
                for (var c = window.location.search.substring(1).split("&"), d = 0; d < c.length; d++) {
                    var f = c[d].indexOf("=");
                    if (0 < f) {
                        var g = c[d].substring(0, f)
                          , f = c[d].substring(f + 1);
                        b[g] = f
                    }
                }
                b[v.detectLngQS] && (a = b[v.detectLngQS])
            }
            !a && "undefined" !== typeof document && 
            v.useCookie && (b = I.cookie.read(v.cookieName)) && (a = b);
            a || "undefined" === typeof navigator || (a = navigator.language ? navigator.language : navigator.userLanguage);
            return a
        },
        escape: function(a) {
            return "string" === typeof a ? a.replace(/[&<>"'\/]/g, function(a) {
                return D[a]
            }
            ) : a
        },
        log: function(a) {
            v.debug && "undefined" !== typeof console && console.log(a)
        },
        toLanguages: function(a) {
            var b = [];
            if ("string" === typeof a && -1 < a.indexOf("-")) {
                var c = a.split("-");
                a = v.lowerCaseLng ? c[0].toLowerCase() + "-" + c[1].toLowerCase() : c[0].toLowerCase() + 
                "-" + c[1].toUpperCase();
                "unspecific" !== v.load && b.push(a);
                "current" !== v.load && b.push(c[0])
            } else
                b.push(a);
            for (a = 0; a < v.fallbackLng.length; a++)
                -1 === b.indexOf(v.fallbackLng[a]) && v.fallbackLng[a] && b.push(v.fallbackLng[a]);
            return b
        },
        regexEscape: function(a) {
            return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
        }
    };
    I.applyReplacement = a;
    var J = {
        load: function(a, b, c) {
            b.useLocalStorage ? J._loadLocal(a, b, function(d, f) {
                for (var g = [], h = 0, k = a.length; h < k; h++)
                    f[a[h]] || g.push(a[h]);
                0 < g.length ? J._fetch(g, b, function(a, 
                b) {
                    I.extend(f, b);
                    J._storeLocal(b);
                    c(null , f)
                }
                ) : c(null , f)
            }
            ) : J._fetch(a, b, function(a, b) {
                c(null , b)
            }
            )
        },
        _loadLocal: function(a, b, c) {
            var d = {}
              , f = (new Date).getTime();
            if (window.localStorage) {
                var g = a.length;
                I.each(a, function(a, h) {
                    var k = window.localStorage.getItem("res_" + h);
                    k && (k = JSON.parse(k),
                    k.i18nStamp && k.i18nStamp + b.localStorageExpirationTime > f && (d[h] = k));
                    g--;
                    0 === g && c(null , d)
                }
                )
            }
        },
        _storeLocal: function(a) {
            if (window.localStorage)
                for (var b in a)
                    a[b].i18nStamp = (new Date).getTime(),
                    window.localStorage.setItem("res_" + 
                    b, JSON.stringify(a[b]))
        },
        _fetch: function(b, c, d) {
            var f = c.ns
              , g = {};
            if (c.dynamicLoad) {
                var h = function(a, b) {
                    d(null , b)
                }
                ;
                if ("function" == typeof c.customLoad)
                    c.customLoad(b, f.namespaces, c, h);
                else {
                    var k = a(c.resGetPath, {
                        lng: b.join("+"),
                        ns: f.namespaces.join("+")
                    })
                      , k = Teratek.Viewing.Private.getResourceUrl(k);
                    I.ajax({
                        url: k,
                        success: function(a, b, c) {
                            I.log("loaded: " + k);
                            a = a.json();
                            d(null , a)
                        },
                        error: function(a, b, c) {
                            I.log("failed loading: " + k);
                            d(null , void 0)
                        },
                        dataType: "text",
                        async: c.getAsync
                    })
                }
            } else {
                var l = f.namespaces.length * 
                b.length, m;
                I.each(f.namespaces, function(a, f) {
                    I.each(b, function(a, b) {
                        var h = function(a, c) {
                            a && (m = m || [],
                            m.push(a));
                            g[b] = g[b] || {};
                            g[b][f] = c;
                            l--;
                            0 === l && d(m, g)
                        }
                        ;
                        "function" == typeof c.customLoad ? c.customLoad(b, f, c, h) : J._fetchOne(b, f, c, h)
                    }
                    )
                }
                )
            }
        },
        _fetchOne: function(b, c, d, f) {
            var g = a(d.resGetPath, {
                lng: b,
                ns: c
            })
              , g = Teratek.Viewing.Private.getResourceUrl(g);
            I.ajax({
                url: g,
                success: function(a, b, c) {
                    I.log("loaded: " + g);
                    for (var d = !1, h = !1, k = "", l = 0; l < a.length; l++)
                        if (b = a[l],
                        c = a[l + 1],
                        h || "\\" === a[l - 1] || '"' !== b || (d = !d),
                        d)
                            k += 
                            b;
                        else {
                            if (!h && "//" === b + c)
                                h = "single",
                                l++;
                            else if ("single" === h && "\r\n" === b + c)
                                h = !1,
                                l++;
                            else if ("single" === h && "\n" === b)
                                h = !1;
                            else if (!h && "/*" === b + c) {
                                h = "multi";
                                l++;
                                continue
                            } else if ("multi" === h && "*/" === b + c) {
                                h = !1;
                                l++;
                                continue
                            }
                            h || (k += b)
                        }
                    f(null , JSON.parse(k))
                },
                error: function(a, b, c) {
                    b && 200 == b || a && a.status && 200 == a.status ? I.log("There is a typo in: " + g) : b && 404 == b || a && a.status && 404 == a.status ? I.log("Does not exist: " + g) : I.log((b ? b : a && a.status ? a.status : null ) + " when loading " + g);
                    f(c, {})
                },
                dataType: "text",
                async: d.getAsync
            })
        },
        postMissing: function(b, c, d, f, g) {
            var h = {};
            h[d] = f;
            var k = [];
            if ("fallback" === v.sendMissingTo && !1 !== v.fallbackLng[0])
                for (b = 0; b < v.fallbackLng.length; b++)
                    k.push({
                        lng: v.fallbackLng[b],
                        url: a(v.resPostPath, {
                            lng: v.fallbackLng[b],
                            ns: c
                        })
                    });
            else if ("current" === v.sendMissingTo || "fallback" === v.sendMissingTo && !1 === v.fallbackLng[0])
                k.push({
                    lng: b,
                    url: a(v.resPostPath, {
                        lng: b,
                        ns: c
                    })
                });
            else if ("all" === v.sendMissingTo) {
                b = 0;
                for (var l = g.length; b < l; b++)
                    k.push({
                        lng: g[b],
                        url: a(v.resPostPath, {
                            lng: g[b],
                            ns: c
                        })
                    })
            }
            g = 0;
            for (b = k.length; g < 
            b; g++) {
                var m = k[g];
                I.ajax({
                    url: m.url,
                    type: v.sendType,
                    data: h,
                    success: function(a, b, g) {
                        I.log("posted missing key '" + d + "' to: " + m.url);
                        a = d.split(".");
                        b = 0;
                        for (g = w[m.lng][c]; a[b]; )
                            g = b === a.length - 1 ? g[a[b]] = f : g[a[b]] = g[a[b]] || {},
                            b++
                    },
                    error: function(a, b, c) {
                        I.log("failed posting missing key '" + d + "' to: " + m.url)
                    },
                    dataType: "json",
                    async: v.postAsync
                })
            }
        }
    }
      , L = {
        rules: {
            ach: {
                name: "Acholi",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            af: {
                name: "Afrikaans",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ak: {
                name: "Akan",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            am: {
                name: "Amharic",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            an: {
                name: "Aragonese",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ar: {
                name: "Arabic",
                numbers: [0, 1, 2, 3, 11, 100],
                plurals: function(a) {
                    return Number(0 === a ? 0 : 1 == a ? 1 : 2 == a ? 2 : 3 <= a % 100 && 10 >= a % 100 ? 3 : 11 <= a % 100 ? 4 : 5)
                }
            },
            arn: {
                name: "Mapudungun",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            ast: {
                name: "Asturian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != 
                    a)
                }
            },
            ay: {
                name: "Aymar\u00e1",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            az: {
                name: "Azerbaijani",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            be: {
                name: "Belarusian",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a % 10 && 11 != a % 100 ? 0 : 2 <= a % 10 && 4 >= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            bg: {
                name: "Bulgarian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            bn: {
                name: "Bengali",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            bo: {
                name: "Tibetan",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            br: {
                name: "Breton",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            bs: {
                name: "Bosnian",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a % 10 && 11 != a % 100 ? 0 : 2 <= a % 10 && 4 >= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            ca: {
                name: "Catalan",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            cgg: {
                name: "Chiga",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            cs: {
                name: "Czech",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a ? 0 : 2 <= a && 4 >= a ? 1 : 2)
                }
            },
            csb: {
                name: "Kashubian",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == 
                    a ? 0 : 2 <= a % 10 && 4 >= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            cy: {
                name: "Welsh",
                numbers: [1, 2, 3, 8],
                plurals: function(a) {
                    return Number(1 == a ? 0 : 2 == a ? 1 : 8 != a && 11 != a ? 2 : 3)
                }
            },
            da: {
                name: "Danish",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            de: {
                name: "German",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            dz: {
                name: "Dzongkha",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            el: {
                name: "Greek",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            en: {
                name: "English",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != 
                    a)
                }
            },
            eo: {
                name: "Esperanto",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            es: {
                name: "Spanish",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            es_ar: {
                name: "Argentinean Spanish",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            et: {
                name: "Estonian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            eu: {
                name: "Basque",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            fa: {
                name: "Persian",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            fi: {
                name: "Finnish",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != 
                    a)
                }
            },
            fil: {
                name: "Filipino",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            fo: {
                name: "Faroese",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            fr: {
                name: "French",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            fur: {
                name: "Friulian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            fy: {
                name: "Frisian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ga: {
                name: "Irish",
                numbers: [1, 2, 3, 7, 11],
                plurals: function(a) {
                    return Number(1 == a ? 0 : 2 == a ? 1 : 7 > a ? 2 : 11 > a ? 3 : 4)
                }
            },
            gd: {
                name: "Scottish Gaelic",
                numbers: [1, 2, 3, 20],
                plurals: function(a) {
                    return Number(1 == a || 11 == a ? 0 : 2 == a || 12 == a ? 1 : 2 < a && 20 > a ? 2 : 3)
                }
            },
            gl: {
                name: "Galician",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            gu: {
                name: "Gujarati",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            gun: {
                name: "Gun",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            ha: {
                name: "Hausa",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            he: {
                name: "Hebrew",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            hi: {
                name: "Hindi",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != 
                    a)
                }
            },
            hr: {
                name: "Croatian",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a % 10 && 11 != a % 100 ? 0 : 2 <= a % 10 && 4 >= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            hu: {
                name: "Hungarian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            hy: {
                name: "Armenian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ia: {
                name: "Interlingua",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            id: {
                name: "Indonesian",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            is: {
                name: "Icelandic",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != 
                    a % 10 || 11 == a % 100)
                }
            },
            it: {
                name: "Italian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ja: {
                name: "Japanese",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            jbo: {
                name: "Lojban",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            jv: {
                name: "Javanese",
                numbers: [0, 1],
                plurals: function(a) {
                    return Number(0 !== a)
                }
            },
            ka: {
                name: "Georgian",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            kk: {
                name: "Kazakh",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            km: {
                name: "Khmer",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            kn: {
                name: "Kannada",
                numbers: [1, 
                2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ko: {
                name: "Korean",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            ku: {
                name: "Kurdish",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            kw: {
                name: "Cornish",
                numbers: [1, 2, 3, 4],
                plurals: function(a) {
                    return Number(1 == a ? 0 : 2 == a ? 1 : 3 == a ? 2 : 3)
                }
            },
            ky: {
                name: "Kyrgyz",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            lb: {
                name: "Letzeburgesch",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ln: {
                name: "Lingala",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            lo: {
                name: "Lao",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            lt: {
                name: "Lithuanian",
                numbers: [1, 2, 10],
                plurals: function(a) {
                    return Number(1 == a % 10 && 11 != a % 100 ? 0 : 2 <= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            lv: {
                name: "Latvian",
                numbers: [1, 2, 0],
                plurals: function(a) {
                    return Number(1 == a % 10 && 11 != a % 100 ? 0 : 0 !== a ? 1 : 2)
                }
            },
            mai: {
                name: "Maithili",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            mfe: {
                name: "Mauritian Creole",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            mg: {
                name: "Malagasy",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < 
                    a)
                }
            },
            mi: {
                name: "Maori",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            mk: {
                name: "Macedonian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 == a || 1 == a % 10 ? 0 : 1)
                }
            },
            ml: {
                name: "Malayalam",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            mn: {
                name: "Mongolian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            mnk: {
                name: "Mandinka",
                numbers: [0, 1, 2],
                plurals: function(a) {
                    return Number(1 == a ? 1 : 2)
                }
            },
            mr: {
                name: "Marathi",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ms: {
                name: "Malay",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            mt: {
                name: "Maltese",
                numbers: [1, 2, 11, 20],
                plurals: function(a) {
                    return Number(1 == a ? 0 : 0 === a || 1 < a % 100 && 11 > a % 100 ? 1 : 10 < a % 100 && 20 > a % 100 ? 2 : 3)
                }
            },
            nah: {
                name: "Nahuatl",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            nap: {
                name: "Neapolitan",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            nb: {
                name: "Norwegian Bokmal",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ne: {
                name: "Nepali",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            nl: {
                name: "Dutch",
                numbers: [1, 
                2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            nn: {
                name: "Norwegian Nynorsk",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            no: {
                name: "Norwegian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            nso: {
                name: "Northern Sotho",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            oc: {
                name: "Occitan",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            or: {
                name: "Oriya",
                numbers: [2, 1],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            pa: {
                name: "Punjabi",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != 
                    a)
                }
            },
            pap: {
                name: "Papiamento",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            pl: {
                name: "Polish",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a ? 0 : 2 <= a % 10 && 4 >= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            pms: {
                name: "Piemontese",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ps: {
                name: "Pashto",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            pt: {
                name: "Portuguese",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            pt_br: {
                name: "Brazilian Portuguese",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != 
                    a)
                }
            },
            rm: {
                name: "Romansh",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ro: {
                name: "Romanian",
                numbers: [1, 2, 20],
                plurals: function(a) {
                    return Number(1 == a ? 0 : 0 === a || 0 < a % 100 && 20 > a % 100 ? 1 : 2)
                }
            },
            ru: {
                name: "Russian",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a % 10 && 11 != a % 100 ? 0 : 2 <= a % 10 && 4 >= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            sah: {
                name: "Yakut",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            sco: {
                name: "Scots",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            se: {
                name: "Northern Sami",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            si: {
                name: "Sinhala",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            sk: {
                name: "Slovak",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a ? 0 : 2 <= a && 4 >= a ? 1 : 2)
                }
            },
            sl: {
                name: "Slovenian",
                numbers: [5, 1, 2, 3],
                plurals: function(a) {
                    return Number(1 == a % 100 ? 1 : 2 == a % 100 ? 2 : 3 == a % 100 || 4 == a % 100 ? 3 : 0)
                }
            },
            so: {
                name: "Somali",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            son: {
                name: "Songhay",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            sq: {
                name: "Albanian",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            sr: {
                name: "Serbian",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a % 10 && 11 != a % 100 ? 0 : 2 <= a % 10 && 4 >= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            su: {
                name: "Sundanese",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            sv: {
                name: "Swedish",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            sw: {
                name: "Swahili",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            ta: {
                name: "Tamil",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            te: {
                name: "Telugu",
                numbers: [1, 
                2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            tg: {
                name: "Tajik",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            th: {
                name: "Thai",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            ti: {
                name: "Tigrinya",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            tk: {
                name: "Turkmen",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            tr: {
                name: "Turkish",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            tt: {
                name: "Tatar",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            ug: {
                name: "Uyghur",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            uk: {
                name: "Ukrainian",
                numbers: [1, 2, 5],
                plurals: function(a) {
                    return Number(1 == a % 10 && 11 != a % 100 ? 0 : 2 <= a % 10 && 4 >= a % 10 && (10 > a % 100 || 20 <= a % 100) ? 1 : 2)
                }
            },
            ur: {
                name: "Urdu",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            uz: {
                name: "Uzbek",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            vi: {
                name: "Vietnamese",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            wa: {
                name: "Walloon",
                numbers: [1, 2],
                plurals: function(a) {
                    return Number(1 < a)
                }
            },
            wo: {
                name: "Wolof",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            },
            yo: {
                name: "Yoruba",
                numbers: [1, 
                2],
                plurals: function(a) {
                    return Number(1 != a)
                }
            },
            zh: {
                name: "Chinese",
                numbers: [1],
                plurals: function(a) {
                    return 0
                }
            }
        },
        addRule: function(a, b) {
            L.rules[a] = b
        },
        setCurrentLng: function(a) {
            if (!L.currentRule || L.currentRule.lng !== a) {
                var b = a.split("-");
                L.currentRule = {
                    lng: a,
                    rule: L.rules[b[0]]
                }
            }
        },
        get: function(a, b) {
            var c = a.split("-");
            if (c = L.currentRule && L.currentRule.lng === a ? L.currentRule.rule : L.rules[c[0]]) {
                var d = c.plurals(b)
                  , d = c.numbers[d];
                2 === c.numbers.length && 1 === c.numbers[0] && (2 === d ? d = -1 : 1 === d && (d = 1));
                c = d
            } else
                c = 1 === 
                b ? "1" : "-1";
            return c
        }
    }
      , F = {}
      , r = function(a, b) {
        F[a] = b
    }
      , N = function() {
        function a(b) {
            return Object.prototype.toString.call(b).slice(8, -1).toLowerCase()
        }
        var b = function() {
            b.cache.hasOwnProperty(arguments[0]) || (b.cache[arguments[0]] = b.parse(arguments[0]));
            return b.format.call(null , b.cache[arguments[0]], arguments)
        }
        ;
        b.format = function(b, c) {
            var d = 1, f = b.length, g = "", h = [], k, l, m, n;
            for (k = 0; k < f; k++)
                if (g = a(b[k]),
                "string" === g)
                    h.push(b[k]);
                else if ("array" === g) {
                    m = b[k];
                    if (m[2])
                        for (g = c[d],
                        l = 0; l < m[2].length; l++) {
                            if (!g.hasOwnProperty(m[2][l]))
                                throw N('[sprintf] property "%s" does not exist', 
                                m[2][l]);
                            g = g[m[2][l]]
                        }
                    else
                        g = m[1] ? c[m[1]] : c[d++];
                    if (/[^s]/.test(m[8]) && "number" != a(g))
                        throw N("[sprintf] expecting number but found %s", a(g));
                    switch (m[8]) {
                    case "b":
                        g = g.toString(2);
                        break;
                    case "c":
                        g = String.fromCharCode(g);
                        break;
                    case "d":
                        g = parseInt(g, 10);
                        break;
                    case "e":
                        g = m[7] ? g.toExponential(m[7]) : g.toExponential();
                        break;
                    case "f":
                        g = m[7] ? parseFloat(g).toFixed(m[7]) : parseFloat(g);
                        break;
                    case "o":
                        g = g.toString(8);
                        break;
                    case "s":
                        g = (g = String(g)) && m[7] ? g.substring(0, m[7]) : g;
                        break;
                    case "u":
                        g = Math.abs(g);
                        break;
                    case "x":
                        g = g.toString(16);
                        break;
                    case "X":
                        g = g.toString(16).toUpperCase()
                    }
                    g = /[def]/.test(m[8]) && m[3] && 0 <= g ? "+" + g : g;
                    l = m[4] ? "0" == m[4] ? "0" : m[4].charAt(1) : " ";
                    n = m[6] - String(g).length;
                    if (m[6]) {
                        for (var q = []; 0 < n; q[--n] = l)
                            ;
                        l = q.join("")
                    } else
                        l = "";
                    h.push(m[5] ? g + l : l + g)
                }
            return h.join("")
        }
        ;
        b.cache = {};
        b.parse = function(a) {
            for (var b = [], c = [], d = 0; a; ) {
                if (null  !== (b = /^[^\x25]+/.exec(a)))
                    c.push(b[0]);
                else if (null  !== (b = /^\x25{2}/.exec(a)))
                    c.push("%");
                else if (null  !== (b = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(a))) {
                    if (b[2]) {
                        var d = 
                        d | 1
                          , f = []
                          , g = b[2]
                          , h = [];
                        if (null  !== (h = /^([a-z_][a-z_\d]*)/i.exec(g)))
                            for (f.push(h[1]); "" !== (g = g.substring(h[0].length)); )
                                if (null  !== (h = /^\.([a-z_][a-z_\d]*)/i.exec(g)))
                                    f.push(h[1]);
                                else if (null  !== (h = /^\[(\d+)\]/.exec(g)))
                                    f.push(h[1]);
                                else
                                    throw "[sprintf] huh?";
                        else
                            throw "[sprintf] huh?";
                        b[2] = f
                    } else
                        d |= 2;
                    if (3 === d)
                        throw "[sprintf] mixing positional and named placeholders is not (yet) supported";
                    c.push(b)
                } else
                    throw "[sprintf] huh?";
                a = a.substring(b[0].length)
            }
            return c
        }
        ;
        return b
    }
    ();
    r("sprintf", function(a, b, 
    c) {
        return c.sprintf ? "[object Array]" === Object.prototype.toString.apply(c.sprintf) ? (b = c.sprintf,
        b.unshift(a),
        N.apply(null , b)) : "object" === typeof c.sprintf ? N(a, c.sprintf) : a : a
    }
    );
    Teratek.Viewing.i18n.init = d;
    Teratek.Viewing.i18n.setLng = function(a, b, c) {
        "function" === typeof b ? (c = b,
        b = {}) : b || (b = {});
        b.lng = a;
        return d(b, c)
    }
    ;
    Teratek.Viewing.i18n.preload = function(a, b) {
        "string" === typeof a && (a = [a]);
        for (var c = 0, f = a.length; c < f; c++)
            0 > v.preload.indexOf(a[c]) && v.preload.push(a[c]);
        return d(b)
    }
    ;
    Teratek.Viewing.i18n.addResourceBundle = 
    function(a, b, c) {
        "string" !== typeof b ? (c = b,
        b = v.ns.defaultNs) : 0 > v.ns.namespaces.indexOf(b) && v.ns.namespaces.push(b);
        w[a] = w[a] || {};
        w[a][b] = w[a][b] || {};
        I.extend(w[a][b], c)
    }
    ;
    Teratek.Viewing.i18n.removeResourceBundle = function(a, b) {
        "string" !== typeof b && (b = v.ns.defaultNs);
        w[a] = w[a] || {};
        w[a][b] = {}
    }
    ;
    Teratek.Viewing.i18n.loadNamespace = function(a, b) {
        c([a], b)
    }
    ;
    Teratek.Viewing.i18n.loadNamespaces = c;
    Teratek.Viewing.i18n.localize = function() {
        Array.prototype.forEach.call(document.querySelectorAll("[data-i18n]"), 
        function(a) {
            var b, c, d = a.getAttribute("data-i18n").split(/\[|\]/);
            1 === d.length ? (c = null ,
            b = d[0]) : 3 === d.length && (c = d[1],
            b = d[2]);
            b = [c, b];
            c = b[0];
            b = b[1];
            (d = Teratek.Viewing.i18n.translate(b)) ? c ? a.setAttribute(c, d) : a.textContent = d : c ? a.setAttribute(c, b) : a.textContent = b
        }
        )
    }
    ;
    Teratek.Viewing.i18n.setDefaultNamespace = function(a) {
        v.ns.defaultNs = a
    }
    ;
    Teratek.Viewing.i18n.t = l;
    Teratek.Viewing.i18n.translate = l;
    Teratek.Viewing.i18n.exists = k;
    Teratek.Viewing.i18n.detectLanguage = I.detectLanguage;
    Teratek.Viewing.i18n.pluralExtensions = 
    L;
    Teratek.Viewing.i18n.sync = J;
    Teratek.Viewing.i18n.functions = I;
    Teratek.Viewing.i18n.lng = function() {
        return C
    }
    ;
    Teratek.Viewing.i18n.addPostProcessor = r;
    Teratek.Viewing.i18n.options = v
}
)();
(function() {
    var f = function(f, g, d, c) {
        this.kMinHeight = this.kMinWdth = 100;
        this.visibilityCallbacks = [];
        this.movedSinceLastClick = !1;
        this.parentContainer = f;
        this.container = document.createElement("div");
        this.container.id = g;
        this.container.lastWidth = "";
        this.container.dockRight = !1;
        this.container.dockBottom = !1;
        this.titleLabel = d;
        c = c || {};
        c.hasOwnProperty("localizeTitle") || (c.localizeTitle = !0);
        this.options = c;
        this.container.classList.add("dockingPanel");
        f.appendChild(this.container);
        this.listeners = [];
        this.initialize();
        this.setVisible(!1)
    }
    ;
    f.prototype.initialize = function() {
        this.title = this.createTitleBar(this.titleLabel || this.container.id);
        this.container.appendChild(this.title);
        this.initializeMoveHandlers(this.title);
        this.setTitle(this.titleLabel || this.container.id, this.options);
        this.closer = this.createCloseButton();
        this.container.appendChild(this.closer)
    }
    ;
    f.prototype.uninitialize = function() {
        for (var f = 0; f < this.listeners.length; ++f) {
            var g = this.listeners[f];
            g.target.removeEventListener(g.eventId, g.callback)
        }
        this.listeners = 
        [];
        this.visibilityCallbacks = [];
        this.parentContainer.removeChild(this.container);
        this.closer = this.title = this.container = this.parentContainer = null 
    }
    ;
    f.prototype.addVisibilityListener = function(f) {
        this.visibilityCallbacks.push(f)
    }
    ;
    f.prototype.setVisible = function(f) {
        if (f) {
            var g = this.getContainerBoundingRect();
            if (this.container.dockRight) {
                var d = g.width
                  , c = 300
                  , a = this.container.lastWidth || this.container.style.width;
                a || (a = this.container.getBoundingClientRect().width);
                a && (c = parseInt(a));
                this.container.style.left = 
                d - c + "px"
            }
            this.container.dockBottom && (d = g.height,
            c = 300,
            a = this.container.lastHeight || this.container.style.height,
            a || (a = this.container.getBoundingClientRect().height),
            a && (c = parseInt(a)),
            this.container.style.top = d - c + "px");
            this.container.style.maxHeight = g.height + "px";
            this.container.style.maxWidth = g.width + "px";
            this.container.style.display = "block"
        } else
            this.container.lastWidth = this.container.style.width,
            this.container.lastHeight = this.container.style.height,
            this.container.style.display = "none";
        for (g = 0; g < this.visibilityCallbacks.length; g++)
            this.visibilityCallbacks[g](f)
    }
    ;
    f.prototype.isVisible = function() {
        return "block" === this.container.style.display
    }
    ;
    f.prototype.visibilityChanged = function() {}
    ;
    f.prototype.initializeMoveHandlers = function(f) {
        function g(c) {
            var d = t.style.minWidth ? parseInt(t.style.minWidth) : w.kMinWdth
              , f = t.style.minHeight ? parseInt(t.style.minHeight) : w.kMinHeight
              , g = w.getContainerBoundingRect();
            t.style.maxWidth && parseInt(t.style.width) > parseInt(t.style.maxWidth) && (t.style.width = t.style.maxWidth);
            t.style.maxHeight && parseInt(t.style.height) > parseInt(t.style.maxHeight) && 
            (t.style.height = t.style.maxHeight);
            parseInt(t.style.width) < d && (t.style.width = d + "px");
            parseInt(t.style.height) < f && (t.style.height = f + "px");
            "touchmove" === c.type && (c.screenX = c.touches[0].screenX,
            c.screenY = c.touches[0].screenY);
            q += c.screenX - k;
            r += c.screenY - l;
            a = n + q;
            b = m + r;
            d = parseInt(t.style.width);
            f = parseInt(t.style.height);
            isNaN(d) && (d = w.container.getBoundingClientRect().width);
            isNaN(f) && (f = w.container.getBoundingClientRect().height);
            5 > a && (a = 0);
            5 > b && (b = 0);
            t.dockRight = !1;
            t.dockBottom = !1;
            g.width - 5 < a + d && (a = 
            g.width - d,
            t.dockRight = !0);
            g.height - 5 < b + f && (b = g.height - f,
            t.dockBottom = !0);
            t.style.left = a + "px";
            t.style.top = b + "px";
            t.style.maxWidth = g.width - a + "px";
            t.style.maxHeight = g.height - b + "px";
            k = c.screenX;
            l = c.screenY;
            w.onMove(c, a, b)
        }
        function d(c) {
            window.removeEventListener("mousemove", g);
            window.removeEventListener("mouseup", d);
            window.removeEventListener("touchmove", g);
            window.removeEventListener("touchend", d);
            w.onEndMove(c, a, b)
        }
        function c(a) {
            "touchstart" === a.type && (a.screenX = a.touches[0].screenX,
            a.screenY = a.touches[0].screenY);
            k = a.screenX;
            l = a.screenY;
            r = q = 0;
            n = w.container.offsetLeft;
            m = w.container.offsetTop;
            window.addEventListener("mousemove", g, !1);
            window.addEventListener("mouseup", d, !1);
            window.addEventListener("touchmove", g, !1);
            window.addEventListener("touchend", d, !1);
            a.preventDefault();
            w.onStartMove(a, n, m)
        }
        var a, b, k, l, n, m, q, r, t = this.container, w = this;
        w.addEventListener(f, "mousedown", c);
        w.addEventListener(f, "touchstart", c)
    }
    ;
    f.prototype.initializeCloseHandler = function(f) {
        var g = this;
        g.addEventListener(f, "click", function(d) {
            g.setVisible(!1)
        }
        , 
        !1)
    }
    ;
    f.prototype.createScrollContainer = function(f) {
        var g = document.createElement("div")
          , d = g.classList;
        d.add("dockingPanelScroll");
        d.add(f && f.left ? "left" : "right");
        f && f.heightAdjustment && (g.style.height = "calc(100% - " + f.heightAdjustment + "px)");
        f.marginTop && (g.style.marginTop = f.marginTop + "px");
        g.id = this.container.id + "-scroll-container";
        this.container.appendChild(g);
        return this.scrollContainer = g
    }
    ;
    f.prototype.createTitleBar = function(f) {
        var g = document.createElement("div");
        g.className = "dockingPanelTitle";
        g.textContent = f;
        var d = this;
        d.addEventListener(g, "click", function(c) {
            if (!d.movedSinceLastClick)
                d.onTitleClick(c);
            d.movedSinceLastClick = !1
        }
        );
        d.addEventListener(g, "dblclick", function(c) {
            d.onTitleDoubleClick(c)
        }
        );
        return g
    }
    ;
    f.prototype.setTitle = function(f, g) {
        g && g.localizeTitle ? (this.title.setAttribute("data-i18n", f),
        f = Teratek.Viewing.i18n.translate(f)) : this.title.removeAttribute("data-i18n");
        this.title.textContent = f
    }
    ;
    f.prototype.createCloseButton = function() {
        var f = document.createElement("div");
        f.className = 
        "dockingPanelClose";
        f.innerHTML = "&times;";
        this.initializeCloseHandler(f);
        return f
    }
    ;
    f.prototype.onStartMove = function(f, g, d) {}
    ;
    f.prototype.onEndMove = function(f, g, d) {}
    ;
    f.prototype.onMove = function(f, g, d) {
        this.movedSinceLastClick = !0
    }
    ;
    f.prototype.onTitleClick = function(f) {}
    ;
    f.prototype.onTitleDoubleClick = function(f) {}
    ;
    f.prototype.addEventListener = function(f, g, d) {
        f.addEventListener(g, d);
        this.listeners.push({
            target: f,
            eventId: g,
            callback: d
        })
    }
    ;
    f.prototype.removeEventListener = function(f, g, d) {
        for (var c = 0; c < this.listeners.length; ++c) {
            var a = 
            this.listeners[c];
            if (a.target === f && a.eventId === g && a.callback === d)
                return f.removeEventListener(g, d),
                this.listeners.splice(c, 1),
                !0
        }
        return !1
    }
    ;
    f.prototype.getContentSize = function() {
        return {
            height: this.container.clientHeight,
            width: this.container.clientWidth
        }
    }
    ;
    f.prototype.resizeToContent = function(f) {
        if (this.isVisible()) {
            var g = this.getContentSize().height
              , d = this.container.getBoundingClientRect()
              , c = this.getContainerBoundingRect();
            f = f && f.maxHeight ? f.maxHeight - d.top : c.height - d.top;
            f -= 75;
            g > f && (g = f);
            this.container.style.height = 
            g.toString() + "px"
        }
    }
    ;
    f.prototype.getContainerBoundingRect = function() {
        return this.parentContainer.getBoundingClientRect()
    }
    ;
    Teratek.Viewing.UI.DockingPanel = f
}
)();
(function() {
    var f = Teratek.Viewing.UI
      , h = function(g, d, c, a) {
        f.DockingPanel.call(this, g, d, c, a);
        this.container.classList.add("modelStructurePanel");
        a = a || {};
        a.heightAdjustment || (a.heightAdjustment = 40);
        a.marginTop || (a.marginTop = 0);
        a.left = !0;
        this.createScrollContainer(a);
        this.options = a;
        this.tree = this.instanceTree = null ;
        this.selectedNodes = [];
        this.uiCreated = !1;
        var b = this;
        this.addVisibilityListener(function(a) {
            a && (b.uiCreated || b.createUI(),
            b.resizeToContent())
        }
        )
    }
    ;
    h.prototype = Object.create(f.DockingPanel.prototype);
    h.prototype.constructor = h;
    h.prototype.setModel = function(f, d) {
        this.instanceTree = f;
        this.modelTitle = d;
        this.isVisible() ? this.createUI() : this.uiCreated = !1
    }
    ;
    h.prototype.createUI = function() {
        var g = this
          , d = g.instanceTree;
        if (d) {
            g.selectedNodes = [];
            var c = g.modelTitle;
            !c && g.options && g.options.defaultTitle && (c = g.options.defaultTitle);
            var a = {};
            c || (c = "Browser",
            a.localizeTitle = !0);
            g.setTitle(c, a);
            if (g.tree) {
                for (; g.scrollContainer.hasChildNodes(); )
                    g.scrollContainer.removeChild(g.scrollContainer.lastChild);
                g.title.removeEventListener("click", 
                g.onTitleClick);
                g.title.removeEventListener("dblclick", g.onTitleDoubleClick)
            }
            var c = this.rootId = d.getRootId(), b = d.getNodeName(c), h, l = 0, n = 0;
            d.enumNodeChildren(c, function(a) {
                n || (h = d.getNodeName(a),
                l = a);
                n++
            }
            );
            this.myDelegate = a = function() {
                var a = new f.TreeDelegate;
                a.getTreeNodeId = function(a) {
                    return "object" == typeof a ? (stderr("Object used instead of dbId. Fix it."),
                    a.dbId) : a
                }
                ;
                a.getTreeNodeLabel = function(a) {
                    a = this.getTreeNodeId(a);
                    return g.instanceTree.getNodeName(a) || "Object " + a
                }
                ;
                a.getTreeNodeClass = function(a) {
                    return g.getNodeClass(a)
                }
                ;
                a.isTreeNodeGroup = function(a) {
                    return g.isGroupNode(a)
                }
                ;
                a.shouldCreateTreeNode = function(a) {
                    return g.shouldInclude(a)
                }
                ;
                a.onTreeNodeClick = function(a, b, c) {
                    g.onClick(b, c)
                }
                ;
                a.onTreeNodeRightClick = function(a, b, c) {
                    g.onRightClick(b, c)
                }
                ;
                a.onTreeNodeDoubleClick = function(a, b, c) {
                    g.onDoubleClick(b, c)
                }
                ;
                a.onTreeNodeIconClick = function(a, b, c) {
                    g.onIconClick(b, c)
                }
                ;
                a.forEachChild = function(a, b) {
                    var c = this.getTreeNodeId(a);
                    g.instanceTree.enumNodeChildren(c, b)
                }
                ;
                return a
            }
            ();
            b = 1 === n && b === h;
            g.tree = new f.Tree(a,c,g.scrollContainer,
            {
                excludeRoot: b
            });
            g.options && g.options.hasOwnProperty("startCollapsed") && !g.options.startCollapsed || (g.tree.setAllCollapsed(!0),
            g.tree.setCollapsed(c, !1),
            b && g.tree.setCollapsed(l, !1));
            this.uiCreated = !0
        }
    }
    ;
    h.prototype.getNodeLabel = function(f) {
        return this.myDelegate.getNodeLabel(f)
    }
    ;
    h.prototype.getNodeClass = function(f) {
        return ""
    }
    ;
    h.prototype.isGroupNode = function(f) {
        f = this.myDelegate.getTreeNodeId(f);
        return this.instanceTree.getChildCount(f)
    }
    ;
    h.prototype.shouldInclude = function(f) {
        return !0
    }
    ;
    h.prototype.onClick = 
    function(f, d) {
        this.setSelection([f])
    }
    ;
    h.prototype.onDoubleClick = function(f, d) {}
    ;
    h.prototype.onIconClick = function(f, d) {
        this.setGroupCollapsed(f, !this.isGroupCollapsed(f))
    }
    ;
    h.prototype.setGroupCollapsed = function(f, d) {
        this.tree.delegate().isTreeNodeGroup(f) && (this.tree.setCollapsed(f, d),
        this.resizeToContent())
    }
    ;
    h.prototype.isGroupCollapsed = function(f) {
        return this.tree.delegate().isTreeNodeGroup(f) ? this.tree.isCollapsed(f) : !1
    }
    ;
    h.prototype.onRightClick = function(f, d) {}
    ;
    h.prototype.onTitleClick = function(f) {}
    ;
    h.prototype.onTitleDoubleClick = function(f) {}
    ;
    h.prototype.setSelection = function(f) {
        if (this.tree) {
            var d, c;
            for (d = 0; d < this.selectedNodes.length; ++d)
                for (c = this.instanceTree.getNodeParentId(this.selectedNodes[d]); c; )
                    this.tree.removeClass(c, "ancestor-selected"),
                    c = this.instanceTree.getNodeParentId(c);
            var a = [];
            for (d = 0; d < f.length; ++d)
                for (a.push(f[d]),
                c = this.instanceTree.getNodeParentId(f[d]); c; )
                    this.tree.addClass(c, "ancestor-selected"),
                    c = this.instanceTree.getNodeParentId(c);
            this.selectedNodes = f;
            this.tree.setSelection(a)
        }
    }
    ;
    h.prototype.getContentSize = function() {
        var f = this.tree;
        return f && (f = f.getRootContainer()) ? {
            height: f.clientHeight + this.options.heightAdjustment + 35,
            width: f.clientWidth
        } : {
            height: 0,
            width: 0
        }
    }
    ;
    h.prototype.addClass = function(f, d) {
        return null  !== this.tree && this.tree.addClass(f, d)
    }
    ;
    h.prototype.removeClass = function(f, d) {
        return null  !== this.tree && this.tree.removeClass(f, d)
    }
    ;
    Teratek.Viewing.UI.ModelStructurePanel = h
}
)();
(function() {
    var f = Teratek.Viewing.UI
      , h = function(g, d, c, a) {
        f.DockingPanel.call(this, g, d, c, a);
        this.container.classList.add("propertyPanel");
        this.container.dockRight = !0;
        this.createScrollContainer({
            left: !1,
            heightAdjustment: 45,
            marginTop: 0
        });
        this.highlightableElements = {};
        var b = this;
        g = function() {
            function a(b) {
                return "category" === b.type
            }
            var c = new f.TreeDelegate;
            c.getTreeNodeId = function(a) {
                return a.name + (a.hasOwnProperty("value") ? a.value : "") + (a.hasOwnProperty("category") ? a.category : "")
            }
            ;
            c.getTreeNodeClass = 
            function(c) {
                return a(c) ? b.getCategoryClass(c) : b.getPropertyClass(c)
            }
            ;
            c.isTreeNodeGroup = function(b) {
                return a(b)
            }
            ;
            c.onTreeNodeClick = function(c, d, f) {
                if (a(d))
                    b.onCategoryClick(d, f);
                else
                    b.onPropertyClick(d, f)
            }
            ;
            c.onTreeNodeRightClick = function(c, d, f) {
                if (a(d))
                    b.onCategoryRightClick(d, f);
                else
                    b.onPropertyRightClick(d, f)
            }
            ;
            c.onTreeNodeDoubleClick = function(c, d, f) {
                if (a(d))
                    b.onCategoryDoubleClick(d, f);
                else
                    b.onPropertyDoubleClick(d, f)
            }
            ;
            c.onTreeNodeIconClick = function(c, d, f) {
                if (a(d))
                    b.onCategoryIconClick(d, f);
                else
                    b.onPropertyIconClick(d, 
                    f)
            }
            ;
            c.createTreeNode = function(c, d, f) {
                var g = null ;
                (g = a(c) ? b.displayCategory(c, d, f) : b.displayProperty(c, d, f)) && (b.highlightableElements[this.getTreeNodeId(c)] = g)
            }
            ;
            return c
        }
        ();
        this.tree = new f.Tree(g,null ,this.scrollContainer,{})
    }
    ;
    h.prototype = Object.create(f.DockingPanel.prototype);
    h.prototype.constructor = h;
    h.prototype.setProperties = function(f, d) {
        this.removeAllProperties();
        for (var c = [], a = [], b = 0; b < f.length; b++) {
            var h = f[b];
            if (!h.hidden) {
                var l = f[b].displayCategory;
                l && "string" === typeof l && "" !== l ? c.push(h) : 
                a.push(h)
            }
        }
        if (0 === c.length + a.length)
            this.showNoProperties();
        else {
            for (b = 0; b < c.length; b++)
                h = c[b],
                l = Teratek.Viewing.Private.formatValueWithUnits(h.displayValue, h.units, h.type),
                this.addProperty(h.displayName, l, h.displayCategory);
            c = 0 < c.length;
            for (b = 0; b < a.length; b++)
                h = a[b],
                l = Teratek.Viewing.Private.formatValueWithUnits(h.displayValue, h.units, h.type),
                this.addProperty(h.displayName, l, c ? "Other" : "", c ? {
                    localizeCategory: !0
                } : {})
        }
    }
    ;
    h.prototype.showNoProperties = function() {
        this.removeAllProperties();
        var f = this.tree.myRootContainer
          , 
        d = document.createElement("div");
        d.className = "noProperties";
        d.setAttribute("data-i18n", "No properties to display");
        d.textContent = Teratek.Viewing.i18n.translate("No properties to display");
        f.appendChild(d)
    }
    ;
    h.prototype.showDefaultProperties = function() {
        this.showNoProperties();
        this.resizeToContent()
    }
    ;
    h.prototype.areDefaultPropertiesShown = function() {
        return !this.hasProperties()
    }
    ;
    h.prototype.addProperty = function(f, d, c, a) {
        if (this.tree.getElementForNode({
            name: f,
            value: d,
            category: c
        }))
            return !1;
        var b = null ;
        f = 
        {
            name: f,
            value: d,
            type: "property"
        };
        c ? ((b = this.tree.getElementForNode({
            name: c
        })) || (b = this.tree.createElement_({
            name: c,
            type: "category"
        }, this.tree.myRootContainer, a && a.localizeCategory ? {
            localize: !0
        } : null )),
        f.category = c) : b = this.tree.myRootContainer;
        this.tree.createElement_(f, b, a && a.localizeProperty ? {
            localize: !0
        } : null );
        return !0
    }
    ;
    h.prototype.hasProperties = function() {
        for (var f in this.highlightableElements)
            return !0;
        return !1
    }
    ;
    h.prototype.removeProperty = function(f, d, c, a) {
        f = {
            name: f,
            value: d,
            category: c
        };
        return (d = 
        this.tree.getElementForNode(f)) ? (delete this.highlightableElements[this.tree.delegate().getTreeNodeId(f)],
        d.parentNode.removeChild(d),
        !0) : !1
    }
    ;
    h.prototype.removeAllProperties = function() {
        this.highlightableElements = {};
        this.tree.clear()
    }
    ;
    h.prototype.setCategoryCollapsed = function(f, d) {
        var c = this.tree.delegate().getTreeNodeId(f);
        this.tree.setCollapsed(c, d)
    }
    ;
    h.prototype.isCategoryCollapsed = function(f) {
        f = this.tree.delegate().getTreeNodeId(f);
        return this.tree.isCollapsed(f)
    }
    ;
    h.prototype.getContentSize = function() {
        var f = 
        this.tree.myRootContainer;
        return {
            height: f.clientHeight + 55,
            width: f.clientWidth
        }
    }
    ;
    h.prototype.highlight = function(f, d) {
        for (var c in this.highlightableElements)
            for (var a = this.highlightableElements[c], b = 0; b < a.length; ++b) {
                var h = a[b]
                  , l = h.innerHTML
                  , n = l.replace(/(<highlight>|<\/highlight>)/igm, "");
                l !== n && (h.innerHTML = n);
                f && "" !== f && (l = n.replace(new RegExp("(\\b" + f + "\\b)","gim"), "<highlight>$1</highlight>"),
                h.innerHTML = l)
            }
    }
    ;
    h.prototype.displayCategory = function(f, d, c) {
        var a = document.createElement("div");
        f = f.name;
        c && c.localize && (a.setAttribute("data-i18n", f),
        f = Teratek.Viewing.i18n.translate(f));
        a.textContent = f;
        a.title = f;
        a.className = "categoryName";
        d.appendChild(a);
        return [a]
    }
    ;
    h.prototype.displayProperty = function(f, d, c) {
        var a = document.createElement("div")
          , b = f.name;
        c && c.localize && (a.setAttribute("data-i18n", b),
        b = Teratek.Viewing.i18n.translate(b));
        a.textContent = b;
        a.title = b;
        a.className = "propertyName";
        c = document.createElement("div");
        c.className = "separator";
        b = document.createElement("div");
        b.textContent = f.value;
        b.title = f.value;
        b.className = "propertyValue";
        d.appendChild(a);
        d.appendChild(c);
        d.appendChild(b);
        return [a, b]
    }
    ;
    h.prototype.getCategoryClass = function(f) {
        return "category"
    }
    ;
    h.prototype.getPropertyClass = function(f) {
        return "property"
    }
    ;
    h.prototype.onCategoryClick = function(f, d) {
        this.setCategoryCollapsed(f, !this.isCategoryCollapsed(f))
    }
    ;
    h.prototype.onPropertyClick = function(f, d) {}
    ;
    h.prototype.onCategoryIconClick = function(f, d) {
        this.setCategoryCollapsed(f, !this.isCategoryCollapsed(f))
    }
    ;
    h.prototype.onPropertyIconClick = 
    function(f, d) {}
    ;
    h.prototype.onCategoryDoubleClick = function(f, d) {}
    ;
    h.prototype.onPropertyDoubleClick = function(f, d) {}
    ;
    h.prototype.onCategoryRightClick = function(f, d) {}
    ;
    h.prototype.onPropertyRightClick = function(f, d) {}
    ;
    Teratek.Viewing.UI.PropertyPanel = h
}
)();
(function() {
    var f = function(f) {
        this.viewer = f;
        this.menus = [];
        this.open = !1
    }
    ;
    f.prototype.constructor = f;
    f.prototype.show = function(f, g) {
        var d = this.viewer.container.getBoundingClientRect()
          , c = f.clientX - d.left
          , d = f.clientY - d.top;
        if (!this.open) {
            var a = this;
            this.showMenu(g, c, d);
            this.open = !0;
            this.hideEventListener = function(b) {
                "menuItem" !== b.target.className && a.hide(b)
            }
            ;
            this.isTouch = "press" === f.type;
            document.body.addEventListener(this.isTouch ? "touchstart" : "mousedown", this.hideEventListener, !0)
        }
    }
    ;
    f.prototype.showMenu = 
    function(f, g, d) {
        var c = document.createElement("div"), a, b = [];
        c.className = "menu";
        this.viewer.container.appendChild(c);
        this.menus.push(c);
        for (var k = 0; k < f.length; ++k) {
            a = f[k];
            var l = a.title
              , n = a.target;
            a = this.createMenuItem(c, l);
            "function" === typeof n ? this.addCallbackToMenuItem(a, n) : Array.isArray(n) ? b.push({
                menuItem: a,
                target: n
            }) : console.warn("Invalid context menu option:", l, n)
        }
        n = c.getBoundingClientRect();
        k = n.width;
        a = n.height;
        f = this.viewer.container.getBoundingClientRect();
        var n = f.width
          , m = f.height;
        (l = isTouchDevice() && 
        !this.viewer.navigation.getUseLeftHandedInput()) && (g -= k);
        0 > g && (g = 0);
        n < g + k && (g = n - k,
        0 > g && (g = 0));
        0 > d && (d = 0);
        m < d + a && (d = m - a,
        0 > d && (d = 0));
        c.style.top = Math.round(d) + "px";
        c.style.left = Math.round(g) + "px";
        for (k = 0; k < b.length; ++k)
            c = b[k],
            a = c.menuItem,
            n = a.getBoundingClientRect(),
            g = Math.round((l ? n.left : n.right) - f.left),
            d = Math.round(n.top - f.top),
            this.addSubmenuCallbackToMenuItem(a, c.target, g, d)
    }
    ;
    f.prototype.createMenuItem = function(f, g) {
        var d = document.createElement("div");
        d.className = "menuItem";
        d.setAttribute("data-i18n", 
        g);
        d.textContent = Teratek.Viewing.i18n.translate(g);
        f.appendChild(d);
        return d
    }
    ;
    f.prototype.addCallbackToMenuItem = function(f, g) {
        var d = this;
        f.addEventListener("click", function(c) {
            d.hide();
            g();
            c.preventDefault();
            return !1
        }
        , !1)
    }
    ;
    f.prototype.addSubmenuCallbackToMenuItem = function(f, g, d, c) {
        var a = this;
        f.addEventListener("click", function() {
            a.showMenu(g, d, c)
        }
        , !1)
    }
    ;
    f.prototype.hide = function() {
        if (this.open) {
            for (var f = 0; f < this.menus.length; ++f)
                this.menus[f] && this.menus[f].parentNode.removeChild(this.menus[f]);
            this.menus = [];
            this.open = !1;
            document.body.removeEventListener(this.isTouch ? "touchstart" : "mousedown", this.hideEventListener);
            this.isTouch = !1;
            return !0
        }
        return !1
    }
    ;
    Teratek.Viewing.Private.ContextMenu = f
}
)();
(function() {
    var f = Teratek.Viewing.Private
      , h = function(g) {
        this.viewer = g;
        this.contextMenu = new f.ContextMenu(g)
    }
    ;
    h.prototype.constructor = h;
    h.prototype.show = function(f) {
        var d = this.viewer.getSelectionCount()
          , c = this.viewer.getSelectionVisibility()
          , d = {
            numSelected: d,
            hasSelected: 0 < d,
            hasVisible: c.hasVisible,
            hasHidden: c.hasHidden
        }
          , c = this.buildMenu(f, d);
        this.viewer.runContextMenuCallbacks(c, d);
        c && 0 < c.length && this.contextMenu.show(f, c)
    }
    ;
    h.prototype.hide = function() {
        return this.contextMenu.hide()
    }
    ;
    h.prototype.buildMenu = 
    function(f, d) {
        return null 
    }
    ;
    Teratek.Viewing.UI.ObjectContextMenu = h
}
)();
Teratek.Viewing.Private.Preferences = function(f, h) {
    function g(a, b) {
        if (k)
            return a = h + a,
            "undefined" !== typeof b ? localStorage[a] = b : b = localStorage[a],
            b
    }
    function d(a, c) {
        if ("string" !== typeof a || "function" === typeof l[a])
            stderr("Preferences: invalid name=" + a);
        else {
            var d = g(a);
            ok = !1;
            if (void 0 !== d)
                try {
                    d = JSON.parse(d),
                    ok = !0
                } catch (f) {}
            l[a] = ok ? d : c;
            b[a] = {}
        }
    }
    h || (h = "Teratek.Viewing.Preferences.");
    var c = {}
      , a = {}
      , b = {}
      , k = function() {
        var a = h + "test"
          , b = window.localStorage;
        try {
            return b.setItem(a, "1"),
            b.removeItem(a),
            !0
        } catch (c) {
            return !1
        }
    }
    ()
      , 
    l = this;
    f.addEventListener("PrefChanged", function(b) {
        var c = a[b.name];
        c && (c = c.changed) && c(b.value)
    }
    );
    f.addEventListener("PrefReset", function(b) {
        for (var c in a)
            a.hasOwnProperty(c) && (b = a[c].reset) && b(l[c])
    }
    );
    this.load = function(a) {
        c = a;
        for (var b in c)
            c.hasOwnProperty(b) && d(b, c[b])
    }
    ;
    this.tag = function(a, d) {
        if (a) {
            d ? Array.isArray(d) || (d = [d]) : d = Object.keys(c);
            for (var f = 0; f < d.length; ++f)
                b[d[f]][a] = !0
        }
    }
    ;
    this.untag = function(a, d) {
        if (a) {
            d ? Array.isArray(d) || (d = [d]) : d = Object.keys(c);
            for (var f = 0; f < d.length; ++f)
                b[d[f]][a] = 
                !1
        }
    }
    ;
    this.add = function(a, b, f) {
        if (c.hasOwnProperty(a))
            stderr("Preferences: " + a + " already exists");
        else {
            c[a] = b;
            d(a, b);
            if (f)
                for (Array.isArray(f) || (f = [f]),
                b = 0; b < f.length; ++b)
                    this.tag(f[b], a);
            return !0
        }
        return !1
    }
    ;
    this.remove = function(a, d) {
        return c.hasOwnProperty(a) ? (delete c[a],
        delete b[a],
        delete this[a],
        d && k && (a = h + a,
        delete localStorage[a]),
        !0) : !1
    }
    ;
    this.reset = function(a, d) {
        a && void 0 === d && (d = !0);
        for (var g in c)
            if (c.hasOwnProperty(g)) {
                if (a) {
                    var h = !!b[g][a];
                    if (d && !h || !d && h)
                        continue
                }
                this.set(g, c[g], !1) && f.fireEvent({
                    type: "PrefReset",
                    name: g,
                    value: this[g]
                })
            }
    }
    ;
    this.get = function(a) {
        return this[a]
    }
    ;
    this.set = function(a, b, c) {
        return this[a] !== b ? (this[a] = b,
        g(a, b),
        (void 0 === c || c) && f.fireEvent({
            type: "PrefChanged",
            name: a,
            value: b
        }),
        (c = Teratek.Viewing.Private.logger) && c.log({
            category: "pref_changed",
            name: a,
            value: b
        }),
        !0) : !1
    }
    ;
    this.addListeners = function(b, c, d) {
        a[b] = {
            changed: c,
            reset: d
        }
    }
    ;
    this.removeListeners = function(b) {
        void 0 !== a[b] && delete a[b]
    }
}
;
TeratekNamespace("Teratek.Viewing.Private");
Teratek.Viewing.Private.formatValueWithUnits = function(f, h, g, d) {
    function c(a) {
        var b = 0 <= a ? Math.floor(a) : Math.ceil(a);
        return {
            intPart: b,
            fracPart: a - b
        }
    }
    function a(a, b, d) {
        var f = "";
        d && 0 === a && (f += "-");
        0 === c(a).fracPart ? f += a : 0 < b ? (a = a.toFixed(b),
        b = /^\-?([0-9]+)\.0+$/.exec(a),
        f = null  !== b ? f + b[1] : f + a) : f += a.toFixed(0);
        return f
    }
    function b(b, d, f) {
        for (var g = "", h = 1, k = 0 > b, w = 0; w < d; ++w)
            h *= 2;
        b = 0 < b ? b + .5 / h : b - .5 / h;
        f ? k = b : (d = c(b / 12).intPart,
        g += a(d, 0, k) + "' ",
        k = b - 12 * d,
        0 > k && (k = -k));
        b = c(k).intPart;
        k = c((k - b) * h).intPart;
        if (0 === k || 
        0 !== b)
            g += a(b, 0);
        if (0 !== k) {
            for (0 > b && 0 > k && (k = -k); 0 === k % 2; )
                k /= 2,
                h /= 2;
            0 !== b && (g += "-");
            g += a(k, 0) + "/" + a(h, 0)
        }
        return g + '"'
    }
    function k(b, d) {
        var f = "";
        0 > b && (f = "-",
        b = Math.abs(b));
        var g = c(b)
          , h = 100 * g.fracPart;
        return f + a(g.intPart, 0) + " m " + a(h, d) + " cm"
    }
    void 0 === d && (d = 3);
    1 === g ? f = Teratek.Viewing.i18n.translate(f ? "Yes" : "No") : 2 !== g && 3 !== g || !isNaN(f) ? "ft" === h || "feet" === h || "foot" === h ? f = b(12 * f, d) : "ft^2" === h || "feet^2" === h || "foot^2" === h ? f = b(12 * f, d) + " " + String.fromCharCode(178) : "in" === h || "inch" === h ? f = b(f, d) : "in^2" === h || 
    "inch^2" === h ? f = b(f, d) + " " + String.fromCharCode(178) : "decimal-in" === h ? f = a(f, d) + '"' : "decimal-in^2" === h ? f = a(f, d) + '" ' + String.fromCharCode(178) : "decimal-ft" === h ? f = a(f, d) + "'" : "decimal-ft^2" === h ? f = a(f, d) + "' " + String.fromCharCode(178) : "fractional-in" === h ? f = b(f, d, !0) : "fractional-in^2" === h ? f = b(f, d, !0) + " " + String.fromCharCode(178) : "m-and-cm" === h ? f = k(f, d) : "m-and-cm^2" === h ? f = k(f, d) + " " + String.fromCharCode(178) : 3 === g && h ? (h = h.replace("^2", String.fromCharCode(178)),
    h = h.replace("^3", String.fromCharCode(179)),
    f = a(f, 
    d) + " " + h) : f = h ? f + " " + h : 3 === g ? a(f, d) : f : f = "NaN";
    return f
}
;
Teratek.Viewing.Private.convertUnits = function(f, h, g, d) {
    if (f === h)
        return g;
    var c = 1;
    switch (h) {
    case "mm":
        c = 1E3;
        break;
    case "cm":
        c = 100;
        break;
    case "m":
        c = 1;
        break;
    case "in":
        c = 39.37007874;
        break;
    case "ft":
        c = 3.280839895;
        break;
    case "decimal-in":
        c = 39.37007874;
        break;
    case "decimal-ft":
        c = 3.280839895;
        break;
    case "fractional-in":
        c = 39.37007874;
        break;
    case "m-and-cm":
        c = 1
    }
    h = 1;
    switch (f) {
    case "mm":
        h = .001;
        break;
    case "cm":
        h = .01;
        break;
    case "m":
        h = 1;
        break;
    case "in":
        h = .0254;
        break;
    case "ft":
        h = .3048;
        break;
    case "decimal-in":
        h = .0254;
        break;
    case "decimal-ft":
        h = .3048;
        break;
    case "fractional-in":
        h = .0254;
        break;
    case "m-and-cm":
        h = 1
    }
    return "square" === d ? g * Math.pow(c * h, 2) : g * c * h
}
;
TeratekNamespace("Teratek.Viewing.Private");
(function() {
    var f = Teratek.Viewing
      , h = Teratek.Viewing.Private;
    h.OptionSlider = function(g, d, c, a, b) {
        function h(a) {
            a.target != l.stepperElement && (l.stepperElement.value = l.sliderElement.value);
            l.fireChangeEvent()
        }
        var l = this;
        this.tbody = a;
        this.sliderRow = this.tbody.insertRow(b && b.insertAtIndex ? b.insertAtIndex : -1);
        a = this.sliderRow.insertCell(0);
        this.caption = document.createElement("div");
        this.caption.setAttribute("data-i18n", g);
        this.caption.textContent = f.i18n.translate(g);
        this.sliderElement = document.createElement("input");
        this.sliderElement.type = "range";
        this.sliderElement.id = g + "_slider";
        this.sliderElement.min = d;
        this.sliderElement.max = c;
        a.appendChild(this.caption);
        a.appendChild(this.sliderElement);
        a = this.sliderRow.insertCell(1);
        this.stepperElement = document.createElement("input");
        this.stepperElement.type = "number";
        this.stepperElement.id = g + "_stepper";
        this.stepperElement.min = d;
        this.stepperElement.max = c;
        this.stepperElement.step = 1;
        this.stepperElement.style.width = "64px";
        a.appendChild(this.stepperElement);
        this.blockEvent = !1;
        this.stepperElement.addEventListener("change", function(a) {
            a.target != l.sliderElement && (l.sliderElement.value = l.stepperElement.value);
            l.fireChangeEvent()
        }
        , !1);
        this.sliderElement.addEventListener("change", h, !1);
        this.sliderElement.addEventListener("input", h, !1)
    }
    ;
    h.OptionSlider.prototype.constructor = h.OptionSlider;
    f.EventDispatcher.prototype.apply(h.OptionSlider.prototype);
    h.OptionSlider.prototype.fireChangeEvent = function() {
        if (!this.blockEvent) {
            this.value = this.sliderElement.value;
            var f = new CustomEvent("change",
            {
                detail: {
                    target: this,
                    value: this.sliderElement.value
                }
            });
            this.dispatchEvent(f)
        }
    }
    ;
    h.OptionSlider.prototype.setValue = function(f) {
        this.blockEvent = !0;
        this.value = f;
        this.sliderElement.value = f;
        this.stepperElement.value = f;
        this.blockEvent = !1
    }
    ;
    h.OptionSlider.prototype.setDisabled = function(f) {
        this.sliderElement.disabled = f;
        this.stepperElement.disabled = f;
        this.caption.disabled = f
    }
    ;
    h.OptionCheckbox = function(g, d, c, a) {
        var b = this;
        this.tbody = d;
        this.sliderRow = this.tbody.insertRow(a && a.insertAtIndex ? a.insertAtIndex : -1);
        d = this.sliderRow.insertCell(0);
        this.caption = document.createElement("div");
        this.caption.setAttribute("data-i18n", g);
        this.caption.textContent = f.i18n.translate(g);
        d.appendChild(this.caption);
        d = this.sliderRow.insertCell(1);
        this.checkElement = document.createElement("input");
        this.checkElement.type = "checkbox";
        this.checkElement.id = g + "_check";
        this.checkElement.checked = c;
        d.appendChild(this.checkElement);
        this.blockEvent = !1;
        this.checked = c;
        this.checkElement.addEventListener("change", function(a) {
            b.fireChangeEvent()
        }
        , 
        !1);
        isTouchDevice() && (this.sliderRowHammer = new Hammer.Manager(this.sliderRow,{
            recognizers: [[Hammer.Tap]],
            inputClass: Hammer.TouchInput
        }),
        this.sliderRowHammer.on("tap", function(a) {
            a.preventDefault();
            a.target.click()
        }
        ));
        this.checkElement.addEventListener("click", function(a) {
            a.stopPropagation()
        }
        , !1);
        this.sliderRow.addEventListener("click", function(a) {
            b.checkElement.disabled || (b.checkElement.checked = !b.checkElement.checked,
            b.fireChangeEvent())
        }
        , !1)
    }
    ;
    h.OptionCheckbox.prototype.constructor = h.OptionCheckbox;
    f.EventDispatcher.prototype.apply(h.OptionCheckbox.prototype);
    h.OptionCheckbox.prototype.fireChangeEvent = function() {
        if (!this.blockEvent) {
            this.checked = this.checkElement.checked;
            var f = new CustomEvent("change",{
                detail: {
                    target: this,
                    value: this.checkElement.checked
                }
            });
            this.dispatchEvent(f)
        }
    }
    ;
    h.OptionCheckbox.prototype.setValue = function(f) {
        this.blockEvent = !0;
        this.checked = f;
        this.checkElement.checked = f;
        this.blockEvent = !1
    }
    ;
    h.OptionCheckbox.prototype.setDisabled = function(f) {
        this.checkElement.disabled = f;
        this.caption.disabled = 
        f
    }
    ;
    h.OptionCheckbox.prototype.setVisibility = function(f) {
        this.sliderRow.style.display = f ? "table-row" : "none"
    }
    ;
    h.OptionDropDown = function(g, d, c, a, b) {
        var h = this;
        this.tbody = d;
        this.sliderRow = this.tbody.insertRow(b && b.insertAtIndex ? b.insertAtIndex : -1);
        d = this.sliderRow.insertCell(0);
        this.caption = document.createElement("div");
        this.caption.setAttribute("data-i18n", g);
        this.caption.textContent = f.i18n.translate(g);
        d.appendChild(this.caption);
        d = this.sliderRow.insertCell(1);
        this.dropdownElement = document.createElement("select");
        this.dropdownElement.id = g + "_dropdown";
        this.dropdownElement.className = "optionDropDown";
        for (g = 0; g < c.length; g++)
            b = document.createElement("option"),
            b.value = g,
            b.setAttribute("data-i18n", c[g]),
            b.textContent = f.i18n.translate(c[g]),
            this.dropdownElement.add(b);
        this.selectedIndex = this.dropdownElement.selectedIndex = a;
        d.appendChild(this.dropdownElement);
        d.style.paddingLeft = "5px";
        d.style.paddingRight = "5px";
        this.blockEvent = !1;
        this.dropdownElement.addEventListener("change", function(a) {
            h.fireChangeEvent()
        }
        , !1)
    }
    ;
    h.OptionDropDown.prototype.constructor = h.OptionDropDown;
    f.EventDispatcher.prototype.apply(h.OptionDropDown.prototype);
    h.OptionDropDown.prototype.setSelectedIndex = function(f) {
        this.blockEvent = !0;
        this.selectedIndex = this.dropdownElement.selectedIndex = f;
        this.blockEvent = !1
    }
    ;
    h.OptionDropDown.prototype.setSelectedValue = function(f) {
        this.blockEvent = !0;
        this.dropdownElement.selectedValue = f;
        this.selectedIndex = this.dropdownElement.selectedIndex;
        this.blockEvent = !1
    }
    ;
    h.OptionDropDown.prototype.fireChangeEvent = function() {
        if (!this.blockEvent) {
            this.selectedIndex = 
            this.dropdownElement.selectedIndex;
            var f = new CustomEvent("change",{
                detail: {
                    target: this,
                    value: this.selectedIndex
                }
            });
            this.dispatchEvent(f)
        }
    }
    ;
    h.OptionDropDown.prototype.setDisabled = function(f) {
        this.dropdownElement.disabled = f;
        this.caption.disabled = f
    }
}
)();
(function() {
    var f = function(f) {
        this.bg = document.createElement("div");
        this.bg.className = "progressbg";
        this.fg = document.createElement("div");
        this.fg.className = "progressfg";
        this.bg.appendChild(this.fg);
        this.lastValue = -1;
        f.appendChild(this.bg);
        this.widthScale = this.fg.clientWidth
    }
    ;
    f.prototype.setPercent = function(f) {
        f != this.lastValue && (this.lastValue = f,
        99 <= f ? this.bg.style.visibility = "hidden" : (this.bg.style.visibility = "visible",
        this.fg.style.width = this.widthScale * f * .01 + "px"))
    }
    ;
    Teratek.Viewing.Private.ProgressBar = 
    f
}
)();
TeratekNamespace("Teratek.Viewing.Private");
Teratek.Viewing.Private.RenderOptionsPanel = function(f) {
    var h = this
      , g = Teratek.Viewing.Private;
    this.viewer = f;
    Teratek.Viewing.UI.DockingPanel.call(this, f.container, "RenderOptionsPanel", "Rendering Options");
    this.table = document.createElement("table");
    this.table.className = "tftable";
    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);
    this.createScrollContainer({
        heightAdjustment: 70,
        marginTop: 20
    });
    this.scrollContainer.appendChild(this.table);
    this.container.style.width = "320px";
    this.container.style.top = 
    "260px";
    this.container.style.left = "220px";
    this.container.style.height = "460px";
    this.container.dockRight = !0;
    var d = [], c;
    for (c in f.impl.BackgroundPresets)
        d.push(c);
    this.bgSelect = new g.OptionDropDown("Background Color",this.tbody,d,-1);
    this.updateBgColorIndex();
    this.addEventListener(this.bgSelect, "change", function(a) {
        a = f.BackgroundPresets[h.bgSelect.value];
        f.prefs.set("backgroundColorPreset", JSON.stringify(a));
        f.impl.setClearColors(a[0], a[1], a[2], a[3], a[4], a[5])
    }
    );
    this.celToggle = new g.OptionCheckbox("Cel Shaded",
    this.tbody,!0);
    this.addEventListener(this.celToggle, "change", function(a) {
        a = h.celToggle.checked;
        f.prefs.set("celShaded", a);
        f.impl.toggleCelShading(a)
    }
    );
    this.saoToggle = new g.OptionCheckbox("AO Enabled",this.tbody,!0);
    this.addEventListener(this.saoToggle, "change", function(a) {
        a = h.saoToggle.checked;
        f.prefs.set("ambientShadows", a);
        f.setQualityLevel(a, f.impl.renderer().settings.antialias)
    }
    );
    this.saoRadius = new g.OptionSlider("AO Radius",0,100,this.tbody);
    this.saoRadius.setValue(10);
    this.saoRadius.sliderElement.step = 
    this.saoRadius.stepperElement.step = 1;
    this.addEventListener(this.saoRadius, "change", function(a) {
        f.impl.renderer().setAOOptions(parseInt(h.saoRadius.value), parseFloat(h.saoIntensity.value));
        f.impl.renderer().composeFinalFrame(!1)
    }
    );
    this.saoIntensity = new g.OptionSlider("AO Intensity",0,3,this.tbody);
    this.saoIntensity.setValue(.75);
    this.saoIntensity.sliderElement.step = this.saoIntensity.stepperElement.step = .1;
    this.addEventListener(this.saoIntensity, "change", function(a) {
        f.impl.renderer().setAOOptions(parseInt(h.saoRadius.value), 
        parseFloat(h.saoIntensity.value));
        f.impl.renderer().composeFinalFrame(!1)
    }
    );
    this.groundShadowAlpha = new g.OptionSlider("Shadow Alpha",0,2,this.tbody);
    this.groundShadowAlpha.setValue(1);
    this.groundShadowAlpha.sliderElement.step = this.groundShadowAlpha.stepperElement.step = .1;
    this.addEventListener(this.groundShadowAlpha, "change", function(a) {
        f.setGroundShadowAlpha(parseFloat(h.groundShadowAlpha.value))
    }
    );
    this.groundShadowColor = new g.OptionCheckbox("Shadow Color",this.tbody);
    _isIE11 || (this.groundShadowColor.checkElement.type = 
    "color");
    this.addEventListener(this.groundShadowColor, "change", function(a) {
        f.setGroundShadowColor(new THREE.Color(parseInt(h.groundShadowColor.checkElement.value.substr(1, 7), 16)))
    }
    );
    this.groundReflectionAlpha = new g.OptionSlider("Reflection Alpha",0,2,this.tbody);
    this.groundReflectionAlpha.setValue(1);
    this.groundReflectionAlpha.sliderElement.step = this.groundReflectionAlpha.stepperElement.step = .1;
    this.addEventListener(this.groundReflectionAlpha, "change", function(a) {
        f.setGroundReflectionAlpha(parseFloat(h.groundReflectionAlpha.value))
    }
    );
    this.groundReflectionColor = new g.OptionCheckbox("Reflection Color",this.tbody);
    _isIE11 || (this.groundReflectionColor.checkElement.type = "color");
    this.addEventListener(this.groundReflectionColor, "change", function(a) {
        f.setGroundReflectionColor(new THREE.Color(parseInt(h.groundReflectionColor.checkElement.value.substr(1, 7), 16)))
    }
    );
    d = [];
    for (c = 0; c < g.LightPresets.length; c++)
        d.push(g.LightPresets[c].name);
    this.envSelect = new g.OptionDropDown("Environment",this.tbody,d,f.impl.currentLightPreset());
    this.addEventListener(this.envSelect, 
    "change", function(a) {
        f.setLightPreset(h.envSelect.selectedIndex)
    }
    );
    d = f.impl.renderer().getToneMapMethod();
    this.toneMapMethod = new g.OptionDropDown("Tonemap Method",this.tbody,["None", "Canon-RGB", "Canon-Lum"],d);
    this.addEventListener(this.toneMapMethod, "change", function() {
        f.impl.setTonemapMethod(h.toneMapMethod.selectedIndex)
    }
    );
    this.exposureBias = new g.OptionSlider("Exposure Bias",-30,30,this.tbody);
    this.exposureBias.setValue(f.impl.renderer().getExposureBias());
    this.exposureBias.sliderElement.step = 
    this.exposureBias.stepperElement.step = .1;
    this.addEventListener(this.exposureBias, "change", function(a) {
        f.impl.setTonemapExposureBias(h.exposureBias.value, h.whiteScale.value)
    }
    );
    this.exposureBias.setDisabled(0 == d);
    this.whiteScale = new g.OptionSlider("Light Intensity",-5,20,this.tbody);
    d = 0;
    f.impl.dir_light1 && (d = 0 != f.impl.dir_light1.intensity ? Math.log(f.impl.dir_light1.intensity) / Math.log(2) : -1E-20);
    this.whiteScale.setValue(d);
    this.whiteScale.sliderElement.step = this.whiteScale.stepperElement.step = .1;
    this.addEventListener(this.whiteScale, 
    "change", function(a) {
        f.impl.dir_light1.intensity = Math.pow(2, h.whiteScale.value);
        f.impl.setTonemapExposureBias(h.exposureBias.value, h.whiteScale.value)
    }
    );
    this.fovAngle = new g.OptionSlider("FOV-degrees",6.88,100,this.tbody);
    this.fovAngle.setValue(f.getFOV());
    this.addEventListener(this.fovAngle, "change", function(a) {
        f.setFOV(parseFloat(h.fovAngle.value))
    }
    );
    this.addEventListener(this.viewer, Teratek.Viewing.CAMERA_CHANGE_EVENT, function(a) {
        a = parseFloat(h.fovAngle.value);
        var b = f.getFOV();
        a != b && h.fovAngle.setValue(b)
    }
    );
    this.addEventListener(this.viewer, Teratek.Viewing.RENDER_OPTION_CHANGED_EVENT, function(a) {
        h.syncUI()
    }
    );
    this.addVisibilityListener(function() {
        h.resizeToContent()
    }
    )
}
;
Teratek.Viewing.Private.RenderOptionsPanel.prototype = Object.create(Teratek.Viewing.UI.DockingPanel.prototype);
Teratek.Viewing.Private.RenderOptionsPanel.prototype.constructor = Teratek.Viewing.Private.RenderOptionsPanel;
Teratek.Viewing.Private.RenderOptionsPanel.prototype.getContentSize = function() {
    return {
        height: this.table.clientHeight + 75,
        width: this.table.clientWidth
    }
}
;
Teratek.Viewing.Private.RenderOptionsPanel.prototype.updateBgColorIndex = function() {
    var f = this.viewer.impl, h = f.clearColorTop, f = f.clearColorBottom, h = [255 * h.x | 0, 255 * h.y | 0, 255 * h.z | 0, 255 * f.x | 0, 255 * f.y | 0, 255 * f.z | 0], g, d;
    for (d in Teratek.Viewing.Private.BackgroundPresets) {
        var f = Teratek.Viewing.Private.BackgroundPresets[d], c;
        for (c = 0; 6 > c && f[c] == h[c]; c++)
            ;
        if (6 == c) {
            g = d;
            break
        }
    }
    if (!g)
        for (g = "Custom",
        d = Teratek.Viewing.Private.BackgroundPresets[g],
        f = 0; 6 > f; f++)
            d[f] = h[f];
    this.bgSelect.setSelectedValue(g)
}
;
Teratek.Viewing.Private.RenderOptionsPanel.prototype.syncUI = function() {
    var f = this.viewer.impl
      , h = 0;
    f.dir_light1 && (h = 0 != f.dir_light1.intensity ? Math.log(f.dir_light1.intensity) / Math.log(2) : -1E-20);
    this.whiteScale.setValue(h);
    this.exposureBias.setValue(f.renderer().getExposureBias());
    this.updateBgColorIndex();
    h = f.renderer().getToneMapMethod();
    this.toneMapMethod.setSelectedIndex(h);
    this.envSelect.setSelectedIndex(f.currentLightPreset());
    this.exposureBias.setDisabled(0 == h);
    this.saoToggle.setValue(f.renderer().settings.sao);
    this.saoRadius.setDisabled(!f.renderer().settings.sao);
    this.saoIntensity.setDisabled(!f.renderer().settings.sao);
    this.saoRadius.setValue(f.renderer().getAORadius());
    this.saoIntensity.setValue(f.renderer().getAOIntensity());
    this.groundShadowAlpha.setDisabled(!this.viewer.prefs.get("groundShadow"));
    this.groundShadowColor.setDisabled(!this.viewer.prefs.get("groundShadow"));
    this.groundReflectionAlpha.setDisabled(!this.viewer.prefs.get("groundReflection"));
    this.groundReflectionColor.setDisabled(!this.viewer.prefs.get("groundReflection"));
    this.fovAngle.setValue(this.viewer.getFOV());
    this.celToggle.setValue(f.renderer().settings.toonShaded)
}
;
Teratek.Viewing.Private.RenderOptionsPanel.prototype.uninitialize = function() {
    Teratek.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);
    this.viewer = this.fovAngle = this.whiteScale = this.exposureBias = this.toneMapMethod = this.envSelect = this.groundShadowAlpha = this.saoIntensity = this.saoRadius = this.saoToggle = this.bgSelect = this.tbody = this.table = null 
}
;
(function() {
    var f = Teratek.Viewing
      , h = Teratek.Viewing.UI
      , g = function(d, c, a) {
        this.viewer = d;
        this.layersRoot = this.tree = null ;
        this.visibilityImages = {};
        this.isMac = -1 !== navigator.userAgent.search("Mac OS");
        c = "Layer Manager";
        var b = d.config.viewableName
          , g = !0;
        b && "W2D" !== b && (c = f.i18n.translate(c) + ": " + b,
        g = !1);
        this.filterImageId = a + "-layerFilterImageId";
        h.DockingPanel.call(this, d.container, a, c, {
            localizeTitle: g
        });
        this.container.classList.add("layersPanel");
        this.filterContainer = document.createElement("div");
        this.filterContainer.className = 
        "filterBox";
        this.filterContainer.id = this.container.id + "-search-container";
        this.container.appendChild(this.filterContainer);
        this.createScrollContainer({
            heightAdjustment: 105,
            marginTop: 5
        });
        var l = this;
        d.model ? l.build() : l.addEventListener(d, f.GEOMETRY_LOADED_EVENT, function() {
            l.build()
        }
        );
        this.addVisibilityListener(function() {
            l.resizeToContent()
        }
        )
    }
    ;
    g.prototype = Object.create(h.DockingPanel.prototype);
    g.prototype.constructor = g;
    g.prototype.uninitialize = function() {
        h.DockingPanel.prototype.uninitialize.call(this);
        this.filterContainer = this.scrollContainer = this.visibilityImages = this.layersRoot = this.tree = this.viewer = null 
    }
    ;
    g.prototype.build = function() {
        function d() {
            function a(c) {
                var d = [];
                if (-1 !== c.name.toLowerCase().indexOf(b))
                    d.push(c);
                else if (!c.isLayer) {
                    c = c.children;
                    for (var f = 0; f < c.length; ++f)
                        d = d.concat(a(c[f]))
                }
                return d
            }
            if (g.value) {
                var b = g.value.toLowerCase();
                m && 0 < m.childCount && n.setLayerVisible(a(m), !0, !0)
            } else
                n.setLayerVisible(null , !0);
            l = null 
        }
        var c = this
          , a = document.createElement("div");
        a.className = "filterSearch";
        c.filterContainer.appendChild(a);
        var b = document.createElement("div");
        b.className = "filterImage";
        b.id = c.filterImageId;
        b.title = f.i18n.translate("Show/hide all layers");
        a.appendChild(b);
        c.visibilityImages[c.filterImageId] = b;
        c.addEventListener(b, "click", function(a) {
            c.onImageClick(null , a);
            a.stopPropagation()
        }
        );
        var g = this.filterField = document.createElement("input");
        g.className = "filterInput";
        g.placeholder = f.i18n.translate("Enter filter term");
        g.setAttribute("data-i18n", "[placeholder]Enter filter term");
        g.type = 
        "search";
        g.incremental = "incremental";
        a.appendChild(g);
        var l = null 
          , n = c.viewer;
        g.addEventListener("keyup", function(a) {
            l && clearTimeout(l);
            l = setTimeout(d, 500)
        }
        );
        g.addEventListener("click", function(a) {
            "" === g.value ? n.setLayerVisible(null , !0) : setTimeout(function() {
                "" === g.value && (n.setLayerVisible(null , !0),
                a.preventDefault())
            }
            , 1)
        }
        );
        var a = function() {
            var a = new h.TreeDelegate;
            a.getTreeNodeId = function(a) {
                return a.id
            }
            ;
            a.getTreeNodeLabel = function(a) {
                return c.getNodeLabel(a)
            }
            ;
            a.getTreeNodeClass = function(a) {
                return c.getNodeClass(a)
            }
            ;
            a.isTreeNodeGroup = function(a) {
                return c.isGroupNode(a)
            }
            ;
            a.shouldCreateTreeNode = function(a) {
                return c.shouldInclude(a)
            }
            ;
            a.onTreeNodeClick = function(a, b, d) {
                c.onClick(b, d)
            }
            ;
            a.onTreeNodeRightClick = function(a, b, d) {
                c.onRightClick(b, d)
            }
            ;
            a.onTreeNodeDoubleClick = function(a, b, d) {
                c.onDoubleClick(b, d)
            }
            ;
            a.onTreeNodeIconClick = function(a, b, d) {
                c.onIconClick(b, d)
            }
            ;
            a.createTreeNode = function(a, b) {
                c.createNode(a, b)
            }
            ;
            return a
        }
        ()
          , m = c.layersRoot = c.viewer.model.getLayersRoot();
        m && (c.tree = new h.Tree(a,m,c.scrollContainer,{
            excludeRoot: !0
        }),
        c.resizeToContent(),
        c.update(),
        c.addEventListener(c.viewer, f.LAYER_VISIBILITY_CHANGED_EVENT, function() {
            c.update()
        }
        ))
    }
    ;
    g.prototype.update = function() {
        function d(a, b) {
            var c;
            c = 1 === b ? "layerVisible" : 0 === b ? "layerHidden" : "layerMixed";
            a.classList.remove("layerVisible", "layerHidden", "layerMixed");
            a.classList.add(c)
        }
        function c(a, b) {
            0 === b ? f.tree.addClass(a.id, "dim") : f.tree.removeClass(a.id, "dim")
        }
        function a(a) {
            var b;
            if (0 < a.length)
                for (var c = 0; c < a.length; ++c) {
                    var d = a[c];
                    void 0 === b ? b = d : 0 === d && 1 === b ? b = -1 : 1 === d && 
                    0 === b && (b = -1);
                    if (-1 === b)
                        break
                }
            else
                b = 0;
            return b
        }
        function b(g) {
            var h = f.visibilityImages[g.id];
            if (!g.isLayer) {
                for (var l = g.children, r = [], t = 0; t < l.length; ++t)
                    r = r.concat(b(l[t]));
                l = a(r);
                d(h, l);
                c(g, l);
                return r
            }
            r = f.viewer.isLayerVisible(g) ? 1 : 0;
            d(h, r);
            c(g, r);
            return [r]
        }
        var f = this
          , g = this.layersRoot && 0 < this.layersRoot.childCount ? b(f.layersRoot) : [];
        d(f.visibilityImages[f.filterImageId], a(g))
    }
    ;
    g.prototype.setLayerVisible = function(d, c) {
        this.viewer.setLayerVisible(d, "layerVisible" !== this.visibilityImages[d ? d.id : 
        this.filterImageId].className, c);
        this.filterField.value = ""
    }
    ;
    g.prototype.getNodeLabel = function(d) {
        return d.isLayer || 0 === d.childCount ? d.name : d.name + " (" + d.childCount + ")"
    }
    ;
    g.prototype.getNodeClass = function(d) {
        return ""
    }
    ;
    g.prototype.isGroupNode = function(d) {
        return !d.isLayer
    }
    ;
    g.prototype.shouldInclude = function(d) {
        return !0
    }
    ;
    g.prototype.onIconClick = function(d, c) {
        this.setGroupCollapsed(d, !this.isGroupCollapsed(d))
    }
    ;
    g.prototype.setGroupCollapsed = function(d, c) {
        var a = this.tree.delegate();
        a.isTreeNodeGroup(d) && 
        (a = a.getTreeNodeId(d),
        this.tree.setCollapsed(a, c),
        this.resizeToContent())
    }
    ;
    g.prototype.isGroupCollapsed = function(d) {
        var c = this.tree.delegate();
        return c.isTreeNodeGroup(d) ? (d = c.getTreeNodeId(d),
        this.tree.isCollapsed(d)) : !1
    }
    ;
    g.prototype.onClick = function(d, c) {}
    ;
    g.prototype.onDoubleClick = function(d, c) {}
    ;
    g.prototype.onRightClick = function(d, c) {}
    ;
    g.prototype.onImageClick = function(d, c) {}
    ;
    g.prototype.getContentSize = function() {
        var d = this.filterContainer
          , c = d.clientHeight + 80
          , d = d.clientWidth
          , a = this.tree;
        return a && 
        (a = a.getRootContainer()) ? {
            height: a.clientHeight + c,
            width: Math.max(a.clientWidth, d)
        } : {
            height: c,
            width: d
        }
    }
    ;
    g.prototype.createNode = function(d, c) {
        var a = document.createElement("div");
        c.children && 0 < c.children.length ? c.insertBefore(a, c.children[0]) : c.appendChild(a);
        a.title = f.i18n.translate("Show/hide this layer");
        this.visibilityImages[d.id] = a;
        var b = document.createElement("label");
        b.textContent = this.getNodeLabel(d);
        c.appendChild(b);
        var g = this;
        this.addEventListener(a, "click", function(a) {
            g.onImageClick(d, a);
            a.stopPropagation()
        }
        )
    }
    ;
    Teratek.Viewing.UI.LayersPanel = g
}
)();
TeratekNamespace("Teratek.Viewing.UI");
Teratek.Viewing.UI.SettingsPanel = function(f, h, g, d) {
    Teratek.Viewing.UI.DockingPanel.call(this, f, h, g, d);
    this.panelTabs = [];
    this.tabIdToIndex = {};
    this.controls = {};
    this.controlIdCount = 0;
    var c = this;
    h = d && void 0 !== d.width ? d.width : 340;
    this.container.style.maxWidth = "800px";
    this.container.style.minWidth = h + "px";
    this.container.style.top = "100px";
    this.container.style.left = f.offsetWidth / 2 - 170 + "px";
    this.container.style.position = "absolute";
    this.tabContainer = document.createElement("div");
    this.tabContainer.className = 
    "settings-tabs";
    this.container.appendChild(this.tabContainer);
    this.tabs = document.createElement("ul");
    this.tabContainer.appendChild(this.tabs);
    this.heightAdjustment = d && d.heightAdjustment ? d.heightAdjustment : 110;
    this.createScrollContainer({
        left: !1,
        heightAdjustment: this.heightAdjustment,
        marginTop: 0
    });
    this.mouseOver = !1;
    this.addEventListener(this.container, "mouseover", function(a) {
        a = a.toElement || a.relatedTarget;
        if (c.mouseOver)
            return !0;
        for (var b = 0; a && a.parentNode && a.parentNode != window; ) {
            if (a.parentNode == 
            this || a == this) {
                a.preventDefault && a.preventDefault();
                c.mouseOver = !0;
                for (b = 0; b < c.panelTabs.length; b++)
                    c.panelTabs[b].classList.remove("selectedmouseout");
                return !0
            }
            a = a.parentNode
        }
    }
    );
    this.addEventListener(this.container, "mouseout", function(a) {
        a = a.toElement || a.relatedTarget;
        if (c.mouseOver) {
            for (; a && a.parentNode && a.parentNode != window; ) {
                if (a.parentNode == this || a == this)
                    return a.preventDefault && a.preventDefault(),
                    !1;
                a = a.parentNode
            }
            c.mouseOver = !1;
            for (a = 0; a < c.panelTabs.length; a++)
                c.panelTabs[a].classList.contains("tabselected") && 
                c.panelTabs[a].classList.add("selectedmouseout")
        }
    }
    )
}
;
Teratek.Viewing.UI.SettingsPanel.prototype = Object.create(Teratek.Viewing.UI.DockingPanel.prototype);
Teratek.Viewing.UI.SettingsPanel.prototype.constructor = Teratek.Viewing.UI.SettingsPanel;
Teratek.Viewing.UI.SettingsPanel.prototype.setVisible = function(f) {
    f && (this.container.style.display = "block");
    Teratek.Viewing.UI.DockingPanel.prototype.setVisible.call(this, f)
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.addTab = function(f, h, g) {
    var d = this;
    if (void 0 !== this.tabIdToIndex[f])
        return !1;
    var c = g && void 0 !== g.className ? g.className : null 
      , a = g && void 0 !== g.width ? g.width : 200;
    g = g && void 0 !== g.index ? g.index : this.panelTabs.length;
    var b = document.createElement("li");
    b.id = f;
    var k = document.createElement("a")
      , l = document.createElement("span");
    l.setAttribute("data-i18n", h);
    l.textContent = Teratek.Viewing.i18n.translate(h);
    k.appendChild(l);
    b.appendChild(k);
    this.tabs.appendChild(b);
    h = 
    document.createElement("table");
    h.id = f + "-table";
    h.className = "settings-table tftable " + c;
    c = document.createElement("tbody");
    h.appendChild(c);
    this.scrollContainer.appendChild(h);
    this.addEventListener(b, "touchstart", touchStartToClick);
    this.addEventListener(b, "click", function(a) {
        d.selectTab(f)
    }
    );
    this.panelTabs.push(b);
    this.tabIdToIndex[f] = g;
    c = this.container.style.minWidth ? parseInt(this.container.style.minWidth) : 0;
    a > c && (this.container.style.minWidth = a + "px");
    return !0
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.removeTab = function(f) {
    f = this.tabIdToIndex[f];
    if (!f)
        return !1;
    this.panelTabs.splice(f, 1);
    this.tabs.removeChild(tabDom);
    this.tabIdToIndex = {};
    f = this.panelTabs.length;
    for (var h = 0; h < f; h++)
        this.tabIdToIndex[this.panelTabs[h].id] = h;
    return !0
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.hasTab = function(f) {
    return void 0 !== this.panelTabs[this.tabIdToIndex[f]]
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.selectTab = function(f) {
    if (this.isTabSelected(f))
        return !1;
    for (var h = this.panelTabs.length, g = 0; g < h; g++) {
        var d = this.panelTabs[g]
          , c = document.getElementById(d.id + "-table");
        f === d.id ? (d.classList.add("tabselected"),
        c.style.display = "table",
        this.mouseOver || d.classList.add("selectedmouseout")) : (d.classList.remove("tabselected"),
        c.style.display = "none",
        this.mouseOver || this.panelTabs[g].classList.remove("selectedmouseout"))
    }
    this.resizeToContent();
    return !0
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.isTabSelected = function(f) {
    return (f = this.panelTabs[this.tabIdToIndex[f]]) && f.classList.contains("tabselected")
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.addCheckbox = function(f, h, g, d, c) {
    if (void 0 === this.tabIdToIndex[f])
        return null ;
    var a = document.getElementById(f + "-table");
    h = new Teratek.Viewing.Private.OptionCheckbox(h,a.tBodies[0],g,c);
    h.changeListener = function(a) {
        d(a.detail.target.checked)
    }
    ;
    this.addEventListener(h, "change", h.changeListener);
    return this.addControl(f, h)
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.addSlider = function(f, h, g, d, c, a, b) {
    if (void 0 === this.tabIdToIndex[f])
        return null ;
    var k = document.getElementById(f + "-table");
    h = new Teratek.Viewing.Private.OptionSlider(h,g,d,k.tBodies[0],b);
    h.setValue(c);
    h.sliderElement.step = h.stepperElement.step = 1;
    this.addEventListener(h, "change", function(b) {
        a(b)
    }
    );
    return this.addControl(f, h)
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.addDropDownMenu = function(f, h, g, d, c, a) {
    if (void 0 === this.tabIdToIndex[f])
        return null ;
    var b = document.getElementById(f + "-table");
    h = new Teratek.Viewing.Private.OptionDropDown(h,b.tBodies[0],g,d,a);
    this.addEventListener(h, "change", function(a) {
        c(a)
    }
    );
    return this.addControl(f, h)
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.addControl = function(f, h, g) {
    if (void 0 === this.tabIdToIndex[f])
        return null ;
    if (!h.hasOwnProperty("sliderRow")) {
        var d = g && g.insertAtIndex ? g.insertAtIndex : -1;
        g = g && g.caption ? g.caption : null ;
        f = document.getElementById(f + "-table");
        d > f.length && (d = -1);
        var d = f.tBodies[0].insertRow(d)
          , c = d.insertCell(0);
        if (g) {
            var a = document.createElement("div");
            a.setAttribute("data-i18n", g);
            a.textContent = Teratek.Viewing.i18n.translate(g);
            c.appendChild(a);
            c = d.insertCell(1)
        } else
            c.colSpan = 
            2;
        c.appendChild(h);
        h.sliderRow = d;
        h.tbody = f.tBodies[0]
    }
    g = "teratek_settings_control_id_" + this.controlIdCount.toString();
    this.controlIdCount += 1;
    this.controls[g] = h;
    this.resizeToContent();
    return g
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.removeCheckbox = function(f) {
    return this.removeControl(f)
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.removeSlider = function(f) {
    return this.removeControl(f)
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.removeCheckbox = function(f) {
    return this.removeControl(f)
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.removeControl = function(f) {
    var h = this.controls[f];
    if (void 0 === h)
        return !1;
    h.tbody.deleteRow(h.sliderRow.rowIndex);
    delete this.controls[f];
    this.resizeToContent();
    return !0
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.getControl = function(f) {
    return void 0 !== this.controls[f] ? this.controls[f] : null 
}
;
Teratek.Viewing.UI.SettingsPanel.prototype.getContentSize = function() {
    for (var f = this.heightAdjustment, h = this.panelTabs.length > this.panelTabs[0] ? 0 : null , g = 0; g < this.panelTabs.length; g++) {
        var d = this.panelTabs[g];
        if (this.isTabSelected(d.id)) {
            h = d;
            break
        }
    }
    h && (h = document.getElementById(d.id + "-table"),
    f += h.clientHeight);
    return {
        height: f,
        width: this.container.clientWidth
    }
}
;
(function() {
    var f = function() {}
    ;
    f.instances = [];
    f.displayError = function(h, g, d, c, a) {
        var b = document.createElement("div");
        b.className = "alertBox error";
        h.appendChild(b);
        c || (c = "img-item-not-found");
        var k = document.createElement("div");
        k.className = "alertBoxImage " + c;
        b.appendChild(k);
        c = document.createElement("div");
        c.className = "alertBoxMsg";
        b.appendChild(c);
        d || (d = Teratek.Viewing.i18n.translate("Error Occurred", {
            defaultValue: "Error Occurred"
        }));
        k = document.createElement("div");
        k.className = "alertBoxTitle";
        k.textContent = 
        d;
        c.appendChild(k);
        d = document.createElement("div");
        d.className = "alertBoxText";
        d.textContent = g;
        c.appendChild(d);
        if (a) {
            g = document.createElement("div");
            g.className = "alertBoxContent";
            c.appendChild(g);
            c = document.createElement("ul");
            c.className = "alertBoxContent";
            for (d = 0; d < a.length; d++) {
                var l = a[d];
                if (l) {
                    k = document.createElement("li");
                    c.appendChild(k);
                    l = this.extractList(l);
                    if (l.list.length) {
                        var n = this.generateListElement(list);
                        c.appendChild(n)
                    }
                    k.innerHTML = l.msg
                }
            }
            g.appendChild(c)
        }
        a = document.createElement("div");
        a.className = "alertBoxOK";
        a.textContent = Teratek.Viewing.i18n.translate("OK", {
            defaultValue: "OK"
        });
        var m = {
            alertBox: b,
            container: h
        };
        a.addEventListener("click", function(a) {
            b.style.visibility = "hidden";
            h.removeChild(b);
            f.instances.splice(f.instances.indexOf(m), 1)
        }
        );
        b.appendChild(a);
        b.style.visibility = "visible";
        f.instances.push(m)
    }
    ;
    f.displayErrors = function(h, g, d) {
        var c = document.createElement("div");
        c.className = "alertBox errors";
        h.appendChild(c);
        g || (g = "img-item-not-found");
        var a = document.createElement("div");
        a.className = "alertBoxImage " + g;
        c.appendChild(a);
        g = document.createElement("div");
        g.className = "alertBoxMsg errors";
        c.appendChild(g);
        for (a = 0; a < d.length; a++) {
            var b = d[a].header;
            b || (b = Teratek.Viewing.i18n.translate("Error", {
                defaultValue: "Error"
            }));
            var k = document.createElement("div");
            k.className = "alertBoxTitle errors";
            k.textContent = b;
            g.appendChild(k);
            var l = document.createElement("div");
            l.className = "alertBoxText errors";
            k = d[a].msg;
            b = this.extractList(k);
            if (b.list.length) {
                var n = document.createElement("div")
                  , 
                k = this.generateListElement(b.list);
                n.appendChild(k);
                l.textContent = b.msg;
                l.appendChild(n)
            } else
                l.textContent = k;
            g.appendChild(l);
            if (d[a].hints) {
                l = document.createElement("ul");
                l.className = "alertBoxContent";
                for (var n = d[a].hints, m = 0; m < n.length; m++)
                    if (b = n[m]) {
                        var q = document.createElement("li");
                        l.appendChild(q);
                        b = this.extractList(b);
                        b.list.length && (k = this.generateListElement(b.list),
                        l.appendChild(k));
                        q.innerHTML = b.msg
                    }
                g.appendChild(l)
            }
        }
        d = document.createElement("div");
        d.className = "alertBoxOK";
        d.textContent = 
        Teratek.Viewing.i18n.translate("OK", {
            defaultValue: "OK"
        });
        var r = {
            alertBox: c,
            container: h
        };
        d.addEventListener("click", function(a) {
            c.style.visibility = "hidden";
            h.removeChild(c);
            f.instances.splice(f.instances.indexOf(r), 1)
        }
        );
        c.appendChild(d);
        c.style.visibility = "visible";
        f.instances.push(r)
    }
    ;
    f.extractList = function(f) {
        var g = {
            msg: f,
            list: []
        };
        f && -1 != f.indexOf("<ul>") && (f = f.split("<ul>"),
        g.msg = f[0],
        f = f[1].split("</ul>"),
        g.list = f[0].split(", "),
        1 === g.list.length && (g.list = f[0].split(",")));
        return g
    }
    ;
    f.generateListElement = 
    function(f) {
        for (var g = document.createElement("ul"), d = 0; d < f.length; d++) {
            var c = document.createElement("li");
            c.textContent = f[d];
            g.appendChild(c)
        }
        return g
    }
    ;
    f.dismiss = function() {
        if (0 < f.instances.length) {
            var h = f.instances.pop();
            h.alertBox.style.visibility = "hidden";
            h.container.removeChild(h.alertBox);
            return !0
        }
        return !1
    }
    ;
    Teratek.Viewing.Private.AlertBox = f
}
)();
(function() {
    var f = Teratek.Viewing
      , h = function() {}
    ;
    h.instances = [];
    h.displayMessage = function(g, d, c, a, b) {
        if (!(0 < h.instances.length)) {
            var k = d.msgTitleKey
              , l = d.msgTitleDefaultValue || k
              , n = d.messageKey
              , m = d.messageDefaultValue || n
              , q = d.buttonText
              , r = d.checkboxChecked || !1;
            d = document.createElement("div");
            d.className = "hud";
            g.appendChild(d);
            var t = document.createElement("div");
            t.className = "hudTitle";
            t.textContent = f.i18n.translate(k, {
                defaultValue: l
            });
            t.setAttribute("data-i18n", k);
            d.appendChild(t);
            c && (k = document.createElement("div"),
            k.className = "hudClose",
            k.innerHTML = "&times;",
            k.addEventListener("click", function(a) {
                h.dismiss();
                c && c(a)
            }
            ),
            d.appendChild(k));
            k = document.createElement("div");
            k.className = "hudMessage";
            k.textContent = f.i18n.translate(n, {
                defaultValue: m
            });
            k.setAttribute("data-i18n", n);
            d.appendChild(k);
            a && (n = document.createElement("div"),
            n.className = "hudButton",
            n.textContent = f.i18n.translate(q, {
                defaultValue: q
            }),
            n.setAttribute("data-i18n", q),
            n.addEventListener("click", a),
            d.appendChild(n));
            b && (a = document.createElement("div"),
            q = document.createElement("input"),
            q.className = "hudCheckbox",
            q.type = "checkbox",
            q.checked = r,
            a.appendChild(q),
            r = document.createElement("label"),
            r.setAttribute("for", "Do not show this message again"),
            r.setAttribute("data-i18n", "Do not show this message again"),
            r.textContent = f.i18n.translate("Do not show this message again", {
                defaultValue: "Do not show this message again"
            }),
            a.appendChild(r),
            q.addEventListener("change", b),
            d.appendChild(a));
            h.instances.push({
                hudMessage: d,
                container: g
            })
        }
    }
    ;
    h.dismiss = function() {
        if (0 < 
        h.instances.length) {
            var f = h.instances.pop();
            f.hudMessage.style.visibility = "hidden";
            f.container.removeChild(f.hudMessage);
            return !0
        }
        return !1
    }
    ;
    Teratek.Viewing.Private.HudMessage = h
}
)();
(function() {
    var f = Teratek.Viewing.UI
      , h = Teratek.Viewing.Private
      , g = function() {}
    ;
    g.prototype.constructor = g;
    g.prototype.isTreeNodeGroup = function(c) {
        throw "isTreeNodeGroup is not implemented.";
    }
    ;
    g.prototype.getTreeNodeId = function(c) {
        throw "getTreeNodeId is not implemented.";
    }
    ;
    g.prototype.getTreeNodeLabel = function(c) {
        return c.name
    }
    ;
    g.prototype.shouldCreateTreeNode = function(c) {
        return !0
    }
    ;
    g.prototype.forEachChild = function(c, a) {
        for (var b = c.children ? c.children.length : 0, d = 0; d < b; ++d)
            a(c.children[d])
    }
    ;
    g.prototype.createTreeNode = 
    function(c, a, b) {
        var d = document.createElement("label");
        a.appendChild(d);
        c = this.getTreeNodeLabel(c);
        b && b.localize && (d.setAttribute("data-i18n", c),
        c = Teratek.Viewing.i18n.translate(c));
        d.textContent = c
    }
    ;
    g.prototype.onTreeNodeClick = function(c, a, b) {}
    ;
    g.prototype.onTreeNodeIconClick = function(c, a, b) {
        c.delegate().isTreeNodeGroup(a) && c.setCollapsed(a, !c.isCollapsed(a))
    }
    ;
    g.prototype.onTreeNodeDoubleClick = function(c, a, b) {}
    ;
    g.prototype.onTreeNodeRightClick = function(c, a, b) {}
    ;
    g.prototype.getTreeNodeClass = function(c) {
        return ""
    }
    ;
    var d = function(c, a, b, d) {
        this.myDelegate = c;
        this.mySelectedNodes = [];
        this.myOptions = d || {};
        this.myGroupNodes = [];
        this.nodeToElement = [];
        c = this.myRootContainer = this.createHtmlElement_(b, "div", "treeview");
        a = this.rootElem = this.createElement_(a, c, null , 0);
        d && d.excludeRoot && a.classList.add("exclude")
    }
    ;
    d.prototype.constructor = d;
    d.prototype.show = function(c) {
        this.myRootContainer.style.display = c ? "block" : "none"
    }
    ;
    d.prototype.getRootContainer = function() {
        return this.myRootContainer
    }
    ;
    d.prototype.getElementForNode = function(c) {
        "number" !== 
        typeof c && "string" !== typeof c && (c = this.myDelegate.getTreeNodeId(c));
        return this.nodeToElement[c]
    }
    ;
    d.prototype.delegate = function() {
        return this.myDelegate
    }
    ;
    d.prototype.isCollapsed = function(c) {
        return this.hasClass(c, "collapsed")
    }
    ;
    d.prototype.setCollapsed = function(c, a, b) {
        a ? (this.addClass(c, "collapsed", b),
        this.removeClass(c, "expanded", b)) : (this.addClass(c, "expanded", b),
        this.removeClass(c, "collapsed", b))
    }
    ;
    d.prototype.setAllCollapsed = function(c) {
        var a;
        c ? (c = function(a) {
            return a.classList.contains("expanded")
        }
        ,
        a = function(a) {
            a.classList.add("collapsed");
            a.classList.remove("expanded")
        }
        ) : (c = function(a) {
            return a.classList.contains("collapsed")
        }
        ,
        a = function(a) {
            a.classList.add("expanded");
            a.classList.remove("collapsed")
        }
        );
        for (var b = 0; b < this.myGroupNodes.length; ++b) {
            var d = this.myGroupNodes[b];
            c(d) && a(d)
        }
    }
    ;
    d.prototype.addToSelection = function(c) {
        for (var a = c.length, b = 0; b < a; ++b) {
            var d = c[b], f;
            f = d;
            -1 === this.mySelectedNodes.indexOf(f) ? (this.mySelectedNodes.push(f),
            f = !0) : f = !1;
            f && this.addClass(d, "selected")
        }
    }
    ;
    d.prototype.removeFromSelection = 
    function(c) {
        for (var a = c.length - 1; 0 <= a; --a) {
            var b = c[a], d;
            d = this.mySelectedNodes.indexOf(b);
            -1 !== d ? (this.mySelectedNodes.splice(d, 1),
            d = !0) : d = !1;
            d && this.removeClass(b, "selected")
        }
    }
    ;
    d.prototype.setSelection = function(c) {
        this.removeFromSelection(this.mySelectedNodes);
        this.addToSelection(c);
        return this.mySelectedNodes
    }
    ;
    d.prototype.clearSelection = function() {
        this.removeFromSelection(this.mySelectedNodes)
    }
    ;
    d.prototype.isSelected = function(c) {
        return this.hasClass(c, "selected")
    }
    ;
    d.prototype.scrollTo = function(c) {
        if (c = 
        this.getElementForNode(c)) {
            var a = c.offsetTop;
            for (c = c.parentNode; c && c != this.myRootContainer; )
                a += c.offsetTop,
                c = c.parentNode;
            this.myRootContainer.parentNode.scrollTop = a
        }
    }
    ;
    d.prototype.addClass = function(c, a, b) {
        if (c = this.getElementForNode(c)) {
            if (b)
                for (c = c.parentNode,
                b = this.myOptions.excludeRoot ? this.rootElem : this.myRootContainer; c && c !== b; )
                    c.classList.add(a),
                    c = c.parentNode;
            else
                c.classList.add(a);
            return !0
        }
        return !1
    }
    ;
    d.prototype.removeClass = function(c, a, b) {
        if (c = this.getElementForNode(c)) {
            if (b)
                for (c = c.parentNode,
                b = this.myOptions.excludeRoot ? this.rootElem : this.myRootContainer; c && c !== b; )
                    c.classList.remove(a),
                    c = c.parentNode;
            else
                c.classList.remove(a);
            return !0
        }
        return !1
    }
    ;
    d.prototype.hasClass = function(c, a) {
        return this.getElementForNode(c).classList.contains(a)
    }
    ;
    d.prototype.clear = function() {
        for (var c = this.myRootContainer; c.hasChildNodes(); )
            c.removeChild(c.lastChild);
        this.nodeToElement = {}
    }
    ;
    d.prototype.createElement_ = function(c, a, b, d) {
        function f(a, d, h) {
            a = g.createHtmlElement_(a, d, h);
            d = g.createHtmlElement_(a, "header");
            g.createHtmlElement_(d, "icon").addEventListener("click", function(a) {
                g.myDelegate.onTreeNodeIconClick(g, c, a);
                a.stopPropagation();
                a.preventDefault()
            }
            , !1);
            g.myDelegate.createTreeNode(c, d, b);
            return a
        }
        if (!c || !this.myDelegate.shouldCreateTreeNode(c))
            return null ;
        var g = this, h;
        g.myDelegate.isTreeNodeGroup(c) ? (h = f(a, "group", "expanded"),
        g.nodeToElement[this.myDelegate.getTreeNodeId(c)] = h,
        a = g.myOptions.excludeRoot ? 1 : 0,
        d == a && (h.style.left = "0px"),
        g.myGroupNodes.push(h),
        g.myDelegate.forEachChild(c, function(a) {
            g.createElement_(a, 
            h, b, d + 1)
        }
        )) : (h = f(a, "leaf", "expanded"),
        g.nodeToElement[this.myDelegate.getTreeNodeId(c)] = h,
        a = g.myOptions.excludeRoot ? 1 : 0,
        d == a && (h.style.marginLeft = "0px"));
        isTouchDevice() && (h.hammer = new Hammer.Manager(h,{
            recognizers: [[Hammer.Tap, {
                event: "doubletap",
                taps: 2,
                interval: 400,
                threshold: 6,
                posThreshold: 30
            }], [Hammer.Tap], [Hammer.Press, {
                event: "press",
                time: 500
            }]],
            inputClass: Hammer.TouchInput
        }),
        h.hammer.on("doubletap", function(a) {
            g.myDelegate.onTreeNodeDoubleClick(g, c, a);
            a.srcEvent.stopPropagation();
            a.preventDefault()
        }
        ),
        h.hammer.on("tap", function(a) {
            g.myDelegate.onTreeNodeClick(g, c, a);
            a.srcEvent.stopPropagation();
            a.preventDefault()
        }
        ),
        h.hammer.on("press", function(a) {
            g.myDelegate.onTreeNodeRightClick(g, c, a);
            a.srcEvent.stopPropagation();
            a.preventDefault()
        }
        ));
        h.addEventListener("click", function(a) {
            g.myDelegate.onTreeNodeClick(g, c, a);
            a.stopPropagation();
            a.preventDefault()
        }
        , !1);
        h.addEventListener("dblclick", function(a) {
            g.myDelegate.onTreeNodeDoubleClick(g, c, a);
            a.stopPropagation();
            a.preventDefault()
        }
        , !1);
        h.addEventListener("contextmenu", 
        function(a) {
            g.myDelegate.onTreeNodeRightClick(g, c, a);
            a.stopPropagation();
            a.preventDefault()
        }
        , !1);
        (a = g.myDelegate.getTreeNodeClass(c)) && h.classList.add(a);
        return h
    }
    ;
    d.prototype.createHtmlElement_ = function(c, a, b) {
        a = document.createElement(a);
        c.appendChild(a);
        b && (a.className = b);
        return a
    }
    ;
    d.prototype.iterate = function(c, a) {
        if (c && this.myDelegate.shouldCreateTreeNode(c)) {
            var b = this.getElementForNode(c);
            if (b) {
                a(c, b);
                var d = this;
                this.myDelegate.forEachChild(c, function(b) {
                    d.iterate(b, a)
                }
                )
            }
        }
    }
    ;
    h.TreeDelegate = f.TreeDelegate = 
    g;
    h.Tree = f.Tree = d
}
)();
(function() {
    var f = function() {}
    ;
    f.prototype.constructor = f;
    f.prototype.getNodeId = function(f) {
        throw "getId is not implemented.";
    }
    ;
    f.prototype.getNodeLabel = function(f) {
        return f.name
    }
    ;
    f.prototype.getNodeClass = function(f) {
        return ""
    }
    ;
    f.prototype.hasThumbnail = function(f) {
        return !1
    }
    ;
    f.prototype.getThumbnail = function(f) {
        return null 
    }
    ;
    f.prototype.onNodeClick = function(f, d, c) {}
    ;
    f.prototype.onNodeHover = function(f, d, c) {}
    ;
    f.prototype.selectItem = function(f) {}
    ;
    f.prototype.deselectItem = function(f) {}
    ;
    f.prototype.hasContent = 
    function(f) {
        return !1
    }
    ;
    f.prototype.addContent = function(f, d) {}
    ;
    var h = function(f, d, c) {
        this.myDelegate = f;
        this.mySelectedIds = [];
        this.myRootContainerId = c + "-browserview";
        this.idToElement = {};
        this.myRootContainer = document.createElement("div");
        this.myRootContainer.id = this.myRootContainerId;
        this.myRootContainer.classList.add("browserview");
        document.getElementById(c).appendChild(this.myRootContainer);
        this.createElements(d, this.myRootContainer)
    }
    ;
    h.prototype.constructor = h;
    h.prototype.show = function(f) {
        f ? (this.myRootContainer.classList.remove("browserHidden"),
        this.myRootContainer.classList.add("browserVisible"),
        this.myRootContainer.style.display = "block") : (this.myRootContainer.classList.remove("browserVisible"),
        this.myRootContainer.classList.add("browserHidden"),
        this.myRootContainer.style.display = "none")
    }
    ;
    h.prototype.getRootContainer = function() {
        return this.myRootContainer
    }
    ;
    h.prototype.delegate = function() {
        return this.myDelegate
    }
    ;
    h.prototype.addToSelection = function(f) {
        for (var d = 0, c = f.length; d < c; ++d) {
            var a = f[d], b;
            b = a;
            -1 == this.mySelectedIds.indexOf(b) ? (this.mySelectedIds.push(b),
            b = !0) : b = !1;
            b && (b = this.idToElement[a],
            void 0 === b ? this.myDelegate.selectItem(a) : b.classList.add("selected"))
        }
    }
    ;
    h.prototype.removeFromSelection = function(f) {
        for (var d = f.length - 1; 0 <= d; --d) {
            var c = f[d], a;
            a = this.mySelectedIds.indexOf(c);
            -1 != a ? (this.mySelectedIds.splice(a, 1),
            a = !0) : a = !1;
            a && (a = this.idToElement[c],
            void 0 === a ? this.myDelegate.deselectItem(c) : a.classList.remove("selected"))
        }
    }
    ;
    h.prototype.setSelection = function(f) {
        this.removeFromSelection(this.mySelectedIds);
        this.addToSelection(f);
        return this.mySelectedIds
    }
    ;
    h.prototype.clearSelection = function() {
        this.removeFromSelection(this.mySelectedIds)
    }
    ;
    h.prototype.createElements = function(f, d) {
        if (f)
            for (var c = 0; c < f.length; c++)
                this.createElement(f[c], d)
    }
    ;
    h.prototype.createElement = function(f, d) {
        var c = this
          , a = c.myDelegate.getNodeId(f)
          , b = document.createElement("item");
        d.appendChild(b);
        this.idToElement[a] = b;
        b.onmouseover = function() {
            c.myDelegate.onNodeHover(c, f)
        }
        ;
        b.onclick = function(a) {
            c.myRootContainer.querySelector(".flipped").removeClass("flipped");
            c.myDelegate.onNodeClick(c, 
            f, a)
        }
        ;
        a = document.createElement("div");
        a.classList.add("card");
        b.appendChild(a);
        var h = document.createElement("div");
        h.classList.add("browserElement");
        a.appendChild(h);
        var l = c.myDelegate.getNodeLabel(f)
          , n = document.createElement("label");
        n.innerHTML = l;
        h.appendChild(n);
        n.onclick = function(a) {
            c.myDelegate.onNodeClick(c, f, a)
        }
        ;
        if (l = c.myDelegate.getThumbnail(f))
            n = document.createElement("img"),
            n.classList.add("thumb"),
            n.src = l,
            h.appendChild(n),
            n.onclick = function(a) {
                c.myDelegate.onNodeClick(c, f, a)
            }
            ;
        c.myDelegate.hasContent(f) && 
        c.myDelegate.addContent(f, a);
        b.classList.add(c.myDelegate.getNodeClass(f))
    }
    ;
    Teratek.Viewing.Private.BrowserDelegate = f;
    Teratek.Viewing.Private.Browser = h
}
)();
TeratekNamespace("Teratek.Viewing.Private");
(function() {
    var f = Teratek.Viewing.Private;
    f.WEBGL_HELP_LINK = null ;
    f.ErrorInfoData = {
        1: {
            img: "img-reload",
            "globalized-msg": "Viewer-UnknownFailure",
            "default-msg": "<title> Sorry </title><message>We seem to have some technical difficulties and couldn't complete your request.</message> <hint>Try loading the item again. </hint><hint>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
        },
        2: {
            img: "img-unsupported",
            "globalized-msg": "Viewer-BadData",
            "default-msg": "<title> Sorry </title><message>The item you are trying to view was not processed completely. </message><hint>Try loading the item again.</hint><hint>Please upload the file again to see if that fixes the issue.</hint>"
        },
        3: {
            img: "img-reload",
            "globalized-msg": "Viewer-NetworkError",
            "default-msg": "<title> Sorry </title><message>We seem to have some technical difficulties and couldn't complete your request.</message><hint> Try loading the item again.</hint><hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
        },
        4: {
            img: "img-unloack",
            "globalized-msg": "Viewer-AccessDenied",
            "default-msg": "<title> No access </title><message>Sorry. You don\u2019t have the required privileges to access this item.</message><hint> Please contact the author</hint>"
        },
        5: {
            img: "img-item-not-found",
            "globalized-msg": "Viewer-FileNotFound",
            "default-msg": '<title> Sorry </title><message>We can\u2019t display the item you are looking for. It may not have been processed yet. It may have been moved, deleted, or you may be using a corrupt file or unsupported file format.</message><hint> Try converting the item again.</hint><hint> Please convert the file again to see if that fixes the issue.</hint>'
        },
        6: {
            img: "img-reload",
            "globalized-msg": "Viewer-ServerError",
            "default-msg": "<title> Sorry </title><message>We seem to have some technical difficulties and couldn't complete your request.</message><hint> Try loading the item again.</hint><hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
        },
        7: {
            img: "img-reload",
            "globalized-msg": "Viewer-UnhandledResponseCode",
            "default-msg": "<title> Network problem </title><message>Sorry. We seem to have some technical difficulties and couldn't complete your request.</message><hint> Try loading the item again.</hint><hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
        },
        8: {
            img: "img-unsupported",
            "globalized-msg": "Viewer-WebGlNotSupported",
            "default-msg": '<title>Sorry</title><message>We can\'t show this item because this browser doesn\'t support WebGL.</message><hint>Try Google Chrome, Mozilla Firefox, or another browser that supports WebGL 3D graphics.</hint><hint>For more information, see the <a href="WEBGL_HELP" target="_blank">A360 browser reqirements.</a></hint>'
        },
        9: {
            img: "img-item-not-found",
            "globalized-msg": "Viewer-NoViewable",
            "default-msg": "<title> No viewable content </title><message>There\u2019s nothing to display for this item. It may not have been processed or it may not have content we can display.</message><hint> Please contact the author.</hint><hint> Please upload the file again to see if that fixes the issue.</hint>"
        },
        10: {
            img: "img-unsupported",
            "globalized-msg": "Viewer-WebGlDisabled",
            "default-msg": '<title>Sorry</title><message>We can\'t show this item because WebGL is disabled on this device.</message><hint> For more information see the <a href="WEBGL_HELP" target="_blank">A360 Help.</a></hint>'
        },
        11: {
            img: "img-unsupported",
            "globalized-msg": "Viewer-RTCError",
            "default-msg": "<title> Sorry </title><message>We couldn\u2019t connect to the Collaboration server.</message><hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
        }
    };
    f.currentError = null ;
    f.currentErrors = null ;
    f.ErrorHandler = function() {}
    ;
    f.ErrorHandler.prototype.constructor = f.ErrorHandler;
    f.ErrorHandler.getErrorCode = function(f) {
        return 403 === f || 401 === f ? Teratek.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED : 404 === f ? Teratek.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND : 500 <= f ? Teratek.Viewing.ErrorCodes.NETWORK_SERVER_ERROR : Teratek.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE
    }
    ;
    f.ErrorHandler.reportError = function(h, g, d, c) {
        f.ErrorHandler.currentError = null ;
        f.ErrorHandler.currentErrors = 
        null ;
        if (g) {
            f.logger && f.logger.log({
                category: "error",
                code: g,
                message: d
            }, !0);
            f.ErrorHandler.currentError = [h, g, d, c];
            var a = f.ErrorInfoData[g];
            if (a) {
                var b = {
                    defaultValue: ""
                };
                b.defaultValue = a["default-msg"];
                var k = a.img;
                d = this.parseErrorString(a["globalized-msg"], b);
                if (g === Teratek.Viewing.ErrorCodes.BROWSER_WEBGL_DISABLED || g === Teratek.Viewing.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED)
                    for (g = f.WEBGL_HELP_LINK || "",
                    c = 0; c < d.hints.length; c++)
                        -1 !== d.hints[c].indexOf('href="WEBGL_HELP"') && 
                        (d.hints[c] = d.hints[c].replace('href="WEBGL_HELP"', 'href="' + g + '"'))
            } else
                k = "img-unsupported",
                b = {
                    defaultValue: "",
                    interpolationPrefix: "{",
                    interpolationSuffix: "}"
                },
                this.parseArguments(d, b),
                d = this.parseErrorString(g, b),
                d.header || (d.header = "warning" === c ? Teratek.Viewing.i18n.translate("header-warning") : "");
            f.AlertBox.displayError(h, d.msg, d.header, k, d.hints)
        }
    }
    ;
    f.ErrorHandler.reportErrors = function(h, g) {
        f.ErrorHandler.currentError = null ;
        f.ErrorHandler.currentErrors = null ;
        if (g) {
            f.ErrorHandler.currentErrors = 
            [h, g];
            for (var d = {
                defaultValue: "",
                interpolationPrefix: "{",
                interpolationSuffix: "}"
            }, c = [], a = 0; a < g.length; a++)
                if (g[a].code) {
                    this.parseArguments(g[a].message, d);
                    var b = this.parseErrorString(g[a].code, d);
                    b.header || (b.header = "warning" === g[0].type ? Teratek.Viewing.i18n.translate("header-warning", {
                        defaultValue: "Warning"
                    }) : "");
                    c.push(b);
                    f.logger && f.logger.log({
                        category: "error",
                        code: g[a].code,
                        message: g[a].message
                    }, !0)
                }
            c.length && f.AlertBox.displayErrors(h, "img-unsupported", c)
        }
    }
    ;
    f.ErrorHandler.parseArguments = function(f, 
    g) {
        if (f)
            if ("string" === typeof f)
                g.defaultValue = f;
            else {
                g.defaultValue = f[0];
                for (var d = 1; d < f.length; d++)
                    g[(d - 1).toString()] = f[d]
            }
    }
    ;
    f.ErrorHandler.parseErrorString = function(f, g) {
        var d = {
            msg: null ,
            msgList: null ,
            header: null ,
            hints: null 
        };
        if (!f)
            return d;
        var c = Teratek.Viewing.i18n.translate(f, g);
        if (!c)
            return d;
        -1 != c.indexOf("<title>") && (c = c.split("<title>")[1].split("</title>"),
        d.header = c[0],
        c = c[1]);
        c && -1 != c.indexOf("<message>") ? (c = c.split("<message>")[1].split("</message>"),
        d.msg = c[0],
        c = c[1]) : d.msg = c;
        if (c && -1 != 
        c.indexOf("<hint>")) {
            d.hints = [];
            for (var c = c.split("<hint>"), a = 0; a < c.length; a++) {
                var b = c[a].split("</hint")[0];
                d.hints.push(b)
            }
        }
        return d
    }
    ;
    f.ErrorHandler.localize = function() {
        if (0 < f.AlertBox.instances.length)
            if (f.AlertBox.dismiss(),
            f.ErrorHandler.currentError) {
                var h = f.ErrorHandler.currentError.shift()
                  , g = f.ErrorHandler.currentError;
                f.ErrorHandler.reportError(h, g[0], g[1], g[2])
            } else
                h = f.ErrorHandler.currentErrors.shift(),
                f.ErrorHandler.reportErrors(h, f.ErrorHandler.currentErrors[0])
    }
}
)();
(function() {
    var f = function(f, g) {
        this.viewer = f;
        this.options = g
    }
    ;
    f.prototype.load = function() {
        return !0
    }
    ;
    f.prototype.unload = function() {
        return !0
    }
    ;
    f.prototype.getState = function(f) {}
    ;
    f.prototype.restoreState = function(f, g) {
        return !0
    }
    ;
    Teratek.Viewing.Extension = f
}
)();
(function() {
    var f = new function() {
        var f = {};
        return {
            registerExtension: function(d, c) {
                return f.hasOwnProperty(d) ? !1 : (f[d] = c,
                !0)
            },
            getExtension: function(d) {
                return f.hasOwnProperty(d) ? f[d] : null 
            },
            unregisterExtension: function(d) {
                return f.hasOwnProperty(d) ? (delete f[d],
                !0) : !1
            }
        }
    }
      , h = function() {}
    ;
    h.prototype = {
        loadExtension: function(g, d) {
            this.loadedExtensions || (this.loadedExtensions = {});
            var c = !1;
            if (this.getExtension(g))
                stderr("Extension already loaded: " + g);
            else {
                var a = f.getExtension(g);
                if (a) {
                    if (a = new a(this,d),
                    c = a.load())
                        this.loadedExtensions[g] = a,
                        stderr("Extension loaded: " + g)
                } else
                    stderr("Extension not found: " + g)
            }
            return c
        },
        getExtension: function(f) {
            return this.loadedExtensions && f in this.loadedExtensions ? this.loadedExtensions[f] : null 
        },
        unloadExtension: function(f) {
            var d = !1
              , c = this.getExtension(f);
            c ? (d = c.unload(),
            stderr("Extension unloaded: " + f),
            delete this.loadedExtensions[f]) : stderr("Extension not found: " + f);
            return d
        },
        apply: function(f) {
            var d = h.prototype;
            f.loadExtension = d.loadExtension;
            f.getExtension = d.getExtension;
            f.unloadExtension = d.unloadExtension
        }
    };
    Teratek.Viewing.theExtensionManager = f;
    Teratek.Viewing.ExtensionMixin = h
}
)();
function init_UnifiedCamera() {
    if ("undefined" === typeof Teratek.Viewing.UnifiedCamera) {
        var f = function(f, g) {
            THREE.Camera.call(this);
            this.fov = 45;
            this.near = .1;
            this.far = 1E5;
            this.aspect = f / g;
            this.left = -f / 2;
            this.right = f / 2;
            this.top = g / 2;
            this.bottom = -g / 2;
            this.clientWidth = f;
            this.clientHeight = g;
            this.target = new THREE.Vector3(0,0,-1);
            this.worldup = new THREE.Vector3(0,1,0);
            this.orthographicCamera = new THREE.OrthographicCamera(this.left,this.right,this.top,this.bottom,this.near,this.far);
            this.perspectiveCamera = new THREE.PerspectiveCamera(this.fov,
            this.aspect,this.near,this.far);
            this.zoom = 1;
            this.toPerspective()
        }
        ;
        f.ORTHO_FOV = 360 * Math.atan(.5) / Math.PI;
        f.prototype = Object.create(THREE.Camera.prototype);
        f.prototype.clone = function() {
            var h = new f(2 * this.right,2 * this.top);
            THREE.Camera.prototype.clone.call(this, h);
            h.position.copy(this.position);
            h.up.copy(this.up);
            this.target && (h.target = this.target.clone());
            this.worldup && (h.worldup = this.worldup.clone());
            h.left = this.left;
            h.right = this.right;
            h.top = this.top;
            h.bottom = this.bottom;
            h.near = this.near;
            h.far = this.far;
            h.fov = this.fov;
            h.aspect = this.aspect;
            h.zoom = this.zoom;
            h.isPerspective = this.isPerspective;
            this.updateProjectionMatrix();
            return h
        }
        ;
        f.prototype.__computeFovPosition = function(f) {
            if (1E-4 >= Math.abs(this.fov - f))
                return this.position.clone();
            var g = this.target.clone().sub(this.position)
              , d = THREE.Math.degToRad(this.fov);
            f = THREE.Math.degToRad(f);
            d = g.length() * Math.tan(.5 * d) / Math.tan(.5 * f);
            g = g.normalize().multiplyScalar(-d);
            return this.target.clone().add(g)
        }
        ;
        f.prototype.toPerspective = function() {
            !this.isPerspective && 
            this.saveFov && (this.position.copy(this.__computeFovPosition(this.saveFov)),
            this.fov = this.saveFov);
            this.perspectiveCamera.aspect = this.aspect;
            this.perspectiveCamera.near = this.near;
            this.perspectiveCamera.far = this.far;
            this.perspectiveCamera.fov = this.fov / this.zoom;
            this.perspectiveCamera.updateProjectionMatrix();
            this.projectionMatrix = this.perspectiveCamera.projectionMatrix;
            this.isPerspective = !0
        }
        ;
        f.prototype.toOrthographic = function() {
            if (this.isPerspective) {
                this.saveFov = this.fov;
                var h = f.ORTHO_FOV;
                this.position.copy(this.__computeFovPosition(h));
                this.fov = h
            }
            this.orthoScale = this.target.clone().sub(this.position).length();
            var h = .5 * this.orthoScale
              , g = h * this.aspect;
            this.left = this.orthographicCamera.left = -g;
            this.right = this.orthographicCamera.right = g;
            this.top = this.orthographicCamera.top = h;
            this.bottom = this.orthographicCamera.bottom = -h;
            this.orthographicCamera.near = this.near;
            this.orthographicCamera.far = this.far;
            this.orthographicCamera.updateProjectionMatrix();
            this.projectionMatrix = this.orthographicCamera.projectionMatrix;
            this.isPerspective = !1
        }
        ;
        f.prototype.updateProjectionMatrix = 
        function() {
            this.isPerspective ? this.toPerspective() : this.toOrthographic()
        }
        ;
        f.prototype.setSize = function(f, g) {
            this.aspect = f / g;
            this.left = -f / 2;
            this.right = f / 2;
            this.top = g / 2;
            this.bottom = -g / 2
        }
        ;
        f.prototype.setFov = function(f) {
            this.fov = f;
            this.updateProjectionMatrix()
        }
        ;
        f.prototype.setLens = function(f, g) {
            void 0 === g && (g = 24);
            var d = 2 * THREE.Math.radToDeg(Math.atan(g / (2 * f)));
            this.setFov(d);
            return d
        }
        ;
        f.prototype.getCameraChangedEvent = function() {
            return {
                type: Teratek.Viewing.CAMERA_CHANGE_EVENT,
                camera: this
            }
        }
        ;
        Teratek.Viewing.UnifiedCamera = 
        f
    }
}
(function() {
    var f = Teratek.Viewing
      , h = Teratek.Viewing.Private;
    f.ESCAPE_EVENT = "escape";
    f.PROGRESS_UPDATE_EVENT = "progress";
    f.FULLSCREEN_MODE_EVENT = "fullScreenMode";
    f.NAVIGATION_MODE_CHANGED_EVENT = "navmode";
    f.VIEWER_STATE_RESTORED_EVENT = "viewerStateRestored";
    f.VIEWER_RESIZE_EVENT = "viewerResize";
    f.VIEWER_UNINITIALIZED = "viewerUninitialized";
    f.MODEL_ROOT_LOADED_EVENT = "svfLoaded";
    f.GEOMETRY_LOADED_EVENT = "geometryLoaded";
    f.OBJECT_TREE_CREATED_EVENT = "propertyDbLoaded";
    f.OBJECT_TREE_UNAVAILABLE_EVENT = "propertyDbUnavailable";
    f.SELECTION_CHANGED_EVENT = 
    "selection";
    f.ISOLATE_EVENT = "isolate";
    f.HIDE_EVENT = "hide";
    f.SHOW_EVENT = "show";
    f.HIGHLIGHT_EVENT = "highlight";
    f.CAMERA_CHANGE_EVENT = "cameraChanged";
    f.EXPLODE_CHANGE_EVENT = "explodeChanged";
    f.CUTPLANES_CHANGE_EVENT = "cutplanesChanged";
    f.TOOL_CHANGE_EVENT = "toolChanged";
    f.RENDER_OPTION_CHANGED_EVENT = "renderOptionChanged";
    f.LAYER_VISIBILITY_CHANGED_EVENT = "layerVisibility";
    f.RESET_EVENT = "reset";
    f.ANIMATION_READY_EVENT = "animationReady";
    f.NAVIGATION_MODE = {
        ORBIT: 0,
        PAN: 1,
        DOLLY: 2,
        ROLL: 3,
        FOV: 4,
        TOUCH_PAN_DOLLY: 5,
        TOUCH_ROLL: 6,
        OTHER: 7
    };
    var g = function(d, c) {
        this.clientContainer = d;
        this.container = document.createElement("div");
        this.container.className = "teratek-viewing-viewer";
        this.container.style.height = "100%";
        this.container.style.width = "100%";
        this.container.style.overflow = "hidden";
        this.container.classList.add(isTouchDevice() ? "touch" : "notouch");
        this.clientContainer.appendChild(this.container);
        this.config = c;
        this.contextMenu = null ;
        this.contextMenuCallbacks = {};
        this.started = this.__firefoxLMBfix = !1;
        if ("CANVAS" === this.container.nodeName)
            throw "Viewer must be initialized on a div [temporary]";
        this.canvasWrap = document.createElement("div");
        this.canvasWrap.classList.add("canvas-wrap");
        this.canvas = document.createElement("canvas");
        this.canvas.tabIndex = 0;
        this.canvasWrap.appendChild(this.canvas);
        this.container.appendChild(this.canvasWrap);
        this.canvas.viewer = this;
        this.running = !1;
        this._defaultNavigationTool = this._pushedTool = "";
        this.stats = {
            category: "misc_stats",
            explode_count: 0,
            get_props_count: 0,
            isolate_count: 0
        };
        this.prefs = new h.Preferences(this,"Teratek.Viewing.Private.GuiViewer3D.SavedSettings.")
    }
    ;
    g.prototype.constructor = g;
    f.EventDispatcher.prototype.apply(g.prototype);
    f.ScreenModeMixin.prototype.apply(g.prototype);
    f.ExtensionMixin.prototype.apply(g.prototype);
    g.ScreenMode = f.ScreenMode;
    g.kDefaultCanvasConfig = {
        click: {
            onObject: ["selectOnly"],
            offObject: ["deselectAll"]
        },
        clickAlt: {
            onObject: ["setCOI"],
            offObject: ["setCOI"]
        },
        clickCtrl: {
            onObject: ["selectToggle"],
            offObject: ["deselectAll"]
        },
        clickShift: {
            onObject: ["selectToggle"],
            offObject: ["deselectAll"]
        },
        disableSpinner: !1,
        disableMouseWheel: !1,
        disableTwoFingerSwipe: !1
    };
    g.prototype.start = function() {
        if (this.started)
            return 0;
        var d = this.initialize();
        if (0 === d && (this.started = !0,
        this.config && this.config.hasOwnProperty("extensions")))
            for (var c = this.config.extensions, a = 0; a < c.length; ++a)
                this.loadExtension(c[a], this.config);
        return d
    }
    ;
    g.prototype.registerUniversalHotkeys = function() {
        var d = this, c, a, b, g = f.theHotkeyManager.KEYCODES;
        f.theHotkeyManager.pushHotkeys("Teratek.FitToView", [{
            keycodes: [g.f],
            onPress: function() {
                d.navigation.setRequestFitToView(!0);
                return !0
            }
        }]);
        c = function() {
            d.navigation.setRequestHomeView(!0);
            return !0
        }
        ;
        f.theHotkeyManager.pushHotkeys("Teratek.Home", [{
            keycodes: [g.h],
            onPress: c
        }, {
            keycodes: [g.HOME],
            onPress: c
        }]);
        f.theHotkeyManager.pushHotkeys("Teratek.Escape", [{
            keycodes: [g.ESCAPE],
            onRelease: function() {
                if (d.objectContextMenu && d.objectContextMenu.hide())
                    return !0;
                d.fireEvent({
                    type: f.ESCAPE_EVENT
                });
                return !0
            }
        }]);
        c = function() {
            b = d.getActiveNavigationTool();
            return d.setActiveNavigationTool("pan")
        }
        ;
        a = function() {
            return d.setActiveNavigationTool(b)
        }
        ;
        f.theHotkeyManager.pushHotkeys("Teratek.Pan", [{
            keycodes: [g.SHIFT],
            onPress: c,
            onRelease: a
        }, {
            keycodes: [g.SPACE],
            onPress: c,
            onRelease: a
        }], {
            tryUntilSuccess: !0
        })
    }
    ;
    g.prototype.createControls = function() {
        var d = this.impl;
        this.navigation = new f.Navigation(d.camera);
        this.__initAutoCam(d);
        this.utilities = new f.ViewingUtilities(d,this.autocam,this.navigation);
        this.clickHandler = new f.DefaultHandler(d,this.navigation,this.utilities);
        this.toolController = new f.ToolController(d,this,this.autocam,this.utilities,this.clickHandler);
        this.toolController.registerTool(new f.GestureHandler(this));
        this.toolController.registerTool(f.theHotkeyManager);
        this.toolController.activateTool(f.theHotkeyManager.getName());
        this.registerUniversalHotkeys();
        this.toolController.registerTool(new f.OrbitDollyPanTool(d,this));
        this.toolController.activateTool("gestures");
        return this.toolController
    }
    ;
    g.prototype.initialize = function() {
        var d = detectWebGL();
        if (0 >= d)
            return -1 === d ? f.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED : f.ErrorCodes.BROWSER_WEBGL_DISABLED;
        var c = this;
        this.onResizeCallback = function(a) {
            c.resize()
        }
        ;
        window.addEventListener("resize", 
        this.onResizeCallback, !1);
        this.setScreenModeDelegate(this.config ? this.config.screenModeDelegate : void 0);
        this.initContextMenu();
        this.localize();
        d = this.getDimensions();
        this.canvas.width = d.width;
        this.canvas.height = d.height;
        isIOSDevice() && window.devicePixelRatio && (this.canvas.width /= window.devicePixelRatio,
        this.canvas.height /= window.devicePixelRatio);
        this.impl = new h.Viewer3DImpl(this.canvas,this);
        this.impl.controls = this.createControls();
        this.setDefaultNavigationTool("orbit");
        this.model = null ;
        this.impl.controls && 
        this.impl.controls.setAutocam(this.autocam);
        d = this.config && this.config.canvasConfig ? this.config.canvasConfig : g.kDefaultCanvasConfig;
        this.setCanvasClickBehavior(d);
        this.loader = document.createElement("div");
        this.loader.id = "loader";
        this.loader.className = "spinner";
        this.container.appendChild(this.loader);
        if (!d.disableSpinner)
            for (d = 1; 3 >= d; d++) {
                var a = document.createElement("div");
                a.className = "bounce" + d;
                this.loader.appendChild(a)
            }
        this.initSettings();
        this.viewerState = new h.ViewerState(this);
        this.config && this.config.hasOwnProperty("startOnInitialize") && 
        !this.config.startOnInitialize || this.run();
        window.NOP_VIEWER = this;
        return 0
    }
    ;
    g.prototype.setUp = function(d) {
        if ((this.config = d) && this.config.hasOwnProperty("extensions")) {
            d = this.config.extensions;
            for (var c = 0; c < d.length; ++c)
                this.loadExtension(d[c], this.config)
        }
        this.setCanvasClickBehavior(this.config && this.config.canvasConfig ? this.config.canvasConfig : g.kDefaultCanvasConfig)
    }
    ;
    g.prototype.tearDown = function() {
        this.clearSelection();
        if (this.loadedExtensions) {
            for (var d in this.loadedExtensions)
                try {
                    this.unloadExtension(d)
                } catch (c) {
                    stderr("Failed to unload extension: " + 
                    d);
                    console.log("  error: " + c.message);
                    console.error("  stack:\n" + c.stack);
                    var a = h.logger;
                    a && a.log({
                        category: "error_unload_extension",
                        extensionId: d,
                        error_message: c.message,
                        call_stack: c.stack
                    })
                }
            this.loadedExtensions = null 
        }
        this.__logStats();
        this.loader.style.display = "block";
        this.model = null ;
        this.impl.unloadCurrentModel()
    }
    ;
    g.prototype.run = function() {
        this.running || (this.resize(),
        this.running = !0,
        this.impl.run())
    }
    ;
    g.prototype.localize = function() {
        f.i18n.localize()
    }
    ;
    g.prototype.__logStats = function(d) {
        var c = 
        h.logger;
        c && (this.stats.explode_count || this.stats.get_props_count || this.stats.isolate_count) && (c.log(this.stats, d),
        this.stats.explode_count = 0,
        this.stats.get_props_count = 0,
        this.stats.isolate_count = 0)
    }
    ;
    g.prototype.__initAutoCam = function(d) {
        var c = this
          , a = d.camera;
        a.pivot || (a.pivot = new THREE.Vector3(0,0,0));
        a.target || (a.target = new THREE.Vector3(0,0,0));
        a.worldup || (a.worldup = a.up.clone());
        c.autocamCamera = a.clone();
        c.autocamCamera.target = a.target.clone();
        c.autocamCamera.pivot = a.pivot.clone();
        c.autocamCamera.worldup = 
        a.worldup.clone();
        c.autocam = new Autocam(c.autocamCamera,c.navigation);
        c.autocam.cameraChangedCallback = function(b) {
            c.autocamCamera.isPerspective !== a.isPerspective && (c.autocamCamera.isPerspective ? c.navigation.toPerspective() : c.navigation.toOrthographic());
            c.navigation.setVerticalFov(c.autocamCamera.fov, !1);
            c.navigation.setView(c.autocamCamera.position, c.autocamCamera.target);
            c.navigation.setPivotPoint(c.autocamCamera.pivot);
            c.navigation.setCameraUpVector(c.autocamCamera.up);
            b && c.navigation.setWorldUpVector(c.autocamCamera.worldup);
            c.impl.syncCamera(b)
        }
        ;
        c.autocam.pivotDisplayCallback = function(a) {
            c.utilities ? c.utilities.pivotActive(a, !1) : c.impl.controls.pivotActive(a, !1)
        }
        ;
        c.autocam.canvas = c.canvas;
        c.addEventListener("cameraChanged", function(a) {
            c.autocam.sync(a.camera)
        }
        );
        c.autocam.sync(a)
    }
    ;
    g.prototype.uninitialize = function(d) {
        window.removeEventListener("resize", this.onResizeCallback, !1);
        this.onResizeCallback = null ;
        this.canvas.parentNode.removeChild(this.canvas);
        this.viewerState = this.canvasWrap = this.canvas = this.canvas.viewer = null ;
        this.__logStats();
        (d = h.logger) && d.log({
            category: "viewer_destroy"
        }, !0);
        this.toolController && (this.toolController.uninitialize(),
        this.utilities = this.clickHandler = this.toolController = null );
        this.navigation && (this.navigation.uninitialize(),
        this.navigation = null );
        this.impl && (this.impl.dtor(),
        this.impl = null );
        this.prefs = this.model = this.loader = null ;
        this.autocam.dtor();
        this.autocamCamera = this.autocam = null ;
        f.theHotkeyManager.popHotkeys("Teratek.FitToView");
        f.theHotkeyManager.popHotkeys("Teratek.Home");
        f.theHotkeyManager.popHotkeys("Teratek.Escape");
        f.theHotkeyManager.popHotkeys("Teratek.Pan");
        f.theHotkeyManager.popHotkeys("Teratek.Orbit");
        this.onDefaultContextMenu && (this.container.removeEventListener("contextmenu", this.onDefaultContextMenu, !1),
        this.onDefaultContextMenu = null );
        this.container && this.container.parentNode && this.container.parentNode.removeChild(this.container);
        this.container = null ;
        this.screenModeDelegate && (this.screenModeDelegate.uninitialize(),
        this.screenModeDelegate = null );
        this.config = this.clientContainer = null ;
        this.listeners = {};
        this.contextMenuCallbacks = this.contextMenu = null ;
        this.fireEvent(f.VIEWER_UNINITIALIZED);
        stderr("viewer destroy")
    }
    ;
    g.prototype.finish = function() {
        this.tearDown();
        this.uninitialize()
    }
    ;
    g.prototype.load = function(d, c, a, b) {
        return this.loadModel(d, {
            ids: null ,
            sharedPropertyDbPath: c
        }, a, b)
    }
    ;
    g.prototype.loadModel = function(d, c, a, b) {
        function g() {
            if (n.model.is2d())
                f.theHotkeyManager.popHotkeys("Teratek.Orbit");
            else {
                var a;
                f.theHotkeyManager.pushHotkeys("Teratek.Orbit", [{
                    keycodes: [f.theHotkeyManager.KEYCODES.ALT],
                    onPress: function() {
                        a = n.getActiveNavigationTool();
                        return n.setActiveNavigationTool("orbit")
                    },
                    onRelease: function() {
                        return n.setActiveNavigationTool(a)
                    }
                }], {
                    tryUntilSuccess: !0
                })
            }
        }
        function h() {
            n.impl.needsRender = !0;
            n.removeEventListener(f.GEOMETRY_LOADED_EVENT, h)
        }
        var n = this;
        c = c || {};
        this.addEventListener(f.GEOMETRY_LOADED_EVENT, h);
        var m = d.toLowerCase().match(/\.([a-z0-9]+$)/)
          , m = m ? m[1] : null ;
        return (new (c && c.fileLoader ? c.fileLoader : f.FileLoaderManager.getFileLoaderForExtension(m))(this.impl)).loadFile(d, 
        c, function(b) {
            n.model = b;
            n.impl.addModel(n.model);
            n.loader.style.display = "None";
            n.model.is2d() && n.activateLayerState("Initial");
            g();
            a && a()
        }
        , function(a, c) {
            n.loader.style.display = "None";
            b && b(a, c)
        }
        )
    }
    ;
    g.prototype.getDimensions = function() {
        if (this.container) {
            var d = {};
            this.getScreenMode() === f.ScreenMode.kFullScreen ? (d.width = screen.width,
            d.height = screen.height) : d = this.container.getBoundingClientRect();
            return {
                width: d.width,
                height: d.height
            }
        }
        return null 
    }
    ;
    g.prototype.resize = function() {
        return this.impl.resize(this.container.clientWidth, 
        this.container.clientHeight)
    }
    ;
    g.prototype.getCamera = function() {
        return this.impl.camera
    }
    ;
    g.prototype.getState = function(d) {
        return this.viewerState.getState(d)
    }
    ;
    g.prototype.restoreState = function(d, c, a) {
        (d = this.viewerState.restoreState(d, c, a)) && this.fireEvent({
            type: f.VIEWER_STATE_RESTORED_EVENT,
            value: d
        });
        return d
    }
    ;
    g.prototype.setViewFromArray = function(d, c) {
        this.setActiveNavigationTool("orbit");
        var a = this.model ? this.model.getData().globalOffset : {
            x: 0,
            y: 0,
            z: 0
        }
          , a = {
            position: new THREE.Vector3(d[0] - a.x,d[1] - 
            a.y,d[2] - a.z),
            target: new THREE.Vector3(d[3] - a.x,d[4] - a.y,d[5] - a.z),
            up: new THREE.Vector3(d[6],d[7],d[8]),
            aspect: d[9],
            fov: THREE.Math.radToDeg(d[10]),
            orthoScale: d[11],
            isPerspective: !d[12]
        };
        this.impl.setViewFromCamera(a)
    }
    ;
    g.prototype.setViewFromViewBox = function(d, c) {
        var a = this.model;
        if (a && !a.is2d())
            console.warn("Viewer3D.setViewFromViewBox is not applicable to 3D");
        else {
            if (c && c.length) {
                var a = a.getData().metadata.views, b;
                for (b = 0; b < a.length && a[b].name != c; b++)
                    ;
                b < a.length && (a = a[b].layer_state) && this.activateLayerState(a)
            }
            this.impl.setViewFromViewBox(this.model, 
            d, c, !1)
        }
    }
    ;
    g.prototype.activateLayerState = function(d) {
        if (d && d.length) {
            var c = this.model.getData().metadata
              , a = c.layer_states;
            if (a) {
                var b;
                for (b = 0; b < a.length && a[b].name != d; b++)
                    ;
                if (b < a.length) {
                    a = a[b].visible_layers;
                    d = {};
                    if (a && 0 < a.length)
                        for (b = 0; b < a.length; b++)
                            d[a[b]] = 1;
                    a = [];
                    b = [];
                    for (var g in c.layers)
                        1 === d[c.layers[g].name] ? a.push(g) : b.push(g);
                    this.impl.setLayerVisible(a, !0);
                    this.impl.setLayerVisible(b, !1);
                    this.fireEvent({
                        type: f.LAYER_VISIBILITY_CHANGED_EVENT
                    })
                }
            }
        }
    }
    ;
    g.prototype.getLayerStates = function() {
        function d(a, 
        b) {
            var c = Object.getOwnPropertyNames(a)
              , d = Object.getOwnPropertyNames(b);
            if (c.length !== d.length)
                return !1;
            for (d = 0; d < c.length; ++d) {
                var f = c[d];
                if (a[f] !== b[f])
                    return !1
            }
            return !0
        }
        var c = this.model
          , a = (c = c ? c.getData().metadata : null ) ? c.layers : null 
          , c = c ? c.layer_states : null ;
        if (!a || !c)
            return null ;
        var b, f = {}, g = {}, h;
        for (h in a)
            if (a.hasOwnProperty(h)) {
                var m = parseInt(h);
                b = a[h];
                b = "string" === typeof b ? b : b.name;
                f[b] = !0;
                this.impl.isLayerVisible(m) && (g[b] = !0)
            }
        h = [];
        for (a = 0; a < c.length; ++a) {
            var q = c[a]
              , r = q.visible_layers
              , t = {};
            if (!q.hidden) {
                if (r && 0 < r.length)
                    for (m = 0; m < r.length; ++m)
                        b = r[m],
                        f.hasOwnProperty(b) && (t[b] = !0);
                h.push({
                    name: q.name,
                    description: q.description,
                    active: d(g, t)
                })
            }
        }
        return 0 < h.length ? h : null 
    }
    ;
    g.prototype.setViewFromFile = function() {
        this.setActiveNavigationTool();
        this.impl.setViewFromFile(this.model)
    }
    ;
    g.prototype.getProperties = function(d, c, a) {
        this.stats.get_props_count++;
        this.model ? this.model.getProperties(d, c, a) : a && a(f.ErrorCodes.BAD_DATA, "Properties failed to load since model does not exist")
    }
    ;
    g.prototype.getObjectTree = 
    function(d, c) {
        this.model ? this.model.getObjectTree(d, c) : c && c(f.ErrorCodes.BAD_DATA, "ObjectTree failed to load since model does not exist")
    }
    ;
    g.prototype.setCanvasClickBehavior = function(d) {
        this.impl.controls.hasOwnProperty("setClickBehavior") && this.impl.controls.setClickBehavior(d);
        this.clickHandler && this.clickHandler.setClickBehavior(d);
        d && d.disableMouseWheel && this.toolController.setMouseWheelInputEnabled(!1);
        d && d.disableTwoFingerSwipe && (d = this.toolController.getTool("gestures")) && d.disableTwoFingerSwipe()
    }
    ;
    g.prototype.search = function(d, c, a, b) {
        this.searchText = d;
        this.model ? this.model.search(d, c, a, b) : a && a(f.ErrorCodes.BAD_DATA, "Search failed since model does not exist")
    }
    ;
    g.prototype.getHiddenNodes = function() {
        return this.impl.visibilityManager.getHiddenNodes()
    }
    ;
    g.prototype.getIsolatedNodes = function() {
        return this.model && this.model.is2d() ? (console.warn("Viewer3D.getIsolatedNodes is not yet implemented for 2D"),
        []) : this.impl.visibilityManager.getIsolatedNodes()
    }
    ;
    g.prototype.isolate = function(d) {
        if (this.model && 
        this.model.is2d())
            console.warn("Viewer3D.isolate is not yet implemented for 2D");
        else {
            var c = this;
            this.model.getObjectTree(function() {
                c.stats.isolate_count++;
                c.impl.visibilityManager.isolate(d)
            }
            )
        }
    }
    ;
    g.prototype.isolateById = function(d) {
        console.warn("isolateById() is deprecated. Use isolate() instead.");
        return this.isolate(d)
    }
    ;
    g.prototype.setBackgroundColor = function(d, c, a, b, f, g) {
        this.impl.setClearColors(d, c, a, b, f, g)
    }
    ;
    g.prototype.toggleSelect = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.toggleSelect is not yet implemented for 2D") : 
        this.impl.selector.toggleSelection(d)
    }
    ;
    g.prototype.select = function(d) {
        "number" === typeof d && (d = [d]);
        this.impl.selector.setSelection(d)
    }
    ;
    g.prototype.clearSelection = function() {
        this.impl.selector.clearSelection()
    }
    ;
    g.prototype.getSelectionVisibility = function() {
        return this.impl.selector.getSelectionVisibility()
    }
    ;
    g.prototype.getSelectionCount = function() {
        return this.impl.selector.getSelectionLength()
    }
    ;
    g.prototype.setSelectionMode = function(d) {
        this.impl.selector.setSelectionMode(d)
    }
    ;
    g.prototype.getSelection = 
    function() {
        return this.impl.selector.getSelection()
    }
    ;
    g.prototype.hide = function(d) {
        if (this.model && this.model.is2d())
            console.warn("Viewer3D.hide is not yet implemented for 2D");
        else {
            var c = h.logger;
            c && c.log({
                category: "hide"
            });
            this.impl.visibilityManager.hide(d)
        }
    }
    ;
    g.prototype.hideById = function(d) {
        this.hide(d)
    }
    ;
    g.prototype.show = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.show is not yet implemented for 2D") : this.impl.visibilityManager.show(d)
    }
    ;
    g.prototype.showAll = function() {
        this.impl.visibilityManager.isolate();
        this.model.is2d() && this.setLayerVisible(null , !0)
    }
    ;
    g.prototype.toggleVisibility = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.toggleVisibility is not yet implemented for 2D") : this.impl.visibilityManager.toggleVisibility(d)
    }
    ;
    g.prototype.areAllVisible = function() {
        return this.impl.isWholeModelVisible(this.model)
    }
    ;
    g.prototype.explode = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.explode is not applicable to 2D") : (this.stats.explode_count++,
        this.impl.explode(d))
    }
    ;
    g.prototype.getExplodeScale = 
    function() {
        return this.model && this.model.is2d() ? (console.warn("Viewer3D.getExplodeScale is not applicable to 2D"),
        0) : this.impl.getExplodeScale()
    }
    ;
    g.prototype.setQualityLevel = function(d, c) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setQualityLevel is not applicable to 2D") : (this.prefs.set("ambientShadows", d),
        this.prefs.set("antialiasing", c),
        this.impl.togglePostProcess(d, c))
    }
    ;
    g.prototype.setGhosting = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setGhosting is not applicable to 2D") : 
        (this.prefs.set("ghosting", d),
        this.impl.toggleGhosting(d))
    }
    ;
    g.prototype.setGroundShadow = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setGroundShadow is not applicable to 2D") : (this.prefs.set("groundShadow", d),
        this.impl.toggleGroundShadow(d))
    }
    ;
    g.prototype.setGroundReflection = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setGroundReflection is not applicable to 2D") : (this.prefs.set("groundReflection", d),
        this.impl.toggleGroundReflection(d))
    }
    ;
    g.prototype.setEnvMapBackground = 
    function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setEnvMapBackground is not applicable to 2D") : (this.prefs.set("envMapBackground", d),
        this.impl.toggleEnvMapBackground(d))
    }
    ;
    g.prototype.setRenderPrism = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setRenderPrism is not applicable to 2D") : (this.prefs.set("renderPrism", d),
        this.impl.toggleRenderPrism(d))
    }
    ;
    g.prototype.setProgressiveRendering = function(d) {
        this.prefs.set("progressiveRendering", d);
        this.impl.toggleProgressive(d)
    }
    ;
    g.prototype.setOptimizeNavigation = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setOptimizeNaviation is not applicable to 2D") : (this.prefs.set("optimizeNavigation", d),
        this.impl.setOptimizeNavigation(d))
    }
    ;
    g.prototype.setActiveNavigationTool = function(d) {
        if (d === this._pushedTool || !d && !this._pushedTool)
            return !0;
        if (this._pushedTool) {
            if (!this.impl.controls.deactivateTool(this._pushedTool))
                return !1;
            this._pushedTool = null ;
            var c = h.logger;
            c && c.log({
                category: "tool_changed",
                name: d
            })
        }
        return d && 
        d !== this.getDefaultNavigationToolName() || null  !== this._pushedTool ? this.impl.controls.activateTool(d) ? (this._pushedTool = d,
        this.fireEvent({
            type: f.NAVIGATION_MODE_CHANGED_EVENT,
            id: this._pushedTool
        }),
        !0) : !1 : (this.fireEvent({
            type: f.NAVIGATION_MODE_CHANGED_EVENT,
            id: this.getDefaultNavigationToolName()
        }),
        !0)
    }
    ;
    g.prototype.getActiveNavigationTool = function() {
        return this._pushedTool ? this._pushedTool : this._defaultNavigationTool
    }
    ;
    g.prototype.setDefaultNavigationTool = function(d) {
        this._defaultNavigationTool && this.impl.controls.deactivateTool(this._defaultNavigationTool);
        this._pushedTool && this.impl.controls.deactivateTool(this._pushedTool);
        this.impl.controls.activateTool(d);
        this._defaultNavigationTool = d;
        this._pushedTool && this.impl.controls.activateTool(this._pushedTool)
    }
    ;
    g.prototype.getDefaultNavigationToolName = function() {
        return this._defaultNavigationTool
    }
    ;
    g.prototype.getFOV = function() {
        return this.navigation.getVerticalFov()
    }
    ;
    g.prototype.setFOV = function(d) {
        this.navigation.setVerticalFov(d, !0)
    }
    ;
    g.prototype.getFocalLength = function() {
        return this.navigation.getFocalLength()
    }
    ;
    g.prototype.setFocalLength = function(d) {
        this.navigation.setFocalLength(d, !0)
    }
    ;
    g.prototype.hideLines = function(d) {
        function c() {
            a.impl.hideLines(d);
            a.removeEventListener(f.GEOMETRY_LOADED_EVENT, c)
        }
        this.prefs.set("lineRendering", !d);
        var a = this;
        this.impl.hideLines(d) || this.addEventListener(f.GEOMETRY_LOADED_EVENT, c)
    }
    ;
    g.prototype.applyCamera = function(d, c) {
        this.impl.setViewFromCamera(d, !0);
        c && this.fitToView()
    }
    ;
    g.prototype.fitToView = function(d) {
        var c = this
          , a = !0
          , b = c.model
          , g = function() {
            var m = null ;
            if (Array.isArray(d) && 
            0 < d.length) {
                for (var n = new THREE.Box3, r = new THREE.Box3, t = b.getData().instanceTree, w = b.getFragmentList(), C = 0; C < d.length; C++)
                    t.enumNodeFragments(d[C], function(a) {
                        w.getWorldBounds(a, r);
                        n.union(r)
                    }
                    , !0);
                n.empty() || (m = n)
            }
            if (!m || m.empty())
                m = c.impl.getFitBounds();
            c.navigation.fitBounds(!1, m);
            c.removeEventListener(f.OBJECT_TREE_CREATED_EVENT, h);
            c.removeEventListener(f.GEOMETRY_LOADED_EVENT, g);
            return a
        }
          , h = function() {
            b && b.isLoadDone() ? g() : (a = !1,
            c.addEventListener(f.GEOMETRY_LOADED_EVENT, g))
        }
          , n = b.getData().propertydb
          , 
        n = n && 0 < n.attrs.length;
        !b.is2d() && n && null  !== d && void 0 !== d ? b && b.isObjectTreeCreated() ? h() : (a = !1,
        this.addEventListener(f.OBJECT_TREE_CREATED_EVENT, h)) : this.navigation.fitBounds(!1, this.impl.getFitBounds(!0))
    }
    ;
    g.prototype.setClickConfig = function(d, c, a) {
        var b = this.clickHandler ? this.clickHandler.getClickBehavior() : this.impl.controls.getClickBehavior();
        return d in b && (d = b[d],
        c in d) ? (d[c] = a,
        !0) : !1
    }
    ;
    g.prototype.getClickConfig = function(d, c) {
        var a = this.clickHandler ? this.clickHandler.getClickBehavior() : this.impl.controls.getClickBehavior();
        return d in a && (a = a[d],
        c in a) ? a[c] : null 
    }
    ;
    g.prototype.setClickToSetCOI = function(d, c) {
        !1 !== c && this.prefs.set("clickToSetCOI", d);
        var a = this.getClickConfig("click", "onObject");
        d ? -1 === a.indexOf("setCOI") && this.setClickConfig("click", "onObject", ["setCOI"]) : 0 <= a.indexOf("setCOI") && this.setClickConfig("click", "onObject", ["selectOnly"])
    }
    ;
    g.prototype.initSettings = function() {
        var d = isIOSDevice() || isAndroidDevice();
        this.prefs.load({
            ambientShadows: !0,
            antialiasing: !d,
            groundShadow: !0,
            groundReflection: !1,
            progressiveRendering: !0,
            environmentMap: !1,
            openPropertiesOnSelect: !1,
            ghosting: !0,
            viewCube: !d,
            lineRendering: !0,
            lightPreset: h.DefaultLightPreset,
            backgroundColorPreset: null ,
            reverseMouseZoomDir: !1,
            reverseHorizontalLookDirection: !1,
            reverseVerticalLookDirection: !1,
            alwaysUsePivot: !1,
            zoomTowardsPivot: !1,
            orbitPastWorldPoles: !0,
            leftHandedMouseSetup: !1,
            clickToSetCOI: !1,
            optimizeNavigation: d,
            fusionOrbit: !0,
            fusionOrbitConstrained: !0,
            useFirstPersonNav: !1,
            envMapBackground: !1,
            renderPrism: !1
        });
        this.prefs.tag("3d");
        this.prefs.tag("2d");
        this.prefs.untag("2d", 
        "viewCube alwaysUsePivot zoomTowardsPivot reverseHorizontalLookDirection reverseVerticalLookDirection orbitPastWorldPoles clickToSetCOI ghosting optimizeNavigation ambientShadows antialiasing groundShadow groundReflection lineRendering lightPreset envMapBackground renderPrism".split(" "));
        this.setQualityLevel(this.prefs.ambientShadows, this.prefs.antialiasing);
        this.setGroundShadow(this.prefs.groundShadow);
        this.setGroundReflection(this.prefs.groundReflection);
        this.setGhosting(this.prefs.ghosting);
        this.setProgressiveRendering(this.prefs.progressiveRendering);
        this.setClickToSetCOI(this.prefs.clickToSetCOI);
        this.setOptimizeNavigation(this.prefs.optimizeNavigation);
        this.hideLines(!this.prefs.lineRendering);
        this.setEnvMapBackground(this.prefs.envMapBackground);
        this.setRenderPrism(this.prefs.renderPrism);
        this.navigation.setUsePivotAlways(this.prefs.alwaysUsePivot);
        this.navigation.setReverseZoomDirection(this.prefs.reverseMouseZoomDir);
        this.navigation.setReverseHorizontalLookDirection(this.prefs.reverseHorizontalLookDirection);
        this.navigation.setReverseVerticalLookDirection(this.prefs.reverseVerticalLookDirection);
        this.navigation.setZoomTowardsPivot(this.prefs.zoomTowardsPivot);
        this.navigation.setOrbitPastWorldPoles(this.prefs.orbitPastWorldPoles);
        this.navigation.setUseLeftHandedInput(this.prefs.leftHandedMouseSetup);
        if (d = this.prefs.backgroundColorPreset)
            try {
                var c = JSON.parse(d);
                this.impl.setClearColors(c[0], c[1], c[2], c[3], c[4], c[5])
            } catch (a) {
                this.prefs.set("backgroundColorPreset", null )
            }
        this.impl.setLightPreset(this.prefs.lightPreset)
    }
    ;
    g.prototype.setLightPreset = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setLightPreset is not applicable to 2D") : 
        (this.prefs.set("lightPreset", d),
        this.impl.setLightPreset(d))
    }
    ;
    g.prototype.setUsePivotAlways = function(d) {
        this.prefs.set("alwaysUsePivot", d);
        this.navigation.setUsePivotAlways(d)
    }
    ;
    g.prototype.setReverseZoomDirection = function(d) {
        this.prefs.set("reverseMouseZoomDir", d);
        this.navigation.setReverseZoomDirection(d)
    }
    ;
    g.prototype.setReverseHorizontalLookDirection = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setReverseHorizontalLookDirection is not applicable to 2D") : (this.prefs.set("reverseHorizontalLookDirection", 
        d),
        this.navigation.setReverseHorizontalLookDirection(d))
    }
    ;
    g.prototype.setReverseVerticalLookDirection = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setReverseVerticalLookDirection is not applicable to 2D") : (this.prefs.set("reverseVerticalLookDirection", d),
        this.navigation.setReverseVerticalLookDirection(d))
    }
    ;
    g.prototype.setZoomTowardsPivot = function(d) {
        this.prefs.set("zoomTowardsPivot", d);
        this.navigation.setZoomTowardsPivot(d)
    }
    ;
    g.prototype.setOrbitPastWorldPoles = function(d) {
        this.model && 
        this.model.is2d() ? console.warn("Viewer3D.setOrbitPastWorldPoles is not applicable to 2D") : (this.prefs.set("orbitPastWorldPoles", d),
        this.navigation.setOrbitPastWorldPoles(d))
    }
    ;
    g.prototype.setUseLeftHandedInput = function(d) {
        this.prefs.set("leftHandedMouseSetup", d);
        this.navigation.setUseLeftHandedInput(d)
    }
    ;
    g.prototype.setLayerVisible = function(d, c, a) {
        function b(a, c) {
            var d = [];
            if (a.isLayer)
                d.push(a.index);
            else
                for (var f = a.children, g = 0; g < f.length; ++g)
                    d = d.concat(b(f[g]));
            return d
        }
        if (this.model && !this.model.is2d())
            console.warn("Viewer3D.setLayerVisible is not yet implemented for 3D");
        else {
            var g = this.model.getLayersRoot();
            if (g && 0 !== g.childCount) {
                null  === d && (d = [g]);
                Array.isArray(d) || (d = [d]);
                a && (this.impl.setLayerVisible(b(g), !1),
                c = !0);
                a = [];
                for (g = 0; g < d.length; ++g)
                    a = a.concat(b(d[g]));
                this.impl.setLayerVisible(a, c);
                this.fireEvent({
                    type: f.LAYER_VISIBILITY_CHANGED_EVENT
                })
            }
        }
    }
    ;
    g.prototype.isLayerVisible = function(d) {
        return this.model && !this.model.is2d() ? (console.warn("Viewer3D.isLayerVisible is not yet implemented for 3D"),
        !1) : !!(d && d.isLayer && this.impl.isLayerVisible(d.index))
    }
    ;
    g.prototype.anyLayerHidden = 
    function() {
        function d(a) {
            if (a.isLayer)
                return !c.impl.isLayerVisible(a.index);
            a = a.children;
            for (var f = 0; f < a.length; ++f)
                if (d(a[f]))
                    return !0;
            return !1
        }
        if (this.model && !this.model.is2d())
            return console.warn("Viewer3D.anyLayerHidden is not yet implemented for 3D"),
            !1;
        var c = this
          , a = c.model.getLayersRoot();
        return !(!a || !d(a))
    }
    ;
    g.prototype.setGroundShadowColor = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setGroundShadowColor is not applicable to 2D") : this.impl.setGroundShadowColor(d)
    }
    ;
    g.prototype.setGroundShadowAlpha = 
    function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setGroundShadowAlpha is not applicable to 2D") : this.impl.setGroundShadowAlpha(d)
    }
    ;
    g.prototype.setGroundReflectionColor = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setGroundReflectionColor is not applicable to 2D") : this.impl.setGroundReflectionColor(d)
    }
    ;
    g.prototype.setGroundReflectionAlpha = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setGroundReflectionAlpha is not applicable to 2D") : this.impl.setGroundReflectionAlpha(d)
    }
    ;
    g.prototype.getCutPlanes = function() {
        return this.model && this.model.is2d() ? (console.warn("Viewer3D.getCutPlanes is not applicable to 2D"),
        []) : this.impl.getCutPlanes()
    }
    ;
    g.prototype.setCutPlanes = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.getCutPlanes is not applicable to 2D") : this.impl.setCutPlanes(d)
    }
    ;
    g.prototype.setCutPlanesOutlineColor = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setCutPlanesOutlineColor is not applicable to 2D") : this.impl.setCutPlanesOutlineColor(d)
    }
    ;
    g.prototype.setCutPlanesOutlineThickness = function(d) {
        this.model && this.model.is2d() ? console.warn("Viewer3D.setCutPlanesOutlineThickness is not applicable to 2D") : this.impl.setCutPlanesOutlineThickness(d)
    }
    ;
    g.prototype.getScreenShot = function(d, c, a) {
        return this.impl.getScreenShot(d, c, a)
    }
    ;
    g.prototype.setContextMenu = function(d) {
        this.contextMenu && this.contextMenu.hide();
        this.contextMenu = d
    }
    ;
    g.prototype.triggerContextMenu = function(d) {
        if (this.config && this.config.onTriggerContextMenuCallback)
            this.config.onTriggerContextMenuCallback(d);
        return this.contextMenu ? (this.contextMenu.show(d),
        !0) : !1
    }
    ;
    g.prototype.triggerSelectionChanged = function(d) {
        if (this.config && this.config.onTriggerSelectionChangedCallback)
            this.config.onTriggerSelectionChangedCallback(d)
    }
    ;
    g.prototype.triggerDoubleTapCallback = function(d) {
        if (this.config && this.config.onTriggerDoubleTapCallback)
            this.config.onTriggerDoubleTapCallback(d)
    }
    ;
    g.prototype.triggerSingleTapCallback = function(d) {
        if (this.config && this.config.onTriggerSingleTapCallback)
            this.config.onTriggerSingleTapCallback(d)
    }
    ;
    g.prototype.initContextMenu = function() {
        function d(a) {
            var d = a.button;
            "buttons" in a && (!c.__firefoxLMBfix || a.buttons & 1 ? 2 === d && a.buttons & 1 && (d = 0,
            c.__firefoxLMBfix = !0) : (c.__firefoxLMBfix = !1,
            d = 0));
            a = c.navigation && c.navigation.getUseLeftHandedInput() ? 0 : 2;
            return d === a ? !0 : !1
        }
        if (!this.config || (this.config.hasOwnProperty("disableBrowserContextMenu") ? this.config.disableBrowserContextMenu : 1))
            this.onDefaultContextMenu = function(a) {
                a.preventDefault()
            }
            ,
            this.container.addEventListener("contextmenu", this.onDefaultContextMenu, 
            !1);
        var c = this
          , a = this.canvas || this.container;
        a.addEventListener("mousedown", function(a) {
            d(a) && (c.startX = a.clientX,
            c.startY = a.clientY)
        }
        );
        a.addEventListener("mouseup", function(a) {
            d(a) && a.clientX === c.startX && a.clientY === c.startY && c.triggerContextMenu(a);
            return !0
        }
        , !1)
    }
    ;
    g.prototype.registerContextMenuCallback = function(d, c) {
        this.contextMenuCallbacks[d] = c
    }
    ;
    g.prototype.unregisterContextMenuCallback = function(d) {
        return d in this.contextMenuCallbacks ? (delete this.contextMenuCallbacks[d],
        !0) : !1
    }
    ;
    g.prototype.runContextMenuCallbacks = 
    function(d, c) {
        for (var a in this.contextMenuCallbacks)
            if (this.contextMenuCallbacks.hasOwnProperty(a))
                this.contextMenuCallbacks[a](d, c)
    }
    ;
    g.prototype.playAnimation = function(d) {
        var c = this.impl.keyFrameAnimator;
        c && c.play(0, d)
    }
    ;
    g.prototype.joinLiveReview = function(d) {
        this.impl.joinLiveReviewSession(d)
    }
    ;
    g.prototype.leaveLiveReview = function() {
        this.impl.leaveLiveReviewSession()
    }
    ;
    g.prototype.getAttributeToIdMap = function(d, c) {
        this.model ? this.model.getAttributeToIdMap(d, c) : c && c(f.ErrorCodes.UNKNOWN_FAILURE, "Function getAttributeToIdMap failed")
    }
    ;
    Teratek.Viewing.Viewer3D = g
}
)();
Teratek.Viewing.ErrorCodes = {
    UNKNOWN_FAILURE: 1,
    BAD_DATA: 2,
    NETWORK_FAILURE: 3,
    NETWORK_ACCESS_DENIED: 4,
    NETWORK_FILE_NOT_FOUND: 5,
    NETWORK_SERVER_ERROR: 6,
    NETWORK_UNHANDLED_RESPONSE_CODE: 7,
    BROWSER_WEBGL_NOT_SUPPORTED: 8,
    BAD_DATA_NO_VIEWABLE_CONTENT: 9,
    BROWSER_WEBGL_DISABLED: 10,
    RTC_ERROR: 11
};
(function() {
    var f = Teratek.Viewing;
    f.HTTP_REQUEST_HEADERS = {};
    f.ACM_SESSION_ID = void 0;
    var h = function(f, d) {
        function c(a) {
            if (a) {
                var d = a.children ? a.children.length : 0;
                if ("geometry" === a.type && d) {
                    for (var f = 0, g = 0; g < d; g++) {
                        var h = a.children[g];
                        h && "view" === h.type && (b.myViewGeometry[h.guid] = a,
                        f++)
                    }
                    b.myNumViews[a.guid] = f
                } else if ("application/autodesk-db" == a.mime && a.urn)
                    0 === a.urn.indexOf("urn:adsk.objects:os.object") ? b.myPropertyDb = a.urn.substr(0, a.urn.lastIndexOf("%2F") + 3) : b.myPropertyDb = a.urn.substr(0, a.urn.lastIndexOf("/") + 
                    1);
                else if (0 < d)
                    for (g = 0; g < d; g++)
                        c(a.children[g])
            }
        }
        function a(b, c, d) {
            if (b) {
                var f = b.guid;
                if (f) {
                    d.apply(this, [f, c]);
                    c = b.children ? b.children.length : 0;
                    for (var g = 0; g < c; g++)
                        a(b.children[g], f, d)
                }
            }
        }
        this.myPath = d;
        this.myData = f;
        this.myViewGeometry = {};
        this.myNumViews = {};
        this.myPropertyDb = null ;
        var b = this;
        c(f);
        this.parents = {};
        a(this.myData, null , function(a, c) {
            b.parents[a] = c
        }
        )
    }
    ;
    h.prototype.constructor = h;
    h.load = function(g, d, c, a) {
        function b(a) {
            var b = {}, c;
            for (c in a)
                -1 != c.indexOf("x-ads-acm") && (b[c] = a[c]);
            return b
        }
        function k(a) {
            for (var b in a)
                if ("oauth2AccessToken" === 
                b)
                    return a[b];
            return null 
        }
        function l(a, b) {
            a.application = "autodesk";
            var d = new XMLHttpRequest;
            d.open("POST", ACM_SESSION_URL, !0);
            d.setRequestHeader("Content-Type", "application/json");
            d.setRequestHeader("Authorization", "Bearer " + b);
            d.onload = function() {
                200 === d.status && (f.ACM_SESSION_ID = JSON.parse(d.responseText).acmsession);
                q()
            }
            ;
            d.onerror = c;
            d.ontimeout = c;
            d.send(JSON.stringify(a));
            delete a.application
        }
        function n(a) {
            if (-1 === a.indexOf("urn:")) {
                if (0 === a.indexOf("http"))
                    return a;
                0 !== a.indexOf("/") && (a = "/" + 
                a);
                return window.location.protocol + "//" + window.location.host + a
            }
            return a
        }
        function m(a, b) {
            var c = []
              , d = 0
              , f = 0;
            b = b || "children";
            var g = function(a) {
                var h = a[b] || []
                  , k = a.messages || [];
                0 < k.filter(function(a) {
                    return "error" === a.type
                }
                ).length && (d += 1);
                "inprogress" === a.status && (f += 1);
                Array.prototype.push.apply(c, k.slice(0));
                for (a = h.length; a--; g(h[a]))
                    ;
            }
            ;
            g(a);
            var h;
            h = 0 < f ? "processing" : 0 < d ? "failed" : "translated";
            for (var k = c.length; k--; c[k].$translation = h)
                ;
            return c
        }
        function q() {
            function a(b) {
                if (/<[^>]*script/.test(b))
                    c && 
                    c(f.ErrorCodes.BAD_DATA, "Malicious document content detected Abort loading");
                else {
                    b = "string" === typeof b ? JSON.parse(b) : b;
                    b = new h(b,k);
                    var g = h.getSubItemsWithProperties(b.getRootItem(), {
                        type: "folder",
                        role: "viewable"
                    }, !0)[0];
                    0 < h.getSubItemsWithProperties(g, {
                        type: "geometry"
                    }, !0).length ? (g = m(b.getRootItem()),
                    d && d(b, g)) : c && (g = m(b.getRootItem()),
                    c(f.ErrorCodes.BAD_DATA_NO_VIEWABLE_CONTENT, "No viewable content", g))
                }
            }
            function b(a, d, g) {
                g = m(g);
                c && (d = "Error: " + a + " (" + d + ")",
                a = f.Private.ErrorHandler.getErrorCode(a),
                c(a, d, g))
            }
            var k = n(g)
              , l = {
                headers: f.HTTP_REQUEST_HEADERS,
                withCredentials: !!auth
            };
            try {
                f.Private.ViewingService.get(VIEWING_URL, "bubbles", k, a, b, l)
            } catch (q) {
                c && c(f.ErrorCodes.UNKNOWN_FAILURE, "An exception occurred while loading the document", null )
            }
        }
        "function" !== typeof d && (console.log("Document.load called with deprecated (auth) parameter"),
        "function" === typeof c && (d = c),
        "function" === typeof a && (c = a));
        if (a) {
            var r = b(a);
            a = k(a);
            f.HTTP_REQUEST_HEADERS = r;
            l(r, a)
        } else
            q()
    }
    ;
    h.prototype.getFullPath = function(g) {
        if (!g)
            return g;
        var d = g;
        f.Private.offline ? d = decodeURIComponent(f.Private.offlineResourcePrefix) + d.substr(d.indexOf("/")) : 0 === g.indexOf("urn") ? d = VIEWING_URL + "/items/" + g : 0 === g.indexOf("$file$") && -1 !== this.myPath.indexOf("/output/bubble.json") && (d = this.myPath.replace("/output/bubble.json", "") + g.replace("$file$", ""));
        return d
    }
    ;
    h.prototype.getThumbnailPath = function(g, d, c) {
        d = d ? d : 200;
        c = c ? c : 200;
        g = VIEWING_URL + "/thumbnails/" + this.myData.urn + "?guid=" + encodeURIComponent(g.guid) + "&width=" + d + "&height=" + c;
        f.ACM_SESSION_ID && (g += 
        "&acmsession=" + f.ACM_SESSION_ID);
        return g
    }
    ;
    h.prototype.getViewablePath = function(f) {
        if ("geometry" === f.type) {
            var d = [];
            "3d" === f.role ? d = h.getSubItemsWithProperties(f, {
                mime: "application/autodesk-svf"
            }, !1) : "2d" === f.role && (d = h.getSubItemsWithProperties(f, {
                mime: "application/autodesk-f2d"
            }, !1),
            0 == d.length && (d = h.getSubItemsWithProperties(f, {
                role: "tileRoot"
            }, !0)));
            if (0 < d.length)
                return this.getFullPath(d[0].urn)
        } else if ("view" === f.type && (f = this.getViewGeometry(f)))
            return this.getViewablePath(f);
        return ""
    }
    ;
    h.prototype.getPropertyDbPath = 
    function() {
        return this.myPropertyDb
    }
    ;
    h.prototype.getRootItem = function() {
        return this.myData
    }
    ;
    h.prototype.getPath = function() {
        return this.myPath
    }
    ;
    h.prototype.getItemById = function(f) {
        function d(c) {
            if (!c)
                return null ;
            for (var a in c) {
                var b = c[a];
                if ("guid" === a && b === f)
                    return c;
                if (null  !== b && "object" === typeof b && (b = d(b)))
                    return b
            }
            return null 
        }
        return d(this.myData)
    }
    ;
    h.getSubItemsWithProperties = function(f, d, c) {
        var a = [];
        if (!f)
            return [];
        for (var b = f.children ? f.children.length : 0, k = 0; k < b; k++) {
            var l = f.children[k], n;
            a: {
                n = 
                d;
                var m = void 0;
                for (m in n)
                    if (!(m in l) || n[m] !== l[m]) {
                        n = !1;
                        break a
                    }
                n = !0
            }
            n && a.push(l);
            c && a.push.apply(a, h.getSubItemsWithProperties(l, d, c))
        }
        return a
    }
    ;
    h.prototype.getViewGeometry = function(f) {
        return this.myViewGeometry[f.guid]
    }
    ;
    h.prototype.getNumViews = function(f) {
        return this.myNumViews[f.guid] || 0
    }
    ;
    h.prototype.getParentId = function(f) {
        return this.parents[f]
    }
    ;
    h.prototype.getMessages = function(f, d) {
        var c = [];
        if (!f)
            return c;
        var a = null ;
        d && (a = this.getRootItem().guid);
        for (var b = f, h = this.parents[b]; b && (!d || h !== 
        a); ) {
            if ((b = this.getItemById(b)) && b.messages)
                for (var l = 0; l < b.messages.length; l++)
                    c.push(b.messages[l]);
            b = h;
            h = this.parents[b]
        }
        return c
    }
    ;
    f.Document = h
}
)();
TeratekNamespace("Teratek.Viewing");
Teratek.Viewing.Navigation = function(f) {
    this.__options = {
        dollyToPivot: !1,
        orbitPastPoles: !0,
        reverseDolly: !1,
        reverseHorizontalLook: !1,
        reverseVerticalLook: !1,
        useLeftHandedInput: !1,
        usePivotAlways: !1,
        lockNavigation: !1
    };
    this.__transitionActive = this.__homeViewRequested = this.__fitToViewRequested = this.__pivotIsSetFlag = !1;
    this.__destinationView = null ;
    this.__isTouchDevice = this.__is2D = !1;
    this.__kEpsilon = 1E-6;
    var h = null 
      , g = {
        left: 0,
        top: 0,
        width: 1,
        height: 1
    };
    this.uninitialize = function() {
        this.setCamera(null )
    }
    ;
    this.setCamera = 
    function(d) {
        d !== h && (h = d) && (d.hasOwnProperty("target") || (d.target = new THREE.Vector3(0,0,0)),
        d.hasOwnProperty("pivot") || (d.pivot = new THREE.Vector3(0,0,0)),
        d.worldup = d.up.clone(),
        d.dirty = !0)
    }
    ;
    this.getCamera = function() {
        return h
    }
    ;
    this.setScreenViewport = function(d) {
        g = d
    }
    ;
    this.getScreenViewport = function() {
        return g
    }
    ;
    this.__setUp = function(d) {
        return d && h && 0 !== d.clone().normalize().sub(h.worldup).lengthSq() ? (h.worldup.copy(d).normalize(),
        h.dirty = !0) : !1
    }
    ;
    this.__getUp = function() {
        return h ? h.worldup : new THREE.Vector3(0,
        1,0)
    }
    ;
    this.setView = function(d, c) {
        h && d && c && !this.__options.lockNavigation && (h.position.copy(d),
        h.target.copy(c),
        h.dirty = !0)
    }
    ;
    this.orientCameraUp = function() {
        h && !this.__options.lockNavigation && (h.up.copy(this.getAlignedUpVector()),
        h.dirty = !0)
    }
    ;
    this.getPivotPoint = function() {
        return h ? h.pivot.clone() : new THREE.Vector3(0,0,0)
    }
    ;
    this.setPivotPoint = function(d) {
        h && d && !this.__options.lockNavigation && (h.pivot.copy(d),
        h.dirty = !0)
    }
    ;
    this.getPosition = function() {
        return h ? h.position.clone() : new THREE.Vector3(0,0,1)
    }
    ;
    this.setPosition = function(d) {
        h && d && !this.__options.lockNavigation && (h.position.copy(d),
        h.dirty = !0)
    }
    ;
    this.setTarget = function(d) {
        h && d && !this.__options.lockNavigation && (h.target.copy(d),
        h.dirty = !0)
    }
    ;
    this.getTarget = function() {
        return h ? h.target.clone() : new THREE.Vector3(0,0,0)
    }
    ;
    this.getEyeVector = function() {
        return h ? h.target.clone().sub(h.position) : new THREE.Vector3(0,0,-1)
    }
    ;
    this.getFovMin = function() {
        return 6.88
    }
    ;
    this.getFovMax = function() {
        return 100
    }
    ;
    this.isPointVisible = function(d) {
        return (new THREE.Frustum).setFromMatrix(h.projectionMatrix.clone().multiply(h.matrixWorldInverse)).containsPoint(d)
    }
    ;
    this.setVerticalFov = function(d, c) {
        if (!h || h.isPerspective)
            if (6.88 > d ? d = 6.88 : 100 < d && (d = 100),
            h && !this.__options.lockNavigation && !(1E-6 >= Math.abs(h.fov - d))) {
                if (c) {
                    var a = this.__pivotIsSetFlag && this.isPointVisible(this.getPivotPoint())
                      , b = this.getPosition()
                      , f = this.getEyeVector()
                      , g = THREE.Math.degToRad(h.fov)
                      , n = THREE.Math.degToRad(d)
                      , m = a ? this.getPivotPlaneDistance() : f.length()
                      , g = m * Math.tan(.5 * g) / Math.tan(.5 * n)
                      , f = f.normalize().multiplyScalar(m - g);
                    this.setPosition(b.add(f));
                    a && this.setTarget(this.getTarget().add(f))
                }
                h.setFov(d);
                h.dirty = !0
            }
    }
    ;
    this.computeFit = function(d, c, a, b) {
        if (!b || b.empty())
            return {
                position: d,
                target: c
            };
        var f = b.center();
        b = b.size();
        b = .5 * Math.sqrt(b.x * b.x + b.y * b.y + b.z * b.z);
        0 === b && (b = 1);
        if (!this.getIs2D()) {
            var g = Math.max(1, .9 + a / 100 * .5);
            b *= g
        }
        d = d.clone().sub(c).normalize();
        a = b / Math.tan(THREE.Math.degToRad(.5 * a));
        d.multiplyScalar(a);
        return {
            position: f.clone().add(d),
            target: f
        }
    }
    ;
    this.computeOrthogonalUp = function(d, c) {
        var a = this.__getUp()
          , b = c.clone().sub(d);
        if (0 === b.lengthSq())
            return b.copy(a);
        var f = b.clone().cross(a);
        0 === f.lengthSq() && (a.z > a.y ? b.y -= 1E-4 : b.z -= 1E-4,
        f.crossVectors(b, a));
        return f.cross(b).normalize()
    }
    ;
    this.fitBounds = function(d, c, a) {
        var b = this.getTarget()
          , f = this.getPosition();
        if (this.__options.lockNavigation || !c || c.empty())
            return {
                position: f,
                target: b
            };
        var g = this.getVerticalFov();
        c = this.computeFit(f, b, g, c);
        a = a ? this.computeOrthogonalUp(f, b) : h.up;
        d ? (h.up.copy(a),
        this.setView(c.position, c.target)) : this.setRequestTransitionWithUp(!0, c.position, c.target, g, a);
        this.setPivotPoint(c.target);
        this.setPivotSetFlag(!0);
        return c
    }
    ;
    this.updateCamera = function() {
        h && (h.updateProjectionMatrix(),
        this.orient(h, h.target, h.position, h.up),
        h.dirty = !1)
    }
    ;
    this.setCamera(f)
}
;
Teratek.Viewing.Navigation.prototype.constructor = Teratek.Viewing.Navigation;
Teratek.Viewing.Navigation.prototype.setIs2D = function(f) {
    this.__is2D = !!f
}
;
Teratek.Viewing.Navigation.prototype.getIs2D = function() {
    return this.__is2D
}
;
Teratek.Viewing.Navigation.prototype.setIsTouchDevice = function(f) {
    this.__isTouchDevice = !!f
}
;
Teratek.Viewing.Navigation.prototype.getIsTouchDevice = function() {
    return this.__isTouchDevice
}
;
Teratek.Viewing.Navigation.prototype.orient = function() {
    var f, h, g, d;
    return function(c, a, b, k) {
        f || (f = new THREE.Matrix4,
        h = new THREE.Vector3,
        g = new THREE.Vector3,
        d = new THREE.Vector3);
        var l = f.elements;
        d.subVectors(b, a).normalize();
        0 === d.lengthSq() && (d.z = 1);
        h.crossVectors(k, d).normalize();
        0 === h.lengthSq() && (k.z > k.y ? d.y -= 1E-4 : d.z += 1E-4,
        h.crossVectors(k, d).normalize());
        g.crossVectors(d, h);
        l[0] = h.x;
        l[4] = g.x;
        l[8] = d.x;
        l[1] = h.y;
        l[5] = g.y;
        l[9] = d.y;
        l[2] = h.z;
        l[6] = g.z;
        l[10] = d.z;
        c.setRotationFromMatrix(f)
    }
}
();
Teratek.Viewing.Navigation.prototype.fov2fl = function(f) {
    f = THREE.Math.degToRad(f);
    0 >= f && (f = 1E-4);
    return Math.round(12 / Math.tan(.5 * f))
}
;
Teratek.Viewing.Navigation.prototype.fl2fov = function(f) {
    0 >= f && (f = 1E-4);
    f = 2 * Math.atan(12 / f);
    return THREE.Math.radToDeg(f)
}
;
Teratek.Viewing.Navigation.prototype.setCameraUpVector = function(f) {
    if (!this.__options.lockNavigation) {
        var h = this.getCamera();
        h.up.copy(f);
        h.dirty = !0
    }
}
;
Teratek.Viewing.Navigation.prototype.getCameraUpVector = function() {
    var f = this.getCameraRightVector(!1)
      , h = this.getEyeVector();
    return f.cross(h).normalize()
}
;
Teratek.Viewing.Navigation.prototype.getAlignedUpVector = function() {
    var f = this.getCameraRightVector(!0)
      , h = this.getEyeVector();
    return f.cross(h).normalize()
}
;
Teratek.Viewing.Navigation.prototype.getCameraRightVector = function(f) {
    var h = new THREE.Vector3;
    f = f ? this.getWorldUpVector() : this.getCamera().up;
    var g = this.getEyeVector();
    h.crossVectors(g, f);
    0 === h.lengthSq() && (f.z > f.y ? g.y -= 1E-4 : g.z += 1E-4,
    h.crossVectors(g, f));
    return h.normalize()
}
;
Teratek.Viewing.Navigation.prototype.setWorldUpVector = function(f, h) {
    this.__options.lockNavigation || (this.__setUp(f),
    h && this.orientCameraUp())
}
;
Teratek.Viewing.Navigation.prototype.getWorldUpVector = function() {
    return this.__getUp().clone()
}
;
Teratek.Viewing.Navigation.prototype.getWorldRightVector = function() {
    var f = new THREE.Vector3;
    f.copy(this.__getUp());
    Math.abs(f.z) <= Math.abs(f.y) ? f.set(f.y, -f.x, 0) : 0 <= f.z ? f.set(f.z, 0, -f.x) : f.set(-f.z, 0, f.x);
    return f.normalize()
}
;
Teratek.Viewing.Navigation.prototype.getVerticalFov = function() {
    return this.getCamera().fov
}
;
Teratek.Viewing.Navigation.prototype.getHorizontalFov = function() {
    var f = this.getScreenViewport();
    return this.getCamera().fov * (f.width / f.height)
}
;
Teratek.Viewing.Navigation.prototype.getFocalLength = function() {
    return this.fov2fl(this.getVerticalFov())
}
;
Teratek.Viewing.Navigation.prototype.setFocalLength = function(f, h) {
    this.setVerticalFov(this.fl2fov(f), h)
}
;
Teratek.Viewing.Navigation.prototype.setReverseZoomDirection = function(f) {
    this.__options.reverseDolly = !!f
}
;
Teratek.Viewing.Navigation.prototype.setReverseHorizontalLookDirection = function(f) {
    this.getIs2D() ? console.warn("Teratek.Viewing.Navigation.setReverseHorizontalLookDirection is not applicable to 2D") : this.__options.reverseHorizontalLookDirection = !!f
}
;
Teratek.Viewing.Navigation.prototype.setReverseVerticalLookDirection = function(f) {
    this.getIs2D() ? console.warn("Teratek.Viewing.Navigation.setReverseVerticalLookDirection is not applicable to 2D") : this.__options.reverseVerticalLookDirection = !!f
}
;
Teratek.Viewing.Navigation.prototype.getReverseZoomDirection = function() {
    return this.__options.reverseDolly
}
;
Teratek.Viewing.Navigation.prototype.getReverseHorizontalLookDirection = function() {
    return this.getIs2D() ? (console.warn("Teratek.Viewing.Navigation.getReverseHorizontalLookDirection is not applicable to 2D"),
    !1) : this.__options.reverseHorizontalLookDirection
}
;
Teratek.Viewing.Navigation.prototype.getReverseVerticalLookDirection = function() {
    return this.getIs2D() ? (console.warn("Teratek.Viewing.Navigation.getReverseVerticalLookDirection is not applicable to 2D"),
    !1) : this.__options.reverseVerticalLookDirection
}
;
Teratek.Viewing.Navigation.prototype.setZoomTowardsPivot = function(f) {
    this.__options.dollyToPivot = !!f
}
;
Teratek.Viewing.Navigation.prototype.getZoomTowardsPivot = function() {
    return this.__options.dollyToPivot
}
;
Teratek.Viewing.Navigation.prototype.setOrbitPastWorldPoles = function(f) {
    this.getIs2D() ? console.warn("Teratek.Viewing.Navigation.setOrbitPastWorldPoles is not applicable to 2D") : this.__options.orbitPastPoles = !!f
}
;
Teratek.Viewing.Navigation.prototype.getOrbitPastWorldPoles = function() {
    return this.getIs2D() ? (console.warn("Teratek.Viewing.Navigation.orbitPastWorldPoles is not applicable to 2D"),
    !1) : this.__options.orbitPastPoles
}
;
Teratek.Viewing.Navigation.prototype.setUsePivotAlways = function(f) {
    this.__options.usePivotAlways = !!f
}
;
Teratek.Viewing.Navigation.prototype.getUsePivotAlways = function() {
    return this.__options.usePivotAlways
}
;
Teratek.Viewing.Navigation.prototype.setUseLeftHandedInput = function(f) {
    this.__options.useLeftHandedInput = !!f
}
;
Teratek.Viewing.Navigation.prototype.getUseLeftHandedInput = function() {
    return this.__options.useLeftHandedInput
}
;
Teratek.Viewing.Navigation.prototype.setIsLocked = function(f) {
    this.__options.lockNavigation = !!f
}
;
Teratek.Viewing.Navigation.prototype.getIsLocked = function() {
    return this.__options.lockNavigation
}
;
Teratek.Viewing.Navigation.prototype.setPivotSetFlag = function(f) {
    this.__options.lockNavigation || (this.__pivotIsSetFlag = !!f)
}
;
Teratek.Viewing.Navigation.prototype.getPivotSetFlag = function() {
    return this.__pivotIsSetFlag
}
;
Teratek.Viewing.Navigation.prototype.setRequestFitToView = function(f) {
    this.__options.lockNavigation || (this.__fitToViewRequested = !!f)
}
;
Teratek.Viewing.Navigation.prototype.getRequestFitToView = function() {
    return this.__fitToViewRequested
}
;
Teratek.Viewing.Navigation.prototype.setRequestHomeView = function(f) {
    this.__options.lockNavigation || (this.__homeViewRequested = !!f)
}
;
Teratek.Viewing.Navigation.prototype.getRequestHomeView = function() {
    return this.__homeViewRequested
}
;
Teratek.Viewing.Navigation.prototype.setRequestTransition = function(f, h, g, d, c) {
    this.__destinationView = f ? {
        position: h.clone(),
        coi: g.clone(),
        fov: d,
        up: this.getCamera().up.clone(),
        worldUp: this.getWorldUpVector(),
        reorient: c
    } : null 
}
;
Teratek.Viewing.Navigation.prototype.setRequestTransitionWithUp = function(f, h, g, d, c, a) {
    this.__destinationView = f ? {
        position: h.clone(),
        coi: g.clone(),
        fov: d,
        up: c.clone(),
        worldUp: a ? a : this.getWorldUpVector(),
        reorient: !1
    } : null 
}
;
Teratek.Viewing.Navigation.prototype.getRequestTransition = function() {
    return this.__destinationView
}
;
Teratek.Viewing.Navigation.prototype.setTransitionActive = function(f) {
    this.__transitionActive = !!f
}
;
Teratek.Viewing.Navigation.prototype.getTransitionActive = function() {
    return this.__transitionActive
}
;
Teratek.Viewing.Navigation.prototype.getWorldSize = function(f) {
    var h = this.getScreenViewport()
      , h = h.width / h.height;
    f = 2 * f * Math.tan(THREE.Math.degToRad(.5 * this.getCamera().fov));
    return new THREE.Vector2(f * h,f)
}
;
Teratek.Viewing.Navigation.prototype.getWorldPoint = function(f, h) {
    f = 2 * f - 1;
    h = 2 * (1 - h) - 1;
    var g = this.getCamera(), d;
    g.isPerspective && (d = new THREE.Vector3(f,h,1),
    d = d.unproject(g));
    var c = this.getEyeVector()
      , a = this.getPosition();
    if (!g.isPerspective || isNaN(d.x)) {
        var b = this.getWorldSize(c.length());
        d = this.getCameraRightVector(!1).multiplyScalar(.5 * f * b.x);
        b = this.getCameraUpVector().multiplyScalar(.5 * h * b.y);
        d = c.clone().add(d).add(b).normalize()
    } else
        d = d.sub(a).normalize();
    b = this.getPivotPoint();
    this.__pivotIsSetFlag && 
    (this.getIs2D() || g.isPerspective && this.isPointVisible(b)) ? (g = d.dot(c),
    c = 0 !== g ? Math.abs(b.sub(a).dot(c)) / g : b.sub(a).length()) : c = g.isPerspective ? .5 * (g.near + g.far) : g.orthoScale;
    return d.multiplyScalar(c).add(a)
}
;
Teratek.Viewing.Navigation.prototype.getPivotPlaneDistance = function() {
    var f = this.getPivotPoint()
      , h = this.getEyeVector()
      , g = this.getPosition();
    return f.sub(g).dot(h.normalize())
}
;
Teratek.Viewing.Navigation.prototype.panRelative = function(f, h, g) {
    g = this.getWorldSize(g);
    f *= g.x;
    h *= g.y;
    f = this.getCameraRightVector(!1).multiplyScalar(f);
    h = this.getCameraUpVector().multiplyScalar(h);
    h = f.add(h);
    this.setView(this.getPosition().add(h), this.getTarget().add(h))
}
;
Teratek.Viewing.Navigation.prototype.dollyFromPoint = function(f, h) {
    if (!(Math.abs(f) <= this.__kEpsilon)) {
        var g = this.getPosition()
          , g = h.clone().sub(g)
          , d = g.length()
          , c = d + f
          , a = 10 * this.__kEpsilon;
        c < a && (c = a);
        d = c / d;
        Math.abs(d - 1) > this.__kEpsilon && (g.multiplyScalar(d),
        g.set(-g.x, -g.y, -g.z),
        g = g.add(h),
        c = this.getEyeVector(),
        this.getCamera().isPerspective || c.multiplyScalar(d),
        this.setView(g, c.add(g)))
    }
}
;
Teratek.Viewing.Navigation.prototype.toPerspective = function() {
    if (this.getIs2D())
        console.warn("Teratek.Viewing.Navigation.toPerspective is not applicable to 2D");
    else {
        var f = this.getCamera();
        this.__options.lockNavigation || f.isPerspective || (f.toPerspective(),
        f.dirty = !0)
    }
}
;
Teratek.Viewing.Navigation.prototype.toOrthographic = function() {
    var f = this.getCamera();
    !this.__options.lockNavigation && f.isPerspective && (f.toOrthographic(),
    f.dirty = !0)
}
;
Teratek.Viewing.Navigation.snapToAxis = function(f) {
    var h = new THREE.Vector3(Math.abs(f.x),Math.abs(f.y),Math.abs(f.z));
    h.x > h.y && h.x > h.z ? f.set(0 < f.x ? 1 : -1, 0, 0) : h.y > h.x && h.y > h.z ? f.set(0, 0 < f.y ? 1 : -1, 0) : f.set(0, 0, 0 < f.z ? 1 : -1);
    return f
}
;
(function() {
    var f = Teratek.Viewing
      , h = Teratek.Viewing.Private
      , g = function(d, c) {
        this.appContainerId = d;
        this.container = document.getElementById(d);
        this.options = c;
        this.myRegisteredViewers = {};
        this.selectedItem = this.urn = this.myCurrentViewer = this.myDocument = null 
    }
    ;
    g.prototype.k3D = "3D";
    g.prototype.k2D = "2D";
    g.prototype.finish = function() {
        this.myCurrentViewer && (this.myCurrentViewer.finish(),
        this.myCurrentViewer = null )
    }
    ;
    g.prototype.registerViewer = function(d, c, a) {
        a = a || {};
        this.options && this.options.hasOwnProperty("disableBrowserContextMenu") && 
        !a.hasOwnProperty("disableBrowserContextMenu") && (a.disableBrowserContextMenu = this.options.disableBrowserContextMenu);
        this.myRegisteredViewers[d] = {};
        this.myRegisteredViewers[d].class = c;
        this.myRegisteredViewers[d].config = a
    }
    ;
    g.prototype.getViewerClass = function(d) {
        return this.myRegisteredViewers.hasOwnProperty(d) ? this.myRegisteredViewers[d].class : null 
    }
    ;
    g.prototype.getViewerContainer = function() {
        return document.getElementById(this.appContainerId)
    }
    ;
    g.prototype.getViewer = function(d, c, a) {
        if (d in this.myRegisteredViewers) {
            var b = 
            {}, f = this.myRegisteredViewers[d].config, g;
            for (g in f)
                f.hasOwnProperty(g) && (b[g] = f[g]);
            for (g in c)
                if (c.hasOwnProperty(g)) {
                    var f = c[g]
                      , h = Array.isArray(f)
                      , m = b[g]
                      , q = Array.isArray(m);
                    h && q ? (f ? h || (f = [f]) : f = [],
                    m ? q || (m = [m]) : m = [],
                    b[g] = m.concat(f)) : b[g] = f
                }
            d = this.myRegisteredViewers[d].class;
            if (this.myCurrentViewer && this.myCurrentViewer.__proto__.constructor === d)
                return this.myCurrentViewer.tearDown(),
                this.myCurrentViewer.setUp(b),
                this.myCurrentViewer;
            this.setCurrentViewer(null );
            for (c = this.getViewerContainer(); c.hasChildNodes(); )
                c.removeChild(c.lastChild);
            b = new d(c,b);
            d = b.start();
            if (0 === d)
                return this.setCurrentViewer(b),
                b;
            a && a(d, "Viewer failed to initialize")
        }
        return null 
    }
    ;
    g.prototype.setCurrentViewer = function(d) {
        this.myCurrentViewer && this.myCurrentViewer.finish();
        this.myCurrentViewer = d
    }
    ;
    g.prototype.getCurrentViewer = function() {
        return this.myCurrentViewer
    }
    ;
    g.prototype.loadDocument = function(d, c, a, b) {
        var g = this;
        h.logger && h.logger.log({
            category: "load_document",
            urn: 0 == d.indexOf("urn:") ? d.substring(4) : d
        });
        f.Document.load(d, function(a, b) {
            g.myDocument = a;
            g.onDocumentLoaded(a, 
            b);
            c && c(a, b)
        }
        , function(b, c, d) {
            g.onDocumentFailedToLoad(c, b, d);
            a && a(b, c, d)
        }
        , b)
    }
    ;
    g.prototype.onDocumentLoaded = function(d, c) {
        console.log(d, c)
    }
    ;
    g.prototype.onDocumentFailedToLoad = function(d, c, a) {
        console.log(d, c, a)
    }
    ;
    g.prototype.getDefaultGeometry = function(d) {
        for (var c = 0, a = d.length; c < a; ++c) {
            var b = d[c].useAsDefault;
            if (!0 === b || "true" === b)
                return d[c]
        }
        return d[0]
    }
    ;
    g.prototype.selectItem = function(d, c, a) {
        var b = this.myDocument.getViewablePath(d);
        if (b) {
            var f, g, n, m;
            if ("geometry" === d.type && "3d" === d.role)
                f = this.k3D,
                n = d.name,
                m = d;
            else if ("view" === d.type && "3d" === d.role) {
                if (g = d,
                f = this.k3D,
                m = this.myDocument.getViewGeometry(d))
                    n = m.name
            } else
                "geometry" === d.type && "2d" === d.role ? (f = 0 < Teratek.Viewing.Document.getSubItemsWithProperties(d, {
                    mime: "application/autodesk-f2d"
                }, !1).length ? this.k3D : this.k2D,
                n = d.name,
                m = d) : "view" === d.type && "2d" === d.role && (g = d,
                f = this.k3D,
                m = this.myDocument.getViewGeometry(d)) && (n = m.name);
            var q = h.logger;
            if (q) {
                var r = b.indexOf("urn:");
                q.log({
                    category: "load_viewable",
                    role: d.role,
                    type: d.type,
                    urn: -1 !== r ? 
                    b.substring(r + 4) : b
                })
            }
            var t = this.myDocument.getMessages(d.guid, !0);
            if (f) {
                var w = this
                  , C = this.myCurrentViewer && this.urn === b
                  , q = null 
                  , q = g && g.camera ? function() {
                    w.myCurrentViewer.setViewFromArray(g.camera, g.name);
                    c && c(w.myCurrentViewer, d, t)
                }
                 : g && g.viewbox ? function() {
                    w.myCurrentViewer.setViewFromViewBox(g.viewbox, g.name);
                    c && c(w.myCurrentViewer, d, t)
                }
                 : C ? function() {
                    w.myCurrentViewer.setViewFromFile();
                    c && c(w.myCurrentViewer, d, t)
                }
                 : function() {
                    c && c(w.myCurrentViewer, d, t)
                }
                  , r = function(b, c) {
                    a && a(b, c, t)
                }
                  , E = !1;
                C ? (q && q(),
                E = !0) : (this.urn = null ,
                n = {
                    defaultModelStructureTitle: n,
                    viewableName: n
                },
                d.hasOwnProperty("extensions") && (n.extensions = Array.isArray(d.extensions) ? d.extensions : [d.extensions]),
                (f = this.getViewer(f, n, a)) && f.load(this.myDocument.getFullPath(b), this.myDocument.getPropertyDbPath(), q, r) && (this.urn = b,
                E = !0));
                if (E)
                    return this.selectedItem = d,
                    this.onItemSelected(d, m),
                    !0
            }
        }
        return !1
    }
    ;
    g.prototype.onItemSelected = function(d, c) {
        stderr("Selected URL: http://" + location.host + location.pathname + "?document=urn:" + this.myDocument.getRootItem().guid + 
        "&item=" + encodeURIComponent(d.guid));
        if (this.itemSelectedObservers)
            for (var a = this.getCurrentViewer(), b = 0; b < this.itemSelectedObservers.length; ++b) {
                var f = this.itemSelectedObservers[b];
                f.onItemSelected && f.onItemSelected(a, d, c)
            }
    }
    ;
    g.prototype.addItemSelectedObserver = function(d) {
        this.itemSelectedObservers || (this.itemSelectedObservers = []);
        this.itemSelectedObservers.push(d)
    }
    ;
    g.prototype.selectItemById = function(d, c, a) {
        return (d = this.myDocument.getItemById(d)) ? this.selectItem(d, c, a) : !1
    }
    ;
    g.prototype.getSelectedItem = 
    function() {
        return this.selectedItem
    }
    ;
    f.ViewingApplication = g
}
)();
TeratekNamespace("Teratek.Viewing.Private");
Teratek.Viewing.Private.ViewCubeUi = function(f) {
    this.viewer = f;
    this.homeViewContainer = this.infoButton = this.viewcube = this.cube = null 
}
;
Teratek.Viewing.Private.ViewCubeUi.prototype = {
    constructor: Teratek.Viewing.UI.ViewCube,
    create: function() {
        var f = this.viewer.config;
        (f && void 0 !== f.wantInfoButton ? f.wantInfoButton : 1) && this.initInfoButton();
        this.initHomeButton()
    },
    initInfoButton: function() {
        if (!(0 < document.getElementsByClassName("infoButton").length)) {
            this.infoButton = document.createElement("div");
            this.infoButton.className = "infoButton";
            this.infoButton.style.cursor = "pointer";
            this.viewer.container.appendChild(this.infoButton);
            var f = this;
            this.infoButton.addEventListener("click", function(h) {
                h = f.viewer.getPropertyPanel(!0);
                var g = !h.areDefaultPropertiesShown() || !h.isVisible();
                g && h.showDefaultProperties();
                g !== h.isVisible() && h.setVisible(g)
            }
            )
        }
    },
    initHomeButton: function() {
        if (!(0 < document.getElementsByClassName("homeViewWrapper").length)) {
            var f = document.createElement("div");
            f.className = "homeViewWrapper";
            f.style.cursor = "pointer";
            this.viewer.container.appendChild(f);
            this.homeViewContainer = f;
            var h = this;
            f.addEventListener("click", function(f) {
                h.viewer.navigation.setRequestHomeView(!0)
            }
            );
            this._initHomeMenu(f)
        }
    },
    _initHomeMenu: function(f) {
        var h = this.viewer
          , g = h.autocam
          , d = this;
        this.hideHomeViewMenu = function(a) {
            b.style.display = "none";
            document.removeEventListener("click", d.hideHomeViewMenu)
        }
        ;
        var c = document.createElement("div");
        c.className = "homeViewMenuHandle";
        var a = document.createElement("img");
        a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsSAAALEgHS3X78AAAAIGNIUk0AAH7FAACLdgAA9UcAAIsOAABxUAAA6BUAADlYAAAfBMec4XAAAAEBSURBVHja7JcxCsIwFIb/V3oFx04v4iB4A3ev4Ak9iOABOhQcageHDh7iuVSwpW1eYmIFEwiFQvN9SZP/ERIRLNkyLNySQBLIhy+I6AhgE5F5FZHTpACAbV3X61h0Zs5nVwBAJiL0rd+eNuHvnQIArTEmplhrE7gAWEUUePSO/Vg1jJgFvQyYWoFoWTDMgLlNWDFzIyIUqjNzA6DSCpwBlMaYW4iZd+OU3bh2ARG5h5J4h3fj6nIghIQNbg2iTyQ0cFUS+kho4eoodpFwgTvVAo2EK9y5GM1J+MC9quGYhC98shaoPiQqAOwB7Hzhrxn1umMrABy6pxeT0t3w7wWeAwD5qe4YizvzugAAAABJRU5ErkJggg==";
        a.width = a.height = 18;
        c.appendChild(a);
        c.addEventListener("mouseover", function(b) {
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsSAAALEgHS3X78AAAAIGNIUk0AAH7FAACLdgAA9UcAAIsOAABxUAAA6BUAADlYAAAfBMec4XAAAAEVSURBVHja7JcxDoJAEEX/rvY2HMEb6AEsaTDxBngKIzfgDBR6AxJtiI0egN7Ght6GWBIYGzVKQHaQDYU7yYSwxb5HMvs3CCJCnyXRcxkBIzAsLwyWpx0ARyNzn29m81oBAE60mmqj237smBkwAl9PAfIssv3Y1kbMs+j9VZQvIyHEGMBI40enRHSpFdCcBR8ZUJcD2rKgnAH1Q5gmnu3HXcOBNPGUBIrQDbqUeMKL0A2UBIjo2pXEO5yIrso50IVEE7wxiH6RUIErJWEbCVW4chRzJDhw1l2gIsGFPzdmNQBLLrZr6R7pcL69WrpHkovtGoDF2o8rUCXRFt5aoCzRFl4pwCwLwOTxBGOeXi3Mv+HfC9wHAAIQ03ZDDGqmAAAAAElFTkSuQmCC"
        }
        );
        c.addEventListener("mouseleave", function(b) {
            a.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsSAAALEgHS3X78AAAAIGNIUk0AAH7FAACLdgAA9UcAAIsOAABxUAAA6BUAADlYAAAfBMec4XAAAAEBSURBVHja7JcxCsIwFIb/V3oFx04v4iB4A3ev4Ak9iOABOhQcageHDh7iuVSwpW1eYmIFEwiFQvN9SZP/ERIRLNkyLNySQBLIhy+I6AhgE5F5FZHTpACAbV3X61h0Zs5nVwBAJiL0rd+eNuHvnQIArTEmplhrE7gAWEUUePSO/Vg1jJgFvQyYWoFoWTDMgLlNWDFzIyIUqjNzA6DSCpwBlMaYW4iZd+OU3bh2ARG5h5J4h3fj6nIghIQNbg2iTyQ0cFUS+kho4eoodpFwgTvVAo2EK9y5GM1J+MC9quGYhC98shaoPiQqAOwB7Hzhrxn1umMrABy6pxeT0t3w7wWeAwD5qe4YizvzugAAAABJRU5ErkJggg=="
        }
        );
        f.appendChild(c);
        var b = document.createElement("div");
        b.className = "homeViewMenu";
        this.viewer.container.appendChild(b);
        var k = document.createElement("div");
        k.className = "homeViewMenuItem";
        k.textContent = Teratek.Viewing.i18n.translate("Set current view as Home");
        b.appendChild(k);
        k.addEventListener("click", function(a) {
            g.setCurrentViewAsHome(!1);
            d.hideHomeViewMenu(a)
        }
        );
        k = document.createElement("div");
        k.className = "homeViewMenuItem";
        k.textContent = Teratek.Viewing.i18n.translate("Focus and set as Home");
        b.appendChild(k);
        k.addEventListener("click", function(a) {
            g.setCurrentViewAsHome(!0);
            d.hideHomeViewMenu(a)
        }
        );
        k = document.createElement("div");
        k.className = "homeViewMenuItem";
        k.textContent = Teratek.Viewing.i18n.translate("Reset Home");
        b.appendChild(k);
        k.addEventListener("click", function(a) {
            g.resetHome();
            d.hideHomeViewMenu(a)
        }
        );
        f.addEventListener("mouseover", function(a) {
            if (h.model && h.model.is2d() || h.prefs && !h.prefs.viewCube)
                c.style.display = "block"
        }
        );
        f.addEventListener("mouseleave", function(a) {
            c.style.display = "none"
        }
        );
        c.addEventListener("click", 
        function(a) {
            if (h.model && h.model.is2d() || h.prefs && !h.prefs.viewCube)
                b.style.display = "block",
                document.addEventListener("click", d.hideHomeViewMenu);
            a.stopPropagation()
        }
        );
        f.addEventListener("contextmenu", function(a) {
            if (h.model && h.model.is2d() || h.prefs && !h.prefs.viewCube)
                b.style.display = "block",
                document.addEventListener("click", d.hideHomeViewMenu)
        }
        )
    },
    displayViewCube: function(f, h) {
        !1 !== h && this.viewer.prefs.set("viewCube", f);
        if (f && !this.cube)
            this.viewcube = document.createElement("div"),
            this.viewcube.className = 
            "viewcube",
            this.viewer.container.appendChild(this.viewcube),
            this.cube = new Autocam.ViewCube("cube",this.viewer.autocam,this.viewcube,LOCALIZATION_REL_PATH);
        else if (!this.cube) {
            this._positionHomeButton();
            return
        }
        this.viewcube.style.display = f ? "block" : "none";
        this._positionHomeButton();
        f && this.viewer.autocam.refresh()
    },
    _positionHomeButton: function() {
        if (this.homeViewContainer) {
            var f = this.cube && this.viewcube && "block" === this.viewcube.style.display
              , h = this.viewer.container.getBoundingClientRect()
              , g = this.homeViewContainer.getBoundingClientRect();
            f ? (f = this.viewcube.getBoundingClientRect(),
            h = h.left + h.width - f.left - g.width) : this.infoButton ? (f = this.infoButton.getBoundingClientRect(),
            h = h.left + h.width - f.left + f.width - g.width) : h = 10;
            this.homeViewContainer.style.right = h + "px"
        }
    },
    uninitialize: function() {
        this.viewcube && (this.viewer.container.removeChild(this.viewcube),
        this.viewcube = null );
        this.infoButton = null ;
        this.cube && (this.cube.dtor(),
        this.cube = null );
        this.viewer = this.hideHomeViewMenu = this.homeViewContainer = null 
    }
};
function stringToDOM(f) {
    var h = document.createElement("div");
    h.innerHTML = f;
    return h.firstChild
}
(function() {
    var f = Teratek.Viewing
      , h = Teratek.Viewing.Private
      , g = Teratek.Viewing.UI
      , d = Teratek.Viewing.Extensions;
    f.TOOLBAR_CREATED_EVENT = "toolbarCreated";
    f.TOOLBAR = {
        NAVTOOLSID: "navTools",
        MODELTOOLSID: "modelTools",
        SETTINGSTOOLSID: "settingsTools"
    };
    var c = function(a, b) {
        b || (b = {});
        b.startOnInitialize = !1;
        f.Viewer3D.call(this, a, b);
        this.toolbar = null ;
        this.dockingPanels = [];
        this.layersPanel = this.modelstructure = null 
    }
    ;
    c.prototype = Object.create(f.Viewer3D.prototype);
    c.prototype.constructor = c;
    c.prototype.resize = 
    function() {
        f.Viewer3D.prototype.resize.call(this);
        this.resizePanels();
        this.viewCubeUi && this.viewCubeUi.cube && this.viewCubeUi.cube.refreshCube();
        this.centerToolBar && this.centerToolBar()
    }
    ;
    c.prototype.initialize = function() {
        var a = f.Viewer3D.prototype.initialize.call(this);
        if (0 < a)
            return a;
        var b = this;
        this.toolController && (a = new f.HotGestureTool(this),
        this.toolController.registerTool(a),
        this.toolController.activateTool(a.getName()));
        this.getToolbar(!0);
        this.addEventListener(f.FULLSCREEN_MODE_EVENT, function(a) {
            b.resizePanels({
                viewer: b
            });
            b.updateFullscreenButton(a.mode)
        }
        );
        this.contextMenu || this.setContextMenu(new d.ViewerObjectContextMenu(this));
        this.progressbar = new h.ProgressBar(this.container);
        this.addEventListener(f.PROGRESS_UPDATE_EVENT, function(a) {
            void 0 !== a.percent && b.progressbar.setPercent(a.percent)
        }
        , !1);
        this.selectionActive = !1;
        this.addEventListener(f.SELECTION_CHANGED_EVENT, function(a) {
            b.selectionActive = 0 < a.dbIdArray.length;
            b.prefs.openPropertiesOnSelect && b.getPropertyPanel(!0).setVisible(b.selectionActive)
        }
        );
        this.addEventListener(f.ISOLATE_EVENT, 
        function(a) {
            (b.prefs.openPropertiesOnSelect || a.nodeIdArray[0] === b.model.getRootId()) && b.propertygrid && b.propertygrid.setVisible(0 < a.nodeIdArray.length || b.selectionActive)
        }
        );
        this.addEventListener(f.VIEWER_STATE_RESTORED_EVENT, function(a) {
            b.renderoptions && b.renderoptions.syncUI();
            (a = b.getSettingsPanel(!0)) && a.syncUI()
        }
        );
        this.initEscapeHandlers();
        this.localize();
        this.run();
        return 0
    }
    ;
    c.prototype.uninitialize = function() {
        this.viewerSettingsPanel && (this.viewerSettingsPanel.uninitialize(),
        this.viewerSettingsPanel = 
        null );
        this.modelstructure && (this.modelstructure.uninitialize(),
        this.modelstructure = null );
        this.layersPanel && (this.layersPanel.uninitialize(),
        this.layersPanel = null );
        this.propertygrid && (this.propertygrid.uninitialize(),
        this.propertygrid = null );
        this.renderoptions && (this.renderoptions.uninitialize(),
        this.renderoptions = null );
        this.viewerOptionButton && (this.viewerOptionButton = this.show3dOptionsPerformanceTab = this.show3dOptionsNavigationTab = null );
        f.theHotkeyManager.popHotkeys("Teratek.ROLL");
        f.theHotkeyManager.popHotkeys("Teratek.FOV");
        this.removeEventListener(f.RENDER_OPTION_CHANGED_EVENT, this.selectLightPreset);
        this.centerToolBar = this.explodeSubmenu = this.explodeSlider = this.modelStats = this.debugMenu = this.settingsTools = this.navTools = this.modelTools = this.progressbar = this.selectLightPreset = null ;
        this.viewCubeUi.uninitialize();
        this.toolbar = this.viewCubeUi = null ;
        f.Viewer3D.prototype.uninitialize.call(this)
    }
    ;
    c.prototype.setUp = function(a) {
        a || (a = {});
        a.startOnInitialize = !1;
        this.getToolbar(!0);
        f.Viewer3D.prototype.setUp.call(this, a)
    }
    ;
    c.prototype.tearDown = 
    function() {
        f.Viewer3D.prototype.tearDown.call(this);
        this.toolbar && (this.toolbar.container.parentNode.removeChild(this.toolbar.container),
        this.toolbar = null );
        this.modelstructure && this.setModelStructurePanel(null );
        this.propertygrid && this.setPropertyPanel(null );
        this.viewerSettingsPanel && this.setSettingsPanel(null );
        this.layersPanel && this.setLayersPanel(null );
        this.renderoptions && (this.removePanel(this.renderoptions),
        this.renderoptions.uninitialize(),
        this.renderoptions = null )
    }
    ;
    c.prototype.loadModel = function(a, 
    b, c, d) {
        var g = this
          , h = function() {
            g.displayViewCube(g.prefs.viewCube);
            g.removeEventListener(f.GEOMETRY_LOADED_EVENT, h)
        }
          , q = this.config.disabledExtensions;
        -1 != a.indexOf(".f2d") ? (this.createUI("2d"),
        g.prefs.useFirstPersonNav ? this.unloadExtension("Teratek.FirstPerson") : this.unloadExtension("Teratek.Beeline"),
        this.setDefaultNavigationTool("pan"),
        this.setClickToSetCOI(!1, !1),
        this.displayViewCube(!1, !1),
        (!q || q && !q.measure) && this.loadExtension("Teratek.Measure", null )) : (this.createUI("3d"),
        -1 === this.getDefaultNavigationToolName().indexOf("orbit") && 
        this.setDefaultNavigationTool("orbit"),
        g.prefs.useFirstPersonNav ? this.loadExtension("Teratek.FirstPerson", null ) : this.loadExtension("Teratek.Beeline", null ),
        this.loadExtension("Teratek.Viewing.Oculus", null ),
        this.prefs.fusionOrbit && this.loadExtension("Teratek.Viewing.FusionOrbit", null ),
        (!q || q && !q.section) && this.loadExtension("Teratek.Section", null ),
        this.addEventListener(f.GEOMETRY_LOADED_EVENT, h));
        var r = function() {
            g.modelstructure && g.model.getObjectTree(function(a) {
                g.modelstructure.setModel(a, g.config.defaultModelStructureTitle ? 
                g.config.defaultModelStructureTitle : "")
            }
            , function(a) {}
            );
            g.removeEventListener(f.OBJECT_TREE_CREATED_EVENT, r)
        }
        ;
        this.addEventListener(f.OBJECT_TREE_CREATED_EVENT, r);
        return f.Viewer3D.prototype.loadModel.call(this, a, b, c, d)
    }
    ;
    c.prototype.createUI = function(a) {
        var b = this;
        this.initHotkeys(a);
        this.loadExtension("Teratek.DefaultTools.NavTools", {
            mode: a
        });
        this.initModelTools(a);
        ENABLE_DEBUG && this.initDebugTools();
        this.fireEvent({
            type: f.TOOLBAR_CREATED_EVENT
        });
        this.viewCubeUi || (this.viewCubeUi = new h.ViewCubeUi(this));
        this.viewCubeUi.create();
        this.centerToolBar = function() {
            b.toolbar.container.style.left = "calc(50% - " + b.toolbar.getDimensions().width / 2 + "px)"
        }
        ;
        this.toolbar.addEventListener(g.ToolBar.Event.SIZE_CHANGED, this.centerToolBar);
        this.initModality();
        this.resize()
    }
    ;
    c.prototype.addOptionToggle = function(a, b, c, d, g) {
        var h = g ? this.prefs[g] : null ;
        c = "boolean" === typeof h ? h : c;
        h = document.createElement("li");
        h.className = "toolbar-submenu-listitem";
        var q = document.createElement("input");
        q.className = "toolbar-submenu-checkbox";
        q.type = "checkbox";
        q.id = b;
        h.appendChild(q);
        var r = document.createElement("label");
        r.setAttribute("for", b);
        r.setAttribute("data-i18n", b);
        r.textContent = f.i18n.translate(b);
        h.appendChild(r);
        a.appendChild(h);
        q.checked = c;
        q.addEventListener("touchstart", touchStartToClick);
        r.addEventListener("touchstart", touchStartToClick);
        h.addEventListener("touchstart", touchStartToClick);
        q.addEventListener("click", function(a) {
            d(q.checked);
            a.stopPropagation()
        }
        );
        r.addEventListener("click", function(a) {
            a.stopPropagation()
        }
        );
        h.addEventListener("click", function(a) {
            d(!q.checked);
            a.stopPropagation()
        }
        );
        g && this.prefs.addListeners(g, function(a) {
            q.checked = a
        }
        , function(a) {
            q.checked = a;
            d(a)
        }
        );
        return q
    }
    ;
    c.prototype.addOptionList = function(a, b, c, d, g, h) {
        var q = this.prefs[h];
        d = "number" === typeof q ? q : d;
        var r = document.createElement("select");
        r.className = "optionDropDown";
        r.id = "selectMenu_" + b;
        for (q = 0; q < c.length; q++) {
            var t = document.createElement("option");
            t.value = q;
            t.setAttribute("data-i18n", c[q]);
            t.textContent = Teratek.Viewing.i18n.translate(c[q]);
            r.add(t)
        }
        c = document.createElement("li");
        c.className = "toolbar-submenu-select";
        q = document.createElement("div");
        q.className = "toolbar-submenu-selectlabel";
        q.setAttribute("for", b);
        q.setAttribute("data-i18n", b);
        q.textContent = f.i18n.translate(b);
        c.appendChild(q);
        c.appendChild(r);
        a.appendChild(c);
        r.selectedIndex = d;
        r.onchange = function(a) {
            g(a.target.selectedIndex);
            a.stopPropagation()
        }
        ;
        r.addEventListener("touchstart", function(a) {
            a.stopPropagation()
        }
        );
        r.addEventListener("click", function(a) {
            a.stopPropagation()
        }
        );
        h && this.prefs.addListeners(h, function(a) {
            r.selectedIndex = a
        }
        , function(a) {
            r.selectedIndex = a;
            g(a)
        }
        );
        return r
    }
    ;
    c.prototype.showViewer3dOptions = function(a) {
        var b = this.getSettingsPanel(!0);
        a && b.isVisible() && b.setVisible(!1);
        b.setVisible(a)
    }
    ;
    c.prototype.showRenderingOptions = function(a) {
        this.renderoptions.setVisible(a)
    }
    ;
    c.prototype.showLayerManager = function(a) {
        this.layersPanel.setVisible(a)
    }
    ;
    c.prototype.initHotkeys = function(a) {
        var b = this
          , c = f.theHotkeyManager.KEYCODES;
        if ("3d" === a) {
            var d;
            f.theHotkeyManager.pushHotkeys("Teratek.FOV", 
            [{
                keycodes: [c.CONTROL, c.SHIFT],
                onPress: function() {
                    if (b.toolController.getIsLocked())
                        return !1;
                    d = b.getActiveNavigationTool();
                    b.setActiveNavigationTool("fov");
                    return !0
                },
                onRelease: function() {
                    if (b.toolController.getIsLocked())
                        return !1;
                    b.setActiveNavigationTool(d);
                    return !0
                }
            }], {
                tryUntilSuccess: !0
            })
        }
        var g;
        f.theHotkeyManager.pushHotkeys("Teratek.ROLL", [{
            keycodes: [c.ALT, c.SHIFT],
            onPress: function() {
                if (b.toolController.getIsLocked())
                    return !1;
                g = b.getActiveNavigationTool();
                b.setActiveNavigationTool("worldup");
                return !0
            },
            onRelease: function() {
                if (b.toolController.getIsLocked())
                    return !1;
                b.setActiveNavigationTool(g);
                return !0
            }
        }], {
            tryUntilSuccess: !0
        })
    }
    ;
    c.prototype.setModelStructurePanel = function(a) {
        var b = this;
        if (a instanceof f.UI.ModelStructurePanel || null  === a) {
            this.modelstructure && (this.modelstructure.setVisible(!1),
            this.removePanel(this.modelstructure),
            this.modelstructure.uninitialize());
            if (this.modelstructure = a)
                this.addPanel(this.modelstructure),
                a.addVisibilityListener(function(c) {
                    if (c)
                        b.onPanelVisible(a, b);
                    b.settingsTools.structurebutton.setState(c ? g.Button.State.ACTIVE : g.Button.State.INACTIVE)
                }
                ),
                b.model && b.model.getObjectTree(function(a) {
                    b.modelstructure.setModel(a)
                }
                );
            return !0
        }
        return !1
    }
    ;
    c.prototype.setLayersPanel = function(a) {
        var b = this;
        if (this.model && !this.model.is2d())
            return console.warn("av.Viewer3D.setLayersPanel is not yet implemented for 3D"),
            !1;
        if (a instanceof f.UI.LayersPanel || !a) {
            this.layersPanel && (this.layersPanel.setVisible(!1),
            this.removePanel(this.layersPanel),
            this.layersPanel.uninitialize());
            if (this.layersPanel = a)
                this.addPanel(a),
                a.addVisibilityListener(function(c) {
                    if (c)
                        b.onPanelVisible(a, b);
                    b.settingsTools.layerButton.setState(c ? g.Button.State.ACTIVE : g.Button.State.INACTIVE)
                }
                );
            return !0
        }
        return !1
    }
    ;
    c.prototype.setPropertyPanel = function(a) {
        var b = this;
        if (a instanceof f.UI.PropertyPanel || !a) {
            this.propertygrid && (this.propertygrid.setVisible(!1),
            this.removePanel(this.propertygrid),
            this.propertygrid.uninitialize());
            if (this.propertygrid = a)
                this.addPanel(a),
                a.addVisibilityListener(function(c) {
                    if (c)
                        b.onPanelVisible(a, 
                        b);
                    b.settingsTools.propertiesbutton.setState(c ? g.Button.State.ACTIVE : g.Button.State.INACTIVE)
                }
                );
            return !0
        }
        return !1
    }
    ;
    c.prototype.getPropertyPanel = function(a) {
        !this.propertygrid && a && this.setPropertyPanel(new d.ViewerPropertyPanel(this));
        return this.propertygrid
    }
    ;
    c.prototype.setSettingsPanel = function(a) {
        return a instanceof f.UI.SettingsPanel || !a ? (this.viewerSettingsPanel && (this.viewerSettingsPanel.setVisible(!1),
        this.removePanel(this.viewerSettingsPanel),
        this.viewerSettingsPanel.uninitialize()),
        (this.viewerSettingsPanel = 
        a) && this.addPanel(a),
        !0) : !1
    }
    ;
    c.prototype.getSettingsPanel = function(a) {
        !this.viewerSettingsPanel && a && this.setSettingsPanel(new d.ViewerSettingsPanel(this,this.model.is2d() ? "2d" : "3d"));
        return this.viewerSettingsPanel
    }
    ;
    c.prototype.initModelTools = function(a) {
        var b = this;
        if ("3d" === a) {
            b.modelstructure || b.setModelStructurePanel(new d.ViewerModelStructurePanel(b,"Browser",{
                docStructureConfig: b.config.docStructureConfig
            }));
            var c = new g.Button("toolbar-modelStructureTool");
            c.setToolTip("Model browser");
            c.setIcon("teratek-icon-structure");
            c.onClick = function(a) {
                b.showModelStructurePanel(!b.modelstructure.isVisible())
            }
            ;
            this.settingsTools.addControl(c);
            this.settingsTools.structurebutton = c;
            this.initExplodeSlider()
        } else
            c = new d.ViewerLayersPanel(this),
            this.setLayersPanel(c),
            c = new g.Button("toolbar-layersTool"),
            c.setToolTip("Layer Manager"),
            c.setIcon("teratek-icon-layers"),
            c.onClick = function(a) {
                b.layersPanel || b.setLayersPanel(new d.ViewerLayersPanel(b));
                b.showLayerManager(!b.layersPanel.isVisible())
            }
            ,
            this.settingsTools.addControl(c),
            this.settingsTools.layerButton = 
            c;
        b.addEventListener(f.RESET_EVENT, function() {
            b.model && !b.model.is2d() && (b.explode(0),
            b.explodeSlider.value = 0);
            b.showAll()
        }
        );
        c = new g.Button("toolbar-propertiesTool");
        c.setToolTip("Properties");
        c.setIcon("teratek-icon-properties");
        c.onClick = function(a) {
            a = b.getPropertyPanel(!0);
            a.setVisible(!a.isVisible())
        }
        ;
        c.setVisible(!b.prefs.openPropertiesOnSelect);
        this.settingsTools.addControl(c);
        this.settingsTools.propertiesbutton = c;
        c = new d.ViewerSettingsPanel(this,a);
        this.setSettingsPanel(c);
        this.viewerOptionButton = 
        c = new g.Button("toolbar-settingsTool");
        c.setIcon("teratek-icon-settings");
        c.setToolTip("Settings");
        this.settingsTools.addControl(c);
        this.createViewerOptionsMenu(a);
        ENABLE_DEBUG && "3d" === a && (this.renderoptions = new h.RenderOptionsPanel(this),
        this.addPanel(this.renderoptions),
        a = new g.Button("toolbar-renderOptionsTool"),
        a.setToolTip("Rendering options"),
        a.setIcon("teratek-icon-settings-render"),
        a.onClick = function(a) {
            b.showRenderingOptions(!b.renderoptions.isVisible())
        }
        ,
        this.settingsTools.addControl(a));
        this.canChangeScreenMode() && 
        (a = new g.Button("toolbar-fullscreenTool",{
            collapsible: !1
        }),
        a.setToolTip("Full screen"),
        a.setIcon("teratek-icon-fullscreen"),
        a.onClick = function(a) {
            b.nextScreenMode()
        }
        ,
        this.settingsTools.addControl(a),
        this.settingsTools.fullscreenbutton = a,
        this.updateFullscreenButton(this.getScreenMode()))
    }
    ;
    c.prototype.setPropertiesOnSelect = function(a) {
        this.settingsTools.propertiesbutton.setVisible(!a)
    }
    ;
    c.prototype.addDivider = function(a) {
        var b = document.createElement("li");
        b.className = "toolbar-submenu-horizontal-divider";
        a.appendChild(b);
        return b
    }
    ;
    c.prototype.createViewerOptionsMenu = function(a) {
        function b(a) {
            var b = c.getSettingsPanel(!0);
            b.isVisible() && b.isTabSelected(a) ? c.showViewer3dOptions(!1) : (c.showViewer3dOptions(!0),
            b.selectTab(a))
        }
        var c = this
          , l = document.createElement("div");
        l.id = "toolbar-settingsToolSubmenu";
        l.classList.add("toolbar-submenu");
        l.classList.add("toolbar-settings-sub-menu");
        l.classList.add("teratek-hidden");
        l.mode = a;
        this.container.appendChild(l);
        if ("3d" === a) {
            a = [];
            for (var n = 0; n < h.LightPresets.length; n++)
                a.push(h.LightPresets[n].name);
            this.viewerOptionButton.envList = this.addOptionList(l, "Background and lighting", a, 4, function(a) {
                c.blockEvent || c.setLightPreset(a)
            }
            , "lightPreset");
            this.selectLightPreset = function(a) {
                c.blockEvent = !0;
                c.viewerOptionButton.envList && (c.viewerOptionButton.envList.selectedIndex = c.impl.currentLightPreset());
                c.blockEvent = !1
            }
            ;
            c.addEventListener(f.RENDER_OPTION_CHANGED_EVENT, this.selectLightPreset);
            this.viewerOptionButton.displayLines = this.addOptionToggle(l, "Display Lines", !0, function(a) {
                c.hideLines(!a)
            }
            , "lineRendering");
            this.addDivider(l)
        }
        a = document.createElement("li");
        a.className = "toolbar-submenu-listitem";
        n = document.createElement("label");
        n.setAttribute("data-i18n", "Performance and appearance settings");
        n.textContent = f.i18n.translate("Performance and appearance settings");
        a.appendChild(n);
        this.show3dOptionsPerformanceTab = function() {
            b(d.ViewerSettingTab.Performance)
        }
        ;
        this.viewerOptionButton.performanceOption = a;
        this.viewerOptionButton.performanceOption.addEventListener("touchstart", touchStartToClick);
        this.viewerOptionButton.performanceOption.addEventListener("click", 
        this.show3dOptionsPerformanceTab);
        l.appendChild(this.viewerOptionButton.performanceOption);
        this.addDivider(l);
        a = document.createElement("li");
        a.className = "toolbar-submenu-listitem";
        n = document.createElement("label");
        n.setAttribute("data-i18n", "Navigation and selection settings");
        n.textContent = f.i18n.translate("Navigation and selection settings");
        a.appendChild(n);
        this.show3dOptionsNavigationTab = function() {
            b(d.ViewerSettingTab.Navigation)
        }
        ;
        this.viewerOptionButton.navigationOption = a;
        this.viewerOptionButton.navigationOption.addEventListener("touchstart", 
        touchStartToClick);
        this.viewerOptionButton.navigationOption.addEventListener("click", this.show3dOptionsNavigationTab);
        l.appendChild(a);
        l.style.width = l.getBoundingClientRect().width + "px";
        this.container.removeChild(l);
        this.viewerOptionButton.onClick = function(a) {
            l.classList.toggle("teratek-hidden");
            this.setState(this.getState() === g.Button.State.ACTIVE ? g.Button.State.INACTIVE : g.Button.State.ACTIVE)
        }
        ;
        this.viewerOptionButton.container.appendChild(l);
        this.viewerOptionButton.subMenu = l
    }
    ;
    c.prototype.removeViewerOptionsMenu = 
    function(a) {
        var b = this.viewerOptionButton;
        b.container.removeChild(b.subMenu);
        "3d" === a && (this.removeEventListener(Teratek.Viewing.RENDER_OPTION_CHANGED_EVENT, this.selectLightPreset),
        b.envList = null );
        b.navigationOption.removeEventListener("touchstart", touchStartToClick);
        b.navigationOption.removeEventListener("click", this.show3dOptionsNavigationTab);
        b.navigationOption = null ;
        b.performanceOption.removeEventListener("touchstart", touchStartToClick);
        b.performanceOption.removeEventListener("click", this.show3dOptionsPerformanceTab);
        b.performanceOption = null 
    }
    ;
    c.prototype.initDebugTools = function() {
        var a = new g.ControlGroup("debugTools");
        this.debugMenu = a;
        var b = new g.Button("toolbar-debugTool");
        b.setIcon("teratek-icon-bug");
        a.addControl(b);
        this.debugMenu.debugSubMenuButton = b;
        this.createDebugSubmenu(this.debugMenu.debugSubMenuButton);
        this.toolbar.addControl(a)
    }
    ;
    c.prototype.createDebugSubmenu = function(a) {
        function b() {
            c.localize()
        }
        var c = this
          , d = document.createElement("div");
        d.id = "toolbar-debugToolSubmenu";
        d.classList.add("toolbar-submenu");
        d.classList.add("toolbar-settings-sub-menu");
        d.classList.add("teratek-hidden");
        this.debugMenu.subMenu = d;
        this.debugMenu.subMenu.style.minWidth = "180px";
        this.container.appendChild(d);
        this.initModelStats();
        this.addDivider(d);
        this.addDivider(d);
        var f = "en zh-Hans zh-Hant ja cs ko pl ru fr de it es pt-br tr".split(" ");
        this.addOptionList(d, "Language", "English;Chinese Simplified;Chinese Traditional;Japanese;Czech;Korean;Polish;Russian;French;German;Italian;Spanish;Portuguese Brazil;Turkish".split(";"), c.selectedLanguage ? 
        c.selectedLanguage : 0, function(a) {
            var d = f[a];
            c.selectedLanguage = a;
            h.setLanguage(d, b)
        }
        , null ).parentNode.style.paddingBottom = "15px";
        this.addDivider(this.debugMenu.subMenu);
        this.addOptionList(d, "Error", "UNKNOWN FAILURE;BAD DATA;NETWORK ERROR;NETWORK ACCESS DENIED;NETWORK FILE NOT FOUND;NETWORK SERVER ERROR;NETWORK UNHANDLED RESPONSE CODE;BROWSER WEBGL NOT SUPPORTED;BAD DATA NO VIEWABLE CONTENT".split(";"), 0, function(a) {
            h.ErrorHandler.reportError(c.container, a + 1, "")
        }
        , null ).parentNode.style.paddingBottom = 
        "15px";
        var g = d.getBoundingClientRect();
        this.debugMenu.subMenu.style.width = g.width + "px";
        this.container.removeChild(d);
        a.container.appendChild(d);
        var g = g.left + g.width
          , q = this.container.getBoundingClientRect().right;
        g > q && (this.debugMenu.subMenu.style.left = -(g - q + 10) + "px");
        a.onMouseOver = function(a) {
            d.classList.remove("teratek-hidden")
        }
        ;
        a.onMouseOut = function(a) {
            d.classList.add("teratek-hidden")
        }
        ;
        isTouchDevice() && (a.onClick = function(a) {
            d.classList.toggle("teratek-hidden")
        }
        )
    }
    ;
    c.prototype.initModelStats = function() {
        function a(a) {
            var b = 
            c.impl
              , d = "";
            c.model && (d += "Geom&nbsp;polys:&nbsp;" + b.modelQueue().getGeometryList().geomPolyCount + "<br>",
            d += "Instance&nbsp;polys:&nbsp;" + b.modelQueue().getGeometryList().instancePolyCount + "<br>",
            d += "Fragments:&nbsp;" + b.modelQueue().getFragmentList().getCount() + "<br>",
            d += "Geoms:&nbsp;" + b.modelQueue().getGeometryList().geoms.length + "<br>",
            d += "Loading&nbsp;time:&nbsp;" + (b.model.loader.loadTime / 1E3).toFixed(2) + " s<br>");
            c.modelStats.innerHTML = d + ("# " + (a || ""))
        }
        function b() {
            c.modelStats = document.createElement("div");
            c.modelStats.className = "statspanel";
            c.container.appendChild(c.modelStats);
            c.addEventListener(f.PROGRESS_UPDATE_EVENT, function(b) {
                b.message && a(b.message)
            }
            );
            c.fpsDisplay = document.createElement("div");
            c.fpsDisplay.className = "fps";
            c.container.appendChild(c.fpsDisplay)
        }
        var c = this;
        this.addOptionToggle(this.debugMenu.subMenu, "Model statistics", !1, function(d) {
            d && !c.modelStats && (b(),
            a(""));
            c.modelStats.style.visibility = d ? "visible" : "hidden";
            c.fpsDisplay.style.visibility = d ? "visible" : "hidden";
            c.impl.fpsCallback = 
            d ? function(a) {
                c.fpsDisplay.textContent = "" + (0 | a)
            }
             : null 
        }
        )
    }
    ;
    c.prototype.initEscapeHandlers = function() {
        var a = this;
        this.addEventListener(f.ESCAPE_EVENT, function(b) {
            if (!a.contextMenu || !a.contextMenu.hide())
                if (a.renderoptions && a.renderoptions.isVisible())
                    a.renderoptions.setVisible(!1);
                else if (a.getActiveNavigationTool() !== a.getDefaultNavigationToolName())
                    a.toolController && a.toolController.setIsLocked(!1),
                    a.setActiveNavigationTool(),
                    h.HudMessage.dismiss();
                else if (a.selectionActive)
                    a.clearSelection();
                else if (!a.areAllVisible())
                    a.showAll();
                else if (!h.AlertBox.dismiss()) {
                    for (b = 0; b < a.dockingPanels.length; ++b) {
                        var c = a.dockingPanels[b];
                        if ("none" !== c.container.style.display && "" !== c.container.style.display) {
                            c.container === a.modelstructure ? a.showModelStructurePanel(!1) : c.setVisible(!1);
                            return
                        }
                    }
                    a.escapeScreenMode()
                }
        }
        )
    }
    ;
    c.prototype.displayViewCube = function(a, b) {
        this.viewCubeUi.displayViewCube(a, b)
    }
    ;
    c.prototype.getToolbar = function(a) {
        !this.toolbar && a && (a = f.UI,
        this.toolbar = new a.ToolBar("guiviewer3d-toolbar"),
        this.navTools = new a.RadioButtonGroup(f.TOOLBAR.NAVTOOLSID),
        this.modelTools = new a.ControlGroup(f.TOOLBAR.MODELTOOLSID),
        this.settingsTools = new a.ControlGroup(f.TOOLBAR.SETTINGSTOOLSID),
        this.toolbar.addControl(this.navTools),
        this.toolbar.addControl(this.modelTools),
        this.toolbar.addControl(this.settingsTools),
        this.container.appendChild(this.toolbar.container));
        return this.toolbar
    }
    ;
    c.prototype.showModelStructurePanel = function(a) {
        this.modelstructure.setVisible(a)
    }
    ;
    c.prototype.onPanelVisible = function(a) {
        this.dockingPanels.splice(this.dockingPanels.indexOf(a), 1);
        this.dockingPanels.splice(0, 0, a)
    }
    ;
    c.prototype.updateFullscreenButton = function(a) {
        var b = "teratek-icon-fullscreen";
        switch (a) {
        case f.ScreenMode.kNormal:
            this.isScreenModeSupported(f.ScreenMode.kFullBrowser) || (b = "teratek-icon-fullscreen");
            break;
        case f.ScreenMode.kFullBrowser:
            b = this.isScreenModeSupported(f.ScreenMode.kFullScreen) ? "teratek-icon-fullscreen" : "teratek-icon-fullscreen-exit";
            break;
        case f.ScreenMode.kFullScreen:
            b = "teratek-icon-fullscreen-exit"
        }
        this.settingsTools.fullscreenbutton.setIcon(b)
    }
    ;
    c.prototype.localize = 
    function() {
        f.i18n.localize();
        if (this.viewerOptionButton && this.viewerOptionButton.subMenu) {
            var a = this.viewerOptionButton.subMenu.mode;
            this.removeViewerOptionsMenu(a);
            this.createViewerOptionsMenu(a)
        }
        this.debugMenu && this.debugMenu.debugSubMenuButton && (this.debugMenu.debugSubMenuButton.container.removeChild(this.debugMenu.subMenu),
        this.createDebugSubmenu(this.debugMenu.debugSubMenuButton));
        h.ErrorHandler.localize()
    }
    ;
    c.prototype.addPanel = function(a) {
        return -1 === this.dockingPanels.indexOf(a) ? (this.dockingPanels.push(a),
        !0) : !1
    }
    ;
    c.prototype.removePanel = function(a) {
        a = this.dockingPanels.indexOf(a);
        return -1 < a ? (this.dockingPanels.splice(a, 1),
        !0) : !1
    }
    ;
    c.prototype.resizePanels = function(a) {
        a = a || {};
        var b = this.toolbar.getDimensions().height
          , c = this.getDimensions()
          , d = c.height;
        a.dimensions && a.dimensions.height ? d = a.dimensions.height : a.dimensions = {
            height: c.height,
            width: c.width
        };
        a.dimensions.height = d - b;
        (c = a ? a.viewer : null ) || (c = this);
        b = a ? a.dockingPanels : null ;
        b || (b = c.dockingPanels);
        var f = c.container.getBoundingClientRect(), c = f.top, 
        d = f.bottom, g = f.left, h = f.right, r;
        a && a.dimensions ? (r = a.dimensions.width,
        d = f = a.dimensions.height) : (r = f.width,
        f = f.height);
        for (a = 0; a < b.length; ++a) {
            var t = b[a].container
              , w = t.getBoundingClientRect()
              , C = w.top
              , C = w.bottom
              , E = w.left
              , E = w.right
              , G = w.width
              , w = w.height;
            if (G && w) {
                r < G && (G = Math.round(r),
                t.style.width = G + "px");
                f < w && (w = Math.round(f),
                t.style.height = w + "px");
                if (h < E || t.dockRight)
                    E = Math.round(h - G - g),
                    t.style.left = E + "px";
                if (d < C || t.dockBottom)
                    C = Math.round(d - w - c),
                    0 > C && (C = 0),
                    t.style.top = C + "px";
                t.style.maxWidth = Math.round(r) + 
                "px";
                t.style.maxHeight = Math.round(f) + "px"
            }
        }
    }
    ;
    c.prototype.initExplodeSlider = function() {
        var a = this
          , b = new g.Button("toolbar-explodeTool");
        b.setIcon("teratek-icon-explode");
        b.setToolTip("Explode model");
        a.modelTools.addControl(b, {
            index: 0
        });
        this.explodeSubmenu = stringToDOM('<div class="explode-submenu" style="display:none"><input class="explode-slider" type="range" min="0" max="1" step="0.01" value="0"/></div>');
        var c;
        c = document.querySelector("#toolbar-explodeTool").parentNode;
        this.explodeSubmenu.classList.add("ios");
        c.appendChild(this.explodeSubmenu);
        var d = this.explodeSubmenu.querySelector(".explode-slider");
        a.explodeSlider = d;
        d.oninput = function(b) {
            a.explode(d.value)
        }
        ;
        d.onchange = function(b) {
            a.explode(d.value)
        }
        ;
        this.explodeSubmenu.onclick = function(a) {
            a.stopPropagation()
        }
        ;
        var f = b.container.querySelector(".teratek-control-tooltip");
        b.onClick = function(c) {
            c = b.getState();
            c === g.Button.State.INACTIVE ? (b.setState(g.Button.State.ACTIVE),
            f.style.display = "none",
            a.explodeSubmenu.style.display = "") : c === g.Button.State.ACTIVE && (b.setState(g.Button.State.INACTIVE),
            f.style.display = "",
            d.parentNode.style.display = "none",
            a.explode(0),
            a.explodeSlider.value = 0)
        }
    }
    ;
    c.prototype.initInspectTools = function() {
        var a = new g.Button("toolbar-inspectTools");
        a.setToolTip("Inspect");
        a.setIcon("measure");
        a.setVisible(!1);
        this.modelTools.addControl(a);
        var b = new g.RadioButtonGroup("toolbar-inspectSubMenu");
        b.addClass("toolbar-vertical-group");
        b.setVisible(!1);
        this.modelTools.addControl(b);
        a.container.insertBefore(b.container, a.container.firstChild);
        a.onMouseOver = function() {
            b.setVisible(!0)
        }
        ;
        a.onMouseOut = function() {
            b.setVisible(!1)
        }
        ;
        isTouchDevice() && (a.onClick = function(a) {
            b.setVisible(!b.isVisible())
        }
        )
    }
    ;
    c.prototype.initModality = function() {
        function a(b) {
            for (var c = 0; 2 > c && b.parentElement; ) {
                var d = b.id;
                if (0 === d.indexOf("toolbar-"))
                    return d.indexOf("arrow") === d.length - 5 ? void 0 : a(b.parentElement) || b;
                b = b.parentElement;
                c++
            }
        }
        var b = {
            orbitTools: {
                explodeTool: 1
            },
            panTool: {
                explodeTool: 1
            },
            zoomTool: {
                explodeTool: 1
            },
            beelineTool: {},
            sectionTool: {},
            measureTool: {},
            explodeTool: {}
        }
          , c = {};
        this.toolbar.container.addEventListener("click", 
        function(d) {
            if (!d.target.classList.contains("clickoff")) {
                var f = a(d.target);
                if (f) {
                    var g = f.id.substring(8, f.id.length);
                    if (b[g] && ("sectionTool" !== g || !d.target.classList.contains("teratek-icon-section-analysis") && !d.target.querySelector(".teratek-icon-section-analysis"))) {
                        if (c[g] && (c[g] = void 0,
                        f.classList.contains("active")))
                            return;
                        for (var h in c)
                            if (d = c[h]) {
                                var r = d.id.substring(8, d.id.length);
                                d.classList.contains("active") ? b[g][r] || d.dispatchEvent(new Event("click")) : c[r] = void 0
                            }
                        c[g] = f
                    }
                }
            }
        }
        , !0)
    }
    ;
    h.GuiViewer3D = 
    c
}
)();
(function() {
    function f(f, d) {
        this._id = f;
        this._isCollapsible = !d || d.collapsible;
        this._toolTipElement = null ;
        this._listeners = {};
        this.container = document.createElement("div");
        this.container.id = f;
        this.addClass("teratek-control")
    }
    var h = Teratek.Viewing;
    f.Event = {
        VISIBILITY_CHANGED: "Control.VisibilityChanged",
        COLLAPSED_CHANGED: "Control.CollapsedChanged"
    };
    h.EventDispatcher.prototype.apply(f.prototype);
    f.prototype.constructor = f;
    f.prototype.container = null ;
    f.prototype.getId = function() {
        return this._id
    }
    ;
    f.prototype.setVisible = function(g) {
        if (!this.container.classList.contains("teratek-hidden") === 
        g)
            return !1;
        g ? this.container.classList.remove("teratek-hidden") : this.container.classList.add("teratek-hidden");
        this.fireEvent({
            type: f.Event.VISIBILITY_CHANGED,
            target: this,
            controlId: this._id,
            isVisible: g
        });
        return !0
    }
    ;
    f.prototype.isVisible = function() {
        return !this.container.classList.contains("teratek-hidden")
    }
    ;
    f.prototype.setToolTip = function(f) {
        if (this._toolTipElement && this._toolTipElement.getAttribute("tooltipText") === f)
            return !1;
        this._toolTipElement || (this._toolTipElement = document.createElement("div"),
        this._toolTipElement.id = 
        this._id + "-tooltip",
        this._toolTipElement.classList.add("teratek-control-tooltip"),
        this.container.appendChild(this._toolTipElement));
        this._toolTipElement.setAttribute("data-i18n", f);
        this._toolTipElement.setAttribute("tooltipText", f);
        this._toolTipElement.textContent = Teratek.Viewing.i18n.translate(f, {
            defaultValue: f
        });
        return !0
    }
    ;
    f.prototype.getToolTip = function() {
        return this._toolTipElement && this._toolTipElement.getAttribute("tooltipText")
    }
    ;
    f.prototype.setCollapsed = function(g) {
        if (!this._isCollapsible || this.isCollapsed() === 
        g)
            return !1;
        g ? this.container.classList.add("collapsed") : this.container.classList.remove("collapsed");
        this.fireEvent({
            type: f.Event.COLLAPSED_CHANGED,
            isCollapsed: g
        });
        return !0
    }
    ;
    f.prototype.isCollapsed = function() {
        return !!this.container.classList.contains("collapsed")
    }
    ;
    f.prototype.isCollapsible = function() {
        return this._isCollapsible
    }
    ;
    f.prototype.addClass = function(f) {
        this.container.classList.add(f)
    }
    ;
    f.prototype.removeClass = function(f) {
        this.container.classList.remove(f)
    }
    ;
    f.prototype.getPosition = function() {
        var f = 
        this.container.getBoundingClientRect();
        return {
            top: f.top,
            left: f.left
        }
    }
    ;
    f.prototype.getDimensions = function() {
        var f = this.container.getBoundingClientRect();
        return {
            width: f.width,
            height: f.height
        }
    }
    ;
    Teratek.Viewing.UI.Control = f
}
)();
(function() {
    function f(g, d) {
        h.Control.call(this, g, d);
        var c = this;
        this._controls = [];
        this.addClass("teratek-control-group");
        this.handleChildSizeChanged = function(a) {
            c.fireEvent({
                type: f.Event.SIZE_CHANGED,
                childEvent: a
            })
        }
    }
    var h = Teratek.Viewing.UI;
    f.Event = {
        VISIBILITY_CHANGED: h.Control.Event.VISIBILITY_CHANGED,
        COLLAPSED_CHANGED: h.Control.Event.COLLAPSED_CHANGED,
        SIZE_CHANGED: "ControlGroup.SizeChanged",
        CONTROL_ADDED: "ControlGroup.ControlAdded",
        CONTROL_REMOVED: "ControlGroup.ControlRemoved"
    };
    f.prototype = Object.create(h.Control.prototype);
    f.prototype.constructor = f;
    f.prototype.addControl = function(g, d) {
        var c = d && void 0 !== d.index ? d.index : this._controls.length;
        if (null  !== this.getControl(g.getId()))
            return !1;
        var a = {
            type: f.Event.CONTROL_ADDED,
            control: g,
            index: c
        };
        c < this._controls.length ? (this.container.insertBefore(g.container, this._controls[c].container),
        this._controls.splice(c, 0, g)) : (this.container.appendChild(g.container),
        this._controls.push(g));
        g.addEventListener(h.Control.Event.VISIBILITY_CHANGED, this.handleChildSizeChanged);
        g.addEventListener(h.Control.Event.COLLAPSED_CHANGED, 
        this.handleChildSizeChanged);
        g instanceof f && g.addEventListener(f.Event.SIZE_CHANGED, this.handleChildSizeChanged);
        this.fireEvent(a);
        this.fireEvent(f.Event.SIZE_CHANGED);
        return !0
    }
    ;
    f.prototype.indexOf = function(f) {
        for (var d = 0; d < this._controls.length; d++) {
            var c = this._controls[d];
            if (c === f || "string" === typeof f && f === c.getId())
                return d
        }
        return -1
    }
    ;
    f.prototype.removeControl = function(g) {
        g = "string" === typeof g ? this.getControl(g) : g;
        if (!g)
            return !1;
        var d = this._controls.indexOf(g);
        this._controls.splice(d, 1);
        this.container.removeChild(g.container);
        d = {
            type: f.Event.CONTROL_REMOVED,
            control: g,
            index: d
        };
        g.removeEventListener(h.Control.Event.VISIBILITY_CHANGED, this.handleChildSizeChanged);
        g.removeEventListener(h.Control.Event.COLLAPSED_CHANGED, this.handleChildSizeChanged);
        g instanceof f && g.removeEventListener(f.Event.SIZE_CHANGED, this.handleChildSizeChanged);
        this.fireEvent(d);
        this.fireEvent(f.Event.SIZE_CHANGED);
        return !0
    }
    ;
    f.prototype.getControl = function(f) {
        for (var d = 0; d < this._controls.length; d++)
            if (f === this._controls[d].getId())
                return this._controls[d];
        return null 
    }
    ;
    f.prototype.getNumberOfControls = function() {
        return this._controls.length
    }
    ;
    f.prototype.setCollapsed = function(g) {
        if (!this._isCollapsible)
            return !1;
        var d = !1;
        this._controls.forEach(function(c) {
            c.isCollapsible() && c.setCollapsed(g) && (d = !0)
        }
        );
        d && (g ? this.container.classList.add("collapsed") : this.container.classList.remove("collapsed"),
        this.fireEvent({
            type: f.Event.COLLAPSED_CHANGED,
            isCollapsed: g
        }));
        return d
    }
    ;
    Teratek.Viewing.UI.ControlGroup = f
}
)();
(function() {
    function f(f, d) {
        h.ControlGroup.call(this, f, d);
        this.removeClass("teratek-control-group");
        this.addClass("teratek-toolbar")
    }
    var h = Teratek.Viewing.UI;
    f.Event = {
        VISIBILITY_CHANGED: h.Control.Event.VISIBILITY_CHANGED,
        COLLAPSED_CHANGED: h.Control.Event.COLLAPSED_CHANGED,
        CONTROL_ADDED: h.ControlGroup.Event.CONTROL_ADDED,
        CONTROL_REMOVED: h.ControlGroup.Event.CONTROL_REMOVED,
        SIZE_CHANGED: h.ControlGroup.Event.SIZE_CHANGED
    };
    f.prototype = Object.create(h.ControlGroup.prototype);
    f.prototype.constructor = f;
    Teratek.Viewing.UI.ToolBar = 
    f
}
)();
(function() {
    function f(g, d) {
        h.Control.call(this, g, d);
        var c = this;
        this._state = f.State.INACTIVE;
        this.icon = document.createElement("div");
        this.icon.classList.add("teratek-button-icon");
        this.container.appendChild(this.icon);
        this.container.addEventListener("click", function(a) {
            c.fireEvent(f.Event.CLICK);
            if (c.onClick)
                c.onClick(a);
            a.stopPropagation()
        }
        );
        isTouchDevice() ? this.container.addEventListener("touchstart", touchStartToClick) : (this.container.addEventListener("mouseover", function(a) {
            c.onMouseOver(a)
        }
        ),
        this.container.addEventListener("mouseout", 
        function(a) {
            c.onMouseOut(a)
        }
        ));
        this.addClass("teratek-button");
        this.addClass(f.StateToClassMap[this._state])
    }
    var h = Teratek.Viewing.UI;
    f.Event = {
        VISIBILITY_CHANGED: h.Control.Event.VISIBILITY_CHANGED,
        COLLAPSED_CHANGED: h.Control.Event.COLLAPSED_CHANGED,
        STATE_CHANGED: "Button.StateChanged",
        CLICK: "click"
    };
    f.State = {
        ACTIVE: 0,
        INACTIVE: 1,
        DISABLED: 2
    };
    f.StateToClassMap = function() {
        var g = f.State
          , d = {};
        d[g.ACTIVE] = "active";
        d[g.INACTIVE] = "inactive";
        d[g.DISABLED] = "disabled";
        return d
    }
    ();
    f.prototype = Object.create(h.Control.prototype);
    f.prototype.constructor = f;
    f.prototype.setState = function(g) {
        if (g === this._state)
            return !1;
        this.removeClass(f.StateToClassMap[this._state]);
        this.addClass(f.StateToClassMap[g]);
        this._state = g;
        this.fireEvent({
            type: f.Event.STATE_CHANGED,
            state: g
        });
        return !0
    }
    ;
    f.prototype.setIcon = function(f) {
        this.iconClass && this.icon.classList.remove(this.iconClass);
        this.iconClass = f;
        this.icon.classList.add(f)
    }
    ;
    f.prototype.getState = function() {
        return this._state
    }
    ;
    f.prototype.onClick = function(f) {}
    ;
    f.prototype.onMouseOver = function(f) {}
    ;
    f.prototype.onMouseOut = function(f) {}
    ;
    Teratek.Viewing.UI.Button = f
}
)();
(function() {
    function f(f, d) {
        h.Button.call(this, f, d);
        this.arrowButton = new h.Button(f + "arrow");
        this.arrowButton.addClass("teratek-button-arrow");
        this.arrowButton.removeClass("teratek-button");
        this.subMenu = new h.RadioButtonGroup(f + "SubMenu");
        this.subMenu.addClass("toolbar-vertical-group");
        this.subMenu.setVisible(!1);
        this.container.insertBefore(this.subMenu.container, this.container.firstChild);
        this.container.insertBefore(this.arrowButton.container, this.container.firstChild);
        var c = this;
        this.arrowButton.onClick = 
        function(a) {
            c.subMenu.setVisible(!c.subMenu.isVisible())
        }
        ;
        this.toggleFlyoutVisible = function() {
            c.subMenu.setVisible(!c.subMenu.isVisible())
        }
        ;
        this.onClick = function(a) {
            c.subMenu.setVisible(!c.subMenu.isVisible())
        }
        ;
        this.subMenuActiveButtonChangedHandler = function(a) {
            a.isActiveButton ? (c.setIcon(a.target.getActiveButton().iconClass),
            c.setToolTip(a.target.getActiveButton().getToolTip()),
            c.setState(h.Button.State.ACTIVE),
            c.onClick = a.button.onClick) : c.setState(h.Button.State.INACTIVE)
        }
        ;
        this.subMenu.addEventListener(h.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED, 
        this.subMenuActiveButtonChangedHandler);
        var a = stringToDOM('<div class="clickoff" style="position:fixed; top:0; left:0; width:100vw; height:100vh;"></div>');
        this.subMenu.container.insertBefore(a, this.subMenu.container.firstChild);
        a.addEventListener("click", function(a) {
            c.subMenu.setVisible(!1);
            a.stopPropagation()
        }
        )
    }
    var h = Teratek.Viewing.UI;
    f.prototype = Object.create(h.Button.prototype);
    f.prototype.constructor = f;
    f.prototype.addControl = function(f) {
        this.subMenu.addControl(f);
        f.addEventListener(h.Button.Event.CLICK, 
        this.toggleFlyoutVisible)
    }
    ;
    f.prototype.removeControl = function(f) {
        f.removeEventListener(h.Button.Event.CLICK, this.toggleFlyoutVisible)
    }
    ;
    f.prototype.setState = function(f) {
        if (f === h.Button.State.INACTIVE) {
            var d = this.subMenu.getActiveButton();
            d && d.setState(h.Button.State.INACTIVE)
        }
        h.Button.prototype.setState.call(this, f)
    }
    ;
    f.prototype.saveAsDefault = function() {
        this.defaultState = {};
        this._toolTipElement && this._toolTipElement.getAttribute("tooltipText") && (this.defaultState.tooltip = this._toolTipElement.getAttribute("tooltipText"));
        this.defaultState.icon = this.iconClass;
        this.defaultState.onClick = this.onClick
    }
    ;
    f.prototype.restoreDefault = function() {
        this.defaultState && (this.defaultState.tooltip && this.setToolTip(this.defaultState.tooltip),
        this.defaultState.icon && this.setIcon(this.defaultState.icon),
        this.onClick = this.defaultState.onClick,
        this.setState(h.Button.State.INACTIVE))
    }
    ;
    Teratek.Viewing.UI.ComboButton = f
}
)();
(function() {
    function f(g, d) {
        h.ControlGroup.call(this, g, d);
        var c = this;
        this._activeButton = null ;
        this._handleButtonStateChange = function(a) {
            var b = h.Button.State;
            a.state !== b.ACTIVE ? a.target === c._activeButton && (c._activeButton = null ,
            c.fireEvent({
                type: f.Event.ACTIVE_BUTTON_CHANGED,
                button: a.target,
                isActiveButton: !1
            })) : (c._activeButton = a.target,
            c.fireEvent({
                type: f.Event.ACTIVE_BUTTON_CHANGED,
                button: a.target,
                isActiveButton: !0
            }),
            c._controls.forEach(function(c) {
                c !== a.target && c.getState() !== b.DISABLED && c.setState(b.INACTIVE)
            }
            ))
        }
    }
    var h = Teratek.Viewing.UI;
    f.Event = {
        ACTIVE_BUTTON_CHANGED: "RadioButtonGroup.ActiveButtonChanged",
        VISIBILITY_CHANGED: h.Control.Event.VISIBILITY_CHANGED,
        COLLAPSED_CHANGED: h.Control.Event.COLLAPSED_CHANGED,
        CONTROL_ADDED: h.ControlGroup.Event.CONTROL_ADDED,
        CONTROL_REMOVED: h.ControlGroup.Event.CONTROL_REMOVED,
        SIZE_CHANGED: h.ControlGroup.Event.SIZE_CHANGED
    };
    f.prototype = Object.create(h.ControlGroup.prototype);
    f.prototype.constructor = f;
    f.prototype.addControl = function(f, d) {
        return f instanceof h.Button ? h.ControlGroup.prototype.addControl.call(this, 
        f, d) ? (f.addEventListener(h.Button.Event.STATE_CHANGED, this._handleButtonStateChange),
        !0) : !1 : !1
    }
    ;
    f.prototype.removeControl = function(f) {
        f = "string" == typeof f ? this.getControl(f) : f;
        return null  !== f && h.ControlGroup.prototype.removeControl.call(this, f) ? (f.removeEventListener(h.Button.Event.STATE_CHANGED, this._handleButtonStateChange),
        !0) : !1
    }
    ;
    f.prototype.getActiveButton = function() {
        return this._activeButton
    }
    ;
    Teratek.Viewing.UI.RadioButtonGroup = f
}
)();
TeratekNamespace("Teratek.Viewing");
function MobileCallbacks() {
    this.ios = window.webkit;
    this.android = window.JSINTERFACE;
    this.iosSend = function(f, h) {
        window.webkit.messageHandlers.callbackHandler.postMessage({
            command: f,
            data: h
        })
    }
    ;
    this.androidSend = window.JSINTERFACE
}
var proto = MobileCallbacks.prototype;
proto.animationReady = function() {
    this.ios ? this.iosSend("animationReady") : this.android && this.androidSend.animationReady()
}
;
proto.onSelectionChanged = function(f) {
    if (this.ios)
        this.iosSend("selectionChanged", f);
    else if (this.android)
        this.androidSend.onSelectionChanged(f)
}
;
proto.onLongTap = function(f, h) {
    if (this.ios)
        this.iosSend("onLongTap", [f, h]);
    else if (this.android)
        this.androidSend.onLongTap(f, h)
}
;
proto.onSingleTap = function(f, h) {
    if (this.ios)
        this.iosSend("onSingleTap", [f, h]);
    else if (this.android)
        this.androidSend.onSingleTap(f, h)
}
;
proto.onDoubleTap = function(f, h) {
    if (this.ios)
        this.iosSend("onDoubleTap", [f, h]);
    else if (this.android)
        this.androidSend.onDoubleTap(f, h)
}
;
proto.setRTCSession = function(f) {
    this.ios ? this.iosSend("setRTCSession", {
        id: f
    }) : this.android && this.androidSend.setRTCSessionID(f)
}
;
proto.putProperties = function(f, h) {
    this.ios ? this.iosSend("putProperties", {
        name: f,
        value: h
    }) : this.android && this.androidSend.putProperties(f, h)
}
;
proto.onPropertyRetrievedSuccess = function() {
    if (this.ios)
        this.iosSend("onPropertyRetrievedSuccess");
    else if (this.android)
        this.androidSend.onPropertyRetrievedSuccess()
}
;
proto.onPropertyRetrievedFailOrEmptyProperties = function() {
    if (this.ios)
        this.iosSend("onPropertyRetrievedFailOrEmptyProperties");
    else if (this.android)
        this.androidSend.onPropertyRetrievedFailOrEmptyProperties()
}
;
proto.resetAnimationStatus = function() {
    this.ios ? this.iosSend("resetAnimationStatus") : this.android && this.androidSend.resetAnimationStatus()
}
;
proto.updateAnimationTime = function(f) {
    this.ios ? this.iosSend("updateAnimationTime", f) : this.android && this.androidSend.updateAnimationTime(f)
}
;
proto.setLoadingProgress = function(f) {
    this.ios ? this.iosSend("setLoadingProgress", f) : this.android && this.androidSend.setLoadingProgress(f)
}
;
proto.objectTreeCreated = function() {
    this.ios ? this.iosSend("objectTreeCreated") : this.android && this.androidSend.objectTreeCreated()
}
;
proto.geometryLoaded = function() {
    this.ios ? this.iosSend("geometryLoaded") : this.android && this.androidSend.geometryLoaded()
}
;
proto.putSheets = function(f, h) {
    this.ios ? this.iosSend("putSheets", [f, h]) : this.android && this.androidSend.putSheets(f, h)
}
;
proto.hideLoadingView = function() {
    this.android && this.androidSend.hideLoadingView()
}
;
Teratek.Viewing.Extensions.ViewerPanelMixin = function() {
    this.getContainerBoundingRect = function() {
        var f = this.parentContainer.getBoundingClientRect()
          , h = {
            height: 0,
            width: 0,
            left: 0,
            bottom: 0,
            right: 0,
            top: 0
        }
          , g = document.getElementsByClassName("toolbar-menu");
        g && 0 < g.length && (h = g[0].getBoundingClientRect());
        return {
            height: f.height - h.height,
            width: f.width,
            left: f.left,
            bottom: f.bottom - h.height,
            right: f.right,
            top: f.top
        }
    }
}
;
(function() {
    var f = Teratek.Viewing
      , h = Teratek.Viewing.UI
      , g = Teratek.Viewing.Extensions
      , d = {
        click: {
            onObject: ["isolate"]
        },
        clickCtrl: {
            onObject: ["toggleVisibility"]
        }
    };
    g.ViewerModelStructurePanel = function(c, a, b) {
        this.viewer = c;
        b = b || {};
        b.heightAdjustment = 75;
        h.ModelStructurePanel.call(this, c.container, c.container.id + "ViewerModelStructurePanel", a, b);
        this.clickConfig = b && b.docStructureConfig ? b.docStructureConfig : d;
        this.isMac = -1 !== navigator.userAgent.search("Mac OS");
        this.initSearchBox();
        this.prevSearchResults = 
        [];
        this.prevSearchString = ""
    }
    ;
    g.ViewerModelStructurePanel.prototype = Object.create(h.ModelStructurePanel.prototype);
    g.ViewerModelStructurePanel.prototype.constructor = g.ViewerModelStructurePanel;
    g.ViewerPanelMixin.call(g.ViewerModelStructurePanel.prototype);
    g.ViewerModelStructurePanel.prototype.initialize = function() {
        h.ModelStructurePanel.prototype.initialize.call(this);
        var c = this;
        c.addEventListener(c.viewer, f.SELECTION_CHANGED_EVENT, function(a) {
            c.setSelection(a.nodeArray.slice())
        }
        );
        c.addEventListener(c.viewer, 
        f.ISOLATE_EVENT, function(a) {
            c.setIsolation(a.nodeIdArray.slice())
        }
        );
        c.addEventListener(c.viewer, f.HIDE_EVENT, function(a) {
            c.setHidden(a.nodeIdArray.slice(), !0)
        }
        );
        c.addEventListener(c.viewer, f.SHOW_EVENT, function(a) {
            c.setHidden(a.nodeIdArray.slice(), !1)
        }
        )
    }
    ;
    g.ViewerModelStructurePanel.prototype.uninitialize = function() {
        this.viewer = null ;
        h.ModelStructurePanel.prototype.uninitialize.call(this)
    }
    ;
    g.ViewerModelStructurePanel.prototype.handleAction = function(c, a) {
        for (var b in c)
            switch (c[b]) {
            case "selectOnly":
                this.viewer.select(a);
                break;
            case "deselectAll":
                this.viewer.select([]);
                break;
            case "selectToggle":
                this.viewer.toggleSelect(a);
                break;
            case "isolate":
                this.viewer.isolate(a);
                break;
            case "showAll":
                this.viewer.isolate(null );
                break;
            case "focus":
                this.viewer.fitToView();
                break;
            case "hide":
                this.viewer.hide(a);
                break;
            case "show":
                this.viewer.show(a);
                break;
            case "toggleVisibility":
                this.viewer.toggleVisibility(a)
            }
    }
    ;
    g.ViewerModelStructurePanel.prototype.ctrlDown = function(c) {
        return this.isMac && c.metaKey || !this.isMac && c.ctrlKey
    }
    ;
    g.ViewerModelStructurePanel.prototype.onClick = 
    function(c, a) {
        if (!this.isMac || !a.ctrlKey) {
            var b = "click";
            this.ctrlDown(a) && (b += "Ctrl");
            a.shiftKey && (b += "Shift");
            a.altKey && (b += "Alt");
            this.clickConfig && this.clickConfig[b] ? this.handleAction(this.clickConfig[b].onObject, c) : this.viewer.select(c)
        }
    }
    ;
    g.ViewerModelStructurePanel.prototype.onDoubleClick = function(c, a) {
        this.handleAction(["focus"], c)
    }
    ;
    g.ViewerModelStructurePanel.prototype.onRightClick = function(c, a) {
        if (this.isMac && a.ctrlKey && 0 === a.button)
            return this.clickConfig && this.clickConfig.clickCtrl ? this.handleAction(this.clickConfig.clickCtrl.onObject, 
            c) : this.viewer.select(c),
            null ;
        var b = []
          , d = !0;
        if (a.shiftKey || this.isMac && a.metaKey || a.ctrlKey && (this.isMac || 2 === a.button))
            for (var f = this.viewer.impl.selector.getSelection(), g = 0; g < f.length; ++g)
                f[g] !== c ? b.push(f[g]) : d = !1;
        d && b.push(c);
        this.viewer.select(b);
        return this.viewer.contextMenu.show(a)
    }
    ;
    g.ViewerModelStructurePanel.prototype.setHidden = function(c, a) {
        this.uiCreated || this.createUI();
        for (var b = 0; b < c.length; ++b)
            this.tree.iterate(c[b], function(b, c) {
                c.classList.toggle("dim", a);
                c.classList.toggle("visible", 
                !a)
            }
            )
    }
    ;
    g.ViewerModelStructurePanel.prototype.setIsolation = function(c) {
        if (this.rootId) {
            this.tree && this.tree.iterate(this.rootId, function(a, b) {
                b.classList.remove("dim");
                b.classList.remove("visible")
            }
            );
            if (0 < c.length) {
                if (1 === c.length && c[0] === this.rootId)
                    return;
                this.setHidden([this.rootId], !0);
                this.setHidden(c, !1)
            }
            this.searchbox && !this.inSearchIsolate && (this.searchbox.value = "")
        }
    }
    ;
    g.ViewerModelStructurePanel.prototype.initSearchBox = function() {
        function c() {
            if (!d.isSearching) {
                for (var c = 0; c < d.prevSearchResults.length; c++)
                    d.tree.setCollapsed(d.prevSearchResults[c], 
                    !0, !0);
                0 === a.value.length ? (d.isSearching = !1,
                d.prevSearchString = "",
                b.isolate()) : d.prevSearchString != a.value && (d.isSearching = !0,
                b.search(a.value, function(a) {
                    d.inSearchIsolate = !0;
                    b.isolate(a);
                    d.inSearchIsolate = !1;
                    if (a.length) {
                        for (var c = 0; c < a.length; c++)
                            d.tree.setCollapsed(a[c], !1, !0);
                        d.resizeToContent();
                        d.tree.scrollTo(a[0])
                    }
                    d.prevSearchResults = a;
                    d.isSearching = !1
                }
                , null , ["name"]))
            }
        }
        var a = document.createElement("input");
        a.className = "toolbar-search-box";
        a.type = "search";
        a.results = 5;
        a.placeholder = f.i18n.translate("Filter by name");
        a.incremental = "incremental";
        a.autosave = this.container.id + "search_autosave";
        a.setAttribute("data-i18n", "[placeholder]Filter by name");
        this.scrollContainer.parentNode.insertBefore(a, this.scrollContainer);
        this.searchbox = a;
        var b = this.viewer, d = this, g;
        a.addEventListener("input", function(a) {
            clearTimeout(g);
            g = setTimeout(c, 500)
        }
        );
        a.addEventListener("change", function(a) {
            clearTimeout(g);
            c()
        }
        )
    }
}
)();
(function() {
    var f = Teratek.Viewing
      , h = f.UI
      , g = function(d) {
        this.viewer = d;
        this.currentNodeIds = [];
        this.currentModel = null ;
        this.isSelection = !1;
        this.isDirty = !0;
        this.propertyNodeId = null ;
        h.PropertyPanel.call(this, d.container, "ViewerPropertyPanel", "Object Properties Loading...")
    }
    ;
    g.prototype = Object.create(h.PropertyPanel.prototype);
    g.prototype.constructor = g;
    f.Extensions.ViewerPanelMixin.call(g.prototype);
    g.prototype.initialize = function() {
        h.PropertyPanel.prototype.initialize.call(this);
        var d = this;
        d.addEventListener(d.viewer, 
        f.SELECTION_CHANGED_EVENT, function(c) {
            d.currentNodeIds = c.dbIdArray;
            d.currentModel = c.model;
            d.isSelection = 0 < c.dbIdArray.length;
            d.isDirty = !0;
            d.requestProperties()
        }
        );
        d.addEventListener(d.viewer, f.ISOLATE_EVENT, function(c) {
            0 == c.nodeIdArray.length && d.isSelection || (d.currentModel = c.model,
            d.currentNodeIds = c.nodeIdArray,
            d.isDirty = !0,
            d.requestProperties())
        }
        );
        d.addEventListener(d.viewer, f.HIDE_EVENT, function(c) {
            d.isDirty = !0;
            d.requestProperties()
        }
        );
        d.addEventListener(d.viewer, f.SHOW_EVENT, function(c) {
            d.isDirty = 
            !0;
            d.requestProperties()
        }
        );
        this.currentModel = d.viewer.model;
        this.currentNodeIds = d.viewer.getSelection();
        0 === this.currentNodeIds.length ? this.currentNodeIds = d.viewer.getIsolatedNodes() : this.isSelection = !0
    }
    ;
    g.prototype.setTitle = function(d, c) {
        d || (d = "Object Properties",
        c = c || {},
        c.localizeTitle = !0);
        h.PropertyPanel.prototype.setTitle.call(this, d, c)
    }
    ;
    g.prototype.setVisible = function(d) {
        h.DockingPanel.prototype.setVisible.call(this, d);
        this.requestProperties()
    }
    ;
    g.prototype.visibilityChanged = function() {
        h.DockingPanel.prototype.visibilityChanged.call(this);
        this.isVisible() && this.requestProperties()
    }
    ;
    g.prototype.requestProperties = function() {
        this.isVisible() && this.isDirty && (0 < this.currentNodeIds.length ? this.setNodeProperties(this.currentNodeIds[this.currentNodeIds.length - 1]) : this.showDefaultProperties(),
        this.isDirty = !1)
    }
    ;
    g.prototype.setNodeProperties = function(d) {
        var c = this;
        this.propertyNodeId = d;
        c.currentModel.getProperties(d, function(a) {
            c.setTitle(a.name);
            c.setProperties(a.properties);
            c.highlight(c.viewer.searchText);
            c.resizeToContent();
            if (c.isVisible()) {
                var b = 
                c.viewer.toolController;
                a = b.lastClickX;
                var b = b.lastClickY
                  , d = c.container.getBoundingClientRect()
                  , f = d.left
                  , g = d.top
                  , h = d.width
                  , d = d.height
                  , q = c.viewer.canvas.getBoundingClientRect()
                  , r = q.left
                  , t = q.top
                  , w = q.width
                  , q = q.height;
                f <= a && a < f + h && g <= b && b < g + d && (a < f + h / 2 && a + h < r + w ? (c.container.style.left = Math.round(a - r) + "px",
                c.container.dockRight = !1) : r <= a - h ? (c.container.style.left = Math.round(a - r - h) + "px",
                c.container.dockRight = !1) : a + h < r + w ? (c.container.style.left = Math.round(a - r) + "px",
                c.container.dockRight = !1) : b + d < t + q ? (c.container.style.top = 
                Math.round(b - t) + "px",
                c.container.dockBottom = !1) : t <= b - d && (c.container.style.top = Math.round(b - t - d) + "px",
                c.container.dockBottom = !1))
            }
        }
        )
    }
    ;
    g.prototype.showDefaultProperties = function() {
        var d = this.viewer.model.getRootId();
        d ? this.setNodeProperties(d) : (this.propertyNodeId = null ,
        this.setTitle("Model Properties", {
            localizeTitle: !0
        }),
        h.PropertyPanel.prototype.showDefaultProperties.call(this))
    }
    ;
    g.prototype.areDefaultPropertiesShown = function() {
        var d = this.viewer.model.getRootId();
        return this.propertyNodeId === d
    }
    ;
    g.prototype.uninitialize = 
    function() {
        h.PropertyPanel.prototype.uninitialize.call(this);
        this.viewer = null 
    }
    ;
    g.prototype.onCategoryClick = function(d, c) {
        h.PropertyPanel.prototype.onCategoryClick.call(this, d, c);
        this.resizeToContent()
    }
    ;
    g.prototype.onCategoryIconClick = function(d, c) {
        h.PropertyPanel.prototype.onCategoryIconClick.call(this, d, c);
        this.resizeToContent()
    }
    ;
    Teratek.Viewing.Extensions.ViewerPropertyPanel = g
}
)();
(function() {
    var f = function(f) {
        var g = f.container;
        Teratek.Viewing.UI.LayersPanel.call(this, f, g, g.id + "ViewerLayersPanel")
    }
    ;
    f.prototype = Object.create(Teratek.Viewing.UI.LayersPanel.prototype);
    f.prototype.constructor = f;
    Teratek.Viewing.Extensions.ViewerPanelMixin.call(f.prototype);
    f.prototype.onClick = function(f, g) {
        this.isMac && g.ctrlKey || this.setLayerVisible(f, !(g.shiftKey || g.metaKey || g.ctrlKey))
    }
    ;
    f.prototype.onRightClick = function(f, g) {
        this.setLayerVisible(f, !(g.shiftKey || g.metaKey || g.ctrlKey))
    }
    ;
    f.prototype.onImageClick = 
    function(f, g) {
        this.isMac && g.ctrlKey || this.setLayerVisible(f)
    }
    ;
    f.prototype.onTitleClick = function(f) {
        this.viewer.setLayerVisible(null , !0)
    }
    ;
    f.prototype.onTitleDoubleClick = function(f) {
        this.viewer.fitToView()
    }
    ;
    Teratek.Viewing.Extensions.ViewerLayersPanel = f
}
)();
(function() {
    var f = Teratek.Viewing.Extensions
      , h = Teratek.Viewing.UI;
    f.ViewerSettingTab = {
        Navigation: "navigationtab",
        Performance: "performancetab"
    };
    var g = function(d, c) {
        this.viewer = d;
        this.is3dMode = "3d" === c;
        h.SettingsPanel.call(this, d.container, "ViewerSettingsPanel", "Settings", {
            width: 360,
            heightAdjustment: 155
        });
        this.addTab("navigationtab", "Navigation and selection", {
            className: "navigation"
        });
        this.addTab("performancetab", "Performance and appearance", {
            className: "performance"
        });
        this.restoreDiv = document.createElement("div");
        this.restoreDiv.className = "viewer-restore-defaults";
        this.restoreDiv.setAttribute("data-i18n", "Restore default settings");
        this.restoreDiv.textContent = Teratek.Viewing.i18n.translate("Restore default settings");
        this.addEventListener(this.restoreDiv, "touchstart", touchStartToClick);
        this.addEventListener(this.restoreDiv, "click", function() {
            var a = d.model.is2d() ? "2d" : "3d";
            d.prefs.reset(a)
        }
        , !1);
        this.container.appendChild(this.restoreDiv);
        this.createNavigationPanel();
        this.createPerformancePanel()
    }
    ;
    g.prototype = 
    Object.create(h.SettingsPanel.prototype);
    g.prototype.constructor = g;
    f.ViewerPanelMixin.call(g.prototype);
    g.prototype.uninitialize = function() {
        this.viewer = null ;
        h.SettingsPanel.prototype.uninitialize.call(this)
    }
    ;
    g.prototype.addCheckbox = function(d, c, a, b, f) {
        var g = this.viewer
          , n = g.prefs[f];
        d = h.SettingsPanel.prototype.addCheckbox.call(this, d, c, "boolean" === typeof n ? n : a, function(a) {
            g.prefs.set(f, a);
            b(a)
        }
        );
        var m = this.getControl(d);
        m.saveKey = f;
        g.prefs.addListeners(f, function(a) {
            m.setValue(a)
        }
        , function(a) {
            m.setValue(a);
            b(a)
        }
        );
        return m
    }
    ;
    g.prototype.removeCheckbox = function(d) {
        this.viewer.prefs.removeListeners(d.saveKey);
        this.removeEventListener(d, "change", d.changeListener);
        return h.SettingsPanel.prototype.removeCheckbox.call(this, d)
    }
    ;
    g.prototype.createNavigationPanel = function() {
        var d = this.viewer
          , c = f.ViewerSettingTab.Navigation;
        this.is3dMode && (this.addCheckbox(c, "Show ViewCube", !0, function(a) {
            d.displayViewCube(a)
        }
        , "viewCube"),
        this.addCheckbox(c, "ViewCube acts on pivot", !1, function(a) {
            d.setUsePivotAlways(a)
        }
        , "alwaysUsePivot"),
        this.addCheckbox(c, "Zoom towards pivot", !1, function(a) {
            d.setZoomTowardsPivot(a)
        }
        , "zoomTowardsPivot"),
        this.addCheckbox(c, "Set pivot with left mouse button", !1, function(a) {
            d.setClickToSetCOI(a)
        }
        , "clickToSetCOI"),
        this.addCheckbox(c, "Fusion style orbit", !1, function(a) {
            a ? d.loadExtension("Teratek.Viewing.FusionOrbit", null ) : d.unloadExtension("Teratek.Viewing.FusionOrbit", null )
        }
        , "fusionOrbit"),
        this.addCheckbox(c, "First person walk", !1, function(a) {
            a ? (d.unloadExtension("Teratek.Beeline", null ),
            d.loadExtension("Teratek.FirstPerson", 
            null )) : (d.unloadExtension("Teratek.FirstPerson", null ),
            d.loadExtension("Teratek.Beeline", null ))
        }
        , "useFirstPersonNav"));
        this.addCheckbox(c, "Reverse mouse zoom direction", !1, function(a) {
            d.setReverseZoomDirection(a)
        }
        , "reverseMouseZoomDir");
        this.is3dMode && this.addCheckbox(c, "Orbit past world poles", !0, function(a) {
            d.setOrbitPastWorldPoles(a)
        }
        , "orbitPastWorldPoles");
        this.addCheckbox(c, "Open properties on select", !0, function(a) {
            d.setPropertiesOnSelect(a)
        }
        , "openPropertiesOnSelect");
        this.addCheckbox(c, "Left handed mouse setup", 
        !1, function(a) {
            d.setUseLeftHandedInput(a)
        }
        , "leftHandedMouseSetup")
    }
    ;
    g.prototype.createPerformancePanel = function() {
        var d = this.viewer
          , c = f.ViewerSettingTab.Performance;
        this.is3dMode && (this.ghosthiddenChkBoxId = this.addCheckbox(c, "Ghost hidden objects", !0, function(a) {
            d.setGhosting(a)
        }
        , "ghosting"),
        this.optimizeNavigationhkBoxId = this.addCheckbox(c, "Smooth navigation", isMobileDevice(), function(a) {
            d.setOptimizeNavigation(a)
        }
        , "optimizeNavigation"),
        this.antialiasingChkBoxId = this.addCheckbox(c, "Anti-aliasing", 
        !0, function(a) {
            d.setQualityLevel(d.prefs.ambientShadows, a)
        }
        , "antialiasing"),
        this.ambientshadowsChkBoxId = this.addCheckbox(c, "Ambient shadows", !0, function(a) {
            d.setQualityLevel(a, d.prefs.antialiasing)
        }
        , "ambientShadows"),
        this.groundShadowChkBoxId = this.addCheckbox(c, "Ground shadow", !0, function(a) {
            d.setGroundShadow(a)
        }
        , "groundShadow"),
        this.groundReflectionChkBoxId = this.addCheckbox(c, "Ground reflection", !0, function(a) {
            d.setGroundReflection(a)
        }
        , "groundReflection"));
        this.progressiveRenderChkBoxId = this.addCheckbox(c, 
        "Progressive model display", !0, function(a) {
            d.setProgressiveRendering(a)
        }
        , "progressiveRendering")
    }
    ;
    g.prototype.syncUI = function() {
        var d = this.viewer
          , c = this.getControl(this.antialiasingChkBoxId);
        c && c.setValue(d.prefs.antialiasing);
        (c = this.getControl(this.ambientshadowsChkBoxId)) && c.setValue(d.prefs.ambientShadows);
        (c = this.getControl(this.groundShadowChkBoxId)) && c.setValue(d.prefs.groundShadow);
        (c = this.getControl(this.groundReflectionChkBoxId)) && c.setValue(d.prefs.groundReflection);
        (c = this.getControl(this.envMapBackgroundChkBoxId)) && 
        c.setValue(d.prefs.envMapBackground);
        (c = this.getControl(this.progressiveRenderChkBoxId)) && c.setValue(d.prefs.progressiveRendering);
        (c = this.getControl(this.ghosthiddenChkBoxId)) && c.setValue(d.prefs.ghosting)
    }
    ;
    f.ViewerSettingsPanel = g
}
)();
(function() {
    function f(f) {
        h.ObjectContextMenu.call(this, f)
    }
    var h = Teratek.Viewing.UI;
    f.prototype = Object.create(h.ObjectContextMenu.prototype);
    f.prototype.constructor = f;
    f.prototype.buildMenu = function(f, d) {
        var c = this
          , a = []
          , b = this.viewer.model.is2d();
        if (!b) {
            var h = this.viewer.navigation.getScreenViewport();
            (h = c.viewer.impl.hitTest(f.clientX - h.left, f.clientY - h.top, !1)) && h.dbId && (-1 == c.viewer.getSelection().indexOf(h.dbId) && c.viewer.select(h.dbId),
            d.hasSelected = !0,
            d.hasVisible = !0)
        }
        !b && d.hasSelected && (a.push({
            title: "Isolate",
            target: function() {
                var a = c.viewer.getSelection();
                c.viewer.clearSelection();
                c.viewer.isolate(a)
            }
        }),
        d.hasVisible && a.push({
            title: "Hide Selected",
            target: function() {
                var a = c.viewer.getSelection();
                c.viewer.clearSelection();
                c.viewer.hide(a)
            }
        }),
        d.hasHidden && a.push({
            title: "Show Selected",
            target: function() {
                var a = c.viewer.getSelection();
                c.viewer.clearSelection();
                c.viewer.show(a)
            }
        }));
        b ? a.push({
            title: "Show All Layers",
            target: function() {
                c.viewer.setLayerVisible(null , !0)
            }
        }) : a.push({
            title: "Show All Objects",
            target: function() {
                c.viewer.showAll()
            }
        });
        !b && d.hasSelected && a.push({
            title: "Focus",
            target: function() {
                var a = c.viewer.getSelection();
                c.viewer.fitToView(a)
            }
        });
        d.hasSelected && a.push({
            title: "Clear Selection",
            target: function() {
                c.viewer.clearSelection()
            }
        });
        return a
    }
    ;
    Teratek.Viewing.Extensions.ViewerObjectContextMenu = f
}
)();
(function() {
    function f(f, d) {
        Teratek.Viewing.Extension.call(this, f, d)
    }
    var h = TeratekNamespace("Teratek.Viewing.Extensions.CAM360");
    f.prototype = Object.create(Teratek.Viewing.Extension.prototype);
    f.prototype.constructor = f;
    f.prototype.load = function() {
        function f() {
            d.impl.setLightPreset(0, !0);
            d.removeEventListener(Teratek.Viewing.GEOMETRY_LOADED_EVENT, f)
        }
        var d = this.viewer
          , c = new h.CAMModelStructurePanel(this.viewer,"CAM Model Structure Loading",this.options);
        d.setModelStructurePanel(c);
        d.hideLines(!1);
        d.setGhosting(!1);
        d.setQualityLevel(!1, !0);
        d.addEventListener(Teratek.Viewing.GEOMETRY_LOADED_EVENT, f);
        return !0
    }
    ;
    f.prototype.unload = function() {
        this.viewer.setModelStructurePanel(null )
    }
    ;
    h.CAM360Extension = f;
    Teratek.Viewing.theExtensionManager.registerExtension("Teratek.CAM360", h.CAM360Extension)
}
)();
(function() {
    function f(d, c, a) {
        g.ViewerModelStructurePanel.call(this, d, c, a);
        this.viewer = d
    }
    var h = TeratekNamespace("Teratek.Viewing.Extensions.CAM360")
      , g = Teratek.Viewing.Extensions;
    f.prototype = Object.create(g.ViewerModelStructurePanel.prototype);
    f.prototype.constructor = f;
    f.prototype.sortCamNodes = function(d, c) {
        function a(a, b) {
            f.viewer.getProperties(a, function(c) {
                a: {
                    c = c.properties;
                    for (var d = 0; d < c.length; ++d) {
                        var g = c[d];
                        if ("9429B915-D020-4CEB-971B-6ADD0A5D4BFA" === g.displayName) {
                            c = g.displayValue;
                            break a
                        }
                    }
                    c = 
                    null 
                }
                c ? ("CAM_Setup" == c ? f.camSetupNodes.push(a) : "CAM_Operation" == c ? f.camOperationNodes.push(a) : "CAM_Tool" === c ? f.camToolNodes.push(a) : "CAM_Stock" === c ? f.camStockNodes.push(a) : "CAM_Folder" == c && f.camFolderNodes.push(a),
                f.camNodes.push(a)) : f.camModelNodes.push(a);
                b()
            }
            , function(a, c, d) {
                b()
            }
            )
        }
        function b() {
            0 < g.length ? a(g.shift(), b) : c()
        }
        this.camNodes = [];
        this.camModelNodes = [];
        this.camSetupNodes = [];
        this.camStockNodes = [];
        this.camOperationNodes = [];
        this.camToolNodes = [];
        this.camFolderNodes = [];
        var f = this
          , g = [];
        d.enumNodeChildren(d.getRootId(), 
        function(a) {
            g.push(a)
        }
        , !0);
        g.shift();
        b()
    }
    ;
    f.prototype.setModel = function(d, c) {
        var a = this;
        a.sortCamNodes(d, function() {
            g.ViewerModelStructurePanel.prototype.setModel.call(a, d, c);
            a.SetCAMNodeVisible(!1);
            a.setVisible(!0);
            a.ExpandSetupNodes();
            a.resizeToContent()
        }
        )
    }
    ;
    f.prototype.initialize = function() {
        function d(a) {
            c.SetCAMNodeVisible(!1);
            c.removeEventListener(c.viewer, Teratek.Viewing.GEOMETRY_LOADED_EVENT, d)
        }
        g.ViewerModelStructurePanel.prototype.initialize.call(this);
        var c = this;
        this.viewer.model && this.viewer.model.isLoadDone() || 
        c.addEventListener(c.viewer, Teratek.Viewing.GEOMETRY_LOADED_EVENT, d);
        c.addEventListener(c.viewer, Teratek.Viewing.SHOW_EVENT, function(a) {
            if (a = a.nodeIdArray)
                for (var b = 0; b < a.length; b++)
                    c.setCamNodeVisibility(a[b])
        }
        );
        c.addEventListener(c.viewer, Teratek.Viewing.SELECTION_CHANGED_EVENT, function(a) {
            if (a = a.nodeArray)
                for (var b = 0; b < a.length; b++)
                    c.HideHightlightCAMNode(a[b])
        }
        );
        c.addEventListener(c.viewer, Teratek.Viewing.ISOLATE_EVENT, function(a) {
            if (a = a.nodeIdArray)
                if (0 == a.length)
                    c.SetModelVisible(),
                    c.SetCAMNodeVisible(!0);
                else
                    for (var b = 0; b < a.length; b++)
                        c.setCamNodeVisibility(a[b])
        }
        )
    }
    ;
    f.prototype.IsCAMNode = function(d) {
        return -1 !== this.camNodes.indexOf(d)
    }
    ;
    f.prototype.IsCAMSetupNode = function(d) {
        return -1 !== this.camSetupNodes.indexOf(d)
    }
    ;
    f.prototype.IsCAMStockNode = function(d) {
        return -1 !== this.camStockNodes.indexOf(d)
    }
    ;
    f.prototype.IsCAMToolNode = function(d) {
        return -1 !== this.camToolNodes.indexOf(d)
    }
    ;
    f.prototype.IsCAMOperationNode = function(d) {
        return -1 !== this.camOperationNodes.indexOf(d)
    }
    ;
    f.prototype.IsCAMFolderNode = function(d) {
        return -1 !== 
        this.camFolderNodes.indexOf(d)
    }
    ;
    f.prototype.shouldInclude = function(d) {
        return !this.IsCAMStockNode(d)
    }
    ;
    f.prototype.isGroupNode = function(d) {
        return this.IsCAMOperationNode(d) ? !1 : g.ViewerModelStructurePanel.prototype.isGroupNode.call(this, d)
    }
    ;
    f.prototype.setNodeVisibility = function(d, c) {
        c ? this.viewer.show(d) : this.viewer.hide(d)
    }
    ;
    f.prototype.SetModelVisible = function() {
        if (this.camModelNodes)
            for (var d = 0; d < this.camModelNodes.length; d++)
                this.setNodeVisibility(this.camModelNodes[d], !0)
    }
    ;
    f.prototype.SetCAMNodeVisible = 
    function(d) {
        if (this.camNodes) {
            for (var c = 0; c < this.camNodes.length; c++)
                this.setNodeVisibility(this.camNodes[c], d);
            this.SetToolNodeVisible(!1)
        }
    }
    ;
    f.prototype.SetToolNodeVisible = function(d) {
        if (this.camToolNodes)
            for (var c = 0; c < this.camToolNodes.length; c++)
                this.setNodeVisibility(this.camToolNodes[c], d)
    }
    ;
    f.prototype.HideHightlightNode = function(d) {
        var c = this.viewer.impl
          , a = this;
        a.instanceTree.enumNodeFragments(d, function(b) {
            c.highlightFragment(a.model, b, !1, !0)
        }
        , !0)
    }
    ;
    f.prototype.HideHightlightCAMNode = function(d) {
        var c = 
        this.IsCAMSetupNode(d)
          , a = this.IsCAMOperationNode(d)
          , b = this.IsCAMFolderNode(d)
          , f = this;
        f.instanceTree.enumNodeChildren(d, function(d) {
            c ? f.IsCAMStockNode(d) || f.HideHightlightNode(d) : a ? f.IsCAMToolNode(d) && f.HideHightlightNode(d) : b && f.HideHightlightNode(d)
        }
        , !1)
    }
    ;
    f.prototype.setCamNodeVisibility = function(d) {
        var c = this.IsCAMSetupNode(d)
          , a = this.IsCAMOperationNode(d)
          , b = this.IsCAMFolderNode(d)
          , f = this;
        c ? this.instanceTree.enumNodeChildren(d, function(a) {
            var b = f.IsCAMStockNode(a);
            f.setNodeVisibility(a, b)
        }
        ) : a ? this.instanceTree.enumNodeChildren(d, 
        function(a) {
            f.IsCAMToolNode(a) && f.setNodeVisibility(a, !1)
        }
        ) : b && this.instanceTree.enumNodeChildren(d, function(a) {
            f.setNodeVisibility(a, !1)
        }
        )
    }
    ;
    f.prototype.onClick = function(d, c) {
        g.ViewerModelStructurePanel.prototype.onClick.call(this, d, c);
        this.SetModelVisible();
        this.setCamNodeVisibility(d);
        this.viewer.fitToView()
    }
    ;
    f.prototype.ExpandSetupNodes = function() {
        if (this.camSetupNodes)
            for (var d = 0; d < this.camSetupNodes.length; d++)
                this.tree.setCollapsed(this.camSetupNodes[d], !1)
    }
    ;
    h.CAMModelStructurePanel = f
}
)();
(function() {
    var f = Teratek.Viewing
      , h = f.UI
      , g = function(d, c) {
        f.Extension.call(this, d, c);
        this.viewer = d;
        this.animTools = null ;
        this.animToolsId = "animationTools";
        this.playButton = null ;
        this.prevExplodeValue = 0;
        this.prevAnimationTime = -1
    }
    ;
    g.prototype = Object.create(f.Extension.prototype);
    g.prototype.constructor = g;
    g.prototype.load = function() {
        function d(a, b) {
            b ? (a.setIcon("toolbar-animationPlayIcon"),
            a.setToolTip("Play")) : (a.setIcon("toolbar-animationPauseIcon"),
            a.setToolTip("Pause"))
        }
        function c() {
            q.toolbar.removeClass("toolbar-animationMenuplacer");
            m.animTools.setVisible(!1)
        }
        function a(a, b) {
            q.model.is2d() || 0 === q.getExplodeScale() || (m.prevExplodeValue = q.explodeSlider.value,
            b && (q.explodeSlider.value = a),
            q.explode(a))
        }
        function b(a) {
            var b = a.value;
            a.style.background = "-webkit-linear-gradient(left,#ffffff " + b + "%, #393939 " + b + "%)";
            a.style.background = "-moz-linear-gradient(left,#ffffff " + b + "%, #393939 " + b + "%)";
            a.style.background = "-ms-linear-gradient(left,#ffffff " + b + "%, #393939 " + b + "%)";
            a.style.background = "-o-linear-gradient(left,#ffffff " + b + "%, #393939 " + 
            b + "%)";
            a.style.background = "linear-gradient(to right,#ffffff " + b + "%, #393939 " + b + "%)"
        }
        function g(a) {
            var b = "";
            0 > a && (b = "-",
            a = -a);
            var c = ~~(a / 3600)
              , d = ~~(a % 3600 / 60);
            a %= 60;
            0 < c && (b += c + ":" + (10 > d ? "0" : ""));
            return b = b + (d + ":" + (10 > a ? "0" : "")) + a.toFixed(2)
        }
        function l(r) {
            q.removeEventListener(f.TOOLBAR_CREATED_EVENT, l);
            m.toolbar = new h.ToolBar("animation-toolbar");
            m.toolbar.addClass("toolbar-animationSubtoolbar");
            q.container.appendChild(m.toolbar.container);
            m.animTools = new h.ControlGroup(m.animToolsId);
            m.animTools.setVisible(!1);
            m.toolbar.addControl(m.animTools);
            m.playButton = new h.Button("toolbar-animationPlay");
            m.playButton.setToolTip("Play");
            m.playButton.onClick = function(c) {
                a(0);
                var f = q.impl.keyFrameAnimator;
                void 0 !== f && f && (0 < m.prevAnimationTime && (f.goto(m.prevAnimationTime),
                m.prevAnimationTime = -1),
                f.play(0, function(a) {
                    w.value = a;
                    t.value = g(f.currentTime);
                    E.value = g(f.currentTime - f.duration);
                    100 <= a && d(m.playButton, !0);
                    b(w)
                }
                ),
                d(m.playButton, f.isPaused),
                q.toolbar.addClass("toolbar-animationMenuplacer"),
                m.animTools.setVisible(!0),
                m.animTools.isPositionAdjusted || (n(),
                m.animTools.isPositionAdjusted = !0))
            }
            ;
            m.playButton.setIcon("toolbar-animationPlayIcon");
            q.modelTools.addControl(m.playButton);
            m.onExplodeChange = function() {
                var a = q.impl.keyFrameAnimator;
                void 0 !== a && a && (0 !== a.currentTime && (m.prevAnimationTime = a.currentTime,
                a.goto(0)),
                d(m.playButton, !0));
                c()
            }
            ;
            q.addEventListener(Teratek.Viewing.EXPLODE_CHANGE_EVENT, m.onExplodeChange);
            q.modelTools.resetModelButton && (q.modelTools.resetModelButton.onClick = function(c) {
                q.showAll();
                c = q.impl.keyFrameAnimator;
                void 0 !== c && c && (c.goto(0),
                w.value = 0,
                t.value = g(0),
                E.value = g(-c.duration),
                d(m.playButton, !0));
                a(0, !0);
                b(w)
            }
            );
            m.animTools.backwardButton = new h.Button("toolbar-animationBackward");
            m.animTools.backwardButton.setToolTip("Previous keyframe");
            m.animTools.backwardButton.onClick = function(a) {
                a = q.impl.keyFrameAnimator;
                void 0 !== a && a && (a.prev(),
                w.value = 0 < a.duration ? a.currentTime / a.duration * 100 : 0,
                t.value = g(a.currentTime),
                E.value = g(a.currentTime - a.duration),
                d(m.playButton, a.isPaused),
                b(w))
            }
            ;
            m.animTools.backwardButton.addClass("toolbar-animationButton");
            m.animTools.backwardButton.setIcon("toolbar-animationBackwardIcon");
            m.animTools.addControl(m.animTools.backwardButton);
            m.animTools.forwardButton = new h.Button("toolbar-animationForward");
            m.animTools.forwardButton.setToolTip("Next keyframe");
            m.animTools.forwardButton.onClick = function(a) {
                a = q.impl.keyFrameAnimator;
                void 0 !== a && a && (a.next(),
                w.value = 0 < a.duration ? a.currentTime / a.duration * 100 : 0,
                t.value = g(a.currentTime),
                E.value = g(a.currentTime - a.duration),
                d(m.playButton, a.isPaused),
                b(w))
            }
            ;
            m.animTools.forwardButton.addClass("toolbar-animationButton");
            m.animTools.forwardButton.setIcon("toolbar-animationForwardIcon");
            m.animTools.addControl(m.animTools.forwardButton);
            m.animTools.timeText = new h.Control("toolbar-animationTimeLapse");
            var t = document.createElement("input");
            t.type = "text";
            t.value = "0";
            t.className = "animationTimeLapse";
            t.disabled = !0;
            m.animTools.timeText.container.appendChild(t);
            m.animTools.timeText.addClass("toolbar-animationButton");
            m.animTools.addControl(m.animTools.timeText);
            m.animTools.timeline = new h.Control("toolbar-animationTimeline");
            var w = m.animTools.input = document.createElement("input");
            w.type = "range";
            w.value = "0";
            w.className = "animationTimeline";
            m.animTools.timeline.container.appendChild(w);
            w.addEventListener("input", function(a) {
                a = q.impl.keyFrameAnimator;
                if (void 0 !== a && a) {
                    var c = w.value * a.duration / 100;
                    t.value = g(c);
                    E.value = g(c - a.duration);
                    a.goto(c);
                    d(m.playButton, a.isPaused);
                    b(w)
                }
            }
            );
            var C = document.createElement("div");
            C.className = "teratek-control-tooltip";
            C.textContent = Teratek.Viewing.i18n.translate("Click-drag to scrub");
            m.animTools.timeline.container.appendChild(C);
            w.addEventListener("mouseover", function(a) {
                a.target === w && (C.style.visibility = "visible")
            }
            );
            w.addEventListener("mouseout", function(a) {
                a.target === w && (C.style.visibility = "hidden")
            }
            );
            m.animTools.timeline.addClass("toolbar-animationButton");
            m.animTools.timeline.addClass("toolbar-animationTimeline");
            m.animTools.addControl(m.animTools.timeline);
            m.animTools.timeLeftText = new h.Control("toolbar-animationRemainingTime");
            var E = document.createElement("input");
            E.type = "text";
            E.value = "0";
            E.className = "animationTimeLapse";
            E.disabled = !0;
            m.animTools.timeLeftText.container.appendChild(E);
            m.animTools.timeLeftText.addClass("toolbar-animationButton");
            m.animTools.addControl(m.animTools.timeLeftText);
            m.animTools.closeButton = new h.Button("toolbar-animationClose");
            m.animTools.closeButton.setToolTip("Close animation timeline");
            m.animTools.closeButton.onClick = function(a) {
                c()
            }
            ;
            m.animTools.closeButton.setIcon("toolbar-animationCloseIcon");
            m.animTools.closeButton.addClass("toolbar-animationButton");
            m.animTools.addControl(m.animTools.closeButton);
            m.onEscape = function(a) {
                a = q.impl.keyFrameAnimator;
                void 0 !== a && a && (a.isPaused ? c() : a.pause(),
                d(m.playButton, a.isPaused))
            }
            ;
            q.addEventListener(Teratek.Viewing.ESCAPE_EVENT, m.onEscape);
            m.onCameraChange = function() {
                if (q.toolController.cameraUpdated) {
                    var a = q.impl.keyFrameAnimator;
                    void 0 !== a && a && a.isPlaying && !a.isPaused && (a.pause(),
                    d(m.playButton, a.isPaused))
                }
            }
            ;
            q.addEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, m.onCameraChange);
            m.onResize = function() {
                q.container.clientWidth < (isTouchDevice() ? 560 : 600) ? 
                m.toolbar.setCollapsed(!0) : (m.toolbar.setCollapsed(!1),
                n())
            }
            ;
            q.addEventListener(Teratek.Viewing.VIEWER_RESIZE_EVENT, m.onResize)
        }
        function n() {
            var a = q.toolbar.getDimensions().width
              , b = q.container.getBoundingClientRect().width;
            a > b && (a = q.modelTools.getDimensions().width);
            b = a - (2 * m.animTools.backwardButton.getDimensions().width + 3 * m.animTools.timeText.getDimensions().width + m.animTools.closeButton.getDimensions().width) + 12;
            m.animTools.input.style.width = b + "px";
            m.toolbar.container.style.left = "calc(50% - " + 
            a / 2 + "px)"
        }
        var m = this
          , q = this.viewer;
        this.viewer.toolbar && this.viewer.toolbar.modelTools && 0 < this.viewer.toolbar.modelTools.getNumberOfControls() ? l() : this.viewer.addEventListener(f.TOOLBAR_CREATED_EVENT, l);
        return !0
    }
    ;
    g.prototype.unload = function() {
        var d = this.viewer
          , c = d.impl.keyFrameAnimator;
        c && c.stop();
        d.impl.keyFrameAnimator = null ;
        this.animTools && (this.animTools.removeControl(this.animTools.timeText.getId()),
        this.animTools.removeControl(this.animTools.timeline.getId()),
        this.animTools.removeControl(this.animTools.timeLeftText.getId()),
        this.animTools.removeControl(this.animTools.forwardButton.getId()),
        this.animTools.removeControl(this.animTools.backwardButton.getId()),
        this.animTools.removeControl(this.animTools.closeButton.getId()));
        this.toolbar && (this.toolbar.removeControl(this.animTools),
        this.toolbar.container.parentNode.removeChild(this.toolbar.container),
        this.toolbar = null );
        (c = d.getToolbar(!1)) && c.getControl(f.TOOLBAR.MODELTOOLSID).removeControl(this.playButton.getId());
        d.removeEventListener(f.EXPLODE_CHANGE_EVENT, this.onExplodeChange);
        d.removeEventListener(f.ESCAPE_EVENT, this.onEscape);
        d.removeEventListener(f.CAMERA_CHANGE_EVENT, this.onCameraChange);
        d.removeEventListener(f.VIEWER_RESIZE_EVENT, this.onResize);
        return !0
    }
    ;
    TeratekNamespace("Teratek.Viewing.Extensions.Fusion360");
    Teratek.Viewing.Extensions.Fusion360.AnimationExtension = g;
    f.theExtensionManager.registerExtension("Teratek.Fusion360.Animation", g)
}
)();
function init_WarpShader() {
    "undefined" === typeof window.WarpShader && (WarpShader = {
        uniforms: {
            tDiffuse: {
                type: "t",
                value: null 
            },
            scale: {
                type: "v2",
                value: new THREE.Vector2(1,1)
            },
            scaleIn: {
                type: "v2",
                value: new THREE.Vector2(1,1)
            },
            lensCenter: {
                type: "v2",
                value: new THREE.Vector2(0,0)
            },
            hmdWarpParam: {
                type: "v4",
                value: new THREE.Vector4(1,.22,.24,0)
            },
            chromAbParam: {
                type: "v4",
                value: new THREE.Vector4(.996,-.004,1.014,0)
            }
        },
        defines: {},
        vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec2 scale;\nuniform vec2 scaleIn;\nuniform vec2 lensCenter;\nuniform vec4 hmdWarpParam;\nuniform vec4 chromAbParam;\nvarying vec2 vUv;\nvec4 sampleColor() {\nvec2 uv = (vUv*2.0)-1.0;\nvec2 theta = (uv-lensCenter)*scaleIn;\nfloat rSq = theta.x*theta.x + theta.y*theta.y;\nvec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);\n  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);\n  vec2 tcBlue = (lensCenter + scale * rBlue);\n  tcBlue = (tcBlue+1.0)/2.0;\n  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue)))\n    return vec4(0.0, 0.0, 0.0, 1.0);\n  vec2 tcGreen = lensCenter + scale * rvector;\n  tcGreen = (tcGreen+1.0)/2.0;\n  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);\n  vec2 tcRed = lensCenter + scale * rRed;\n  tcRed = (tcRed+1.0)/2.0;\n  return vec4(texture2D(tDiffuse, tcRed).r, texture2D(tDiffuse, tcGreen).g, texture2D(tDiffuse, tcBlue).b, 1);\n}\nvoid main() {\nvec4 texel = sampleColor();\ngl_FragColor = texel;\n}"
    })
}
TeratekNamespace("Teratek.Viewing.Extensions.Oculus");
Teratek.Viewing.Extensions.Oculus.StereoRenderContext = function(f) {
    var h, g, d, c, a, b, k, l, n, m, q = f ? f.useWarp : !0, r = f && f.HMD ? f.HMD : {
        hResolution: 1920,
        vResolution: 1080,
        hScreenSize: .12576,
        vScreenSize: .07074,
        interpupillaryDistance: .0635,
        lensSeparationDistance: .0635,
        eyeToScreenDistance: .041,
        distortionK: [1, .22, .24, 0],
        chromaAbParameter: [.996, -.004, 1.014, 0]
    }, t, w, C = 1, E = 0, G = 100, B = 1;
    this.init = function(f, g, h) {
        init_WarpShader();
        a = f;
        b = g;
        k = h;
        l = a.getPixelRatio();
        B = r.hResolution / (2 * r.vResolution);
        f = -1 - 4 * (r.hScreenSize / 
        4 - r.lensSeparationDistance / 2) / r.hScreenSize;
        C = r.distortionK[0] + r.distortionK[1] * Math.pow(f, 2) + r.distortionK[2] * Math.pow(f, 4) + r.distortionK[3] * Math.pow(f, 6);
        G = THREE.Math.radToDeg(2 * Math.atan2(r.vScreenSize * C, 2 * r.eyeToScreenDistance));
        E = 4 * (r.hScreenSize / 4 - r.interpupillaryDistance / 2) / r.hScreenSize;
        f = 4 * (r.hScreenSize / 4 - r.lensSeparationDistance / 2) / r.hScreenSize;
        t = new THREE.Vector2(f,0);
        w = new THREE.Vector2(-f,0);
        d = new RenderContext;
        c = new RenderContext;
        d.settings.sao = c.settings.sao = !1;
        d.settings.antialias = 
        c.settings.antialias = !1;
        d.settings.customPresentPass = c.settings.customPresentPass = q;
        d.init(a, b / 2 * C / l, k * C / l);
        c.init(a, k / 2 * C / l, k * C / l);
        this.settings = d.settings;
        if (q) {
            n = new Teratek.Viewing.Shaders.LmvShaderPass(WarpShader);
            m = new Teratek.Viewing.Shaders.LmvShaderPass(WarpShader);
            f = [n, m];
            for (g = 0; 2 > g; g++)
                f[g].material.blending = THREE.NoBlending,
                f[g].material.depthWrite = !1,
                f[g].material.depthTest = !1,
                f[g].uniforms.hmdWarpParam.value.set(r.distortionK[0], r.distortionK[1], r.distortionK[2], r.distortionK[3]),
                f[g].uniforms.chromAbParam.value.set(r.chromaAbParameter[0], r.chromaAbParameter[1], r.chromaAbParameter[2], r.chromaAbParameter[3]),
                f[g].uniforms.scaleIn.value.set(1, 1 / B),
                f[g].uniforms.scale.value.set(1 / C, 1 * B / C);
            f[0].uniforms.lensCenter.value.copy(t);
            f[1].uniforms.lensCenter.value.copy(w)
        }
    }
    ;
    this.update = function(a) {
        var b = d.update(a);
        a = c.update(a);
        return b || a
    }
    ;
    this.beginScene = function(a, b, f, k) {
        h = b.clone();
        g = b.clone();
        h.aspect = g.aspect = B;
        h.fov = g.fov = G;
        var l = 1 / d.getUnitScale();
        b = b.target.clone().sub(b.position).cross(b.up).normalize();
        b.multiplyScalar(.5 * r.interpupillaryDistance * l);
        h.position.sub(b);
        g.position.add(b);
        h.target.sub(b);
        g.target.add(b);
        h.toPerspective();
        g.toPerspective();
        h.projectionMatrix.elements[12] += E;
        g.projectionMatrix.elements[12] -= E;
        d.beginScene(a, h, f, k);
        c.beginScene(a, g, f, k)
    }
    ;
    this.renderScenePart = function(a, b, f, g) {
        d.renderScenePart(a, b, f, g);
        c.renderScenePart(a, b, f, g)
    }
    ;
    this.sceneDirty = function(a, b) {
        d.sceneDirty(a, b);
        c.sceneDirty(a, b)
    }
    ;
    this.endScene = function() {
        d.endScene();
        c.endScene()
    }
    ;
    this.clearAllOverlays = 
    function() {
        d.clearAllOverlays();
        c.clearAllOverlays()
    }
    ;
    this.renderOverlays = function(a) {
        d.renderOverlays(a);
        c.renderOverlays(a)
    }
    ;
    this.composeFinalFrame = function(f, g) {
        d.composeFinalFrame(f, g, !0);
        c.composeFinalFrame(f, g, !0);
        a.setViewport(0, 0, b / 2, k);
        d.presentBuffer(n);
        a.setViewport(b / 2, 0, b / 2, k);
        c.presentBuffer(m);
        a.setViewport(0, 0, b, k)
    }
    ;
    this.cleanup = function() {
        d.cleanup();
        c.cleanup()
    }
    ;
    this.setSize = function(f, g, h) {
        b = f;
        k = g;
        d.setSize(b / 2 * C / l, k * C / l, h);
        c.setSize(b / 2 * C / l, k * C / l, h);
        a.setSize(f, g)
    }
    ;
    this.getMaxAnisotropy = 
    function() {
        return d.getMaxAnisotropy()
    }
    ;
    this.hasMRT = function() {
        return d.hasMRT()
    }
    ;
    this.initPostPipeline = function(a, b, f) {
        f = b = a = !1;
        d.initPostPipeline(a, b, f);
        c.initPostPipeline(a, b, f)
    }
    ;
    this.setClearColors = function(a, b) {
        d.setClearColors(a, b);
        c.setClearColors(a, b)
    }
    ;
    this.setAOOptions = function(a, b) {
        d.setAOOptions(a, b);
        c.setAOOptions(a, b)
    }
    ;
    this.getAORadius = function() {
        return d.getAORadius()
    }
    ;
    this.getAOIntensity = function() {
        return d.getAOIntensity()
    }
    ;
    this.setTonemapExposureBias = function(a) {
        d.setTonemapExposureBias(a);
        c.setTonemapExposureBias(a)
    }
    ;
    this.getExposureBias = function() {
        return d.getExposureBias()
    }
    ;
    this.setTonemapMethod = function(a) {
        d.setTonemapMethod(a);
        c.setTonemapMethod(a)
    }
    ;
    this.getToneMapMethod = function() {
        return d.getToneMapMethod()
    }
    ;
    this.toggleTwoSided = function(a) {
        d.toggleTwoSided(a);
        c.toggleTwoSided(a)
    }
    ;
    this.enter2DMode = function(a) {
        d.enter2DMode(a);
        c.enter2DMode(a)
    }
    ;
    this.idAtPixel = function(a, b) {
        console.warn("idAtPixel not implemented in stereo context.");
        return 0
    }
    ;
    this.overlayUpdate = function(a) {
        d.overlayUpdate(a);
        c.overlayUpdate(a)
    }
    ;
    this.rolloverObjectViewport = function(a, b) {
        console.warn("rolloverObjectViewport not implemented in stereo context")
    }
    ;
    this.screenCapture = function() {
        console.warn("Screen capture not implemented by stereo render context");
        return null 
    }
    ;
    this.setUnitScale = function(a) {
        d.setUnitScale(a);
        c.setUnitScale(a)
    }
    ;
    this.getUnitScale = function() {
        return d.getUnitScale()
    }
}
;
TeratekNamespace("Teratek.Viewing.Extensions.Oculus");
(function() {
    function f(a) {
        function c() {
            E.copy(f.matrixWorld);
            E.elements[12] = 0;
            E.elements[13] = 0;
            E.elements[14] = 0;
            B && C.set(B[1], B[2], B[3])
        }
        function d() {
            var a = new WebSocket("ws://localhost:8888/ws");
            a.onopen = function() {
                console.log("### Oculus Connected ####")
            }
            ;
            a.onmessage = function(a) {
                a = a.data;
                try {
                    B = JSON.parse(a)
                } catch (b) {
                    console.log(a)
                }
            }
            ;
            a.onclose = function() {
                console.log("### Oculus Connection Closed ####")
            }
            ;
            S = a
        }
        var f, g = new THREE.Vector3(0,0,0), h = new THREE.Quaternion, t = new THREE.Quaternion, w = new THREE.Matrix4, 
        C = new THREE.Vector3(0,0,0), E = new THREE.Matrix4, G = new THREE.Matrix4, B, v = 0, D = 1, z = 10, H = -1, I = 0, J = 0, L = 0, F = 0, N = 0, K = 0, M = 0, S;
        b ? B = [0, 0, 0, 0, 0, 0, 0, 0] : d();
        this.getNames = function() {
            return ["headtracker"]
        }
        ;
        this.getName = function() {
            return "headtracker"
        }
        ;
        this.activate = function(b) {
            f = a.navigation.getCamera();
            c();
            a.model && (D = 1 / a.model.getUnitScale(),
            z = 1E-4 * a.model.getBoundingBox().size().length())
        }
        ;
        this.deactivate = function(a) {
            f = null 
        }
        ;
        this.update = function(c) {
            0 > H && (H = c);
            var d = c - H;
            f.isPerspective || a.navigation.toPerspective();
            if (b) {
                var l = b.getState();
                B[0] = v + 1;
                l.orientation && (B[4] = l.orientation.x,
                B[5] = l.orientation.y,
                B[6] = l.orientation.z,
                B[7] = l.orientation.w);
                l.position && (B[1] = l.position.x,
                B[2] = l.position.y,
                B[3] = l.position.z)
            }
            if (B) {
                l = B[0];
                if (l > v) {
                    f.position.sub(g);
                    g.set(B[1], B[2], B[3]);
                    g.sub(C);
                    g.multiplyScalar(D);
                    g.applyMatrix4(E);
                    f.position.add(g);
                    I += (K - M) * d * .001;
                    t.setFromAxisAngle(f.worldup, I);
                    h.set(B[4], B[5], B[6], B[7]);
                    t.multiply(h);
                    G.makeRotationFromQuaternion(t);
                    w.multiplyMatrices(E, G);
                    var n = w.elements
                      , V = new THREE.Vector3(-n[8],
                    -n[9],-n[10])
                      , ea = f.target.clone().sub(f.position).length();
                    f.up.set(n[4], n[5], n[6]);
                    var n = new THREE.Vector3(n[0],n[1],n[2])
                      , X = V.clone().multiplyScalar((J - F) * d * z);
                    f.position.add(X);
                    d = n.multiplyScalar((N - L) * d * z);
                    f.position.add(d);
                    f.target.set(f.position.x, f.position.y, f.position.z);
                    f.target.add(V.multiplyScalar(ea))
                }
                v = l
            }
            S && 1 === S.readyState && S.send("get\n");
            H = c;
            return !0
        }
        ;
        this.handleSingleClick = function(a, b) {
            return !1
        }
        ;
        this.handleDoubleClick = function(a, b) {
            return !1
        }
        ;
        this.handleSingleTap = function(a) {
            return !1
        }
        ;
        this.handleDoubleTap = function(a, b) {
            return !1
        }
        ;
        this.handleKeyDown = function(a, b) {
            var c = !1;
            switch (b) {
            case 38:
            case 87:
                J = 1;
                c = !0;
                break;
            case 40:
            case 83:
                F = 1;
                c = !0;
                break;
            case 37:
            case 65:
                L = 1;
                c = !0;
                break;
            case 39:
            case 68:
                N = 1;
                c = !0;
                break;
            case 81:
                K = 1;
                c = !0;
                break;
            case 69:
                M = 1,
                c = !0
            }
            return c
        }
        ;
        this.handleKeyUp = function(a, b) {
            var d = !1;
            switch (b) {
            case 38:
            case 87:
                J = 0;
                d = !0;
                break;
            case 40:
            case 83:
                F = 0;
                d = !0;
                break;
            case 37:
            case 65:
                L = 0;
                d = !0;
                break;
            case 39:
            case 68:
                N = 0;
                d = !0;
                break;
            case 81:
                K = 0;
                d = !0;
                break;
            case 69:
                M = 0;
                d = !0;
                break;
            case 32:
                c(),
                d = !0
            }
            return d
        }
        ;
        this.handleWheelInput = function(a) {
            return !1
        }
        ;
        this.handleButtonDown = function(a, b) {
            return !1
        }
        ;
        this.handleButtonUp = function(a, b) {
            return !1
        }
        ;
        this.handleMouseMove = function(a) {
            return !1
        }
        ;
        this.handleGesture = function(a, b) {
            return !1
        }
        ;
        this.handleTouchChange = function(a, b) {
            return !1
        }
        ;
        this.handleBlur = function(a) {
            return !1
        }
        ;
        this.handleResize = function() {}
    }
    var h = Teratek.Viewing
      , g = h.Extensions
      , d = h.UI
      , c = g.Oculus
      , a = null 
      , b = null ;
    c.Oculus = function(a, b) {
        h.Extension.call(this, a, b);
        this.viewer = a;
        this.context = null ;
        this.initialized = !1
    }
    ;
    c.Oculus.prototype = Object.create(h.Extension.prototype);
    c.Oculus.prototype.constructor = g.Oculus;
    c.Oculus.prototype.toggleOculus = function(b) {
        var d = this.viewer;
        b ? this.context || (this.context = new c.StereoRenderContext({
            useWarp: !a
        }),
        d.impl.setUserRenderContext(this.context),
        d.resize(d.canvas.clientWidth, d.canvas.clientHeight),
        d.displayViewCube(!1, !1),
        d.navigation.isPerspective || d.navigation.toPerspective(),
        a ? launchFullscreen(d.impl.canvas, {
            vrDisplay: a
        }) : launchFullscreen(d.impl.canvas),
        this.headTracker || (this.headTracker = new f(d),
        d.toolController.registerTool(this.headTracker)),
        d.toolController.activateTool("headtracker")) : this.context && (this.context = null ,
        d.impl.setUserRenderContext(null ),
        d.displayViewCube(d.prefs.get("viewCube"), !1),
        d.toolController.deactivateTool("headtracker"),
        exitFullscreen())
    }
    ;
    c.Oculus.prototype.createUI = function() {
        var a = this
          , b = this.viewer;
        this.oculusButton = new d.Button("toolbar-oculusTool");
        this.oculusButton.setToolTip("Oculus VR Mode");
        this.oculusButton.setIcon("oculusIcon");
        this.oculusButton.onClick = function(b) {
            a.toggleOculus(!a.context)
        }
        ;
        b.modelTools.addControl(this.oculusButton)
    }
    ;
    c.Oculus.prototype.load = function() {
        function c(a) {
            f.removeEventListener(h.TOOLBAR_CREATED_EVENT, c);
            g.createUI()
        }
        function d(l) {
            for (var r = 0; r < l.length; ++r)
                if (l[r] instanceof HMDVRDevice) {
                    a = l[r];
                    break
                }
            if (a) {
                for (r = 0; r < l.length; ++r)
                    if (l[r] instanceof PositionSensorVRDevice && l[r].hardwareUnitId == a.hardwareUnitId) {
                        b = l[r];
                        break
                    }
                a && b ? f.modelTools && 0 < f.modelTools.getNumberOfControls() ? g.createUI() : f.addEventListener(h.TOOLBAR_CREATED_EVENT, 
                c) : stderr("Didn't find a HMD and sensor!");
                g.initialized = !0
            }
        }
        var f = this.viewer
          , g = this;
        navigator.getVRDevices ? navigator.getVRDevices().then(d) : navigator.mozGetVRDevices ? navigator.mozGetVRDevices(d) : this.initialized = !0;
        return !0
    }
    ;
    c.Oculus.prototype.unload = function() {
        this.toggleOculus(!1);
        return !0
    }
    ;
    h.theExtensionManager.registerExtension("Teratek.Viewing.Oculus", c.Oculus)
}
)();
TeratekNamespace("Teratek.Viewing.Extensions.Collaboration");
(function() {
    var f = Teratek.Viewing
      , h = f.Private
      , g = f.Extensions.Collaboration;
    g.InteractionInterceptor = function(d) {
        this.getNames = function() {
            return ["intercept"]
        }
        ;
        this.getName = function() {
            return "intercept"
        }
        ;
        this.activate = function(c) {}
        ;
        this.deactivate = function(c) {}
        ;
        this.update = function(c) {
            return !1
        }
        ;
        this.handleSingleClick = function(c, a) {
            return !1
        }
        ;
        this.handleDoubleClick = function(c, a) {
            return !1
        }
        ;
        this.handleSingleTap = function(c) {
            return !1
        }
        ;
        this.handleDoubleTap = function(c, a) {
            return !1
        }
        ;
        this.handleKeyDown = function(c, 
        a) {
            return !1
        }
        ;
        this.handleKeyUp = function(c, a) {
            return !1
        }
        ;
        this.handleWheelInput = function(c) {
            d.takeControl();
            return !1
        }
        ;
        this.handleButtonDown = function(c, a) {
            d.takeControl();
            return !1
        }
        ;
        this.handleButtonUp = function(c, a) {
            return !1
        }
        ;
        this.handleMouseMove = function(c) {
            d.updatePointer(c);
            return !1
        }
        ;
        this.handleGesture = function(c) {
            d.takeControl();
            return !1
        }
        ;
        this.handleBlur = function(c) {
            return !1
        }
        ;
        this.handleResize = function() {}
    }
    ;
    g.ViewTransceiver = function(d) {
        function c(a) {
            t = !0;
            a = JSON.parse(a.data.msg);
            z.restoreState(a);
            r.impl.invalidate(!0, !1, !0);
            t = !1
        }
        function a(a) {
            for (var b = 0; b < a.length; b++)
                a[b] = Math.round(1E3 * a[b]) / 1E3
        }
        function b(a) {
            var b = a.data.msg;
            !0 === b[1] || C || (b[0] != E && (E = b[0],
            a.data.lastInControl = b[0],
            q.dispatchEvent({
                type: "controlChange",
                channelId: q.channelId,
                data: a.data
            })),
            w = !1,
            r.navigation.setView((new THREE.Vector3).set(b[2], b[3], b[4]), (new THREE.Vector3).set(b[5], b[6], b[7])),
            r.navigation.setCameraUpVector((new THREE.Vector3).set(b[8], b[9], b[10])))
        }
        function g(b) {
            if (w || C)
                b = b.camera,
                b = [b.position.x, b.position.y, 
                b.position.z, b.target.x, b.target.y, b.target.z, b.up.x, b.up.y, b.up.z],
                a(b),
                b.unshift(C),
                b.unshift(d.getLocalId()),
                G.sendMessage("camera", b, q.channelId),
                E != b[0] && (E = b[0],
                q.dispatchEvent({
                    type: "controlChange",
                    channelId: q.channelId,
                    data: {
                        lastInControl: E
                    }
                }))
        }
        function l(a, b, c) {
            a && !v && (v = document.createElement("div"),
            v.classList.add("collabPointer"));
            a && !D ? (r.container.appendChild(v),
            D = !0) : !a && D && (r.container.removeChild(v),
            D = !1);
            a && (v.style.left = b - 6 + "px",
            v.style.top = c - 6 + "px")
        }
        function n(a) {
            w || C || (a = a.data.msg,
            B.origin.set(a[1], a[2], a[3]),
            B.direction.set(a[4], a[5], a[6]),
            a = B.at(r.getCamera().near),
            a.project(r.getCamera()),
            a = r.impl.viewportToClient(a.x, a.y),
            l(!0, a.x, a.y))
        }
        function m(a) {
            t || (a = z.getState(H),
            d.sendMessage("state", JSON.stringify(a), q.channelId))
        }
        var q = this, r = this.viewer = null , t = !1, w = !1, C = !1, E, G = this.client = d, B = new THREE.Ray, v = null , D = !1;
        this.channelId = null ;
        var z, H = {
            seedURN: !1,
            objectSet: !0,
            viewport: !1,
            cutplanes: !0,
            renderOptions: {
                environment: !1,
                ambientOcclusion: !1,
                toneMap: {
                    exposure: !1
                },
                appearance: !1
            }
        };
        this.takeControl = function() {
            w = !0;
            l(!1)
        }
        ;
        this.updatePointer = function(b) {
            w && (b = r.impl.clientToViewport(b.canvasX, b.canvasY),
            r.impl.viewportToRay(b, B),
            b = [B.origin.x, B.origin.y, B.origin.z, B.direction.x, B.direction.y, B.direction.z],
            a(b),
            b.unshift(d.getLocalId()),
            G.sendMessage("pointer", b, q.channelId))
        }
        ;
        this.connectCamera = function(a) {
            C = !a
        }
        ;
        this.attach = function(a) {
            r && this.detach();
            this.viewer = r = a;
            z = new h.ViewerState(r);
            G.addEventListener("cameraChange", b);
            G.addEventListener("pointerMove", n);
            G.addEventListener("viewerState", 
            c);
            r.hasEventListener(f.CAMERA_CHANGE_EVENT, g) || r.addEventListener(f.CAMERA_CHANGE_EVENT, g);
            r.hasEventListener(f.SELECTION_CHANGED_EVENT, m) || (r.addEventListener(f.SELECTION_CHANGED_EVENT, m),
            r.addEventListener(f.ISOLATE_EVENT, m),
            r.addEventListener(f.HIDE_EVENT, m),
            r.addEventListener(f.SHOW_EVENT, m),
            r.addEventListener(f.HIGHLIGHT_EVENT, m),
            r.addEventListener(f.EXPLODE_CHANGE_EVENT, m),
            r.addEventListener(f.LAYER_VISIBILITY_CHANGED_EVENT, m),
            r.addEventListener(f.CUTPLANES_CHANGE_EVENT, m))
        }
        ;
        this.detach = function() {
            G && 
            (G.removeEventListener("cameraChange", b),
            G.removeEventListener("viewerState", c));
            r && (r.removeEventListener(f.CAMERA_CHANGE_EVENT, g),
            r.removeEventListener(f.SELECTION_CHANGED_EVENT, m),
            r.removeEventListener(f.ISOLATE_EVENT, m),
            r.removeEventListener(f.HIDE_EVENT, m),
            r.removeEventListener(f.SHOW_EVENT, m),
            r.removeEventListener(f.HIGHLIGHT_EVENT, m),
            r.removeEventListener(f.EXPLODE_CHANGE_EVENT, m),
            r.removeEventListener(f.LAYER_VISIBILITY_CHANGED_EVENT, m),
            r.removeEventListener(f.CUTPLANES_CHANGE_EVENT, m),
            z = 
            this.viewer = r = null )
        }
    }
    ;
    g.ViewTransceiver.prototype.constructor = g.ViewTransceiver;
    Teratek.Viewing.EventDispatcher.prototype.apply(g.ViewTransceiver.prototype)
}
)();
TeratekNamespace("Teratek.Viewing.Extensions.Collaboration");
(function() {
    var f = Teratek.Viewing
      , h = f.Extensions
      , g = f.Private
      , d = f.UI
      , c = h.Collaboration;
    h.Collaboration.Collaboration = function(a, b) {
        f.Extension.call(this, a, b);
        b && b.rtc && b.rtc.disableRTCToolbarButton && (this.disableRTCToolbarButton = !0)
    }
    ;
    h.Collaboration.Collaboration.prototype = Object.create(f.Extension.prototype);
    h.Collaboration.Collaboration.prototype.constructor = h.Collaboration.Collaboration;
    h.Collaboration.Collaboration.prototype.initNetwork = function(a) {
        if (!this.p2p || a)
            this.viewtx = new c.ViewTransceiver(this.client),
            this.interceptor = new c.InteractionInterceptor(this.viewtx),
            this.viewer.toolController.registerTool(this.interceptor),
            this.p2p = new g.P2PClient(this.client)
    }
    ;
    h.Collaboration.Collaboration.prototype.createUI = function() {
        var a = this
          , b = this.viewer;
        this.initNetwork(!1);
        this.panel = new c.DockingCollabPanel(this.viewer,this.client,this.p2p,this.viewtx);
        h.Collaboration.Collaboration.Panel = this.panel;
        this.collabButton = new d.Button("toolbar-collaborateTool");
        this.collabButton.setToolTip("Live review");
        this.collabButton.setIcon("teratek-icon-live-review");
        this.collabButton.onClick = function(d) {
            d = a.panel.isVisible();
            document.getElementById("collabBox") || (d || a.inviteDivInstantiated ? (a.panel.setVisible(!1, !0),
            a.panel.reset()) : (new c.CollabPromptBox).start(b.container, function() {
                a.panel.setVisible(!0, !0)
            }
            , "Start a Live Review", "Start Review"))
        }
        ;
        this.disableRTCToolbarButton && this.collabButton.setVisible(!1, !0);
        this.panel.addVisibilityListener(function(c) {
            c ? (b.model && (c = b.model.getData(),
            a.viewtx.channelId = c.basePath,
            a.viewtx.attach(b),
            a.client.connect(a.viewtx.channelId),
            a.client.join(a.viewtx.channelId)),
            b.toolController.activateTool(a.interceptor.getName()),
            a.collabButton.setState(d.Button.State.ACTIVE),
            g.logger && g.logger.log({
                category: "viewer_rtc_start"
            })) : (g.logger && a.client.isConnected() && g.logger.log({
                category: "viewer_rtc_stop"
            }),
            a.p2p.hangup(),
            a.viewtx.detach(b),
            a.viewtx.channelId = null ,
            a.client.disconnect(),
            a.panel.reset(),
            b.toolController.deactivateTool(a.interceptor.getName()),
            a.collabButton.setState(d.Button.State.INACTIVE))
        }
        );
        b.modelTools.addControl(this.collabButton);
        Teratek.Viewing.Private.getParameterByName("invited") && (new CollabPromptBox).start(b.container, function() {
            a.panel.setVisible(!0, !0)
        }
        , "Join a Live Review", "Join Review")
    }
    ;
    h.Collaboration.Collaboration.prototype.close = function() {
        this.panel.setVisible(!1, !0);
        this.panel.reset()
    }
    ;
    h.Collaboration.Collaboration.prototype.load = function() {
        var a = this.viewer
          , b = this;
        g.loadDependency("lmv_io", "socket.io-1.3.5.js", function() {
            function c(d) {
                a.removeEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, c);
                b.createUI()
            }
            b.client = g.MessageClient.GetInstance(b.options ? b.options.messageServerURL : void 0);
            b.socketErrorHandler = function(c) {
                g.ErrorHandler.reportError(a.container, Teratek.Viewing.ErrorCodes.RTC_ERROR, c.data);
                b.close()
            }
            ;
            b.client.addEventListener("socketError", b.socketErrorHandler);
            b.presenceChannelId = window.location.host;
            b.client.isConnected();
            a.modelTools ? b.createUI() : a.addEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, c)
        }
        );
        return !0
    }
    ;
    h.Collaboration.Collaboration.prototype.unload = function() {
        var a = this.viewer;
        this.client.removeEventListener("socketError", this.socketErrorHandler);
        this.socketErrorHandler = null ;
        this.p2p.hangup();
        this.viewtx.detach(a);
        this.client.disconnect();
        this.panel && (this.panel.reset(),
        this.panel.setVisible(!1),
        this.panel.uninitialize(),
        this.panel = null );
        a.toolController.deactivateTool(this.interceptor.getName());
        this.interceptor = null ;
        a.modelTools.removeControl(this.collabButton.getId());
        this.collabButton = null ;
        return !0
    }
    ;
    f.theExtensionManager.registerExtension("Teratek.Viewing.Collaboration", 
    h.Collaboration.Collaboration)
}
)();
(function() {
    function f(c, a, b, d) {
        this.viewer = c;
        this.client = a;
        this.p2p = b;
        this.viewtx = d;
        h.UI.DockingPanel.call(this, c.container, "CollabPanel", "Live review");
        this.container.classList.add("collabPanel");
        this.container.style.height = "auto";
        this.container.dockRight = !0;
        this.content = document.createElement("div");
        this.container.appendChild(this.content);
        this.content.classList.add("collabPanelContent");
        this.tableContainer = document.createElement("div");
        this.tableContainer.classList.add("userListTable", "dockingPanelScroll");
        this.table = document.createElement("table");
        this.table.classList.add("tftable");
        this.tbody = document.createElement("tbody");
        this.table.appendChild(this.tbody);
        this.tableContainer.appendChild(this.table);
        this.content.appendChild(this.tableContainer);
        this.inviteDiv = document.createElement("div");
        this.inviteDiv.className = "collabBoxOK";
        this.inviteDiv.style.float = "left";
        this.inviteDiv.style.width = "232px";
        this.inviteDiv.setAttribute("data-i18n", "Invite");
        this.inviteDiv.textContent = Teratek.Viewing.i18n.translate("Invite");
        this.content.appendChild(this.inviteDiv);
        this.inviteDiv.addEventListener("click", function(a) {
            (new CollabPromptBox).start(c.container, function() {
                var a = Teratek.Viewing.i18n.translate("Please Join My Live Review");
                document.location.href = "mailto:?subject=" + a
            }
            , "Invite Others", "Email Invite", !0)
        }
        );
        this.chatHistory = document.createElement("div");
        this.chatHistory.classList.add("chatHistory");
        this.chatHistory.classList.add("textEntry");
        this.chatHistory.classList.add("dockingPanelScroll");
        this.content.appendChild(this.chatHistory);
        this.chatPanel = document.createElement("div");
        this.chatPanel.classList.add("chatPanel");
        this.textInput = document.createElement("input");
        this.textInput.type = "text";
        this.textInput.classList.add("textEntry");
        this.textInput.placeholder = Teratek.Viewing.i18n.translate("Type a message");
        this.chatPanel.appendChild(this.textInput);
        this.content.appendChild(this.chatPanel);
        this.isCameraConnected = !0;
        var f = this;
        this.addEventListener(a, "userListChange", function(a) {
            a.channelId && a.channelId !== f.viewtx.channelId || 
            (a = f.client.getChannelInfo(f.viewtx.channelId)) && f.updateUsers(a.users)
        }
        );
        this.addEventListener(this.viewtx, "controlChange", function(a) {
            a.channelId === f.viewtx.channelId && f.updateUserInControl(a.data.lastInControl)
        }
        );
        this.addEventListener(a, "chatReceived", function(a) {
            a.channelId === f.viewtx.channelId && f.updateChatHistory(a)
        }
        );
        this.textInput.onkeyup = function(a) {
            f.handleChatInput(a)
        }
        ;
        this.addEventListener(this.p2p, "remoteStreamAdded", function(a) {
            f.videoPanel || f.createVideoPanel();
            f.remoteVideo.src = window.URL.createObjectURL(a.data)
        }
        );
        this.addEventListener(this.p2p, "localStreamAdded", function(a) {
            f.videoPanel || f.createVideoPanel();
            f.localVideo.src = window.URL.createObjectURL(a.data)
        }
        );
        this.addEventListener(this.p2p, "remoteHangup", function(a) {
            f.removeVideoPanel()
        }
        )
    }
    var h = Teratek.Viewing
      , g = h.Private
      , d = h.Extensions.Collaboration;
    Teratek.Viewing.startLiveReviewSession = function() {
        d.Panel && d.Panel.startSession()
    }
    ;
    Teratek.Viewing.endLiveReviewSession = function() {
        d.Panel && d.Panel.endSession()
    }
    ;
    f.prototype = Object.create(h.UI.DockingPanel.prototype);
    f.prototype.constructor = f;
    f.prototype.startSession = function() {
        var c = this;
        this.isVisible() || (new CollabPromptBox).start(this.viewer.container, function() {
            c.setVisible(!0, !0)
        }
        , "Start a Live Review", "Start Review")
    }
    ;
    f.prototype.endSession = function() {
        this.isVisible() && (this.setVisible(!1, !0),
        this.reset())
    }
    ;
    f.prototype.updateUsers = function(c) {
        for (var a = document.createElement("tbody"), b = 0; b < c.length; b++) {
            var d = a.insertRow(-1);
            d.id = c[b].id;
            var f = d.insertCell(0);
            f.style.width = "14px";
            f.style.cursor = "default";
            var g = document.createElement("div");
            g.classList.add("statusBase");
            g.classList.add("statusNormal");
            g.innerHTML = "&#9679";
            f.appendChild(g);
            d.insertCell(1).textContent = c[b].name
        }
        this.table.replaceChild(a, this.tbody);
        this.tbody = a;
        this.fixComponentPlacement()
    }
    ;
    f.prototype.updateUserInControl = function(c) {
        for (var a = 0; a < this.tbody.rows.length; a++) {
            var b = this.tbody.rows[a]
              , d = b.cells[0].childNodes[0];
            b.id == c ? (d.classList.remove("statusNormal"),
            d.classList.add("statusInControl"),
            d.innerHTML = "&#9784",
            b.cells[1].style.color = 
            "#4CBA36") : (d.classList.remove("statusInControl"),
            d.classList.add("statusNormal"),
            d.innerHTML = "&#9679",
            b.cells[1].style.color = "#ffffff")
        }
    }
    ;
    f.prototype.updateChatHistory = function(c) {
        var a = this.client.getUserById(c.data.from, c.channelId);
        if ("/" != c.data.msg.charAt(0)) {
            if (this.chatHistory.lastUser != a.name) {
                var b = document.createElement("p")
                  , d = document.createElement("div");
                d.classList.add("heading");
                d.style.float = "left";
                d.style.fontStyle = "normal";
                d.style.color = "#857E7E";
                d.textContent = a.name;
                b.appendChild(d);
                d = document.createElement("div");
                d.classList.add("heading");
                d.style.textAlign = "right";
                d.style.fontStyle = "normal";
                d.style.color = "#857E7E";
                d.textContent = (new Date).toLocaleTimeString();
                b.appendChild(d);
                this.chatHistory.appendChild(b);
                this.chatHistory.lastUser = a.name
            } else
                a = document.createElement("br"),
                this.chatHistory.appendChild(a);
            a = document.createElement("span");
            a.classList.add("messageText");
            a.textContent = c.data.msg;
            this.chatHistory.appendChild(a);
            this.chatHistory.scrollTop = this.chatHistory.scrollHeight
        }
    }
    ;
    f.prototype.handleChatInput = function(c) {
        13 == c.which && 0 != this.textInput.value.length && (this.client.sendChatMessage(this.textInput.value, this.viewtx.channelId),
        this.textInput.value = "",
        this.textInput.placeholder = "")
    }
    ;
    f.prototype.fixComponentPlacement = function(c) {
        c = this.tableContainer.offsetHeight + this.chatPanel.offsetHeight;
        this.videoPanel && (c += this.videoPanel.offsetHeight);
        this.chatHistory.style.height = "calc(100% - " + c + "px)"
    }
    ;
    f.prototype.createVideoPanel = function(c) {
        this.videoPanel = document.createElement("div");
        this.videoPanel.classList.add("videoPanel");
        this.localVideo = document.createElement("video");
        this.localVideo.autoplay = !0;
        this.localVideo.muted = !0;
        this.localVideo.classList.add("videoInset");
        this.videoPanel.appendChild(this.localVideo);
        this.remoteVideo = document.createElement("video");
        this.remoteVideo.autoplay = !0;
        this.remoteVideo.classList.add("videoMain");
        this.videoPanel.appendChild(this.remoteVideo);
        var a = this;
        c = document.createElement("div");
        c.classList.add("dockingPanelClose");
        c.innerHTML = "&times";
        c.title = Teratek.Viewing.i18n.translate("End video call");
        c.onclick = function(b) {
            a.p2p.hangup();
            a.removeVideoPanel()
        }
        ;
        this.videoPanel.appendChild(c);
        this.content.insertBefore(this.videoPanel, this.chatHistory);
        this.fixComponentPlacement()
    }
    ;
    f.prototype.removeCollabPrompt = function() {
        var c = document.getElementById("collabBox");
        c && (c.style.visibility = "hidden",
        this.viewer.container.removeChild(c))
    }
    ;
    f.prototype.removeVideoPanel = function() {
        this.videoPanel && this.content.removeChild(this.videoPanel);
        this.videoPanel = 
        null 
    }
    ;
    f.prototype.reset = function(c) {
        this.tbody && (c = document.createElement("tbody"),
        this.table.replaceChild(c, this.tbody),
        this.tbody = c);
        this.chatHistory.textContent = "";
        this.textInput.value = "";
        this.removeVideoPanel();
        this.removeCollabPrompt()
    }
    ;
    CollabPromptBox = function() {}
    ;
    CollabPromptBox.prototype.start = function(c, a, b, d, f) {
        if (c && !document.getElementById("collabBox")) {
            var h = document.createElement("div");
            h.id = "collabBox";
            h.className = "collabBox";
            c.appendChild(h);
            var m = document.createElement("div");
            m.className = 
            "collabBoxTitle";
            m.textContent = Teratek.Viewing.i18n.translate(b, {
                defaultValue: b
            });
            h.appendChild(m);
            b = document.createElement("span");
            b.className = "collabBoxText";
            m = "Enter your name";
            f && (m = "Review URL");
            b.textContent = Teratek.Viewing.i18n.translate(m, {
                defaultValue: m
            });
            h.appendChild(b);
            b = document.createElement("span");
            b.className = "collabBoxInputContainer";
            h.appendChild(b);
            var q = document.createElement("input");
            q.type = "text";
            q.className = "collabBoxInputText";
            f && (m = window.location.toString(),
            m = -1 == m.indexOf("?") ? 
            m + "?invited=true" : m + "&invited=true",
            Teratek.Viewing.Private.docItemId && (m += "&itemid=" + Teratek.Viewing.Private.docItemId),
            q.value = m + "&doNotRedirect=true");
            b.appendChild(q);
            q.onkeyup = function(b) {
                13 == b.keyCode && (h.style.visibility = "hidden",
                c.removeChild(h),
                g.setUserName(q.value),
                a())
            }
            ;
            b = document.createElement("div");
            b.className = "collabBoxClose";
            b.innerHTML = "&times;";
            b.addEventListener("click", function(a) {
                h.style.visibility = "hidden";
                c.removeChild(h)
            }
            );
            h.appendChild(b);
            f ? (b = document.createElement("span"),
            b.className = "collabBoxText",
            b.style.marginTop = "0px",
            m = "Copy and send this URL to invite others",
            b.textContent = Teratek.Viewing.i18n.translate(m, {
                defaultValue: m
            })) : (b = document.createElement("div"),
            b.className = "collabBoxOK",
            b.textContent = Teratek.Viewing.i18n.translate(d, {
                defaultValue: d
            }),
            b.addEventListener("click", function(b) {
                h.style.visibility = "hidden";
                c.removeChild(h);
                "" !== q.value.trim() && g.setUserName(q.value);
                a()
            }
            ));
            h.appendChild(b);
            h.style.visibility = "visible";
            q.focus();
            f && q.select()
        }
    }
    ;
    d.DockingCollabPanel = 
    f;
    d.CollabPromptBox = CollabPromptBox
}
)();
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.Beeline");
Teratek.Viewing.Extensions.Beeline.BeelineExtension = function(f, h) {
    Teratek.Viewing.Extension.call(this, f, h)
}
;
Teratek.Viewing.Extensions.Beeline.BeelineExtension.prototype = Object.create(Teratek.Viewing.Extension.prototype);
Teratek.Viewing.Extensions.Beeline.BeelineExtension.prototype.constructor = Teratek.Viewing.Extensions.Beeline.BeelineExtension;
Teratek.Viewing.Extensions.Beeline.BeelineExtension.prototype.load = function() {
    var f = this
      , h = this.viewer
      , g = h.getToolbar(!0)
      , d = Teratek.Viewing.UI;
    this.tool = new Teratek.Viewing.Extensions.Beeline.BeelineTool(h.impl,h);
    h.toolController.registerTool(this.tool);
    this.createUI(g);
    var c;
    this.HOTKEYS_ID = "Teratek.Beeline.Hotkeys";
    g = [];
    g.push({
        keycodes: [Teratek.Viewing.theHotkeyManager.KEYCODES.CONTROL, Teratek.Viewing.theHotkeyManager.KEYCODES.ALT],
        onPress: function() {
            c = h.getActiveNavigationTool();
            h.setActiveNavigationTool(f.tool.getName());
            return !0
        },
        onRelease: function() {
            h.setActiveNavigationTool(c ? c : h.defaultNavigationToolName);
            return !0
        }
    });
    Teratek.Viewing.theHotkeyManager.pushHotkeys(this.HOTKEYS_ID, g);
    this.onToolChanged = function(a) {
        -1 !== a.toolName.indexOf("beeline") && f.beelineButton.setState(a.active ? d.Button.State.ACTIVE : d.Button.State.INACTIVE)
    }
    ;
    h.addEventListener(Teratek.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    return !0
}
;
Teratek.Viewing.Extensions.Beeline.BeelineExtension.prototype.createUI = function(f) {
    var h = Teratek.Viewing.UI;
    f = f.getControl(Teratek.Viewing.TOOLBAR.NAVTOOLSID);
    var g = this.viewer
      , d = new h.Button("toolbar-beelineTool");
    d.setToolTip("Walk to");
    d.setIcon("teratek-icon-walk");
    d.onClick = function(a) {
        a = d.getState();
        a === h.Button.State.INACTIVE ? g.setActiveNavigationTool("beeline") : a === h.Button.State.ACTIVE && g.setActiveNavigationTool()
    }
    ;
    this.beelineButton = d;
    var c = f.getControl("toolbar-cameraSubmenuTool");
    c ? f.addControl(this.beelineButton, 
    {
        index: f.indexOf(c.getId())
    }) : f.addControl(this.beelineButton);
    var a = this
      , b = function() {
        g.removeEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, b);
        var c = Teratek.Viewing.Extensions.ViewerSettingTab.Navigation
          , d = g.getSettingsPanel(!0);
        a.viewerOption_LookHorId = d.addCheckbox(c, "Reverse horizontal look direction", !1, function(a) {
            g.setReverseHorizontalLookDirection(a)
        }
        , "reverseHorizontalLookDirection");
        a.viewerOption_LookVertId = d.addCheckbox(c, "Reverse vertical look direction", !1, function(a) {
            g.setReverseVerticalLookDirection(a)
        }
        , 
        "reverseVerticalLookDirection")
    }
    ;
    this.viewer.getSettingsPanel(!1) ? b() : this.viewer.addEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, b)
}
;
Teratek.Viewing.Extensions.Beeline.BeelineExtension.prototype.unload = function() {
    var f = this.viewer;
    f.removeEventListener(Teratek.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = void 0;
    Teratek.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);
    var h = f.getToolbar(!1);
    h && h.getControl(Teratek.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.beelineButton.getId());
    this.beelineButton = null ;
    this.viewer.getSettingsPanel(!1).removeCheckbox(this.viewerOption_LookHorId);
    this.viewer.getSettingsPanel(!1).removeCheckbox(this.viewerOption_LookVertId);
    f.getActiveNavigationTool() == this.tool.getName() && f.setActiveNavigationTool();
    f.toolController.deregisterTool(this.tool);
    this.tool = null ;
    return !0
}
;
Teratek.Viewing.theExtensionManager.registerExtension("Teratek.Beeline", Teratek.Viewing.Extensions.Beeline.BeelineExtension);
TeratekNamespace("Teratek.Viewing.Extensions.Beeline");
Teratek.Viewing.Extensions.Beeline.BeelineTool = function(f, h) {
    function g() {
        b.revertToStartState()
    }
    function d(a) {
        var b = {};
        b.target = a.target.clone();
        b.worldup = a.worldup.clone();
        b.position = a.position.clone();
        b.up = a.up.clone();
        for (var c = "isPerspective fov zoom aspect left right top bottom".split(" "), d = 0; d < c.length; d++)
            b[c[d]] = a[c[d]];
        return b
    }
    function c(a) {
        var b = new THREE.Vector3(a.x,a.y,1)
          , c = f.hitTestViewport(b.clone(), !1);
        if (!c || !c.intersectPoint)
            return [];
        a = new THREE.Raycaster;
        var b = b.clone()
          , d = f.camera
          , 
        g = new THREE.Vector3(b.x,b.y,1);
        b.z = -1;
        b = b.unproject(d);
        g = g.unproject(d);
        g.sub(b).normalize();
        a.set(n.isPerspective ? d.position : b, g);
        b = [];
        c = c.fragId instanceof Array ? c.fragId : [c.fragId];
        for (d = 0; d < c.length; d++)
            g = f.getRenderProxy(h.model, c[d]),
            VBIntersector.meshRayCast(g, a, b);
        b.sort(function(a, b) {
            return a.distance - b.distance
        }
        );
        return b
    }
    function a() {
        n.isPerspective || (n.toPerspective(),
        m.activatePivot(!1));
        28 < n.getFocalLength() && n.setFocalLength(28, !0)
    }
    var b = this
      , k = h.container
      , l = h.autocam
      , n = h.navigation
      , 
    m = h.utilities
      , q = ["beeline"]
      , r = 0
      , t = !1
      , w = 0
      , C = null 
      , E = null 
      , G = new THREE.Vector3
      , B = new THREE.Vector3
      , v = new THREE.Vector3
      , D = new THREE.Vector3
      , z = !1
      , H = new THREE.Vector3
      , I = new THREE.Vector3
      , J = null 
      , L = null ;
    this.getNames = function() {
        return q
    }
    ;
    this.getName = function() {
        return q[0]
    }
    ;
    this.activate = function(a) {
        w = 0;
        h.addEventListener(Teratek.Viewing.FULLSCREEN_MODE_EVENT, g);
        l.userLookSpeed = .8;
        this.showHUDMessage(!0)
    }
    ;
    this.deactivate = function() {
        h.removeEventListener(Teratek.Viewing.FULLSCREEN_MODE_EVENT, g);
        this.revertToStartState();
        this.showHUDMessage(!1)
    }
    ;
    this.getCursor = function() {
        return t ? "url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAQAAADYBBcfAAAACXBIWXMAABYlAAAWJQFJUiTwAAADGGlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjaY2BgnuDo4uTKJMDAUFBUUuQe5BgZERmlwH6egY2BmYGBgYGBITG5uMAxIMCHgYGBIS8/L5UBFTAyMHy7xsDIwMDAcFnX0cXJlYE0wJpcUFTCwMBwgIGBwSgltTiZgYHhCwMDQ3p5SUEJAwNjDAMDg0hSdkEJAwNjAQMDg0h2SJAzAwNjCwMDE09JakUJAwMDg3N+QWVRZnpGiYKhpaWlgmNKflKqQnBlcUlqbrGCZ15yflFBflFiSWoKAwMD1A4GBgYGXpf8EgX3xMw8BSMDVQYqg4jIKAUICxE+CDEESC4tKoMHJQODAIMCgwGDA0MAQyJDPcMChqMMbxjFGV0YSxlXMN5jEmMKYprAdIFZmDmSeSHzGxZLlg6WW6x6rK2s99gs2aaxfWMPZ9/NocTRxfGFM5HzApcj1xZuTe4FPFI8U3mFeCfxCfNN45fhXyygI7BD0FXwilCq0A/hXhEVkb2i4aJfxCaJG4lfkaiQlJM8JpUvLS19QqZMVl32llyfvIv8H4WtioVKekpvldeqFKiaqP5UO6jepRGqqaT5QeuA9iSdVF0rPUG9V/pHDBYY1hrFGNuayJsym740u2C+02KJ5QSrOutcmzjbQDtXe2sHY0cdJzVnJRcFV3k3BXdlD3VPXS8Tbxsfd99gvwT//ID6wIlBS4N3hVwMfRnOFCEXaRUVEV0RMzN2T9yDBLZE3aSw5IaUNak30zkyLDIzs+ZmX8xlz7PPryjYVPiuWLskq3RV2ZsK/cqSql01jLVedVPrHzbqNdU0n22VaytsP9op3VXUfbpXta+x/+5Em0mzJ/+dGj/t8AyNmf2zvs9JmHt6vvmCpYtEFrcu+bYsc/m9lSGrTq9xWbtvveWGbZtMNm/ZarJt+w6rnft3u+45uy9s/4ODOYd+Hmk/Jn58xUnrU+fOJJ/9dX7SRe1LR68kXv13fc5Nm1t379TfU75/4mHeY7En+59lvhB5efB1/lv5dxc+NH0y/fzq64Lv4T8Ffp360/rP8f9/AA0ADzT6lvFdAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAEtSURBVHja7JQxTkJBFEXPQ/xQEDG0ljRYSU1iLN2AtSWlC7Gw04QtGF2ApQVLIDY2hlgIDagJwWCOhf74JXxRYumbaib3ZO7c9zIhq1WBfzAfjJViDWPdYBq/w0pKITjhd7eGJwQkDu2I8rOFHYcmkqgDz4wfoeGZA01BHXtsbSla89ixZsH3an2LtpRUOQde28xFm17PgyPvVK1bl5yYEOtuq3rnyMQCXNJgiiTchuHCnhrGbYBMaXAJULGqlJz54O43bcFdH5xZUqpWJJWW7duza/tDmTWJbbv27Fs2PS2m1iZRNeGcI/aAEevOgCKnbAI7DNjjhUmk1ouf7xgHbLgF3MSzT7wCaxxSiW3hnsf4OngLotj3ILO74CoWTWzOIGcTXab4/6z+CnwbAGjXSZC++vLvAAAAAElFTkSuQmCC), auto" : 
        1 >= w ? "url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAQdJREFUeNq0k0GOgzAMRZ+jHI4VO4410qzam0aCjbsoaS1PUgfoWIqAEPnZ3z8AN0DNWoFfVeUbC0BtrOtaISNhC3tvGkC2P7ZtY1kWgHul90JEtCYTkVqo7O844LPyeZ51RJ5atQ3biZeolFJ0miYd1d4nd5A/gB+g7E++AFB7VqzWIkKkfdW/d27P8RpE4p8jRy7Z9ZBOpSEgRRb0MAv0lmxZNEXJj0IACTvwrfeksJBW9a0Z6NEh+vl4UI6qHzHBJ4nyFQv6YoaG3Ls80X7vTIqS1W+vdWvArfuSG/pplPzTBRy6ybaLkSSHAFcThoCe/c6C81n7jUY6a78rHQigftBnQY8BAEubfpuApyq2AAAAAElFTkSuQmCC), auto" : 
        null 
    }
    ;
    this.update = function() {
        var a = n.getCamera()
          , b = t = !1;
        if (1 === w) {
            var c = H.clone().sub(I);
            if (0 !== c.x || 0 !== c.y) {
                t = !0;
                I.x += .7 * c.x;
                I.y += .7 * c.y;
                var b = n.getWorldUpVector().dot(n.getCameraUpVector())
                  , f = h.prefs.reverseHorizontalLookDirection ? -1 : 1
                  , g = h.prefs.reverseVerticalLookDirection ? -1 : 1;
                c.x *= 0 > b ? -f : f;
                c.y *= g;
                l.sync(n.getCamera());
                l.look(c);
                b = !0;
                J = d(a)
            }
        }
        return b
    }
    ;
    this.revertToStartState = function() {
        m.pivotActive(!1);
        r = 0;
        z = !0
    }
    ;
    this.attemptFlight = function(a, d) {
        var f = c(a);
        0 < f.length && (G = f[0].point,
        B = f[f.length - 
        1].point,
        b.fly(1E3, d))
    }
    ;
    this.fly = function(c, d) {
        m.setPivotPoint(0 === d ? G : B, !0, !0);
        a();
        v = n.getPosition();
        E = c;
        switch (d) {
        case 0:
            D = v.clone().lerp(G, .8);
            break;
        case 1:
            var f = 2 * l.camera.near
              , g = B.clone().sub(v).length()
              , f = f / g;
            m.setPivotPoint(v.clone().lerp(B, 1 + 10 * f), !0, !0);
            D = v.clone().lerp(B, 1 + f);
            break;
        default:
            return
        }
        r = 1;
        z = !1;
        C = null ;
        requestAnimationFrame(b.step)
    }
    ;
    this.step = function(a) {
        var c = n.getCamera();
        if (!z) {
            if (null  === C)
                J = d(c),
                C = a;
            else {
                var f;
                a: if (f = J,
                c.target.equals(f.target) && c.position.equals(f.position) && 
                c.worldup.equals(f.worldup) && c.up.equals(f.up)) {
                    for (var g = "isPerspective fov zoom aspect left right top bottom".split(" "), h = 0; h < g.length; h++)
                        if (c[g[h]] !== f[g[h]]) {
                            f = !1;
                            break a
                        }
                    f = !0
                } else
                    f = !1;
                if (!f) {
                    b.revertToStartState();
                    return
                }
            }
            a -= C;
            f = a < E ? a / E : 1;
            f = v.clone().lerp(D, f);
            g = n.getEyeVector();
            g.multiplyScalar(n.getPivotPoint().sub(n.getPosition()).length() / g.length());
            n.setView(f, g.add(f));
            J = d(c);
            m.activatePivot(!1);
            a < E ? requestAnimationFrame(b.step) : b.revertToStartState()
        }
    }
    ;
    this.handleGesture = function(a) {
        switch (a.type) {
        case "dragstart":
            return L = 
            "drag",
            this.handleButtonDown(a, 0);
        case "dragmove":
            return "drag" === L ? this.handleMouseMove(a) : !1;
        case "dragend":
            if ("drag" === L)
                return this.handleButtonUp(a, 0),
                L = null ,
                !0
        }
        return !1
    }
    ;
    this.handleButtonDown = function(a, b) {
        w += 1 << b;
        return 0 === b ? (I.x = H.x = a.canvasX,
        I.y = H.y = a.canvasY,
        !0) : !1
    }
    ;
    this.handleButtonUp = function(a, b) {
        w -= 1 << b;
        return 0 === b ? !0 : !1
    }
    ;
    this.handleSingleClick = function(a, c) {
        if (0 === c) {
            var d = {
                x: a.normalizedX,
                y: a.normalizedY
            };
            switch (r) {
            case 0:
                b.attemptFlight(d, 0);
                break;
            case 1:
                b.revertToStartState()
            }
        } else
            return this.revertToStartState(),
            !1;
        return !0
    }
    ;
    this.handleSingleTap = function(a) {
        return this.handleSingleClick(a, 0)
    }
    ;
    this.handleDoubleTap = function(a) {
        return a.pointers && 1 === a.pointers.length ? (b.attemptFlight({
            x: a.normalizedX,
            y: a.normalizedY
        }, 1),
        !0) : !1
    }
    ;
    this.handleDoubleClick = function(a, c) {
        return 0 === c ? (b.attemptFlight({
            x: a.normalizedX,
            y: a.normalizedY
        }, 1),
        !0) : !1
    }
    ;
    this.handleMouseMove = function(b) {
        H.x = b.canvasX;
        H.y = b.canvasY;
        return 1 === w ? (a(),
        !0) : !1
    }
    ;
    this.handleBlur = function(a) {
        this.revertToStartState();
        return !1
    }
    ;
    this.showOrthoWarningMessage = 
    function() {
        Teratek.Viewing.Private.HudMessage.displayMessage(k, {
            msgTitleKey: "Orthographic View Set",
            messageKey: "The view is set to Orthographic Beeline",
            messageDefaultValue: "The view is set to Orthographic. Using this tool will switch to Perspective."
        })
    }
    ;
    this.showFocalWarningMessage = function() {
        Teratek.Viewing.Private.HudMessage.displayMessage(k, {
            msgTitleKey: "Long Focal Length View Set",
            messageKey: "The view is set to a long focal length",
            messageDefaultValue: "This view has a long focal length. Using this tool will set a short focal length."
        })
    }
    ;
    this.watchCamera = function(a) {
        if (h.toolController.getActiveToolName() === q[0] || h.toolController.getActiveToolName() === q[1]) {
            a = (a = n.getCamera()) && !a.isPerspective;
            var c = 28 < n.getFocalLength();
            a ? b.showOrthoWarningMessage() : c ? b.showFocalWarningMessage() : Teratek.Viewing.Private.HudMessage.dismiss()
        }
    }
    ;
    this.showHUDMessage = function(a) {
        var c = n.getCamera()
          , c = c && !c.isPerspective
          , d = 28 < n.getFocalLength();
        a && c ? b.showOrthoWarningMessage() : a && d ? b.showFocalWarningMessage() : Teratek.Viewing.Private.HudMessage.dismiss();
        a ? h.addEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, b.watchCamera) : h.removeEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, b.watchCamera)
    }
}
;
(function() {
    function f(a, b, c) {
        return function() {
            var f = b.getState();
            f === d.Button.State.INACTIVE ? (a.setActiveNavigationTool(c),
            b.setState(d.Button.State.ACTIVE)) : f === d.Button.State.ACTIVE && (a.setActiveNavigationTool(),
            b.setState(d.Button.State.INACTIVE))
        }
    }
    var h = TeratekNamespace("Teratek.Viewing.Extensions.DefaultTools")
      , g = Teratek.Viewing
      , d = g.UI
      , c = function(a, b) {
        g.Extension.call(this, a, b)
    }
    ;
    c.prototype = Object.create(g.Extension.prototype);
    c.prototype.constructor = c;
    c.prototype.load = function() {
        var a = 
        this.viewer
          , b = new g.FovTool(a)
          , c = new g.WorldUpTool(a.impl,a);
        a.toolController.registerTool(b);
        a.toolController.registerTool(c);
        this.createUI();
        this.initCameraStateMachine();
        this.initFocalLengthOverlay();
        return !0
    }
    ;
    c.prototype.createUI = function() {
        var a = this.viewer
          , b = a.getToolbar(!0).getControl(g.TOOLBAR.NAVTOOLSID);
        b.returnToDefault = function() {}
        ;
        if ("3d" === this.options.mode) {
            var c = new d.ComboButton("toolbar-orbitTools");
            c.setToolTip("Orbit");
            c.setIcon("teratek-icon-orbit-constrained");
            this.createOrbitSubmenu(c);
            b.addControl(c);
            b.orbittoolsbutton = c;
            c.setState(d.Button.State.ACTIVE);
            b.returnToDefault = function() {
                c.setState(d.Button.State.ACTIVE)
            }
        }
        var h = new d.Button("toolbar-panTool");
        h.setToolTip("Pan");
        h.setIcon("teratek-icon-pan");
        h.onClick = f(a, h, "pan");
        b.addControl(h);
        b.panbutton = h;
        h = new d.Button("toolbar-zoomTool");
        h.setToolTip("Zoom");
        h.setIcon("teratek-icon-zoom");
        h.onClick = f(a, h, "dolly");
        b.addControl(h);
        b.dollybutton = h;
        a = new d.ComboButton("toolbar-cameraSubmenuTool");
        a.setToolTip("Camera interactions");
        a.setIcon("teratek-icon-camera");
        a.saveAsDefault();
        this.createCameraSubmenu(a);
        b.addControl(a);
        b.camerabutton = a
    }
    ;
    c.prototype.createOrbitSubmenu = function(a) {
        var b = this.viewer
          , c = b.getToolbar(!0).getControl(g.TOOLBAR.NAVTOOLSID)
          , h = new d.Button("toolbar-freeOrbitTool");
        h.setToolTip("Free orbit");
        h.setIcon("teratek-icon-orbit-free");
        h.onClick = f(b, h, "freeorbit");
        a.addControl(h);
        c.freeorbitbutton = h;
        h = new d.Button("toolbar-orbitTool");
        h.setToolTip("Orbit");
        h.setIcon("teratek-icon-orbit-constrained");
        h.onClick = f(b, h, "orbit");
        a.addControl(h);
        c.orbitbutton = 
        h;
        a.onClick = h.onClick
    }
    ;
    c.prototype.createCameraSubmenu = function(a) {
        var b = this
          , c = this.viewer
          , h = c.getToolbar(!0).getControl(g.TOOLBAR.NAVTOOLSID);
        if (isTouchDevice()) {
            var n = new d.Button("toolbar-homeTool");
            n.setToolTip("Home");
            n.setIcon("teratek-icon-home");
            n.onClick = function() {
                c.navigation.setRequestHomeView(!0);
                var b = c.getDefaultNavigationToolName();
                c.setActiveNavigationTool(b);
                a.restoreDefault()
            }
            ;
            a.addControl(n);
            h.homebutton = n
        }
        n = new d.Button("toolbar-fitToViewTool");
        n.setToolTip("Fit to view");
        n.setIcon("teratek-icon-fit-to-view");
        n.onClick = function(d) {
            c.fitToView("3d" === b.options.mode ? c.getSelection() : void 0);
            d = c.getDefaultNavigationToolName();
            c.setActiveNavigationTool(d);
            a.restoreDefault()
        }
        ;
        a.addControl(n);
        h.fovbutton = n;
        "3d" === this.options.mode && (n = new d.Button("toolbar-focalLengthTool"),
        n.setToolTip("Focal length"),
        n.setIcon("teratek-icon-fov"),
        n.onClick = f(c, n, "fov"),
        a.addControl(n),
        h.fovbutton = n);
        n = new d.Button("toolbar-rollTool");
        n.setToolTip("Roll");
        n.setIcon("teratek-icon-roll");
        n.onClick = f(c, n, "worldup");
        a.addControl(n);
        h.rollbutton = n
    }
    ;
    c.prototype.initCameraStateMachine = function(a) {
        var b = this
          , c = this.viewer
          , d = c.getToolbar(!0).getControl(g.TOOLBAR.NAVTOOLSID);
        this.toolChangedHandler = function(a) {
            "fov" === a.toolName && b.showFocalLengthOverlay(a.active)
        }
        ;
        c.addEventListener(g.TOOL_CHANGE_EVENT, this.toolChangedHandler);
        this.navChangedHandler = function(a) {
            c.getDefaultNavigationToolName() === a.id && d.returnToDefault()
        }
        ;
        c.addEventListener(g.NAVIGATION_MODE_CHANGED_EVENT, this.navChangedHandler)
    }
    ;
    c.prototype.initFocalLengthOverlay = 
    function() {
        var a = this.focallength = document.createElement("div");
        a.className = "focallength";
        var b = document.createElement("table")
          , c = document.createElement("tbody");
        b.appendChild(c);
        a.appendChild(b);
        this.viewer.container.appendChild(a);
        b = c.insertRow(-1);
        c = b.insertCell(0);
        c.setAttribute("data-i18n", "Focal Length");
        c.textContent = Teratek.Viewing.i18n.translate("Focal Length");
        c = b.insertCell(1);
        c.textContent = "";
        c.style.width = "4em";
        c.style.textAlign = "right";
        this.fovCell = c;
        a.style.visibility = "hidden"
    }
    ;
    c.prototype.showFocalLengthOverlay = 
    function(a) {
        function b(a) {
            a ? g.Private.HudMessage.displayMessage(q.container, {
                msgTitleKey: "Orthographic View Set",
                messageKey: "The view is set to Orthographic",
                messageDefaultValue: "The view is set to Orthographic. Changing the focal length will switch to Perspective."
            }) : g.Private.HudMessage.dismiss()
        }
        function c(a) {
            a && d();
            h.focallength && (h.focallength.style.visibility = a ? "visible" : "hidden")
        }
        function d() {
            var a = q.getFocalLength();
            r !== a && (r = a,
            h.fovCell.textContent = a.toString() + " mm")
        }
        function f(a) {
            d();
            "fov" === 
            q.toolController.getActiveToolName() && (a = (a = q.navigation.getCamera()) && !a.isPerspective,
            c(!a),
            b(a))
        }
        var h = this
          , q = this.viewer
          , r = 0
          , t = q.navigation.getCamera()
          , t = t && !t.isPerspective;
        c(a && !t);
        b(a && t);
        a ? q.addEventListener(g.CAMERA_CHANGE_EVENT, f) : q.removeEventListener(g.CAMERA_CHANGE_EVENT, f)
    }
    ;
    c.prototype.unload = function() {
        this.destroyUI();
        return !0
    }
    ;
    c.prototype.destroyUI = function() {
        var a = this.viewer
          , b = a.getToolbar(!1);
        if (!b)
            return !0;
        b = b.getControl(g.TOOLBAR.NAVTOOLSID);
        if (!b)
            return !0;
        "3d" === this.options.mode && 
        (b.orbittoolsbutton.subMenu.removeEventListener(d.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED, b.orbittoolsbutton.subMenuActiveButtonChangedHandler(b)),
        b.removeControl(b.orbittoolsbutton.getId()),
        b.orbittoolsbutton = null ,
        b.orbitbutton.onClick = null ,
        b.orbitbutton = null ,
        b.freeorbitbutton.onClick = null ,
        b.freeorbitbutton = null );
        b.removeControl(b.panbutton.getId());
        b.panbutton.onClick = null ;
        b.panbutton = null ;
        b.removeControl(b.dollybutton.getId());
        b.dollybutton.onClick = null ;
        b.dollybutton = null ;
        b.camerabutton.subMenu.removeEventListener(d.RadioButtonGroup.Event.ACTIVE_BUTTON_CHANGED, 
        b.camerabutton.subMenuActiveButtonChangedHandler(b));
        b.removeControl(b.camerabutton.getId());
        b.camerabutton.onClick = null ;
        b.camerabutton = null ;
        b.rollbutton.onClick = null ;
        b.rollbutton = null ;
        b.fovbutton.onClick = null ;
        this.focallength = b.fovbutton = null ;
        a.removeEventListener(g.TOOL_CHANGE_EVENT, this.toolChangedHandler);
        this.toolChangedHandler = null ;
        a.removeEventListener(g.NAVIGATION_MODE_CHANGED_EVENT, this.navChangedHandler);
        this.navChangedHandler = null ;
        return !0
    }
    ;
    h.NavToolsExtension = c;
    g.theExtensionManager.registerExtension("Teratek.DefaultTools.NavTools", 
    c)
}
)();
(function() {
    var f = TeratekNamespace("Teratek.Viewing.Extensions.Measure")
      , h = Teratek.Viewing
      , g = h.UI
      , d = function(c, a) {
        Teratek.Viewing.Extension.call(this, c, a)
    }
    ;
    d.prototype = Object.create(Teratek.Viewing.Extension.prototype);
    d.prototype.constructor = d;
    d.prototype.load = function() {
        function c() {
            a.createUI()
        }
        var a = this
          , b = this.viewer;
        this.escapeHotkeyId = "Teratek.Measure.Hotkeys.Escape";
        if (!b.toolController)
            return !1;
        this.tool = new f.MeasureTool(b,{
            onCloseCallback: function(b) {
                a.enableMeasureTool(!1)
            }
        });
        b.toolController.registerTool(this.tool);
        this.viewer.toolbar ? 0 < this.viewer.toolbar.getControl(h.TOOLBAR.MODELTOOLSID).getNumberOfControls() ? this.createUI() : this.viewer.addEventListener(h.TOOLBAR_CREATED_EVENT, c) : this.viewer.addEventListener(h.TOOLBAR_CREATED_EVENT, c);
        return !0
    }
    ;
    d.prototype.unload = function() {
        var c = this.viewer;
        this.destroyUI();
        c.toolController.deregisterTool(this.tool);
        this.tool = null ;
        return !0
    }
    ;
    d.prototype.enableMeasureTool = function(c) {
        if (this.tool) {
            var a = this.viewer.toolController
              , b = this.tool.isActive();
            if (c && !b)
                return a.activateTool("measure"),
                this.measureToolButton.setState(Teratek.Viewing.UI.Button.State.ACTIVE),
                !0;
            if (!c && b)
                return a.deactivateTool("measure"),
                this.measureToolButton.setState(Teratek.Viewing.UI.Button.State.INACTIVE),
                !0
        }
        return !1
    }
    ;
    d.prototype.createUI = function() {
        var c = this
          , a = this.viewer;
        this.measureToolButton = null ;
        a = a.getToolbar(!0).getControl(h.TOOLBAR.MODELTOOLSID);
        this.measureToolButton = new g.Button("toolbar-measureTool");
        this.measureToolButton.setToolTip("Measure");
        this.measureToolButton.setIcon("teratek-icon-measure");
        this.measureToolButton.onClick = function(a) {
            c.enableMeasureTool(!c.tool.isActive())
        }
        ;
        this.onMeasureButtonStateChange = function(a) {
            a.state === g.Button.State.ACTIVE ? c.enableMeasureTool(!0) : a.state === g.Button.State.INACTIVE && c.enableMeasureTool(!1)
        }
        ;
        this.measureToolButton.addEventListener(g.Button.Event.STATE_CHANGED, this.onMeasureButtonStateChange);
        a.addControl(this.measureToolButton, {
            index: 0
        });
        h.theHotkeyManager.pushHotkeys(this.escapeHotkeyId, [{
            keycodes: [h.theHotkeyManager.KEYCODES.ESCAPE],
            onRelease: function() {
                return c.enableMeasureTool(!1)
            }
        }])
    }
    ;
    d.prototype.destroyUI = function() {
        var c = this.viewer;
        this.measureToolButton && this.measureToolButton.removeEventListener(g.Button.Event.STATE_CHANGED, this.onMeasureButtonStateChange);
        if (c = c.getToolbar(!1))
            if (c = c.getControl(h.TOOLBAR.MODELTOOLSID)) {
                if (this.measureToolButton) {
                    var a = c.getControl("toolbar-inspectSubMenu");
                    a ? a.removeControl(this.measureToolButton.getId()) : c.removeControl(this.measureToolButton.getId())
                }
                this.measureToolButton = null 
            }
        h.theHotkeyManager.popHotkeys(this.escapeHotkeyId)
    }
    ;
    f.MeasureExtension = 
    d;
    h.theExtensionManager.registerExtension("Teratek.Measure", d)
}
)();
TeratekNamespace("Teratek.Viewing.Extensions.Measure");
Teratek.Viewing.Extensions.Measure.MeasureTool = function(f, h) {
    function g() {
        z.updateLabelPositions()
    }
    function d() {
        a.clearMeasurement()
    }
    function c(c) {
        var d = this
          , f = !1
          , g = null 
          , h = null 
          , k = null 
          , l = null 
          , q = null 
          , B = null 
          , r = null 
          , v = {
            first: {},
            second: {}
        }
          , z = {
            first: {},
            second: {}
        }
          , F = {
            first: {},
            second: {}
        }
          , H = {
            xyz: {
                axis: !1,
                color: "FF9900"
            },
            x: {
                axis: !0,
                color: "F12C2C"
            },
            y: {
                axis: !0,
                color: "0BB80B"
            },
            z: {
                axis: !0,
                color: "2C2CF1"
            }
        }
          , J = {}
          , L = [];
        this.showFirstVertex = function(a) {
            var b = this.setScale(a);
            this.showEndPoint("first", a, b)
        }
        ;
        this.showSecondVertex = 
        function(a) {
            var b = this.setScale(a);
            this.showEndPoint("second", a, b)
        }
        ;
        this.showEndPoint = function(a, c, d) {
            g || (g = new THREE.MeshPhongMaterial({
                color: 2002943,
                ambient: 2002943,
                opacity: .7,
                transparent: !0,
                depthTest: !1,
                depthWrite: !1
            }),
            b.impl.createOverlayScene("MeasureTool-endPoint"));
            var f = v[a]
              , h = f.mesh;
            h || (f.geometry = new THREE.SphereGeometry(1),
            h = f.mesh = new THREE.Mesh(f.geometry,g),
            b.impl.addOverlay("MeasureTool-endPoint", h));
            h.scale.x = d;
            h.scale.y = d;
            h.scale.z = d;
            h.position.set(c.x, c.y, c.z);
            h.visible = !0;
            b.impl.invalidate(!1, 
            !1, !0);
            if (t || D)
                d = f.label,
                d || (d = f.label = document.createElement("div"),
                d.className = "measure-label",
                b.container.appendChild(d),
                h = document.createElement("div"),
                h.className = "teratek-icon-" + a + " measure-label-icon",
                d.appendChild(h)),
                d.classList.toggle("visible", !0),
                f.position = c.clone(),
                this.updateLabelPositions()
        }
        ;
        this.setScale = function(a) {
            var c = b.navigation
              , d = c.getCamera()
              , f = c.getEyeVector()
              , g = c.getPosition();
            a = a.clone();
            d = d.isPerspective ? a.sub(g).dot(f.normalize()) : c.getEyeVector().length();
            f = c.getVerticalFov();
            d = 2 * d * Math.tan(THREE.Math.degToRad(.5 * f));
            c = c.getScreenViewport();
            return 5 * d / (c.height * (window.devicePixelRatio || 1))
        }
        ;
        this.updateScale = function() {
            var a = b.impl.overlayScenes["MeasureTool-endPoint"];
            if (a)
                for (var a = a.scene, c = 0; c < a.children.length; c++) {
                    var d = a.children[c];
                    if (d) {
                        var f = this.setScale(d.position);
                        d.scale.x = f;
                        d.scale.y = f;
                        d.scale.z = f
                    }
                }
            if (a = b.impl.overlayScenes["MeasureTool-extensionLine"])
                for (a = a.scene,
                c = 0; c < a.children.length; c++)
                    if (d = a.children[c])
                        f = this.setScale(d.geometry.vertices[0]),
                        d.material.dashSize = 
                        4 * f,
                        d.material.gapSize = 2 * f;
            if (a = b.impl.overlayScenes["MeasureTool-edge"])
                for (a = a.scene,
                c = 0; c < a.children.length; c++)
                    (d = a.children[c]) && this.setCylinderScale(d);
            if (a = b.impl.overlayScenes["MeasureTool-angle-outline"])
                for (a = a.scene,
                c = 0; c < a.children.length; c++)
                    (d = a.children[c]) && this.setCylinderScale(d);
            for (var g in H)
                H.hasOwnProperty(g) && (a = H[g],
                a.line && this.setCylinderScale(a.line))
        }
        ;
        this.showFirstEdge = function(a, b) {
            this.showEdge("first", a, b)
        }
        ;
        this.showSecondEdge = function(a, b) {
            this.showEdge("second", 
            a, b)
        }
        ;
        this.showEdge = function(a, c, d) {
            h || (h = new THREE.MeshPhongMaterial({
                color: 2002943,
                ambient: 2002943,
                opacity: .7,
                transparent: !0,
                depthTest: !1,
                depthWrite: !1,
                side: THREE.DoubleSide
            }),
            b.impl.createOverlayScene("MeasureTool-edge"));
            var f = z[a];
            f.line && b.impl.removeMultipleOverlays("MeasureTool-edge", f.line);
            f.line = this.drawEdgeAsCylinder(c, h, 5, 1);
            b.impl.addMultipleOverlays("MeasureTool-edge", f.line);
            if (t || D) {
                c = f.label;
                if (!c) {
                    c = f.label = document.createElement("div");
                    c.className = "measure-label";
                    b.container.appendChild(c);
                    var g = document.createElement("div");
                    g.className = "teratek-icon-" + a + " measure-label-icon";
                    c.appendChild(g)
                }
                c.classList.toggle("visible", !0);
                f.intersectPoint = d.clone();
                this.updateLabelPositions()
            }
        }
        ;
        this.drawEdgeAsCylinder = function(a, b, c, d) {
            var f = [];
            if (1 == d)
                for (d = 0; d < a.vertices.length; d += 2) {
                    var g = this.cylinderMesh(a.vertices[d], a.vertices[d + 1], b, c);
                    this.setCylinderScale(g);
                    f.push(g)
                }
            else
                for (d = 0; d < a.vertices.length - 1; d++)
                    g = this.cylinderMesh(a.vertices[d], a.vertices[d + 1], b, c),
                    this.setCylinderScale(g),
                    f.push(g);
            return f
        }
        ;
        this.drawLineAsCylinder = function(a, b, c) {
            var d;
            2 == a.vertices.length && (d = this.cylinderMesh(a.vertices[0], a.vertices[1], b, c),
            this.setCylinderScale(d));
            return d
        }
        ;
        this.cylinderMesh = function(a, b, c, d) {
            var f = (new THREE.Vector3).subVectors(b, a)
              , g = new THREE.Matrix4;
            g.lookAt(a, b, (new THREE.Object3D).up);
            g.multiply((new THREE.Matrix4).set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1));
            d = new THREE.CylinderGeometry(.1 * d,.1 * d,f.length(),8,1,!0);
            c = new THREE.Mesh(d,c);
            c.applyMatrix(g);
            c.position.x = (b.x + a.x) / 2;
            c.position.y = 
            (b.y + a.y) / 2;
            c.position.z = (b.z + a.z) / 2;
            return c
        }
        ;
        this.setCylinderScale = function(a) {
            var b = this.setScale(a.position);
            a.scale.x = b;
            a.scale.z = b
        }
        ;
        this.showFirstFace = function(a, b) {
            this.showFace("first", a, b)
        }
        ;
        this.showSecondFace = function(a, b) {
            this.showFace("second", a, b)
        }
        ;
        this.showFace = function(a, c, d) {
            k || (k = new THREE.MeshPhongMaterial({
                color: 2002943,
                ambient: 2002943,
                opacity: .7,
                transparent: !0,
                depthTest: !1,
                depthWrite: !1,
                side: THREE.DoubleSide
            }),
            b.impl.createOverlayScene("MeasureTool-face"));
            var f = F[a];
            f.mesh && b.impl.removeOverlay("MeasureTool-face", 
            f.mesh);
            f.mesh = new THREE.Mesh(c,k);
            b.impl.addOverlay("MeasureTool-face", f.mesh);
            if (t || D) {
                c = f.label;
                if (!c) {
                    c = f.label = document.createElement("div");
                    c.className = "measure-label";
                    b.container.appendChild(c);
                    var g = document.createElement("div");
                    g.className = "teratek-icon-" + a + " measure-label-icon";
                    c.appendChild(g)
                }
                c.classList.toggle("visible", !0);
                f.intersectPoint = d.clone();
                this.updateLabelPositions()
            }
        }
        ;
        this.drawExtensionFace = function(a, c, d) {
            r || (r = new THREE.MeshPhongMaterial({
                color: 6737151,
                ambient: 52479,
                opacity: .2,
                transparent: !0,
                depthTest: !1,
                depthWrite: !1,
                side: THREE.DoubleSide
            }),
            b.impl.createOverlayScene("MeasureTool-extensionFace"));
            a = new THREE.Mesh(a,r);
            a.position.set(c.x, c.y, c.z);
            c = a.position.clone();
            c.add(d);
            a.lookAt(c);
            a.updateMatrixWorld();
            b.impl.addOverlay("MeasureTool-extensionFace", a)
        }
        ;
        this.getEdgeLength = function(a) {
            var c = 0;
            a = a.clone().vertices;
            for (var d = 0; d < a.length; d += 2)
                b.model.is2d() && b.model.pageToModel(a[d], a[d + 1], P),
                c += a[d].distanceTo(a[d + 1]);
            c = Teratek.Viewing.Private.convertUnits(b.model.getUnitString(), 
            E, c);
            return Teratek.Viewing.Private.formatValueWithUnits(c, E, 3, G)
        }
        ;
        this.getFaceArea = function(a) {
            var c = 0;
            a = a.vertices;
            for (var d = new THREE.Vector3, f = new THREE.Vector3, g = 0; g < a.length; g += 3)
                d.subVectors(a[g + 1], a[g]),
                f.subVectors(a[g + 2], a[g]),
                c += d.length() * f.length() * Math.sin(d.angleTo(f)) / 2;
            c = Teratek.Viewing.Private.convertUnits(b.model.getUnitString(), E, c, "square");
            return E ? Teratek.Viewing.Private.formatValueWithUnits(c, E + "^2", 3, G) : Teratek.Viewing.Private.formatValueWithUnits(c, null , 3, G)
        }
        ;
        this.updateLabels = 
        function() {
            w === SNAP_EDGE ? z.first.label.children[0].textContent = this.getEdgeLength(n) : w === SNAP_FACE && (F.first.label.children[0].textContent = this.getFaceArea(n));
            C === SNAP_EDGE ? z.second.label.children[0].textContent = this.getEdgeLength(m) : C === SNAP_FACE && (F.second.label.children[0].textContent = this.getFaceArea(m))
        }
        ;
        this.updateLabelPositions = function() {
            function a(c, d, f) {
                var g = b.navigation.getCamera()
                  , h = b.navigation.getScreenViewport();
                c = new THREE.Vector3(c,d,f);
                c = c.project(g);
                return {
                    x: Math.round((c.x + 1) / 
                    2 * h.width) + 5,
                    y: Math.round((-c.y + 1) / 2 * h.height) + 5
                }
            }
            for (var c in H)
                if (H.hasOwnProperty(c)) {
                    var d = H[c]
                      , f = d.label;
                    f && (d = a((d.p1.x + d.p2.x) / 2, (d.p1.y + d.p2.y) / 2, (d.p1.z + d.p2.z) / 2),
                    f.style.top = d.y + "px",
                    f.style.left = d.x + "px",
                    L.push(f))
                }
            J && (f = J.label) && (d = a((J.p1.x + J.p2.x) / 2, (J.p1.y + J.p2.y) / 2, (J.p1.z + J.p2.z) / 2),
            f.style.top = d.y + "px",
            f.style.left = d.x + "px",
            L.push(f));
            for (c in F)
                F.hasOwnProperty(c) && (d = F[c],
                f = d.label,
                d = d.intersectPoint,
                f && d && (d = a(d.x, d.y, d.z),
                f.style.top = d.y + "px",
                f.style.left = d.x + "px",
                L.push(f)));
            for (c in z)
                z.hasOwnProperty(c) && (d = z[c],
                f = d.label,
                d = d.intersectPoint,
                f && d && (d = a(d.x, d.y, d.z),
                f.style.top = d.y + "px",
                f.style.left = d.x + "px",
                L.push(f)));
            for (c in v)
                v.hasOwnProperty(c) && (d = v[c],
                f = d.label,
                d = d.position,
                f && d && (d = a(d.x, d.y, d.z),
                f.style.top = d.y + "px",
                f.style.left = d.x + "px",
                L.push(f)));
            for (c = 0; c < L.length; c++)
                for (f = 0; f < c; f++)
                    this.labelsOverlapDetection(L[f], L[c]);
            L = []
        }
        ;
        this.labelsOverlapDetection = function(a, b) {
            var c = a.getBoundingClientRect()
              , d = b.getBoundingClientRect();
            d.top <= c.bottom && d.bottom >= 
            c.top && (d.right >= c.left && d.right <= c.right ? b.style.left = parseInt(b.style.left, 10) - (d.right - c.left) + "px" : d.left >= c.left && d.left <= c.right ? b.style.left = parseInt(b.style.left, 10) + (c.right - d.left) + "px" : d.left <= c.left && d.right >= c.right && (b.style.left = parseInt(b.style.left, 10) + (c.right - d.left) + "px"))
        }
        ;
        this.drawLine = function(a, c) {
            function g(a, c, h, k, l, m, n, q) {
                var B = H[a]
                  , r = B.line
                  , v = B.label;
                c = new THREE.Vector3(c,h,k);
                l = new THREE.Vector3(l,m,n);
                r && (b.impl.removeOverlay("MeasureTool-" + a, r),
                B.line = null );
                v && v.classList.remove("visible");
                c.distanceTo(l) >= Math.pow(.1, G) && q && (q = "xyz" === a || !f && t,
                r || (B.material = new THREE.MeshBasicMaterial({
                    color: parseInt(B.color, 16),
                    depthTest: !1,
                    depthWrite: !1
                }),
                B.overlayName = "MeasureTool-" + a,
                b.impl.createOverlayScene(B.overlayName)),
                B.material.opacity = t ? 1 : .7,
                b.impl.clearOverlay(B.overlayName),
                r = B.geometry = new THREE.Geometry,
                r.vertices.push(c),
                r.vertices.push(l),
                r = B.line = d.drawLineAsCylinder(r, B.material, "xyz" === a ? 5 : "z" === a ? 1 : 2),
                b.impl.addOverlay(B.overlayName, r),
                r.visible = q,
                B.p1 = c,
                B.p2 = l,
                "xyz" != a || t) && 
                (v || (v = B.label = document.createElement("div"),
                v.className = "measure-length",
                "xyz" === a ? (r = document.createElement("div"),
                r.className = "measure-length-text",
                v.appendChild(r)) : v.style.pointerEvents = "none",
                B.axis && (v.className = "teratek-icon-axis-" + a + " measure-label-axis measure-label-axis-" + a),
                b.container.appendChild(v)),
                B.axis || d.updateDistance(),
                v.classList.toggle("visible", q))
            }
            g("xyz", a.x, a.y, a.z, c.x, c.y, c.z, !0);
            var h = b.navigation.getAlignedUpVector()
              , k = Math.abs(h.x)
              , l = Math.abs(h.y)
              , h = Math.abs(h.z)
              , m = function(a, 
            b) {
                var c = Math.pow(.1, G);
                return Math.abs(a.x - b.x) >= c && Math.abs(a.y - b.y) < c && Math.abs(a.z - b.z) < c || Math.abs(a.y - b.y) >= c && Math.abs(a.x - b.x) < c && Math.abs(a.z - b.z) < c || Math.abs(a.z - b.z) >= c && Math.abs(a.x - b.x) < c && Math.abs(a.y - b.y) < c ? !1 : !0
            }
            (a, c);
            h > k && h > l ? (g("x", a.x, a.y, a.z, c.x, a.y, a.z, m),
            g("y", c.x, a.y, a.z, c.x, c.y, a.z, m),
            g("z", c.x, c.y, a.z, c.x, c.y, c.z, m)) : l > k && l > h ? (g("x", a.x, a.y, a.z, c.x, a.y, a.z, m),
            g("z", c.x, a.y, a.z, c.x, a.y, c.z, m),
            g("y", c.x, a.y, c.z, c.x, c.y, c.z, m)) : (g("y", a.x, a.y, a.z, a.x, c.y, a.z, m),
            g("z", a.x, c.y, 
            a.z, a.x, c.y, c.z, m),
            g("x", a.x, c.y, c.z, c.x, c.y, c.z, m));
            this.updateLabelPositions()
        }
        ;
        this.updateDistance = function() {
            var b = H.xyz.label;
            b && (b.children[0].textContent = a.getDistance("xyz"))
        }
        ;
        this.updateAngle = function() {
            var b = J.label;
            b && (b.children[0].textContent = a.getAngle())
        }
        ;
        this.drawExtensionLine = function(a, c, d) {
            var f = new THREE.Vector3
              , g = new THREE.Vector3;
            f.subVectors(c, a);
            g.subVectors(d, c);
            a = f.dot(g);
            f.subVectors(d, c);
            a = -a / f.dot(f);
            f.subVectors(d, c);
            f.multiplyScalar(a);
            f = f.add(c);
            if (0 > a)
                d = f;
            else if (1 < 
            a)
                c = d,
                d = f;
            else
                return;
            B || (B = new THREE.LineDashedMaterial({
                color: 13311,
                linewidth: 1,
                dashSize: 1,
                gapSize: .5,
                depthTest: !1,
                depthWrite: !1
            }),
            b.impl.createOverlayScene("MeasureTool-extensionLine"));
            B.opacity = t ? 1 : .7;
            f = this.setScale(c);
            B.dashSize = 4 * f;
            B.gapSize = 2 * f;
            f = new THREE.Geometry;
            f.vertices.push(c);
            f.vertices.push(d);
            f.computeLineDistances();
            c = new THREE.Line(f,B);
            b.impl.addOverlay("MeasureTool-extensionLine", c)
        }
        ;
        this.drawExtensionLinePointToPoint = function(a, c) {
            B || (B = new THREE.LineDashedMaterial({
                color: 13311,
                linewidth: 1,
                dashSize: 1,
                gapSize: .5,
                depthTest: !1,
                depthWrite: !1
            }),
            b.impl.createOverlayScene("MeasureTool-extensionLine"));
            B.opacity = t ? 1 : .7;
            var d = this.setScale(a);
            B.dashSize = 4 * d;
            B.gapSize = 2 * d;
            d = new THREE.Geometry;
            d.vertices.push(a);
            d.vertices.push(c);
            d.computeLineDistances();
            d = new THREE.Line(d,B);
            b.impl.addOverlay("MeasureTool-extensionLine", d)
        }
        ;
        this.nearestPointsInSegmentToSegment = function(a, b, c, d) {
            var f = new THREE.Vector3
              , g = new THREE.Vector3
              , h = new THREE.Vector3;
            f.subVectors(b, a);
            g.subVectors(d, c);
            h.subVectors(a, 
            c);
            d = f.dot(f);
            var k = f.dot(g), l = g.dot(g), m = f.dot(h), n = g.dot(h), q = d * l - k * k, B, r = q;
            b = q;
            .001 > q ? (B = 0,
            r = 1,
            q = n,
            b = l) : (B = k * n - l * m,
            q = d * n - k * m,
            0 > B ? (B = 0,
            q = n,
            b = l) : B > r && (B = r,
            q = n + k,
            b = l));
            0 > q ? (q = 0,
            0 > -m ? B = 0 : -m > d ? B = r : (B = -m,
            r = d)) : q > b && (q = b,
            0 > -m + k ? B = 0 : -m + k > d ? B = r : (B = -m + k,
            r = d));
            d = .001 > Math.abs(B) ? 0 : B / r;
            b = .001 > Math.abs(q) ? 0 : q / b;
            f.multiplyScalar(d);
            g.multiplyScalar(b);
            h.add(f);
            h.sub(g);
            f.add(a);
            g.add(c);
            return [f, g]
        }
        ;
        this.edgeToEdgeMeasure = function(a, b, c) {
            var d = I.getEndPointsInEdge(a);
            a = d[0].clone();
            var f = d[1].clone()
              , d = I.getEndPointsInEdge(b);
            b = d[0].clone();
            var d = d[1].clone()
              , g = this.nearestPointInPointToLine(a, b, d)
              , h = this.nearestPointInPointToLine(f, b, d)
              , k = new THREE.Vector3
              , l = new THREE.Vector3;
            c = this.nearestPointInPointToLine(c, a, f);
            if (a.distanceTo(b) < a.distanceTo(d) && a.distanceTo(b) < f.distanceTo(b) && a.distanceTo(b) < f.distanceTo(d)) {
                k.subVectors(a, f);
                l.subVectors(b, d);
                k.normalize();
                l.normalize();
                if (this.isEqualVectors(k, l, .01) || this.isInverseVectors(k, l, .01))
                    return this.drawLine(a, g),
                    this.drawExtensionLine(a, b, d),
                    [a, g];
                g = this.angleVectorToVector(k, 
                l);
                this.drawAngleLineToLine(a, c, b, d, g);
                return g
            }
            if (a.distanceTo(d) < a.distanceTo(b) && a.distanceTo(d) < f.distanceTo(b) && a.distanceTo(d) < f.distanceTo(d)) {
                k.subVectors(a, f);
                l.subVectors(d, b);
                k.normalize();
                l.normalize();
                if (this.isEqualVectors(k, l, .01) || this.isInverseVectors(k, l, .01))
                    return this.drawLine(a, g),
                    this.drawExtensionLine(a, b, d),
                    [a, g];
                g = this.angleVectorToVector(k, l);
                this.drawAngleLineToLine(a, c, d, b, g);
                return g
            }
            if (f.distanceTo(b) < a.distanceTo(b) && f.distanceTo(b) < a.distanceTo(d) && f.distanceTo(b) < 
            f.distanceTo(d)) {
                k.subVectors(f, a);
                l.subVectors(b, d);
                k.normalize();
                l.normalize();
                if (this.isEqualVectors(k, l, .01) || this.isInverseVectors(k, l, .01))
                    return this.drawLine(f, h),
                    this.drawExtensionLine(f, b, d),
                    [f, h];
                g = this.angleVectorToVector(k, l);
                this.drawAngleLineToLine(f, c, b, d, g);
                return g
            }
            k.subVectors(f, a);
            l.subVectors(d, b);
            k.normalize();
            l.normalize();
            if (this.isEqualVectors(k, l, .01) || this.isInverseVectors(k, l, .01))
                return this.drawLine(f, h),
                this.drawExtensionLine(f, b, d),
                [f, h];
            g = this.angleVectorToVector(k, 
            l);
            this.drawAngleLineToLine(f, c, d, b, g);
            return g
        }
        ;
        this.nearestPointInPointToSegment = function(a, b, c) {
            var d = new THREE.Vector3
              , f = new THREE.Vector3;
            d.subVectors(b, a);
            f.subVectors(c, b);
            a = d.dot(f);
            d.subVectors(c, b);
            a = -a / d.dot(d);
            0 > a || (1 < a ? b = c : (d.subVectors(c, b),
            d.multiplyScalar(a),
            b = d.add(b)));
            return b
        }
        ;
        this.nearestPointInPointToLine = function(a, b, c) {
            var d = new THREE.Vector3
              , f = new THREE.Vector3;
            d.subVectors(b, a);
            f.subVectors(c, b);
            a = d.dot(f);
            d.subVectors(c, b);
            a = -a / d.dot(d);
            d.subVectors(c, b);
            d.multiplyScalar(a);
            return d.add(b)
        }
        ;
        this.pointToEdgeMeasure = function(a, b, c) {
            b = I.getEndPointsInEdge(b);
            var d = b[0]
              , f = b[1];
            b = this.nearestPointInPointToLine(a, d, f);
            c = this.nearestPointInPointToLine(c, d, f);
            d = new THREE.Vector3;
            d.subVectors(c, b);
            d.add(a);
            this.drawLine(d, c);
            this.drawExtensionLinePointToPoint(a, d);
            return [a, b]
        }
        ;
        this.edgeToPointMeasure = function(a, b) {
            var c = I.getEndPointsInEdge(a)
              , d = c[0]
              , c = c[1]
              , f = this.nearestPointInPointToLine(b, d, c);
            this.drawLine(b, f);
            this.drawExtensionLine(b, d, c);
            return [b, f]
        }
        ;
        this.faceToFaceMeasure = 
        function(a, b, c, d) {
            var f = b.clone()
              , g = d.clone()
              , h = this.angleVectorToVector(b, d);
            return f.x <= g.x + .01 && f.x >= g.x - .01 && f.y <= g.y + .01 && f.y >= g.y - .01 && f.z <= g.z + .01 && f.z >= g.z - .01 || f.x <= -g.x + .01 && f.x >= -g.x - .01 && f.y <= -g.y + .01 && f.y >= -g.y - .01 && f.z <= -g.z + .01 && f.z >= -g.z - .01 ? (d = new THREE.Vector3,
            d.subVectors(a, c),
            f = f.dot(d) / f.dot(g),
            d.addVectors(c, g.multiplyScalar(f)),
            g = 2 * d.distanceTo(a),
            g = new THREE.PlaneBufferGeometry(g,g),
            this.drawExtensionFace(g, a, b),
            this.drawLine(c, d),
            [c, d, h]) : h = this.drawAngleFaceToFace(a, b, c, 
            d)
        }
        ;
        this.angleVectorToVector = function(a, b) {
            return 180 * a.angleTo(b) / Math.PI
        }
        ;
        this.intersectPlaneToPlane = function(a, b, c, d) {
            var f = new THREE.Vector3;
            f.crossVectors(b, d);
            var g = 0 <= f.x ? f.x : -f.x, h = 0 <= f.y ? f.y : -f.y, k = 0 <= f.z ? f.z : -f.z, h = g > h ? g > k ? 1 : 3 : h > k ? 2 : 3, g = new THREE.Vector3, l, k = -b.dot(a);
            l = -d.dot(c);
            switch (h) {
            case 1:
                g.x = 0;
                0 !== f.x ? (g.y = (l * b.z - k * d.z) / f.x,
                g.z = (k * d.y - l * b.y) / f.x) : (g.y = -(l * b.z) / (b.z * d.y),
                g.z = -(k * d.y) / (b.z * d.y));
                break;
            case 2:
                g.y = 0;
                0 !== f.y ? (g.x = (k * d.z - l * b.z) / f.y,
                g.z = (l * b.x - k * d.x) / f.y) : (g.x = -(k * d.z) / 
                (b.x * d.z),
                g.z = -(l * b.x) / (b.x * d.z));
                break;
            case 3:
                g.z = 0,
                0 !== f.z ? (g.x = (l * b.y - k * d.y) / f.z,
                g.y = (k * d.x - l * b.x) / f.z) : (g.x = -(l * b.y) / (b.y * d.x),
                g.y = -(k * d.x) / (b.y * d.x))
            }
            b = new THREE.Vector3;
            b.addVectors(g, f.multiplyScalar(100));
            a = this.nearestPointInPointToLine(a, g, b);
            c = this.nearestPointInPointToLine(c, g, b);
            return [a, c]
        }
        ;
        this.drawAngle = function(a, c, d, f, g, h) {
            l || (l = new THREE.MeshPhongMaterial({
                color: 10066329,
                ambient: 10066329,
                opacity: .5,
                transparent: !0,
                depthTest: !1,
                depthWrite: !1,
                side: THREE.DoubleSide
            }),
            q = new THREE.MeshBasicMaterial({
                color: 16750848,
                depthTest: !1,
                depthWrite: !1
            }),
            b.impl.createOverlayScene("MeasureTool-angle", l),
            b.impl.createOverlayScene("MeasureTool-angle-outline", q));
            b.impl.clearOverlay("MeasureTool-angle");
            b.impl.clearOverlay("MeasureTool-angle-outline");
            var k = a.distanceTo(c)
              , m = new THREE.CircleGeometry(k,100,0,g * Math.PI / 180)
              , m = new THREE.Mesh(m,l)
              , n = m.geometry.vertices[0].clone();
            m.geometry.vertices.push(n);
            m.position.set(a.x, a.y, a.z);
            n = m.position.clone();
            n.add(f);
            m.lookAt(n);
            m.updateMatrixWorld();
            var B = m.geometry.vertices[1].clone()
              , 
            r = m.geometry.vertices[m.geometry.vertices.length - 2].clone();
            B.applyMatrix4(m.matrixWorld);
            r.applyMatrix4(m.matrixWorld);
            var n = new THREE.Vector3
              , v = new THREE.Vector3
              , z = new THREE.Vector3
              , D = new THREE.Vector3;
            n.subVectors(B, a);
            v.subVectors(r, a);
            z.subVectors(c, a);
            D.subVectors(d, a);
            d = n.angleTo(z);
            B = n.angleTo(D);
            c = v.angleTo(z);
            r = v.angleTo(D);
            c = (.001 >= d && -.001 <= d || .001 >= B && -.001 <= B) && (.001 >= c && -.001 <= c || .001 >= r && -.001 <= r) ? 0 : (d <= Math.PI + .001 && d >= Math.PI - .001 || B <= Math.PI + .001 && B >= Math.PI - .001) && (c <= Math.PI + 
            .001 && c >= Math.PI - .001 || r <= Math.PI + .001 && r >= Math.PI - .001) ? Math.PI : d <= c + .001 && d >= c - .001 || d <= r + .001 && d >= r - .001 ? d : B;
            d = new THREE.Matrix4;
            d.makeRotationAxis(f, c);
            d.multiply(m.matrix);
            m.matrix = d;
            m.rotation.setFromRotationMatrix(m.matrix);
            m.updateMatrixWorld();
            B = m.geometry.vertices[1].clone();
            r = m.geometry.vertices[m.geometry.vertices.length - 2].clone();
            B.applyMatrix4(m.matrixWorld);
            r.applyMatrix4(m.matrixWorld);
            n.subVectors(B, a);
            v.subVectors(r, a);
            d = n.angleTo(z);
            B = n.angleTo(D);
            v.angleTo(z);
            v.angleTo(D);
            .001 <= 
            d && .001 <= B && (d = new THREE.Matrix4,
            d.makeRotationAxis(f, 2 * -c),
            d.multiply(m.matrix),
            m.matrix = d,
            m.rotation.setFromRotationMatrix(m.matrix));
            a = new THREE.CircleGeometry(.9 * k,100,0,g * Math.PI / 180);
            a.vertices.splice(0, 1);
            m.updateMatrixWorld();
            a.applyMatrix(m.matrixWorld);
            a = this.drawEdgeAsCylinder(a, q, 2.5, 0);
            g = new THREE.Geometry;
            f = new THREE.Geometry;
            g.vertices.push(m.geometry.vertices[0].clone(), m.geometry.vertices[1].clone());
            f.vertices.push(m.geometry.vertices[0].clone(), m.geometry.vertices[m.geometry.vertices.length - 
            2].clone());
            g.applyMatrix(m.matrixWorld);
            f.applyMatrix(m.matrixWorld);
            g = this.drawLineAsCylinder(g, q, 2.5);
            f = this.drawLineAsCylinder(f, q, 2.5);
            b.impl.addOverlay("MeasureTool-angle", m);
            b.impl.addMultipleOverlays("MeasureTool-angle-outline", a);
            b.impl.addOverlay("MeasureTool-angle-outline", g);
            b.impl.addOverlay("MeasureTool-angle-outline", f);
            h.copy(m.geometry.vertices[Math.round(m.geometry.vertices.length / 2) - 1]);
            h.applyMatrix4(m.matrixWorld)
        }
        ;
        this.drawAngleFaceToFace = function(c, d, f, g) {
            var h = this.intersectPlaneToPlane(c, 
            d, f, g)
              , k = new THREE.Vector3
              , l = new THREE.Vector3;
            k.subVectors(c, h[0]);
            l.subVectors(f, h[1]);
            var k = this.angleVectorToVector(k, l)
              , l = h[0].clone()
              , m = new THREE.Vector3;
            m.crossVectors(d, g);
            m.normalize();
            h = this.intersectPlaneToPlane(c, d, l, m);
            c = h[0].clone();
            h = this.intersectPlaneToPlane(f, g, l, m);
            g = h[0].clone();
            f = new THREE.Vector3;
            this.drawAngle(l, c, g, m, k, f);
            t && (g = J.label,
            g || (g = J.label = document.createElement("div"),
            g.className = "measure-length",
            b.container.appendChild(g),
            h = document.createElement("div"),
            h.className = 
            "measure-length-text",
            g.appendChild(h)),
            g.children[0].textContent = a.getAngle(),
            g.classList.toggle("visible", !0),
            J.p1 = f.clone(),
            J.p2 = f.clone(),
            this.updateLabelPositions());
            return k
        }
        ;
        this.drawAngleLineToLine = function(c, d, f, g, h) {
            var k = new THREE.Vector3
              , l = new THREE.Vector3
              , m = new THREE.Vector3;
            l.subVectors(c, d);
            m.subVectors(f, g);
            k.crossVectors(l, m);
            k.normalize();
            l = new THREE.Vector3;
            l.subVectors(c, f);
            l.add(g);
            f = new THREE.Vector3;
            this.drawAngle(c, d, l, k, h, f);
            t && (c = J.label,
            c || (c = J.label = document.createElement("div"),
            c.className = "measure-length",
            b.container.appendChild(c),
            d = document.createElement("div"),
            d.className = "measure-length-text",
            c.appendChild(d)),
            c.children[0].textContent = a.getAngle(),
            c.classList.toggle("visible", !0),
            J.p1 = f.clone(),
            J.p2 = f.clone(),
            this.updateLabelPositions())
        }
        ;
        this.intersectLineToLine = function(a, b, c, d) {
            var f = new THREE.Vector3
              , g = new THREE.Vector3;
            f.subVectors(c, a);
            f.cross(d);
            g.crossVectors(b, d);
            c = f.divide(g);
            g = b.clone();
            g.multiplyScalar(c);
            f.addVectors(a, g);
            return f
        }
        ;
        this.nearestPointInPointToPlane = 
        function(a, b, c) {
            var d = new THREE.Vector3;
            c = c.clone();
            var f = new THREE.Vector3;
            f.subVectors(a, b);
            b = -c.dot(f);
            f = c.dot(c);
            d.addVectors(a, c.multiplyScalar(b / f));
            return d
        }
        ;
        this.faceToPointMeasure = function(a, b, c, d) {
            a = this.nearestPointInPointToPlane(d, a.vertices[0], b);
            var f = c.clone()
              , g = new THREE.Vector3;
            g.subVectors(f, a);
            g.add(d);
            f = 2 * a.distanceTo(c);
            f = new THREE.PlaneBufferGeometry(f,f);
            this.drawExtensionFace(f, c, b);
            this.drawLine(d, a);
            return [d, a]
        }
        ;
        this.nearestPointInPointToFace = function(a, b, c) {
            for (var d, f = 
            Number.MAX_VALUE, g = new THREE.Vector3, h = new THREE.Vector3, k = new THREE.Vector3, l = new THREE.Vector3, m = 0; m < b.vertices.length; m += 3) {
                g.subVectors(b.vertices[m + 1], b.vertices[m]);
                h.subVectors(b.vertices[m + 2], b.vertices[m]);
                l.crossVectors(g, h);
                k.subVectors(a, b.vertices[m]);
                g.cross(k);
                var n = g.dot(l) / l.dot(l);
                k.cross(h);
                var q = k.dot(l) / l.dot(l)
                  , B = 1 - n - q;
                if (0 <= B && 1 >= B && 0 <= q && 1 >= q && 0 <= n && 1 >= n)
                    return d = this.nearestPointInPointToPlane(a, b.vertices[0], c)
            }
            for (m = 0; m < b.vertices.length; m += 3)
                c = this.nearestPointInPointToSegment(a, 
                b.vertices[m], b.vertices[m + 1]),
                a.distanceTo(c) < f && (f = a.distanceTo(c),
                d = c.clone()),
                c = this.nearestPointInPointToSegment(a, b.vertices[m], b.vertices[m + 2]),
                a.distanceTo(c) < f && (f = a.distanceTo(c),
                d = c.clone()),
                c = this.nearestPointInPointToSegment(a, b.vertices[m + 1], b.vertices[m + 2]),
                a.distanceTo(c) < f && (f = a.distanceTo(c),
                d = c.clone());
            return d
        }
        ;
        this.pointToFaceMeasure = function(a, b, c, d) {
            b = this.nearestPointInPointToPlane(a, b.vertices[0], c);
            d = d.clone();
            c = new THREE.Vector3;
            c.subVectors(d, b);
            c.add(a);
            this.drawLine(d, 
            c);
            this.drawExtensionLinePointToPoint(a, c);
            return [a, b]
        }
        ;
        this.nearestPointsInEdgeToFace = function(a, b) {
            for (var c = [], d = Number.MAX_VALUE, f = I.getEndPointsInEdge(a), g = f[0], f = f[1], h, k, l = 0; l < b.vertices.length; l += 3)
                h = b.vertices[l],
                k = b.vertices[l + 1],
                h = this.nearestPointsInSegmentToSegment(g, f, h, k),
                h[0].distanceTo(h[1]) < d && (d = h[0].distanceTo(h[1]),
                c[0] = h[0].clone(),
                c[1] = h[1].clone()),
                h = b.vertices[l],
                k = b.vertices[l + 2],
                h = this.nearestPointsInSegmentToSegment(g, f, h, k),
                h[0].distanceTo(h[1]) < d && (d = h[0].distanceTo(h[1]),
                c[0] = h[0].clone(),
                c[1] = h[1].clone()),
                h = b.vertices[l + 1],
                k = b.vertices[l + 2],
                h = this.nearestPointsInSegmentToSegment(g, f, h, k),
                h[0].distanceTo(h[1]) < d && (d = h[0].distanceTo(h[1]),
                c[0] = h[0].clone(),
                c[1] = h[1].clone());
            return c
        }
        ;
        this.faceToEdgeMeasure = function(a, b, c, d, f) {
            var g = I.getEndPointsInEdge(d), h;
            g[0].distanceTo(c) < g[1].distanceTo(c) ? (d = g[0],
            h = g[1]) : (d = g[1],
            h = g[0]);
            var k = new THREE.Vector3;
            k.subVectors(h, d);
            g = this.angleLineToPlane(k, b);
            if (.01 >= k.dot(b) && -.01 <= k.dot(b))
                return k = this.nearestPointInPointToPlane(d, 
                a.vertices[0], b),
                f = this.nearestPointInPointToLine(f, d, h),
                this.faceToPointMeasure(a, b, c, f),
                [d, k, g];
            f = this.nearestPointInPointToLine(f, d, h);
            this.drawAngleEdgeToFace(a.vertices[0], b, c, d, f, g);
            return g
        }
        ;
        this.edgeToFaceMeasure = function(a, b, c, d, f) {
            var g = I.getEndPointsInEdge(a), h;
            g[0].distanceTo(f) < g[1].distanceTo(f) ? (a = g[0],
            h = g[1]) : (a = g[1],
            h = g[0]);
            var k = new THREE.Vector3;
            k.subVectors(h, a);
            g = this.angleLineToPlane(k, d);
            if (.01 >= k.dot(d) && -.01 <= k.dot(d))
                return c = this.nearestPointInPointToPlane(a, c.vertices[0], 
                d),
                d = new THREE.Vector3,
                d.subVectors(f, c),
                d.add(a),
                b = new THREE.Vector3,
                b.subVectors(f, c),
                b.add(h),
                this.drawLine(d, f),
                this.drawExtensionLinePointToPoint(d, b),
                [a, c, g];
            h = this.nearestPointInPointToLine(b, a, h);
            this.drawAngleEdgeToFace(c.vertices[0], d, f, a, h, g);
            return g
        }
        ;
        this.angleLineToPlane = function(a, b) {
            var c = this.angleVectorToVector(a, b);
            return 90 < c ? c - 90 : 90 - c
        }
        ;
        this.drawAngleEdgeToFace = function(c, d, f, g, h, k) {
            var l = this.intersectPointLineToPlane(c, d, g, h);
            if (l) {
                c = 90 === k ? f.clone() : this.nearestPointInPointToPlane(h, 
                c, d);
                d = new THREE.Vector3;
                f = new THREE.Vector3;
                var m = new THREE.Vector3;
                f.subVectors(h, g);
                m.subVectors(c, l);
                d.crossVectors(f, m);
                d.normalize();
                g = new THREE.Vector3;
                this.drawAngle(l, h, c, d, k, g);
                t && (h = J.label,
                h || (h = J.label = document.createElement("div"),
                h.className = "measure-length",
                b.container.appendChild(h),
                k = document.createElement("div"),
                k.className = "measure-length-text",
                h.appendChild(k)),
                h.children[0].textContent = a.getAngle(),
                h.classList.toggle("visible", !0),
                J.p1 = g.clone(),
                J.p2 = g.clone(),
                this.updateLabelPositions())
            }
        }
        ;
        this.intersectPointLineToPlane = function(a, b, c, d) {
            var f = new THREE.Vector3
              , g = new THREE.Vector3;
            f.subVectors(d, c);
            g.subVectors(c, a);
            a = b.dot(f);
            b = -b.dot(g);
            if (.001 > Math.abs(a))
                return null ;
            f.multiplyScalar(b / a);
            f.add(c);
            return f
        }
        ;
        this.nearestVertexInVertexToEdge = function(a, b) {
            for (var c, d = Number.MAX_VALUE, f = 0; f < b.vertices.length; f++) {
                var g = a.distanceTo(b.vertices[f]);
                d > g && (c = b.vertices[f],
                d = g)
            }
            return c
        }
        ;
        this.isEqualVectors = function(a, b, c) {
            return Math.abs(a.x - b.x) <= c && Math.abs(a.y - b.y) <= c && Math.abs(a.z - 
            b.z) <= c ? !0 : !1
        }
        ;
        this.isInverseVectors = function(a, b, c) {
            return Math.abs(a.x + b.x) <= c && Math.abs(a.y + b.y) <= c && Math.abs(a.z + b.z) <= c ? !0 : !1
        }
        ;
        this.setSimple = function(a) {
            if (f != a) {
                f = a;
                for (var c in H)
                    if ("xyz" !== c && H.hasOwnProperty(c)) {
                        var d = H[c];
                        d.line && (d.line.visible = !a,
                        d.label && d.label.classList.toggle("visible", !a))
                    }
                b.impl.invalidate(!1, !1, !0)
            }
        }
        ;
        this.hide = function() {
            for (var a in v)
                if (v.hasOwnProperty(a)) {
                    var c = v[a];
                    c.mesh && (c.mesh.visible = !1);
                    c.label && c.label.classList.remove("visible")
                }
            for (a in z)
                if (z.hasOwnProperty(a)) {
                    c = 
                    z[a];
                    if (c.line)
                        for (var d in c.line)
                            c.line[d].visible = !1;
                    c.label && c.label.classList.remove("visible")
                }
            for (a in F)
                F.hasOwnProperty(a) && (d = F[a],
                d.mesh && (d.mesh.visible = !1),
                d.label && d.label.classList.remove("visible"));
            for (a in H)
                H.hasOwnProperty(a) && (d = H[a],
                d.line && (d.line.visible = !1),
                d.label && d.label.classList.remove("visible"));
            J.label && J.label.classList.remove("visible");
            l && (b.impl.clearOverlay("MeasureTool-angle"),
            b.impl.clearOverlay("MeasureTool-angle-outline"));
            B && b.impl.clearOverlay("MeasureTool-extensionLine");
            r && b.impl.clearOverlay("MeasureTool-extensionFace");
            b.impl.invalidate(!1, !1, !0)
        }
        ;
        this.hideClick = function(a) {
            if (v.hasOwnProperty(a)) {
                var c = v[a];
                c.mesh && (c.mesh.visible = !1);
                c.label && c.label.classList.remove("visible")
            }
            if (z.hasOwnProperty(a)) {
                c = z[a];
                if (c.line)
                    for (var d in c.line)
                        c.line[d].visible = !1;
                c.label && c.label.classList.remove("visible")
            }
            F.hasOwnProperty(a) && (a = F[a],
            a.mesh && (a.mesh.visible = !1),
            a.label && a.label.classList.remove("visible"));
            for (var f in H)
                H.hasOwnProperty(f) && (a = H[f],
                a.line && (a.line.visible = 
                !1),
                a.label && a.label.classList.remove("visible"));
            J.label && J.label.classList.remove("visible");
            l && (b.impl.clearOverlay("MeasureTool-angle"),
            b.impl.clearOverlay("MeasureTool-angle-outline"));
            B && b.impl.clearOverlay("MeasureTool-extensionLine");
            r && b.impl.clearOverlay("MeasureTool-extensionFace");
            b.impl.invalidate(!1, !1, !0)
        }
        ;
        this.destroy = function() {
            for (var a in v)
                if (v.hasOwnProperty(a)) {
                    var c = v[a];
                    c.mesh && (b.impl.removeOverlay("MeasureTool-endPoint", c.mesh),
                    c.mesh = c.geometry = null );
                    c.label && (c.label.parentNode.removeChild(c.label),
                    c.label = null )
                }
            for (a in z)
                z.hasOwnProperty(a) && (c = z[a],
                c.line && (b.impl.removeMultipleOverlays("MeasureTool-edge", c.line),
                c.line = c.intersectPoint = null ),
                c.label && (c.label.parentNode.removeChild(c.label),
                c.label = null ));
            for (a in F)
                F.hasOwnProperty(a) && (c = F[a],
                c.mesh && (b.impl.removeOverlay("MeasureTool-face", c.mesh),
                c.mesh = c.intersectPoint = null ),
                c.label && (c.label.parentNode.removeChild(c.label),
                c.label = null ));
            g && (g = null ,
            b.impl.removeOverlayScene("MeasureTool-endPoint"));
            k && (k = null ,
            b.impl.removeOverlayScene("MeasureTool-face"));
            h && (h = null ,
            b.impl.removeOverlayScene("MeasureTool-edge"));
            B && (B = null ,
            b.impl.removeOverlayScene("MeasureTool-extensionLine"));
            r && (r = null ,
            b.impl.removeOverlayScene("MeasureTool-extensionFace"));
            for (a in H)
                H.hasOwnProperty(a) && (c = H[a],
                c.line && (b.impl.removeOverlay(c.overlayName, c.line),
                b.impl.removeOverlayScene(c.overlayName),
                c.material = c.line = c.geometry = null ),
                c.label && (c.label.parentNode.removeChild(c.label),
                c.label = null ),
                c.material = c.line = c.geometry = c.label = c.p1 = c.p2 = null );
            J.label && (J.label.parentNode.removeChild(J.label),
            J.label = null );
            J.label = J.p1 = J.p2 = null 
        }
    }
    var a = this
      , b = f
      , k = ["measure"]
      , l = !1
      , n = null 
      , m = null 
      , q = !1
      , r = 0
      , t = !1
      , w = null 
      , C = null 
      , E = ""
      , G = 3
      , B = {}
      , v = 0
      , D = !1
      , z = null 
      , H = null 
      , I = null 
      , J = null 
      , L = null 
      , F = null 
      , N = null 
      , K = null 
      , M = null 
      , S = null 
      , ba = null 
      , P = null 
      , aa = null 
      , Z = Teratek.Viewing.Private.GuiViewer3D && f instanceof Teratek.Viewing.Private.GuiViewer3D;
    this.register = function() {
        Z && !H && (H = new Teratek.Viewing.Extensions.Measure.MeasurePanel(a,b,"measure-panel","Measure",h),
        b.addPanel(H));
        I || (I = new Teratek.Viewing.Extensions.Measure.Snapper(f),
        b.toolController.registerTool(I))
    }
    ;
    this.deregister = function() {
        this.deactivate();
        H && (b.removePanel(H),
        H.uninitialize());
        b.toolController.deregisterTool(I);
        I = null 
    }
    ;
    this.isActive = function() {
        return l
    }
    ;
    this.getNames = function() {
        return k
    }
    ;
    this.getName = function() {
        return k[0]
    }
    ;
    this.getCursor = function() {
        return q ? null  : "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKZJREFUeNrclLEKwzAQQ9+FgH/Nk7d8ViFT+6cG36IsNXgIdMg5kAoOIw8WSDoDvAEN04BdEhFjgCTR4e6klFxSIgDLSNydbdsAPgRCktRaUylFkfZ0Z2qtVTlnAfugGibwAur3JFrAxoBnYGEy1pGYmQCLLNB6Uqmw182M9eRS0yzqGo+y6D9rytSQR8vM7DKfbtHy4x+/xG8J+d4W9WAi8fxFOwYA8W0ypu2ZfcsAAAAASUVORK5CYII=), wait"
    }
    ;
    this.activate = function() {
        l = !0;
        r = 0;
        q = !1;
        E || (E = b.model.getUnitString());
        G = b.model && b.model.is2d() ? 3 : 1;
        z || (z = new c(b));
        z.hide();
        H && (H.setVisible(!0),
        H.updatePanel(),
        b.model && b.model.is2d() && H.isolate.setVisibility(!1),
        E ? H.disableUnitOption(0) : H.disableUnitOption());
        b.clearSelection();
        b.toolController.activateTool("snapper");
        b.addEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, g);
        b.addEventListener(Teratek.Viewing.RESET_EVENT, d)
    }
    ;
    this.deactivate = function() {
        l = !1;
        n = m = null ;
        B = {};
        this.clearMeasurement();
        z && (z.hide(),
        z.destroy());
        B = {};
        H && (H.setVisible(!1),
        H.updatePanel());
        I && I.isActive() && b.toolController.deactivateTool("snapper");
        b.removeEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, g);
        b.removeEventListener(Teratek.Viewing.RESET_EVENT, d)
    }
    ;
    this.update = function() {
        return !1
    }
    ;
    this.getUnits = function() {
        return E
    }
    ;
    this.setUnits = function(a) {
        E !== a && (E = a,
        z && z.updateDistance())
    }
    ;
    this.getPrecision = function() {
        return G
    }
    ;
    this.setPrecision = function(a) {
        G !== a && (G = a,
        z && z.updateDistance())
    }
    ;
    this.getDistance = function(a) {
        if (b.model && 
        b.model.isLoadDone())
            return a = Teratek.Viewing.Private.convertUnits(b.model.getUnitString(), E, B[a] || 0),
            Teratek.Viewing.Private.formatValueWithUnits(a, E, 3, G)
    }
    ;
    this.getAngle = function() {
        return Teratek.Viewing.Private.formatValueWithUnits(v, String.fromCharCode(176), 3, G)
    }
    ;
    this.clearMeasurement = function() {
        P = aa = S = ba = w = C = n = m = null ;
        r = 1;
        B = {};
        v = 0;
        z && z.hide();
        H && (H.updatePanel(),
        H.hideMeasureResult(),
        H.isolateMeasure && this.clearIsolate())
    }
    ;
    this.clearRubberBand = function() {
        C = m = null ;
        z.hideClick("second")
    }
    ;
    this.clearFirstPick = 
    function() {
        m ? (z.hide(),
        n = m.clone(),
        w = C,
        J = L,
        F = N,
        S = ba,
        P = aa,
        K = M,
        D = !0,
        w === SNAP_VERTEX ? z.showFirstVertex(n) : w === SNAP_EDGE ? z.showFirstEdge(n, J) : w === SNAP_FACE && z.showFirstFace(n, J),
        D = !1,
        M = aa = ba = C = m = null ,
        r = 2,
        B = {},
        v = 0,
        H && H.isolateMeasure && this.clearIsolate()) : this.clearMeasurement();
        H && H.showSelection1()
    }
    ;
    this.clearSecondPick = function() {
        aa = ba = C = m = null ;
        r = 2;
        B = {};
        v = 0;
        z.hideClick("second");
        H && H.isolateMeasure && this.clearIsolate()
    }
    ;
    this.getIndicator = function() {
        return z
    }
    ;
    this.getFirstGeometry = function() {
        return {
            type: w,
            geometry: n
        }
    }
    ;
    this.getSecondGeometry = function() {
        return {
            type: C,
            geometry: m
        }
    }
    ;
    this.getEdgeLength = function(a) {
        return z.getEdgeLength(a)
    }
    ;
    this.getFaceArea = function(a) {
        return z.getFaceArea(a)
    }
    ;
    this.isolateMeasurement = function() {
        S && ba && b.isolate([S, ba])
    }
    ;
    this.clearIsolate = function() {
        b.showAll()
    }
    ;
    this._handleMouseEvent = function(a) {
        if (I.isSnapped()) {
            0 === r && (this.clearMeasurement(),
            r = 1);
            if (1 === r)
                P = I.getViewportIndex(),
                w = I.getHighlightGeometry(),
                J = I.getIntersectPoint(),
                w === SNAP_VERTEX ? (n = I.getVertex(),
                z.showFirstVertex(n)) : 
                w === SNAP_EDGE ? (n = I.getEdge(),
                z.showFirstEdge(n, J)) : w === SNAP_FACE ? (n = I.getFace(),
                F = I.getFaceNormal(),
                z.showFirstFace(n, J)) : w === SNAP_CIRCULARARC && (n = I.getEdge(),
                K = I.getCircularArcCenter(),
                z.showFirstEdge(n, J)),
                S = I.getSnapNode(),
                H && H.showSelection1();
            else if (2 === r) {
                var c;
                C = I.getHighlightGeometry();
                L = I.getIntersectPoint();
                w === SNAP_VERTEX && C === SNAP_VERTEX ? (m = I.getVertex(),
                z.showSecondVertex(m),
                z.drawLine(n, m),
                c = [n, m]) : w === SNAP_EDGE && C === SNAP_EDGE ? (m = I.getEdge(),
                z.showSecondEdge(m, L),
                c = z.edgeToEdgeMeasure(m, 
                n, L)) : w === SNAP_FACE && C === SNAP_FACE ? (m = I.getFace(),
                N = I.getFaceNormal(),
                z.showSecondFace(m, L),
                c = z.faceToFaceMeasure(J, F, L, N)) : w === SNAP_VERTEX && C === SNAP_EDGE ? (m = I.getEdge(),
                z.showSecondEdge(m, L),
                c = z.pointToEdgeMeasure(n, m, L)) : w === SNAP_EDGE && C === SNAP_VERTEX ? (m = I.getVertex(),
                z.showSecondVertex(m),
                c = z.edgeToPointMeasure(n, m)) : w === SNAP_VERTEX && C === SNAP_FACE ? (m = I.getFace(),
                N = I.getFaceNormal(),
                z.showSecondFace(m, L),
                c = z.pointToFaceMeasure(n, m, N, L)) : w === SNAP_FACE && C === SNAP_VERTEX ? (m = I.getVertex(),
                z.showSecondVertex(m),
                c = z.faceToPointMeasure(n, F, J, m)) : w === SNAP_EDGE && C === SNAP_FACE ? (m = I.getFace(),
                N = I.getFaceNormal(),
                z.showSecondFace(m, L),
                c = z.edgeToFaceMeasure(n, J, m, N, L)) : w === SNAP_FACE && C === SNAP_EDGE ? (m = I.getEdge(),
                z.showSecondEdge(m, L),
                c = z.faceToEdgeMeasure(n, F, J, m, L)) : w === SNAP_CIRCULARARC && C === SNAP_CIRCULARARC ? (m = I.getEdge(),
                M = I.getCircularArcCenter(),
                K.equals(M) ? (m = z.nearestVertexInVertexToEdge(L, m),
                C = SNAP_VERTEX,
                z.showSecondVertex(m),
                z.drawLine(K, m),
                c = [K, m]) : (z.showSecondEdge(m, L),
                z.drawLine(K, M),
                c = [K, M])) : w === 
                SNAP_CIRCULARARC && C === SNAP_VERTEX ? (m = I.getVertex(),
                z.showSecondVertex(m),
                z.drawLine(K, m),
                c = [K, m]) : w === SNAP_VERTEX && C === SNAP_CIRCULARARC ? (m = I.getEdge(),
                M = I.getCircularArcCenter(),
                z.showSecondEdge(m, L),
                z.drawLine(n, M),
                c = [n, M]) : w === SNAP_CIRCULARARC && C === SNAP_EDGE ? (m = I.getEdge(),
                z.showSecondEdge(m, L),
                c = z.pointToEdgeMeasure(K, m, L)) : w === SNAP_EDGE && C === SNAP_CIRCULARARC && (m = I.getEdge(),
                M = I.getCircularArcCenter(),
                z.showSecondEdge(m, L),
                c = z.edgeToPointMeasure(n, M));
                t && (void 0 === c.length ? (v = c,
                H && H.showAngleResult()) : 
                (a = c[0].clone(),
                c = c[1].clone(),
                b.model.is2d() && b.model.pageToModel(a, c, P),
                B.xyz = a.distanceTo(c),
                B.x = Math.abs(a.x - c.x),
                B.y = Math.abs(a.y - c.y),
                B.z = Math.abs(a.z - c.z),
                H && H.showDistanceResult()),
                H && (H.showSelection2(),
                H.updatePanel()),
                z.updateDistance(),
                z.updateAngle(),
                ba = I.getSnapNode(),
                aa = I.getViewportIndex(),
                H && H.isolateMeasure && this.isolateMeasurement());
                z.updateLabelPositions()
            }
            return !0
        }
        2 === r && (c = this.inverseProject(a.canvasX, a.canvasY),
        w === SNAP_VERTEX ? z.drawLine(n, c) : w === SNAP_EDGE ? z.edgeToPointMeasure(n, 
        c) : w === SNAP_FACE ? z.faceToPointMeasure(n, F, J, c) : w === SNAP_CIRCULARARC && z.drawLine(K, c));
        return !1
    }
    ;
    this.inverseProject = function(a, c) {
        var d = b.navigation.getCamera()
          , f = b.navigation.getScreenViewport()
          , g = new THREE.Vector3;
        g.x = a / f.width * 2 - 1;
        g.y = -(c / f.height * 2 - 1);
        g.z = 0;
        return g = g.unproject(d)
    }
    ;
    this.handleButtonDown = function(a, b) {
        q = !0;
        0 !== b || a.ctrlKey || a.metaKey || a.shiftKey || a.altKey || (t = !0);
        return !1
    }
    ;
    this.handleMouseMove = function(a) {
        t = !1;
        2 === r && (this.clearRubberBand(),
        this._handleMouseEvent(a));
        return !1
    }
    ;
    this.handleButtonUp = function(a, b) {
        return q = !1
    }
    ;
    this.handleSingleClick = function(a, b) {
        if (t) {
            this._handleMouseEvent(a) || (this.clearMeasurement(),
            r = 0);
            if (1 === r || 2 === r)
                r = 1 === r ? 2 : 0;
            t = !1
        }
        return !0
    }
    ;
    this.handleDoubleClick = function(a, b) {
        return !0
    }
    ;
    this.handleWheelInput = function(a) {
        z.updateScale();
        return !1
    }
}
;
(function() {
    var f = TeratekNamespace("Teratek.Viewing.Extensions.Measure")
      , h = Teratek.Viewing
      , g = Teratek.Viewing.Extensions
      , d = Teratek.Viewing.Private
      , c = Teratek.Viewing.UI
      , a = function(a, f, g, n, m) {
        c.DockingPanel.call(this, f.container, g, n, m);
        this.kPanelExpandedHeight = 310;
        this.kPanelCollapsedHeight = 35;
        this.isDeltaExpanded = !0;
        this.isolateMeasure = this.isSettingsExpanded = !1;
        this.measureTool = a;
        this.viewer = f;
        this.parentContainer = f.container;
        this.container.classList.add("measurePanel");
        this.container.dockRight = 
        !0;
        this.container.style.minWidth = "300px";
        this.container.style.width = "300px";
        this.container.style.minHeight = this.kPanelCollapsedHeight + "px";
        this.container.style.height = this.kPanelExpandedHeight + "px";
        this.container.style.maxHeight = this.kPanelExpandedHeight + "px";
        this.container.style.top = "200px";
        this.container.style.left = "220px";
        this.container.style.position = "absolute";
        this.addEventListener(this.closer, "click", function(a) {
            if (m && m.onCloseCallback)
                m.onCloseCallback()
        }
        );
        this.container.children[0].classList.add("expanded");
        m = m || {};
        m.heightAdjustment || (m.heightAdjustment = 40);
        m.marginTop || (m.marginTop = 0);
        m.left = !1;
        this.createScrollContainer(m);
        this.measureResults = document.createElement("div");
        this.scrollContainer.appendChild(this.measureResults);
        var q = this;
        this.selection1 = document.createElement("div");
        this.selection1.className = "measure-result-container";
        this.measureResults.appendChild(this.selection1);
        a = document.createElement("div");
        a.className = "measure-selectionOne-label";
        this.selection1.appendChild(a);
        f = document.createElement("div");
        f.className = "teratek-icon-first measure-label-icon";
        a.appendChild(f);
        this.selection1Result = document.createElement("div");
        this.selection1Result.className = "measure-selection-result";
        this.selection1.appendChild(this.selection1Result);
        a = document.createElement("div");
        a.className = "teratek-icon-refresh measure-repick";
        a.addEventListener("click", function(a) {
            q.firstSelectionRepick()
        }
        , !0);
        this.selection1.appendChild(a);
        this.addDivider(this.selection1);
        this.results = document.createElement("div");
        this.results.className = 
        "measure-result-container";
        this.measureResults.appendChild(this.results);
        this.distIcon = document.createElement("div");
        this.distIcon.className = "teratek-icon-measure-distance measure-distance-icon";
        this.results.appendChild(this.distIcon);
        this.angleIcon = document.createElement("div");
        this.angleIcon.className = "teratek-icon-measure-angle measure-angle-icon";
        this.results.appendChild(this.angleIcon);
        this.distanceDiv = document.createElement("div");
        this.distanceDiv.className = "measure-result";
        this.results.appendChild(this.distanceDiv);
        this.angleDiv = document.createElement("div");
        this.angleDiv.className = "measure-result";
        this.results.appendChild(this.angleDiv);
        this.initialDiv = document.createElement("div");
        this.initialDiv.className = "measure-initial";
        this.initialDiv.textContent = "0.00";
        this.results.appendChild(this.initialDiv);
        this.settingsButton = document.createElement("div");
        this.settingsButton.className = "teratek-icon-settings measure-settings-button";
        this.settingsButton.addEventListener("click", function(a) {
            q.showMeasureSettings()
        }
        , !0);
        this.results.appendChild(this.settingsButton);
        this.deltaButton = document.createElement("div");
        this.deltaButton.className = "teratek-icon-arrow measure-delta-button";
        this.deltaButton.addEventListener("click", function(a) {
            q.toggle()
        }
        , !0);
        this.results.appendChild(this.deltaButton);
        this.deltaXDiv = document.createElement("div");
        this.deltaXDiv.className = "measure-delta-result";
        this.results.appendChild(this.deltaXDiv);
        a = document.createElement("span");
        a.setAttribute("data-i18n", "Delta");
        a.textContent = h.i18n.translate("Delta");
        this.deltaXDiv.appendChild(a);
        a = document.createElement("span");
        a.className = "measure-label-axis-x";
        a.textContent = "X";
        this.deltaXDiv.appendChild(a);
        a = document.createElement("span");
        this.deltaXDiv.appendChild(a);
        this.deltaYDiv = document.createElement("div");
        this.deltaYDiv.className = "measure-delta-result";
        this.results.appendChild(this.deltaYDiv);
        a = document.createElement("span");
        a.setAttribute("data-i18n", "Delta");
        a.textContent = h.i18n.translate("Delta");
        this.deltaYDiv.appendChild(a);
        a = document.createElement("span");
        a.className = "measure-label-axis-y";
        a.textContent = "Y";
        this.deltaYDiv.appendChild(a);
        a = document.createElement("span");
        this.deltaYDiv.appendChild(a);
        this.deltaZDiv = document.createElement("div");
        this.deltaZDiv.className = "measure-delta-result";
        this.results.appendChild(this.deltaZDiv);
        a = document.createElement("span");
        a.setAttribute("data-i18n", "Delta");
        a.textContent = h.i18n.translate("Delta");
        this.deltaZDiv.appendChild(a);
        a = document.createElement("span");
        a.className = "measure-label-axis-z";
        a.textContent = 
        "Z";
        this.deltaZDiv.appendChild(a);
        a = document.createElement("span");
        this.deltaZDiv.appendChild(a);
        this.addDivider(this.results);
        this.selection2 = document.createElement("div");
        this.selection2.className = "measure-result-container";
        this.measureResults.appendChild(this.selection2);
        a = document.createElement("div");
        a.className = "measure-selectionTwo-label";
        this.selection2.appendChild(a);
        f = document.createElement("div");
        f.className = "teratek-icon-second measure-label-icon";
        a.appendChild(f);
        this.selection2Result = document.createElement("div");
        this.selection2Result.className = "measure-selection-result";
        this.selection2.appendChild(this.selection2Result);
        a = document.createElement("div");
        a.className = "teratek-icon-refresh measure-repick";
        a.addEventListener("click", function(a) {
            q.secondSelectionRepick()
        }
        , !0);
        this.selection2.appendChild(a);
        this.addDivider(this.selection2);
        this.measureSettings = document.createElement("div");
        this.measureSettings.className = "measure-settings";
        this.measureSettings.style.display = "none";
        this.measureResults.appendChild(this.measureSettings);
        this.table = document.createElement("table");
        this.table.className = "tftable measure-table";
        this.tbody = document.createElement("tbody");
        this.table.appendChild(this.tbody);
        this.measureSettings.appendChild(this.table);
        this.units = [{
            name: "Unknown",
            units: "",
            matches: [""]
        }, {
            name: "Decimal feet",
            units: "decimal-ft",
            matches: ["decimal-ft"]
        }, {
            name: "Feet and fractional inches",
            units: "ft",
            matches: ["ft", "in"]
        }, {
            name: "Decimal inches",
            units: "decimal-in",
            matches: ["decimal-in"]
        }, {
            name: "Fractional inches",
            units: "fractional-in",
            matches: ["fractional-in"]
        }, {
            name: "Meters",
            units: "m",
            matches: ["m"]
        }, {
            name: "Centimeters",
            units: "cm",
            matches: ["cm"]
        }, {
            name: "Millimeters",
            units: "mm",
            matches: ["mm"]
        }, {
            name: "Meters and centimeters",
            units: "m-and-cm",
            matches: ["m-and-cm"]
        }];
        a = this.findUnits();
        f = [];
        for (g = 0; g < this.units.length; ++g)
            f.push(this.units[g].name);
        this.unitList = new d.OptionDropDown("Unit type",this.tbody,f,a);
        this.addEventListener(this.unitList, "change", function(a) {
            q.measureTool.setUnits(q.units[q.unitList.selectedIndex].units);
            q.updatePanel();
            q.setupPrecision()
        }
        );
        this.precisionList = new d.OptionDropDown("Precision",this.tbody,[],-1);
        this.addEventListener(this.precisionList, "change", function(a) {
            q.measureTool.setPrecision(q.precisionList.selectedIndex);
            q.updatePanel()
        }
        );
        this.setupPrecision();
        this.isolate = new d.OptionCheckbox("Isolate measurement",this.tbody,!1);
        this.addEventListener(this.isolate, "change", function(a) {
            q.isolateMeasure = q.isolate.checked;
            q.isolateMeasure ? q.measureTool.isolateMeasurement() : q.measureTool.clearIsolate()
        }
        );
        this.addDivider(this.measureSettings);
        a = document.createElement("div");
        a.className = "measure-restart";
        a.setAttribute("data-i18n", "Restart");
        a.textContent = h.i18n.translate("Restart");
        a.addEventListener("click", function() {
            q.measureTool.clearMeasurement()
        }
        , !1);
        this.measureResults.appendChild(a);
        this.updatePanel();
        this.addVisibilityListener(function() {
            q.resizeToContent({
                maxHeight: q.parentContainer.offsetHeight - 75
            })
        }
        );
        this.hideMeasureResult()
    }
    ;
    a.prototype = Object.create(c.DockingPanel.prototype);
    g.ViewerPanelMixin.call(a.prototype);
    a.prototype.addDropDownMenu = 
    function(a, c, d, f, g) {
        var q = document.createElement("select");
        q.className = "optionDropDown";
        for (var r = 0; r < d.length; r++) {
            var t = document.createElement("option");
            t.value = r;
            t.setAttribute("data-i18n", d[r]);
            t.textContent = h.i18n.translate(d[r]);
            q.add(t)
        }
        d = document.createElement("div");
        d.className = "measure-submenu-select";
        r = document.createElement("div");
        r.className = "measure-submenu-selectlabel";
        r.setAttribute("for", c);
        r.setAttribute("data-i18n", c);
        r.textContent = h.i18n.translate(c);
        d.appendChild(r);
        d.appendChild(q);
        a.appendChild(d);
        q.selectedIndex = f;
        q.onchange = function(a) {
            g(a.target.selectedIndex)
        }
        ;
        return q
    }
    ;
    a.prototype.addDivider = function(a) {
        var c = document.createElement("div");
        c.className = "measure-horizontal-divider";
        a.appendChild(c);
        return c
    }
    ;
    a.prototype.findUnits = function() {
        var a, c, d = this.measureTool.getUnits();
        for (a = 0; a < this.units.length; ++a) {
            var f = this.units[a].matches;
            if (f)
                for (c = 0; c < f.length; ++c)
                    if (f[c] === d)
                        return a
        }
        return 0
    }
    ;
    a.prototype.setupPrecision = function() {
        for (; this.precisionList.dropdownElement.lastChild; )
            this.precisionList.dropdownElement.removeChild(this.precisionList.dropdownElement.lastChild);
        for (var a = this.measureTool.getUnits(), a = "ft" === a || "in" === a || "fractional-in" === a ? "1 1/2 1/4 1/8 1/16 1/32 1/64".split(" ") : "0 0.1 0.01 0.001 0.0001 0.00001".split(" "), c = 0; c < a.length; ++c) {
            var d = document.createElement("option");
            d.value = c;
            d.textContent = a[c];
            this.precisionList.dropdownElement.appendChild(d)
        }
        c = this.measureTool.getPrecision();
        a.length <= c && (c = a.length - 1,
        self.measureTool.setPrecision(c));
        this.precisionList.dropdownElement.selectedIndex = c
    }
    ;
    a.prototype.uninitialize = function() {
        this.viewer = null ;
        c.DockingPanel.prototype.uninitialize.call(this)
    }
    ;
    a.prototype.onTitleClick = function(a) {}
    ;
    a.prototype.deltaCollapse = function() {
        this.deltaButton.classList.toggle("rotated");
        this.measureTool.getIndicator().setSimple(this.isDeltaExpanded);
        this.isDeltaExpanded ? (this.deltaXDiv.style.display = "none",
        this.deltaYDiv.style.display = "none",
        this.deltaZDiv.style.display = "none",
        this.isDeltaExpanded = !1) : (this.deltaXDiv.style.display = "block",
        this.deltaYDiv.style.display = "block",
        this.viewer.model && !this.viewer.model.is2d() && 
        (this.deltaZDiv.style.display = "block"),
        this.isDeltaExpanded = !0);
        this.resizeToContent()
    }
    ;
    a.prototype.toggle = function() {
        this.deltaCollapse()
    }
    ;
    a.prototype.isExpanded = function() {
        return this.container.children[0].classList.contains("expanded")
    }
    ;
    a.prototype.getContentSize = function() {
        return {
            height: this.isExpanded() ? this.measureResults.clientHeight + 46 : 0,
            width: this.measureResults.clientWidth
        }
    }
    ;
    a.prototype.updatePanel = function() {
        function a(b, d) {
            "angle" === d ? b.textContent = c.measureTool.getAngle() : "xyz" === d ? b.textContent = 
            c.measureTool.getDistance(d) : b.children[2].textContent = " = " + c.measureTool.getDistance(d)
        }
        var c = this;
        a(this.distanceDiv, "xyz");
        a(this.deltaXDiv, "x");
        a(this.deltaYDiv, "y");
        a(this.deltaZDiv, "z");
        a(this.angleDiv, "angle");
        this.unitList.dropdownElement.selectedIndex = this.findUnits();
        this.precisionList.dropdownElement.selectedIndex = this.measureTool.getPrecision();
        this.showSelection1();
        this.showSelection2()
    }
    ;
    a.prototype.showDistanceResult = function() {
        this.results.style.display = "block";
        this.initialDiv.style.display = 
        "none";
        this.angleDiv.style.display = "none";
        this.angleIcon.style.display = "none";
        this.distanceDiv.style.display = "inline-block";
        this.distIcon.style.display = "inline-block";
        this.deltaButton.style.display = "inline-block";
        this.isDeltaExpanded && (this.deltaXDiv.style.display = "block",
        this.deltaYDiv.style.display = "block",
        this.viewer.model && !this.viewer.model.is2d() && (this.deltaZDiv.style.display = "block"));
        this.resizeToContent()
    }
    ;
    a.prototype.showAngleResult = function() {
        this.results.style.display = "block";
        this.initialDiv.style.display = 
        "none";
        this.angleDiv.style.display = "inline-block";
        this.angleIcon.style.display = "inline-block";
        this.distanceDiv.style.display = "none";
        this.distIcon.style.display = "none";
        this.deltaButton.style.display = "none";
        this.isDeltaExpanded && (this.deltaXDiv.style.display = "none",
        this.deltaYDiv.style.display = "none",
        this.deltaZDiv.style.display = "none");
        this.resizeToContent()
    }
    ;
    a.prototype.showSelection1 = function() {
        var a = this.measureTool.getFirstGeometry();
        null  !== a.type && (a.type === SNAP_VERTEX ? (this.selection1Result.setAttribute("data-i18n", 
        "Vertex"),
        this.selection1Result.textContent = h.i18n.translate("Vertex"),
        this.selection1Result.style.display = "inline-block") : a.type === SNAP_EDGE ? (this.selection1Result.setAttribute("data-i18n", "Edge"),
        this.selection1Result.textContent = h.i18n.translate("Edge") + " - " + this.measureTool.getEdgeLength(a.geometry),
        this.selection1Result.style.display = "inline-block") : a.type === SNAP_FACE ? (this.selection1Result.setAttribute("data-i18n", "Face"),
        this.selection1Result.textContent = h.i18n.translate("Face") + " - " + this.measureTool.getFaceArea(a.geometry),
        this.selection1Result.style.display = "inline-block") : a.type === SNAP_CIRCULARARC && (this.selection1Result.setAttribute("data-i18n", "Edge"),
        this.selection1Result.textContent = h.i18n.translate("Edge") + " - " + this.measureTool.getEdgeLength(a.geometry),
        this.selection1Result.style.display = "inline-block"),
        this.selection1.style.display = "block",
        this.resizeToContent())
    }
    ;
    a.prototype.showSelection2 = function() {
        var a = this.measureTool.getSecondGeometry();
        null  !== a.type && (a.type === SNAP_VERTEX ? (this.selection2Result.setAttribute("data-i18n", 
        "Vertex"),
        this.selection2Result.textContent = h.i18n.translate("Vertex"),
        this.selection2Result.style.display = "inline-block") : a.type === SNAP_EDGE ? (this.selection2Result.setAttribute("data-i18n", "Edge"),
        this.selection2Result.textContent = h.i18n.translate("Edge") + " - " + this.measureTool.getEdgeLength(a.geometry),
        this.selection2Result.style.display = "inline-block") : a.type === SNAP_FACE ? (this.selection2Result.setAttribute("data-i18n", "Face"),
        this.selection2Result.textContent = h.i18n.translate("Face") + " - " + this.measureTool.getFaceArea(a.geometry),
        this.selection2Result.style.display = "inline-block") : a.type === SNAP_CIRCULARARC && (this.selection2Result.setAttribute("data-i18n", "Edge"),
        this.selection2Result.textContent = h.i18n.translate("Edge") + " - " + this.measureTool.getEdgeLength(a.geometry),
        this.selection2Result.style.display = "inline-block"),
        this.selection2.style.display = "block",
        this.resizeToContent())
    }
    ;
    a.prototype.firstSelectionRepick = function() {
        this.measureTool.clearFirstPick();
        this.selection1Result.textContent = this.selection2Result.textContent;
        this.clearSelectionTwo();
        this.clearResult();
        this.resizeToContent()
    }
    ;
    a.prototype.secondSelectionRepick = function() {
        this.measureTool.clearSecondPick();
        this.clearSelectionTwo();
        this.clearResult();
        this.resizeToContent()
    }
    ;
    a.prototype.hideMeasureResult = function() {
        this.clearSelectionOne();
        this.clearSelectionTwo();
        this.clearResult();
        this.resizeToContent()
    }
    ;
    a.prototype.disableUnitOption = function(a) {
        null  != a ? this.unitList.dropdownElement.children[a].style.display = "none" : this.unitList.dropdownElement.disabled = 
        !0
    }
    ;
    a.prototype.showMeasureSettings = function() {
        this.isSettingsExpanded ? (this.measureSettings.style.display = "none",
        this.isSettingsExpanded = !1) : (this.measureSettings.style.display = "block",
        this.isSettingsExpanded = !0);
        this.resizeToContent()
    }
    ;
    a.prototype.clearSelectionOne = function() {
        this.selection1Result.setAttribute("data-i18n", "Select Object");
        this.selection1Result.textContent = h.i18n.translate("Select Object")
    }
    ;
    a.prototype.clearSelectionTwo = function() {
        this.selection2Result.setAttribute("data-i18n", "Select Object");
        this.selection2Result.textContent = h.i18n.translate("Select Object")
    }
    ;
    a.prototype.clearResult = function() {
        this.distIcon.style.display = "none";
        this.angleIcon.style.display = "none";
        this.distanceDiv.style.display = "none";
        this.angleDiv.style.display = "none";
        this.initialDiv.style.display = "inline-block";
        this.deltaButton.style.display = "none";
        this.deltaXDiv.style.display = "none";
        this.deltaYDiv.style.display = "none";
        this.deltaZDiv.style.display = "none"
    }
    ;
    f.MeasurePanel = a
}
)();
TeratekNamespace("Teratek.Viewing.Extensions.Measure");
var SNAP_VERTEX = 0
  , SNAP_EDGE = 1
  , SNAP_FACE = 2
  , SNAP_CIRCULARARC = 3
  , SNAP_PRECISION = .001;
Teratek.Viewing.Extensions.Measure.Snapper = function(f) {
    function h(a, b) {
        this.viewer = a;
        this.snapper = b;
        this.lineGeom = new THREE.Geometry;
        this.circularArc = null ;
        this.circularArcCenter;
        this.ellipticalArc = null ;
        this.ellipticalArcCenter;
        this.minDist = Number.MAX_VALUE;
        this.vpIdElliptical = this.vpIdCircular = this.vpIdLine = null ;
        this.detectRadius = this.snapper.getDetectRadius()
    }
    var g = ["snapper"]
      , d = !1
      , c = null 
      , a = Number.MAX_VALUE
      , b = null 
      , k = null 
      , l = null 
      , n = null 
      , m = null 
      , q = null 
      , r = null 
      , t = null 
      , w = !1
      , C = !1
      , E = null 
      , G = null ;
    this.isActive = 
    function() {
        return d
    }
    ;
    this.getNames = function() {
        return g
    }
    ;
    this.getName = function() {
        return g[0]
    }
    ;
    this.activate = function() {
        d = !0
    }
    ;
    this.deactivate = function() {
        d = !1;
        this.destroy()
    }
    ;
    this.getFace = function() {
        return k
    }
    ;
    this.getEdge = function() {
        return l
    }
    ;
    this.getVertex = function() {
        return n
    }
    ;
    this.getSnapNode = function() {
        return m
    }
    ;
    this.getHighlightGeometry = function() {
        return q
    }
    ;
    this.getIntersectPoint = function() {
        return r
    }
    ;
    this.getFaceNormal = function() {
        return t
    }
    ;
    this.getEndPointsInEdge = function(a) {
        a = a.vertices;
        for (var b = 
        [], c = 0; c < a.length; ++c) {
            for (var d = !1, f = 0; f < a.length; ++f)
                if (f !== c && a[f].equals(a[c])) {
                    d = !0;
                    break
                }
            d || b.push(a[c])
        }
        return b
    }
    ;
    this.getViewportIndex = function() {
        return E
    }
    ;
    this.getCircularArcCenter = function() {
        return G
    }
    ;
    this.getDetectRadius = function() {
        return c
    }
    ;
    this.isSnapped = function() {
        return C
    }
    ;
    this.isEqualWithPrecision = function(a, b) {
        return Math.abs(a - b) <= SNAP_PRECISION ? !0 : !1
    }
    ;
    this.isEqualVectorsWithPrecision = function(a, b) {
        return Math.abs(a.x - b.x) <= SNAP_PRECISION && Math.abs(a.y - b.y) <= SNAP_PRECISION && Math.abs(a.z - 
        b.z) <= SNAP_PRECISION ? !0 : !1
    }
    ;
    this.isInverseVectorsWithPrecision = function(a, b) {
        return Math.abs(a.x + b.x) <= SNAP_PRECISION && Math.abs(a.y + b.y) <= SNAP_PRECISION && Math.abs(a.z + b.z) <= SNAP_PRECISION ? !0 : !1
    }
    ;
    this.snapping3D = function(d) {
        m = d.dbId;
        var g = d.face;
        r = d.intersectPoint;
        var h;
        h = void 0 === d.fragId.length ? [d.fragId] : d.fragId;
        if (f.model.hasTopology()) {
            m && (h = [],
            f.model.getData().instanceTree.enumNodeFragments(m, function(a) {
                h.push(a)
            }
            , !0));
            k = l = n = null ;
            a = Number.MAX_VALUE;
            for (d = 0; d < h.length; ++d) {
                var z = h[d]
                  , w = f.impl.getRenderProxy(f.model, 
                z)
                  , I = w.geometry
                  , z = f.model.getTopoIndex(z)
                  , J = f.model.getTopology(z)
                  , z = J.faces
                  , J = J.edges;
                k || (k = this.faceSnappingWithTopology(g, I, z, w),
                z = (new THREE.Matrix3).getNormalMatrix(w.matrixWorld),
                t = g.normal.applyMatrix3(z).normalize());
                this.edgeSnappingWithTopology(r, I, J, w)
            }
            n = this.vertexSnappingWithTopology(l, r);
            k && (c = this.setDetectRadius(r),
            b < c ? (this.drawPoint(n),
            q = SNAP_VERTEX) : a < c ? (this.drawLine(l),
            q = SNAP_EDGE) : (this.drawFace(k),
            q = SNAP_FACE),
            C = !1)
        } else
            for (d = 0; d < h.length; ++d)
                if (z = h[d],
                w = f.impl.getRenderProxy(f.model, 
                z),
                I = w.geometry,
                k = this.faceSnapping(g, I)) {
                    k.applyMatrix(w.matrixWorld);
                    l = this.edgeSnapping(k, r);
                    n = this.vertexSnapping(l, r);
                    z = (new THREE.Matrix3).getNormalMatrix(w.matrixWorld);
                    t = g.normal.applyMatrix3(z).normalize();
                    c = this.setDetectRadius(r);
                    b < c ? (this.drawPoint(n),
                    q = SNAP_VERTEX) : a < c ? (this.drawLine(l),
                    q = SNAP_EDGE) : (this.drawFace(k),
                    q = SNAP_FACE);
                    C = !0;
                    break
                }
    }
    ;
    this.faceSnappingWithTopology = function(a, b, c, d) {
        var f = new THREE.Vector3
          , g = new THREE.Vector3
          , h = new THREE.Vector3
          , k = new THREE.Geometry
          , l = b.attributes;
        if (void 0 !== l.index) {
            l = b.vb ? b.vb : l.position.array;
            b = b.vb ? b.vbstride : 3;
            for (var m = 0; m < c.length; m++) {
                for (var n = c[m].indexList, q = 0; q < n.length; q += 3)
                    if (a.a === n[q]) {
                        if (a.b === n[q + 1] && a.c === n[q + 2] || a.b === n[q + 2] && a.c === n[q + 1])
                            break
                    } else if (a.a === n[q + 1]) {
                        if (a.b === n[q] && a.c === n[q + 2] || a.b === n[q + 2] && a.c === n[q])
                            break
                    } else if (a.a === n[q + 2] && (a.b === n[q] && a.c === n[q + 1] || a.b === n[q + 1] && a.c === n[q]))
                        break;
                if (q < n.length)
                    break
            }
            if (m < c.length)
                for (q = 0; q < n.length; q += 3)
                    f.set(l[n[q] * b], l[n[q] * b + 1], l[n[q] * b + 2]),
                    g.set(l[n[q + 1] * b], 
                    l[n[q + 1] * b + 1], l[n[q + 1] * b + 2]),
                    h.set(l[n[q + 2] * b], l[n[q + 2] * b + 1], l[n[q + 2] * b + 2]),
                    a = k.vertices.length,
                    k.vertices.push(f.clone()),
                    k.vertices.push(g.clone()),
                    k.vertices.push(h.clone()),
                    k.faces.push(new THREE.Face3(a,a + 1,a + 2))
        }
        return 0 < k.vertices.length ? (k.applyMatrix(d.matrixWorld),
        k) : null 
    }
    ;
    this.faceSnapping = function(a, b) {
        var c = new THREE.Vector3
          , d = new THREE.Vector3
          , f = new THREE.Vector3
          , g = new THREE.Geometry
          , h = b.attributes;
        if (void 0 !== h.index) {
            var k = h.index.array || b.ib
              , l = b.vb ? b.vb : h.position.array
              , m = b.vb ? b.vbstride : 
            3;
            (h = b.offsets) && 0 !== h.length || (h = [{
                start: 0,
                count: k.length,
                index: 0
            }]);
            for (var n = 0; n < h.length; ++n)
                for (var q = h[n].start, r = h[n].count, t = h[n].index, w = q; w < q + r; w += 3) {
                    var C = t + k[w]
                      , E = t + k[w + 1]
                      , G = t + k[w + 2];
                    c.set(l[C * m], l[C * m + 1], l[C * m + 2]);
                    d.set(l[E * m], l[E * m + 1], l[E * m + 2]);
                    f.set(l[G * m], l[G * m + 1], l[G * m + 2]);
                    C = THREE.Triangle.normal(c, d, f);
                    E = new THREE.Vector3;
                    E.set(l[a.a * m], l[a.a * m + 1], l[a.a * m + 2]);
                    this.isEqualVectorsWithPrecision(C, a.normal) && this.isEqualWithPrecision(C.dot(c), a.normal.dot(E)) && (C = g.vertices.length,
                    g.vertices.push(c.clone()),
                    g.vertices.push(d.clone()),
                    g.vertices.push(f.clone()),
                    g.faces.push(new THREE.Face3(C,C + 1,C + 2)))
                }
        }
        return 0 < g.vertices.length ? this.getTrianglesOnSameFace(g, a, l, m) : null 
    }
    ;
    this.getTrianglesOnSameFace = function(a, b, c, d) {
        var f = !1;
        a = a.vertices.slice();
        var g = new THREE.Vector3;
        g.set(c[b.a * d], c[b.a * d + 1], c[b.a * d + 2]);
        var h = new THREE.Vector3;
        h.set(c[b.b * d], c[b.b * d + 1], c[b.b * d + 2]);
        var l = new THREE.Vector3;
        l.set(c[b.c * d], c[b.c * d + 1], c[b.c * d + 2]);
        b = new THREE.Geometry;
        b.vertices.push(g);
        b.vertices.push(h);
        b.vertices.push(l);
        b.faces.push(new THREE.Face3(0,1,2));
        c = [];
        do {
            c = [];
            for (d = 0; d < a.length; d += 3)
                if (a[d].equals(g) && a[d + 1].equals(h) && a[d + 2].equals(l))
                    f = !0,
                    c.push(d);
                else
                    for (var k = 0; k < b.vertices.length; k += 3)
                        if (this.trianglesSharedEdge(a[d], a[d + 1], a[d + 2], b.vertices[k], b.vertices[k + 1], b.vertices[k + 2])) {
                            k = b.vertices.length;
                            b.vertices.push(a[d].clone());
                            b.vertices.push(a[d + 1].clone());
                            b.vertices.push(a[d + 2].clone());
                            b.faces.push(new THREE.Face3(k,k + 1,k + 2));
                            c.push(d);
                            break
                        }
            for (d = c.length - 1; 0 <= d; --d)
                a.splice(c[d], 3)
        } while (0 < 
        c.length);return f ? b : null 
    }
    ;
    this.trianglesSharedEdge = function(a, b, c, d, f, g) {
        var h = !1
          , l = !1
          , k = !1;
        if (a.equals(d) || a.equals(f) || a.equals(g))
            h = !0;
        if (b.equals(d) || b.equals(f) || b.equals(g))
            l = !0;
        if (c.equals(d) || c.equals(f) || c.equals(g))
            k = !0;
        return h & l || h & k || l & k ? !0 : !1
    }
    ;
    this.edgeSnappingWithTopology = function(b, c, d, f) {
        var g = new THREE.Geometry, h, k = Number.MAX_VALUE, m = new THREE.Vector3, n = new THREE.Vector3, q = c.attributes;
        if (void 0 !== q.index && void 0 != d) {
            q = c.vb ? c.vb : q.position.array;
            c = c.vb ? c.vbstride : 3;
            for (var r = 0; r < 
            d.length; r++)
                for (var t = d[r].indexList, w = 0; w < t.length - 1; w++) {
                    m.set(q[t[w] * c], q[t[w] * c + 1], q[t[w] * c + 2]);
                    n.set(q[t[w + 1] * c], q[t[w + 1] * c + 1], q[t[w + 1] * c + 2]);
                    m.applyMatrix4(f.matrixWorld);
                    n.applyMatrix4(f.matrixWorld);
                    var C = this.distancePointToLine(b, m, n);
                    C < k && (k = C,
                    h = r)
                }
            if (h)
                for (t = d[h].indexList,
                b = 0; b < t.length - 1; b++)
                    g.vertices.push(new THREE.Vector3(q[t[b] * c],q[t[b] * c + 1],q[t[b] * c + 2])),
                    g.vertices.push(new THREE.Vector3(q[t[b + 1] * c],q[t[b + 1] * c + 1],q[t[b + 1] * c + 2]))
        }
        a >= k && 0 < g.vertices.length && (a = k,
        g.applyMatrix(f.matrixWorld),
        l = g)
    }
    ;
    this.edgeSnapping = function(b, c) {
        for (var d = new THREE.Geometry, f = !0, g = !0, h = !0, k = 0; k < b.vertices.length; k += 3) {
            for (var l = 0; l < b.vertices.length; l += 3)
                k !== l && ((b.vertices[k].equals(b.vertices[l]) || b.vertices[k].equals(b.vertices[l + 1]) || b.vertices[k].equals(b.vertices[l + 2])) && (b.vertices[k + 1].equals(b.vertices[l]) || b.vertices[k + 1].equals(b.vertices[l + 1]) || b.vertices[k + 1].equals(b.vertices[l + 2])) && (f = !1),
                (b.vertices[k].equals(b.vertices[l]) || b.vertices[k].equals(b.vertices[l + 1]) || b.vertices[k].equals(b.vertices[l + 
                2])) && (b.vertices[k + 2].equals(b.vertices[l]) || b.vertices[k + 2].equals(b.vertices[l + 1]) || b.vertices[k + 2].equals(b.vertices[l + 2])) && (g = !1),
                (b.vertices[k + 1].equals(b.vertices[l]) || b.vertices[k + 1].equals(b.vertices[l + 1]) || b.vertices[k + 1].equals(b.vertices[l + 2])) && (b.vertices[k + 2].equals(b.vertices[l]) || b.vertices[k + 2].equals(b.vertices[l + 1]) || b.vertices[k + 2].equals(b.vertices[l + 2])) && (h = !1));
            f && (d.vertices.push(b.vertices[k].clone()),
            d.vertices.push(b.vertices[k + 1].clone()));
            g && (d.vertices.push(b.vertices[k].clone()),
            d.vertices.push(b.vertices[k + 2].clone()));
            h && (d.vertices.push(b.vertices[k + 1].clone()),
            d.vertices.push(b.vertices[k + 2].clone()));
            h = g = f = !0
        }
        for (var f = new THREE.Geometry, m, g = Number.MAX_VALUE, h = 0; h < d.vertices.length; h += 2)
            k = this.distancePointToLine(c, d.vertices[h], d.vertices[h + 1]),
            k < g && (g = k,
            m = h);
        f.vertices.push(d.vertices[m].clone());
        f.vertices.push(d.vertices[m + 1].clone());
        f.vertices = this.getConnectedLineSegmentsOnSameLine(d, f.vertices);
        a = g;
        return f
    }
    ;
    this.distancePointToLine = function(a, b, c) {
        var d = new THREE.Vector3, 
        f = new THREE.Vector3, g;
        d.subVectors(b, a);
        f.subVectors(c, b);
        g = d.dot(f);
        d.subVectors(c, b);
        g = -g / d.dot(d);
        0 > g ? a = a.distanceTo(b) : 1 < g ? a = a.distanceTo(c) : (d.subVectors(a, b),
        f.subVectors(a, c),
        d.cross(f),
        f.subVectors(c, b),
        a = Math.sqrt(d.dot(d)) / Math.sqrt(f.dot(f)));
        return a
    }
    ;
    this.getConnectedLineSegmentsOnSameLine = function(a, b) {
        var c = a.vertices.slice()
          , d = b[0]
          , f = b[1]
          , g = [];
        do {
            for (var g = [], h = 0; h < c.length; h += 2)
                if (!c[h].equals(d) || !c[h + 1].equals(f))
                    for (var k = 0; k < b.length; k += 2)
                        if (c[h].equals(b[k]) || c[h + 1].equals(b[k]) || 
                        c[h].equals(b[k + 1]) || c[h + 1].equals(b[k + 1])) {
                            var l = new THREE.Vector3
                              , m = new THREE.Vector3;
                            l.subVectors(b[k], b[k + 1]);
                            l.normalize();
                            m.subVectors(c[h], c[h + 1]);
                            m.normalize();
                            if (this.isEqualVectorsWithPrecision(l, m) || this.isInverseVectorsWithPrecision(l, m)) {
                                g.push(h);
                                break
                            }
                        }
            for (h = g.length - 1; 0 <= h; --h)
                b.push(c[g[h]]),
                b.push(c[g[h] + 1]),
                c.splice(g[h], 2)
        } while (0 < g.length);return b
    }
    ;
    this.vertexSnappingWithTopology = function(a, c) {
        var d = Number.MAX_VALUE
          , f = new THREE.Vector3;
        a && 1 < a.vertices.length && (d = c.distanceTo(a.vertices[0]),
        f = c.distanceTo(a.vertices[a.vertices.length - 1]),
        d <= f ? f = a.vertices[0].clone() : (d = f,
        f = a.vertices[a.vertices.length - 1].clone()));
        b = d;
        return f
    }
    ;
    this.vertexSnapping = function(a, c) {
        for (var d = Number.MAX_VALUE, f = new THREE.Vector3, g = 0; g < a.vertices.length; ++g) {
            var h = c.distanceTo(a.vertices[g]);
            h < d - SNAP_PRECISION && (d = h,
            f = a.vertices[g].clone())
        }
        b = d;
        return f
    }
    ;
    this.angleVector2 = function(a) {
        return 0 < a.x && 0 <= a.y ? Math.atan(a.y / a.x) : 0 <= a.x && 0 > a.y ? Math.atan(a.y / a.x) + 2 * Math.PI : 0 > a.x && 0 >= a.y ? Math.atan(a.y / a.x) + Math.PI : 
        0 >= a.x && 0 < a.y ? Math.atan(a.y / a.x) + Math.PI : null 
    }
    ;
    h.prototype.onLineSegment = function(a, b, c, d, f) {
        var g = this.snapper.getIntersectPoint()
          , h = this.lineGeom.vertices;
        a = new THREE.Vector3(a,b,g.z);
        c = new THREE.Vector3(c,d,g.z);
        g = this.snapper.distancePointToLine(g, a, c);
        g <= this.detectRadius && g < this.minDist && (h.splice(0, 2, a, c),
        this.minDist = g,
        this.vpIdLine = f)
    }
    ;
    h.prototype.onCircularArc = function(a, b, c, d, f, g) {
        var h = this.snapper.getIntersectPoint()
          , k = new THREE.Vector2(h.x,h.y)
          , l = new THREE.Vector2(a,b)
          , m = k.distanceTo(l);
        k.sub(l);
        k = this.snapper.angleVector2(k);
        if (Math.abs(m - f) <= this.detectRadius) {
            if (d > c && k >= c && k <= d)
                c = new THREE.CircleGeometry(f,100,c,d - c);
            else if (d < c && (k >= c || k <= d))
                c = new THREE.CircleGeometry(f,100,c,2 * Math.PI - c + d);
            else
                return;
            c.vertices.splice(0, 1);
            c.applyMatrix((new THREE.Matrix4).makeTranslation(a, b, h.z));
            this.circularArc = c;
            this.circularArcCenter = new THREE.Vector3(a,b,h.z);
            this.vpIdCircular = g
        }
    }
    ;
    h.prototype.onEllipticalArc = function(a, b, c, d, f, g, h, k) {
        h = this.snapper.getIntersectPoint();
        var l = new THREE.Vector2(h.x,
        h.y)
          , m = f - this.detectRadius
          , n = g - this.detectRadius
          , q = f + this.detectRadius
          , r = g + this.detectRadius
          , m = (l.x - a) * (l.x - a) / (m * m) + (l.y - b) * (l.y - b) / (n * n)
          , q = (l.x - a) * (l.x - a) / (q * q) + (l.y - b) * (l.y - b) / (r * r)
          , r = new THREE.Vector2(a,b);
        l.sub(r);
        l.x *= g;
        l.y *= f;
        l = this.snapper.angleVector2(l);
        d > 2 * Math.PI && (d = 2 * Math.PI);
        1 <= m && 1 >= q && (d > c && l >= c && l <= d || d < c && (l >= c || l <= d)) && (f = new THREE.EllipseCurve(a,b,f,g,c,d,!1),
        f = (new THREE.Path(f.getPoints(50))).createPointsGeometry(50),
        this.snapper.isEqualWithPrecision(d - c, 2 * Math.PI) || f.vertices.pop(),
        f.applyMatrix((new THREE.Matrix4).makeTranslation(0, 0, h.z)),
        this.ellipticalArc = f,
        this.ellipticalArcCenter = new THREE.Vector3(a,b,h.z),
        this.vpIdElliptical = k)
    }
    ;
    this.snapping2D = function(a) {
        if (a) {
            var b = a.intersectPoint
              , d = a.fragId;
            if ("undefined" !== typeof d) {
                Array.isArray(d) || (d = [d]);
                r = b;
                c = this.setDetectRadius(b);
                for (var g = new h(f,this), k = 0; k < d.length; ++k) {
                    var m = f.impl.getRenderProxy(f.model, d[k]);
                    (new Teratek.Viewing.Private.VertexBufferReader(m.geometry)).enumGeomsForObject(a.dbId, g)
                }
                g.circularArc ? (b.distanceTo(g.circularArc.vertices[0]) < 
                c ? (n = g.circularArc.vertices[0],
                this.drawPoint(n),
                q = SNAP_VERTEX) : b.distanceTo(g.circularArc.vertices[g.circularArc.vertices.length - 1]) < c ? (n = g.circularArc.vertices[g.circularArc.vertices.length - 1],
                this.drawPoint(n),
                q = SNAP_VERTEX) : (this.lineStripToPieces(g.circularArc),
                l = g.circularArc,
                this.drawLine(l),
                G = g.circularArcCenter,
                q = SNAP_CIRCULARARC),
                E = g.vpIdCircular,
                C = !0) : g.ellipticalArc ? (b.distanceTo(g.ellipticalArc.vertices[0]) < c ? (n = g.ellipticalArc.vertices[0],
                this.drawPoint(n),
                q = SNAP_VERTEX) : b.distanceTo(g.ellipticalArc.vertices[g.ellipticalArc.vertices.length - 
                1]) < c ? (n = g.ellipticalArc.vertices[g.ellipticalArc.vertices.length - 1],
                this.drawPoint(n),
                q = SNAP_VERTEX) : (this.lineStripToPieces(g.ellipticalArc),
                l = g.ellipticalArc,
                this.drawLine(l),
                G = g.ellipticalArcCenter,
                q = SNAP_CIRCULARARC),
                E = g.vpIdElliptical,
                C = !0) : g.lineGeom.vertices.length && (b.distanceTo(g.lineGeom.vertices[0]) < c ? (n = g.lineGeom.vertices[0],
                this.drawPoint(n),
                q = SNAP_VERTEX) : b.distanceTo(g.lineGeom.vertices[1]) < c ? (n = g.lineGeom.vertices[1],
                this.drawPoint(n),
                q = SNAP_VERTEX) : (l = g.lineGeom,
                this.drawLine(l),
                q = SNAP_EDGE),
                E = g.vpIdLine,
                C = !0)
            }
        }
    }
    ;
    this.lineStripToPieces = function(a) {
        a = a.vertices;
        for (var b = a.length - 2; 0 < b; b--)
            a.splice(b, 0, a[b])
    }
    ;
    this.createOverlay = function(a) {
        f.impl.createOverlayScene(a)
    }
    ;
    this.addOverlay = function(a, b) {
        f.impl.addOverlay(a, b)
    }
    ;
    this.clearOverlay = function() {
        f.impl.overlayScenes["MeasureTool-snapper-face"] && f.impl.clearOverlay("MeasureTool-snapper-face");
        f.impl.overlayScenes["MeasureTool-snapper-vertex"] && f.impl.clearOverlay("MeasureTool-snapper-vertex");
        f.impl.overlayScenes["MeasureTool-snapper-edge"] && 
        f.impl.clearOverlay("MeasureTool-snapper-edge")
    }
    ;
    this.drawFace = function(a) {
        this.createOverlay("MeasureTool-snapper-face");
        var b = new THREE.MeshPhongMaterial({
            color: 52224,
            ambient: 52224,
            opacity: .5,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1,
            side: THREE.DoubleSide
        });
        a = new THREE.Mesh(a,b,!0);
        this.addOverlay("MeasureTool-snapper-face", a)
    }
    ;
    this.cylinderMesh = function(a, b, c) {
        var d = (new THREE.Vector3).subVectors(b, a)
          , f = new THREE.Matrix4;
        f.lookAt(a, b, (new THREE.Object3D).up);
        f.multiply((new THREE.Matrix4).set(1, 
        0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1));
        d = new THREE.CylinderGeometry(.5,.5,d.length(),8,1,!0);
        c = new THREE.Mesh(d,c);
        c.applyMatrix(f);
        c.position.x = (b.x + a.x) / 2;
        c.position.y = (b.y + a.y) / 2;
        c.position.z = (b.z + a.z) / 2;
        return c
    }
    ;
    this.drawLine = function(a) {
        this.createOverlay("MeasureTool-snapper-edge");
        for (var b = new THREE.MeshPhongMaterial({
            color: 52224,
            ambient: 52224,
            opacity: .5,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1,
            side: THREE.DoubleSide
        }), c = 0; c < a.vertices.length; c += 2) {
            var d = this.cylinderMesh(a.vertices[c], a.vertices[c + 
            1], b);
            this.setEdgeScale(d);
            this.addOverlay("MeasureTool-snapper-edge", d)
        }
    }
    ;
    this.drawArc = function(a) {
        this.createOverlay("MeasureTool-snapper-edge");
        for (var b = new THREE.MeshPhongMaterial({
            color: 52224,
            ambient: 52224,
            opacity: .5,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1,
            side: THREE.DoubleSide
        }), c = 0; c < a.vertices.length - 1; c++) {
            var d = this.cylinderMesh(a.vertices[c], a.vertices[c + 1], b);
            this.setEdgeScale(d);
            this.addOverlay("MeasureTool-snapper-edge", d)
        }
    }
    ;
    this.drawPoint = function(a) {
        this.createOverlay("MeasureTool-snapper-vertex");
        var b = new THREE.MeshPhongMaterial({
            color: 52224,
            ambient: 52224,
            opacity: .5,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1
        })
          , b = new THREE.Mesh(new THREE.SphereGeometry(1),b);
        b.position.set(a.x, a.y, a.z);
        this.setPointScale(b);
        this.addOverlay("MeasureTool-snapper-vertex", b)
    }
    ;
    this.setScale = function(a) {
        var b = f.navigation
          , c = b.getCamera()
          , d = b.getEyeVector()
          , g = b.getPosition();
        a = a.position.clone();
        c = c.isPerspective ? a.sub(g).dot(d.normalize()) : b.getEyeVector().length();
        d = b.getVerticalFov();
        c = 2 * c * Math.tan(THREE.Math.degToRad(.5 * 
        d));
        b = b.getScreenViewport();
        return 5 * c / (b.height * (window.devicePixelRatio || 1))
    }
    ;
    this.setPointScale = function(a) {
        var b = this.setScale(a);
        a.scale.x = b;
        a.scale.y = b;
        a.scale.z = b
    }
    ;
    this.setEdgeScale = function(a) {
        var b = this.setScale(a);
        a.scale.x = b;
        a.scale.z = b
    }
    ;
    this.updatePointScale = function() {
        var a = f.impl.overlayScenes["MeasureTool-snapper-vertex"];
        if (a)
            for (var a = a.scene, b = 0; b < a.children.length; b++) {
                var c = a.children[b];
                c && this.setPointScale(c)
            }
    }
    ;
    this.updateEdgeScale = function() {
        var a = f.impl.overlayScenes["MeasureTool-snapper-edge"];
        if (a)
            for (var a = a.scene, b = 0; b < a.children.length; b++) {
                var c = a.children[b];
                c && this.setEdgeScale(c)
            }
    }
    ;
    this.setDetectRadius = function(a) {
        var b = f.navigation
          , c = b.getCamera()
          , d = b.getEyeVector()
          , g = b.getPosition();
        a = a.clone();
        c = c.isPerspective ? a.sub(g).dot(d.normalize()) : b.getEyeVector().length();
        d = b.getVerticalFov();
        c = 2 * c * Math.tan(THREE.Math.degToRad(.5 * d));
        b = b.getScreenViewport();
        return 5 * c / (b.height * (window.devicePixelRatio || 1))
    }
    ;
    this.drawIntersectFace = function(a, b, c, d) {
        this.createOverlay();
        var f = new THREE.Vector3;
        f.set(b[a.a * c], b[a.a * c + 1], b[a.a * c + 2]);
        var g = new THREE.Vector3;
        g.set(b[a.b * c], b[a.b * c + 1], b[a.b * c + 2]);
        var h = new THREE.Vector3;
        h.set(b[a.c * c], b[a.c * c + 1], b[a.c * c + 2]);
        a = new THREE.Geometry;
        a.vertices.push(f);
        a.vertices.push(g);
        a.vertices.push(h);
        a.faces.push(new THREE.Face3(0,1,2));
        f = new THREE.Mesh(a,d.material,!0);
        f.matrixWorld = d.matrixWorld;
        this.addOverlay(f)
    }
    ;
    this.handleWheelInput = function(a) {
        this.updatePointScale();
        this.updateEdgeScale();
        return !1
    }
    ;
    this.handleButtonDown = function(a, b) {
        w = !0;
        return !1
    }
    ;
    this.handleButtonUp = function(a, b) {
        return w = !1
    }
    ;
    this.handleMouseMove = function(a) {
        w || (this.clearOverlay(),
        n = l = k = null ,
        C = !1,
        (a = f.impl.snappingHitTest(a.canvasX, a.canvasY, !1)) && a.intersectPoint && (a.face ? this.snapping3D(a) : this.snapping2D(a)));
        return !1
    }
    ;
    this.destroy = function() {
        this.clearOverlay();
        f.impl.removeOverlayScene("MeasureTool-snapper-face");
        f.impl.removeOverlayScene("MeasureTool-snapper-vertex");
        f.impl.removeOverlayScene("MeasureTool-snapper-edge")
    }
}
;
TeratekNamespace("Teratek.Viewing.Extensions.FirstPerson");
Teratek.Viewing.Extensions.FirstPerson.FirstPersonTool = function(f) {
    var h = -1 != navigator.userAgent.search("Mac OS")
      , g = f.navigation
      , d = f.container
      , c = g.getCamera()
      , a = ["firstperson"]
      , b = 0
      , k = Teratek.Viewing.theHotkeyManager.KEYCODES
      , l = !1
      , n = !0
      , m = !1
      , q = null 
      , r = new THREE.Clock(!0)
      , t = -1
      , w = 5E3
      , C = 1
      , E = 2
      , G = 0
      , B = -1E20
      , v = -1E20
      , D = 0
      , z = 0
      , H = !1
      , I = !1
      , J = !1
      , L = !1
      , F = !1
      , N = !1
      , K = !1;
    this.isActive = function() {
        return l
    }
    ;
    this.getNames = function() {
        return a
    }
    ;
    this.getName = function() {
        return a[0]
    }
    ;
    this.activate = function(a) {
        r.start();
        g.toPerspective();
        g.setVerticalFov(75, !0);
        f.model.getUnitScale();
        a = f.model.getBoundingBox().size();
        C = Math.max(Math.min(Math.min(a.x, a.y), a.z) / 10, 1E-4);
        f.canvas.focus();
        l = !0;
        K || ba()
    }
    ;
    this.deactivate = function(a) {
        l = !1;
        r.stop();
        S()
    }
    ;
    this.getCursor = function() {
        return "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3goOFQoQszohGAAAA9hJREFUSMedll1oHGUUhp8zuzP5291pEvNTomgVjFCCCa0NpAqJEJTUFVv8uWxQLwKCF6IUr7wJ6J30QvBCAlZssA0EkYJaAm1FwU3iakrbVNNuutlukk3dzWyT/ZnJ7ufFTtokbmvX72Y45+N73/Oe8858I+xYSikBJJFI7AmFQh9alvVWoVC47vP5ho4cOXJeRGwqWN4yOQ2oHh0dPROJRNo7OjqIRCKPRxeiP66srBxSSn0vIsX/RaCU0gDV399vNjQ0tB8/fpxAIEAsFuP06dPEYrFvgHqguEMxIqLKdUPbmnArU52dnb2maWJUGeRyOWzbpqGxgXg87gOMncDlwLe2Y5uCwcHBFp/P90k4PE349xkWolGi0SjhPy5hF+UmIEopz/1AtxRcqmJzDQ8P7750+Wq8e9+TPGLe4sSp39jz9LMsxm/izE6gOVnquoIcOHDgnddfe/VEU3PLWkUzSCQSesCzxNtvHKZu11O0137OuTMneYY1+l+px99sci5zgU+/Pv/Z5OTkWeCvigja2tqqri3/RPbiMfSWLvY+/wJ7XwxCOoyz+gPF5C0OzsFZv8NEOOxU7KL5+fkcooFUo9avYt+4htTU43noJVTmIPYvp8hnChSKCr/fr1VMkEqlCgEATUDTAIVykhSWRtj4M4/KKzZ9Z9u2ehCCbVUYhlEaurg7m09NB/GWYhe2r69vV8UEvb29DeIWL+6uIG6w6b1SGAqF0hUTZDKZ7GLKy1w0h+Z1keQuMEDOKbK+oZFIJOyKZqCUEsuy/k4mk6kr0ZH6/Z2CkrttEl1QjuJkKI3z6KGp6vTFpYoVmKaZ9Xg8lleDoq3IzOdBILuygbVgs2YVSNrgOM7o1NTURkUE7qufX15evo5A0VHcnrNRgFgFJF6gsVmntlaIxWKNIlK/s8D/VCAianZ29spmv0vfVoVuaNT6PYhWMpGIGIZhNAGtQC3bbXDfj51YlrWObHeOKu3didfX1x3btgGqgADgu5eafyXT6XT2zmDLnVDg9Xq9uq573fMeQAeqy+HtTAgguq7h0aUsgyZCJpPZcBxnE1xz3fhACqp7enoe+3ZimVg8j6ELiIACEUETWErnsCwrD2h1dXW6C+4A2a033T0VfPD+e8dePvoFb36sM/LzKomkQ1FgMW3z7neL3Gh6jtbW1rmamhrDNM0NYAVIAYWyl06ZPwoNeHh6evqJmZmZiV8vnCBw+yLRRCv7gkdpamr6aGho6KuBgQFnfHx88V7AZQlcEt01jgD+sbGx3V+OjPR07d8fDQaDl1OpVLK7u9swTXP1Qa7NfwCi46BIaoRmhAAAAABJRU5ErkJggg==), auto"
    }
    ;
    this.adjustSpeed = function(a) {
        0 === a ? E = 2 : (E *= 0 < a ? 1.1 : .9,
        .01 > E && (E = .01))
    }
    ;
    this.handleGesture = function(a) {
        switch (a.type) {
        case "dragstart":
            return q = "drag",
            this.handleButtonDown(a, 0);
        case "dragmove":
            return "drag" === q ? this.handleMouseMove(a) : !1;
        case "dragend":
            if ("drag" === q)
                return this.handleButtonUp(a, 0),
                q = null ,
                !0
        }
        return !1
    }
    ;
    this.handleSingleClick = function(a, b) {
        return !1
    }
    ;
    this.handleButtonDown = function(a, b) {
        S();
        var c;
        q ? c = !0 : (c = a.metaKey && !h,
        c = a.ctrlKey || h && a.metaKey || c || a.shiftKey || a.altKey);
        0 !== b || c || (D = z = 
        0,
        m = !0);
        return !0
    }
    ;
    this.handleMouseMove = function(a) {
        var b = -1E10 > B ? 0 : a.pageX - B
          , c = -1E10 > v ? 0 : a.pageY - v;
        B = a.pageX;
        v = a.pageY;
        m === n && (D += .0035 * b,
        z += .0035 * c);
        return !0
    }
    ;
    this.handleButtonUp = function(a, b) {
        0 === b && m && (D = z = 0,
        m = !1);
        return !0
    }
    ;
    this.handleKeyDown = function(a, c) {
        S();
        var d = !1;
        switch (c) {
        case k.TAB:
            d = !1;
            break;
        case k.SHIFT:
            b = 1;
            d = !0;
            break;
        case k.CONTROL:
            d = !0;
            break;
        case k.ALT:
            d = !0;
            break;
        case k.SPACE:
            d = !0;
            break;
        case k.EQUALS:
            this.adjustSpeed(1);
            d = !0;
            break;
        case k.DASH:
            this.adjustSpeed(-1);
            d = !0;
            break;
        case k.ZERO:
            this.adjustSpeed(0);
            d = !0;
            break;
        case k.UP:
        case k.w:
            d = H = !0;
            break;
        case k.LEFT:
        case k.a:
            d = J = !0;
            break;
        case k.DOWN:
        case k.s:
            d = I = !0;
            break;
        case k.RIGHT:
        case k.d:
            d = L = !0;
            break;
        case k.q:
            d = F = !0;
            break;
        case k.e:
            d = N = !0;
            break;
        case k.g:
            d = !0;
            break;
        case k.F1:
            d = !0
        }
        return d
    }
    ;
    this.handleKeyUp = function(a, c) {
        var d = !1;
        switch (c) {
        case k.TAB:
            d = !1;
            break;
        case k.SHIFT:
            b = 0;
            d = !0;
            break;
        case k.CONTROL:
            d = !0;
            break;
        case k.ALT:
            d = !0;
            break;
        case k.SPACE:
            d = !0;
            break;
        case k.UP:
        case k.w:
            H = !1;
            d = !0;
            break;
        case k.LEFT:
        case k.a:
            J = !1;
            d = !0;
            break;
        case k.DOWN:
        case k.s:
            I = 
            !1;
            d = !0;
            break;
        case k.RIGHT:
        case k.d:
            L = !1;
            d = !0;
            break;
        case k.q:
            F = !1;
            d = !0;
            break;
        case k.e:
            N = !1;
            d = !0;
            break;
        case k.g:
            d = n = !n;
            S();
            M({
                msgTitleKey: "View Orientation Drag Mode Toggled",
                messageKey: "View Orientation Drag Mode Toggled",
                messageDefaultValue: d ? "Press the primary mouse button and drag to change the view orientation" : "Move the cursor to change the view orientation"
            }, 0);
            d = !0;
            break;
        case k.F1:
            ba(),
            d = !0
        }
        return d
    }
    ;
    this.handleWheelInput = function(a) {
        g.getReverseZoomDirection() && (a *= -1);
        G += a;
        return !0
    }
    ;
    this.handleSingleClick = 
    function(a, b) {
        return !1
    }
    ;
    this.handleDoubleClick = function(a, b) {
        return !1
    }
    ;
    this.handleSingleTap = function(a) {
        return this.handleSingleClick(a, 0)
    }
    ;
    this.handleDoubleTap = function(a) {
        return !1
    }
    ;
    this.handleBlur = function(a) {
        return F = N = J = L = H = I = !1
    }
    ;
    this.update = function() {
        if (!l)
            return !1;
        var a = r.getDelta();
        -1 < t && (new Date).getTime() - t > w && S();
        c.isPerspective || (console.log("Lost perspective mode: resetting view."),
        g.toPerspective());
        var d = c.clone()
          , f = a * E * C * (1 === b ? 4 : 1)
          , a = .5 * a * C * (1 === b ? 4 : 1);
        0 != G && (d.translateZ(-(1 * G * 
        C * (1 === b ? 4 : 1))),
        G = 0);
        H && d.translateZ(-f);
        I && d.translateZ(f);
        J && d.translateX(-f);
        L && d.translateX(f);
        F && d.translateY(a);
        N && d.translateY(-a);
        var f = d.position
          , a = 0 !== f.distanceToSquared(c.position)
          , h = d.target
          , h = c.target.clone().sub(c.position)
          , k = h.clone().cross(c.up).normalize();
        if (0 != z) {
            var m = new THREE.Quaternion;
            m.setFromAxisAngle(k, -z);
            k = h.clone();
            k.applyQuaternion(m);
            var n = c.worldup.clone()
              , k = k.angleTo(n)
              , n = THREE.Math.degToRad(5);
            k >= n && k <= Math.PI - n && (h.applyQuaternion(m),
            d.up.applyQuaternion(m));
            z = 
            0
        }
        0 != D && (m = new THREE.Quaternion,
        m.setFromAxisAngle(c.worldup, -D),
        h.applyQuaternion(m),
        d.up.applyQuaternion(m),
        D = 0);
        h = f.clone().add(h);
        d = 0 !== h.distanceToSquared(c.target);
        if (a || d)
            g.setView(f, h),
            g.orientCameraUp();
        return c.dirty
    }
    ;
    var M = function(a, b, c, f, g) {
        Teratek.Viewing.Private.HudMessage.displayMessage(d, a, c, f, g);
        0 < b ? (t = (new Date).getTime(),
        w = b) : (t = -1,
        w = 0)
    }
      , S = function() {
        Teratek.Viewing.Private.HudMessage.dismiss();
        t = -1
    }
      , ba = function() {
        S();
        M({
            msgTitleKey: "First Person Tool",
            messageKey: "First Person Tool",
            messageDefaultValue: "Use the WASD and QE keys to move",
            checkboxChecked: K
        }, 0, null , null , function(a) {
            K = a.target.checked
        }
        )
    }
}
;
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.FirstPerson");
Teratek.Viewing.Extensions.FirstPerson.FirstPersonExtension = function(f, h) {
    Teratek.Viewing.Extension.call(this, f, h)
}
;
Teratek.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype = Object.create(Teratek.Viewing.Extension.prototype);
Teratek.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.constructor = Teratek.Viewing.Extensions.FirstPerson.FirstPersonExtension;
Teratek.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.load = function() {
    var f = this
      , h = this.viewer
      , g = h.getToolbar(!0)
      , d = Teratek.Viewing.UI;
    this.tool = new Teratek.Viewing.Extensions.FirstPerson.FirstPersonTool(h);
    h.toolController.registerTool(this.tool);
    this.createUI(g);
    this.onToolChanged = function(c) {
        -1 !== c.toolName.indexOf("firstperson") && f.firstPersonToolButton.setState(c.active ? d.Button.State.ACTIVE : d.Button.State.INACTIVE)
    }
    ;
    h.addEventListener(Teratek.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    return !0
}
;
Teratek.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.createUI = function(f) {
    var h = this
      , g = this.viewer
      , d = Teratek.Viewing.UI;
    f = f.getControl(Teratek.Viewing.TOOLBAR.NAVTOOLSID);
    this.firstPersonToolButton = new d.Button("toolbar-firstPersonTool");
    this.firstPersonToolButton.setToolTip("First person");
    this.firstPersonToolButton.onClick = function(a) {
        a = h.firstPersonToolButton.getState();
        a === d.Button.State.INACTIVE ? g.setActiveNavigationTool("firstperson") : a === d.Button.State.ACTIVE && g.setActiveNavigationTool()
    }
    ;
    this.firstPersonToolButton.setIcon("teratek-icon-first-person");
    var c = f.getControl("toolbar-cameraSubmenuTool");
    c ? f.addControl(this.firstPersonToolButton, {
        index: f.indexOf(c.getId())
    }) : f.addControl(this.firstPersonToolButton)
}
;
Teratek.Viewing.Extensions.FirstPerson.FirstPersonExtension.prototype.unload = function() {
    var f = this.viewer;
    f.removeEventListener(Teratek.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = void 0;
    Teratek.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);
    var h = f.getToolbar(!1);
    h && h.getControl(Teratek.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.firstPersonToolButton.getId());
    this.firstPersonToolButton = null ;
    f.getActiveNavigationTool() == this.tool.getName() && f.setActiveNavigationTool();
    f.toolController.deregisterTool(this.tool);
    this.tool = null ;
    return !0
}
;
Teratek.Viewing.theExtensionManager.registerExtension("Teratek.FirstPerson", Teratek.Viewing.Extensions.FirstPerson.FirstPersonExtension);
TeratekNamespace("Teratek.Viewing.Extensions.VR");
Teratek.Viewing.Extensions.VR.VRTool = function(f, h) {
    var g = f.navigation
      , d = f.container
      , c = g.getCamera()
      , a = ["vr"]
      , b = !1
      , k = null 
      , l = !1
      , n = 0
      , m = 0
      , q = Teratek.Viewing.theHotkeyManager.KEYCODES
      , r = 0
      , t = !1
      , w = !1
      , C = !1
      , E = !1
      , G = !1
      , B = !1
      , v = new THREE.Clock(!0)
      , D = -1
      , z = 5E3
      , H = 1
      , I = 16
      , J = !1
      , L = 16
      , F = c.isPerspective
      , N = null 
      , K = null 
      , M = null 
      , S = !1
      , ba = -1
      , P = !0
      , aa = null 
      , Z = null 
      , V = !1
      , ea = new THREE.Vector3(0,0,0)
      , X = new THREE.Vector3(0,0,0)
      , R = !1;
    this.isActive = function() {
        return b
    }
    ;
    this.getNames = function() {
        return a
    }
    ;
    this.getName = function() {
        return a[0]
    }
    ;
    this.activate = function(a) {
        b || (l = c.worldup && 1 === c.worldup.z,
        console.log("VRTool : camera world up = " + c.worldup.x + "," + c.worldup.y + "," + c.worldup.z),
        v.start(),
        ia() ? (W({
            msgTitleKey: "VR Head Mounted Display",
            messageKey: "VR Head Mounted Display",
            messageDefaultValue: "VR Mode Enabled Head Mounted Display"
        }, 2E3),
        T(!1),
        console.log("VR Supported (Web API): Oculus, etc.")) : (W({
            msgTitleKey: "VR Device Orientation",
            messageKey: "VR Device Orientation",
            messageDefaultValue: "VR Mode Enabled Device Orientation"
        }, 2E3),
        window.addEventListener("deviceorientation", fa, !0)),
        R = "wearality" === (f.config && f.config.useVR ? f.config.useVR : "").toLowerCase(),
        O(!0),
        a = f.utilities.getBoundingBox(!0).size(),
        H = Math.max(Math.min(Math.min(a.x, a.y), a.z) / 100, 1),
        this.resetPointerTracking(),
        f.canvas.focus(),
        ga(),
        b = !0)
    }
    ;
    this.deactivate = function(a) {
        b && (b = !1,
        Teratek.Viewing.Private.HudMessage.dismiss(),
        D = -1,
        N && (M && (M.stop(),
        M = null ),
        N.disconnect(),
        N = null ,
        K && K.disable()),
        O(!1),
        exitFullscreen(),
        v.stop(),
        T(!0))
    }
    ;
    this.getCursor = function() {
        return "url(data:image/gif;base64,R0lGODlhGAAYAMIDAAQEBH19feDg4P///////////////////yH+EUNyZWF0ZWQgd2l0aCBHSU1QACH5BAEKAAQALAAAAAAYABgAAAMqSLrc/jDKSau9OOvN8fjDNghBIITZEABAgHpr+15jeYpgp+987//AICEBADs=), auto"
    }
    ;
    var T = function(a) {
        var b = document.getElementsByClassName("toolbar-menu");
        0 < b.length && "" !== b[0] && (b[0].style.display = a ? "block" : "none")
    }
      , O = function(a) {
        if (a !== !!k)
            if (console.log("Enable Render Context: " + a),
            a) {
                f.displayViewCube(!1, !1);
                (F = f.navigation.isPerspective) || f.navigation.toPerspective();
                a = !!aa;
                var b = null 
                  , b = R ? {
                    useWarp: a,
                    HMD: {
                        hResolution: 1920,
                        vResolution: 1080,
                        hScreenSize: .12576,
                        vScreenSize: .07074,
                        interpupillaryDistance: .075,
                        lensSeparationDistance: .075,
                        eyeToScreenDistance: .041,
                        distortionK: [1, .22, 
                        .24, 0],
                        chromaAbParameter: [.996, -.004, 1.014, 0]
                    }
                } : {
                    useWarp: a
                };
                k = new Teratek.Viewing.Extensions.Oculus.StereoRenderContext(b);
                f.impl.setUserRenderContext(k);
                f.resize(f.canvas.clientWidth, f.canvas.clientHeight);
                aa ? launchFullscreen(f.impl.canvas, {
                    vrDisplay: aa
                }) : launchFullscreen(f.impl.canvas)
            } else
                k = null ,
                f.impl.setUserRenderContext(null ),
                f.setScreenMode(Teratek.Viewing.ScreenMode.kNormal),
                f.displayViewCube(f.prefs.get("viewCube"), !1)
    }
    ;
    this.handleSingleTap = function(a) {
        if (N && a.pointers) {
            if (1 === a.pointers.length)
                return setTimeout(function() {
                    f.setActiveNavigationTool(f.defaultNavigationToolName)
                }
                , 
                10),
                !0;
            if (2 === a.pointers.length)
                return ca(),
                !0
        }
        return !1
    }
    ;
    this.handleDoubleTap = function(a) {
        return !1
    }
    ;
    this.handlePressHold = function(a) {
        return !1
    }
    ;
    this.handleGesture = function(a) {
        return !1
    }
    ;
    this.handleKeyDown = function(a, b) {
        var c = !1;
        switch (b) {
        case q.TAB:
            c = !0;
            break;
        case q.SHIFT:
            n = 1;
            c = !0;
            break;
        case q.CONTROL:
            m = 1;
            c = !0;
            break;
        case q.ALT:
            c = !0;
            break;
        case q.SPACE:
            c = !0;
            break;
        case q.EQUALS:
            this.adjustSpeed(1);
            c = !0;
            break;
        case q.DASH:
            this.adjustSpeed(-1);
            c = !0;
            break;
        case q.ZERO:
            this.adjustSpeed(0);
            c = !0;
            break;
        case q.w:
            if (1 === 
            m && 1 === n) {
                c = !0;
                break
            }
        case q.UP:
            c = t = !0;
            break;
        case q.LEFT:
        case q.a:
            c = C = !0;
            break;
        case q.DOWN:
        case q.s:
            c = w = !0;
            break;
        case q.RIGHT:
        case q.d:
            c = E = !0;
            break;
        case q.q:
            c = B = !0;
            break;
        case q.e:
            c = G = !0;
            break;
        case q.h:
            c = !0
        }
        return c
    }
    ;
    this.handleKeyUp = function(a, b) {
        var c = !1;
        switch (b) {
        case q.SHIFT:
            n = 0;
            break;
        case q.CONTROL:
            m = 0;
            break;
        case q.SPACE:
            aa && aa && ((V = !V) && ea.copy(X),
            da(V));
            c = !0;
            break;
        case q.w:
            if (!t && 1 === m && 1 === n) {
                setTimeout(function() {
                    O(!1);
                    R = !R;
                    O(!0)
                }
                , 10);
                c = !0;
                break
            }
        case q.UP:
            t = !1;
            c = !0;
            break;
        case q.LEFT:
        case q.a:
            C = 
            !1;
            c = !0;
            break;
        case q.DOWN:
        case q.s:
            w = !1;
            c = !0;
            break;
        case q.RIGHT:
        case q.d:
            E = !1;
            c = !0;
            break;
        case q.q:
            B = !1;
            c = !0;
            break;
        case q.e:
            G = !1;
            c = !0;
            break;
        case q.h:
            ga(),
            c = !0
        }
        return c
    }
    ;
    this.handleBlur = function(a) {
        return E = C = w = t = !1
    }
    ;
    this.update = function(a) {
        if (b) {
            a = v.getDelta();
            -1 < D && (new Date).getTime() - D > z && (Teratek.Viewing.Private.HudMessage.dismiss(),
            D = -1);
            var d;
            if (d = !!aa)
                if (Z) {
                    d = Z.getState();
                    if (c) {
                        l ? (X.x = d.position.x,
                        X.y = -d.position.z,
                        X.z = d.position.y) : (X.x = d.position.x,
                        X.y = d.position.y,
                        X.z = d.position.z);
                        if (V) {
                            var f = 
                            ea.distanceTo(X);
                            .15 <= f && (f = (f - .15) / .0762 * I * H * a,
                            f = X.clone().sub(ea).normalize().multiplyScalar(f),
                            c.position.add(f))
                        }
                        l ? (c.quaternion.x = d.orientation.x,
                        c.quaternion.y = -d.orientation.z,
                        c.quaternion.z = d.orientation.y) : (c.quaternion.x = d.orientation.x,
                        c.quaternion.y = d.orientation.y,
                        c.quaternion.z = d.orientation.z);
                        c.quaternion.w = d.orientation.w;
                        d = new THREE.Vector3(0,0,-1);
                        l && (d = new THREE.Vector3(d.x,-d.z,d.y));
                        d.applyQuaternion(c.quaternion);
                        c.target = c.position.clone().add(d.clone().multiplyScalar(10));
                        c.dirty = !0
                    }
                    d = !0
                } else
                    d = !1;
            !d && N && N && (d = N.update()) && (l && (f = d.z,
            d.z = d.y,
            d.y = -f),
            d = (l ? new THREE.Vector3(0,1,0) : new THREE.Vector3(0,0,-1)).clone().applyQuaternion(d),
            f = c.target.clone().sub(c.position).length(),
            g.setTarget(c.position.clone().add(d.multiplyScalar(f))),
            M ? M.isStarted() && (0 >= ba ? M.checkVideoThreshold(15) && ca() : M.checkVideoThreshold(15) ? J && (d = (new Date).getTime(),
            f = d - ba,
            250 < f && (ba = d,
            I += L,
            da(!0))) : ba = -1) : (f = l ? new THREE.Vector3(0,0,-1) : new THREE.Vector3(0,-1,0),
            d = THREE.Math.radToDeg(d.angleTo(f)),
            30 > d) ? S ? J && (d = (new Date).getTime(),
            f = d - ba,
            f >= (P ? 1500 : 1E3) && (P = !1,
            ba = d,
            I += L,
            da(!0))) : (ca(),
            S = !0,
            J && (P = !0)) : 30 <= d && (S = !1,
            ba = -1),
            c.dirty = !0);
            d = c.clone();
            f = a * I * H * (1 === n ? 4 : 1);
            a = 15 * a * H * (1 === n ? 4 : 1);
            0 != r && (d.translateZ(-(3 * r * H * (1 === n ? 4 : 1))),
            r = 0);
            var h = !1;
            J && (h = !0);
            (t || h) && d.translateZ(-f);
            w && d.translateZ(f);
            C && d.translateX(-f);
            E && d.translateX(f);
            G && d.translateY(a);
            B && d.translateY(-a);
            a = d.position;
            0 !== a.distanceToSquared(c.position) && (d = d.target,
            f = a.clone().sub(c.position),
            d.add(f),
            g.setView(a, d));
            return c.dirty
        }
    }
    ;
    this.resetPointerTracking = function() {
        _mouseDraggingLookMode = G = B = C = E = t = w = !1
    }
    ;
    var ca = function() {
        (J = !J) ? (L = I,
        I = 1.75,
        ba = (new Date).getTime()) : I = L;
        da(J);
        return J
    }
      , ia = function() {
        function a(c) {
            for (var d = 0; d < c.length; ++d)
                c[d] instanceof HMDVRDevice && (aa = c[d]);
            for (d = 0; d < c.length; ++d)
                c[d] instanceof PositionSensorVRDevice && (!aa || c[d].hardwareUnitId == aa.hardwareUnitId) && (Z = c[d],
                b = !0)
        }
        var b = !1;
        navigator.getVRDevices ? navigator.getVRDevices().then(a) : navigator.mozGetVRDevices ? navigator.mozGetVRDevices(a) : b = !1;
        return b
    }
      , 
    fa = function(a) {
        if (!a.alpha)
            return !1;
        window.removeEventListener("deviceorientation", fa, !0);
        N = new THREE.DeviceOrientationControls;
        N.connect();
        K || (K = new window.NoSleep,
        K.enable());
        M = new VideoHelper("videoVR","videoVR-canvas",1);
        M.start() || (M = null ,
        console.log("VideoHelper : Failed to start."));
        T(!1);
        console.log("VR Supported (DeviceOrientation): Google Goggles, etc.");
        return !0
    }
      , W = function(a, b) {
        Teratek.Viewing.Private.HudMessage.dismiss();
        Teratek.Viewing.Private.HudMessage.displayMessage(d, a);
        D = (new Date).getTime();
        if (!b || 0 >= b)
            b = 5E3;
        z = b
    }
      , ga = function() {
        W({
            msgTitleKey: "Virtual Reality Tool",
            messageKey: "Virtual Reality Tool",
            messageDefaultValue: "This is the Virtual Reality tool"
        }, 3E3)
    }
      , da = function(a, b) {
        if (!b || 0 >= b)
            b = 250;
        var c = Teratek.Viewing.i18n.translate("START Auto Move")
          , d = Teratek.Viewing.i18n.translate("STOP Auto Move");
        W({
            msgTitleKey: "VR Toggle Move",
            messageKey: "VR Toggle Move",
            messageDefaultValue: a ? c + " (" + Math.floor(I) + ")" : d
        }, b)
    }
}
;
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.VR");
Teratek.Viewing.Extensions.VR.VRExtension = function(f, h) {
    Teratek.Viewing.Extension.call(this, f, h)
}
;
Teratek.Viewing.Extensions.VR.VRExtension.prototype = Object.create(Teratek.Viewing.Extension.prototype);
Teratek.Viewing.Extensions.VR.VRExtension.prototype.constructor = Teratek.Viewing.Extensions.VR.VRExtension;
Teratek.Viewing.Extensions.VR.VRExtension.prototype.load = function() {
    var f = this
      , h = this.viewer
      , g = h.getToolbar(!0)
      , d = Teratek.Viewing.UI;
    this.tool = new Teratek.Viewing.Extensions.VR.VRTool(h,this);
    h.toolController.registerTool(this.tool);
    this.createUI(g);
    this.onToolChanged = function(c) {
        -1 !== c.toolName.indexOf("vr") && f.vrToolButton.setState(c.active ? d.Button.State.ACTIVE : d.Button.State.INACTIVE)
    }
    ;
    h.addEventListener(Teratek.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    return !0
}
;
Teratek.Viewing.Extensions.VR.VRExtension.prototype.createUI = function(f) {
    var h = this
      , g = this.viewer
      , d = Teratek.Viewing.UI;
    f = f.getControl(Teratek.Viewing.TOOLBAR.NAVTOOLSID);
    this.vrToolButton = new d.Button("toolbar-vrTool");
    this.vrToolButton.setToolTip("Virtual Reality Tool");
    this.vrToolButton.setIcon("toolbar-vrToolButton");
    this.vrToolButton.onClick = function(a) {
        a = h.vrToolButton.getState();
        a === d.Button.State.INACTIVE ? g.setActiveNavigationTool("vr") : a === d.Button.State.ACTIVE && g.setActiveNavigationTool()
    }
    ;
    var c = f.getControl("toolbar-cameraSubmenuTool");
    c ? f.addControl(this.vrToolButton, {
        index: f.indexOf(c.getId())
    }) : f.addControl(this.vrToolButton)
}
;
Teratek.Viewing.Extensions.VR.VRExtension.prototype.unload = function() {
    var f = this.viewer;
    f.removeEventListener(Teratek.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = void 0;
    Teratek.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);
    var h = f.getToolbar(!1);
    h && h.getControl(Teratek.Viewing.TOOLBAR.NAVTOOLSID).removeControl(this.vrToolButton.getId());
    this.vrToolButton = null ;
    f.toolController.deregisterTool(this.tool);
    this.tool = null ;
    return !0
}
;
Teratek.Viewing.theExtensionManager.registerExtension("Teratek.VR", Teratek.Viewing.Extensions.VR.VRExtension);
(function() {
    TeratekNamespace("Teratek.Viewing.Extensions.FusionOrbit");
    var f = Teratek.Viewing
      , h = f.UI
      , g = f.Extensions.FusionOrbit
      , d = function(c, a) {
        f.Extension.call(this, c, a)
    }
    ;
    d.prototype = Object.create(f.Extension.prototype);
    d.prototype.constructor = d;
    d.prototype.load = function() {
        function c() {
            b.removeEventListener(f.TOOLBAR_CREATED_EVENT, c);
            a.createUI()
        }
        var a = this
          , b = this.viewer
          , d = b.getToolbar ? b.getToolbar(!0) : void 0;
        this.tool = new g.FusionOrbitTool;
        this.tool.setViewer(b);
        b.toolController.registerTool(this.tool);
        d ? (d = d.getControl(f.TOOLBAR.MODELTOOLSID)) && 0 < d.getNumberOfControls() ? c() : b.addEventListener(f.TOOLBAR_CREATED_EVENT, c) : b.addEventListener(f.TOOLBAR_CREATED_EVENT, c);
        return !0
    }
    ;
    d.prototype.createUI = function() {
        var c = this.viewer
          , a = c.getToolbar(!1).getControl(f.TOOLBAR.NAVTOOLSID);
        this.classicBehavior = {};
        this.classicBehavior.orbitOnClick = a.orbitbutton.onClick;
        this.classicBehavior.freeorbitOnClick = a.freeorbitbutton.onClick;
        this.classicBehavior.returnToDefault = a.returnToDefault;
        a.freeorbitbutton.onClick = 
        function(b) {
            b = a.freeorbitbutton.getState();
            b === h.Button.State.INACTIVE ? (c.setActiveNavigationTool("fusion orbit"),
            a.freeorbitbutton.setState(h.Button.State.ACTIVE)) : b === h.Button.State.ACTIVE && (c.setActiveNavigationTool(),
            a.freeorbitbutton.setState(h.Button.State.INACTIVE))
        }
        ;
        a.orbitbutton.onClick = function(b) {
            b = a.orbitbutton.getState();
            b === h.Button.State.INACTIVE ? (c.setActiveNavigationTool("fusion orbit constrained"),
            a.orbitbutton.setState(h.Button.State.ACTIVE)) : b === h.Button.State.ACTIVE && (c.setActiveNavigationTool(),
            a.orbitbutton.setState(h.Button.State.INACTIVE))
        }
        ;
        a.returnToDefault = function() {
            a.orbittoolsbutton.setState(h.Button.State.ACTIVE);
            a.orbittoolsbutton.setState(h.Button.State.INACTIVE)
        }
        ;
        a.orbittoolsbutton.setState(h.Button.State.INACTIVE);
        c.prefs.fusionOrbitConstrained ? (a.orbittoolsbutton.onClick = a.orbitbutton.onClick,
        a.orbittoolsbutton.setIcon(a.orbitbutton.iconClass),
        c.setDefaultNavigationTool("orbit")) : (a.orbittoolsbutton.onClick = a.freeorbitbutton.onClick,
        a.orbittoolsbutton.setIcon(a.freeorbitbutton.iconClass),
        c.setDefaultNavigationTool("freeorbit"));
        c.setActiveNavigationTool();
        a.returnToDefault()
    }
    ;
    d.prototype.unload = function() {
        var c = this.viewer
          , a = c.getToolbar(!1).getControl(f.TOOLBAR.NAVTOOLSID);
        a && (a.orbitbutton && (a.orbitbutton.onClick = this.classicBehavior.orbitOnClick),
        a.freeorbitbutton && (a.freeorbitbutton.onClick = this.classicBehavior.freeorbitOnClick),
        a.returnToDefault = this.classicBehavior.returnToDefault,
        a.orbittoolsbutton && (a.orbittoolsbutton.onClick = a.orbitbutton.onClick,
        a.orbittoolsbutton.setIcon("teratek-icon-orbit-constrained"),
        a.orbittoolsbutton.setState(h.Button.State.ACTIVE)));
        c.setActiveNavigationTool("orbit");
        c.setDefaultNavigationTool("orbit");
        c.toolController.deregisterTool(this.tool);
        this.tool.setViewer(null );
        this.tool = null ;
        return !0
    }
    ;
    g.FusionOrbitExtension = d;
    f.theExtensionManager.registerExtension("Teratek.Viewing.FusionOrbit", d)
}
)();
Teratek.Viewing.Extensions.FusionOrbit.html = '<div class="orbit-gizmo noselect">\n<div class="outside"></div>\n<div class="ring"></div>\n<div class="layout-hor">\n<div class="edgemark-area"><div class="edgemark"></div></div>\n</div>\n<div class="layout-mid">\n<div class="layout-ver">\n<div class="edgemark-area"><div class="edgemark"></div></div>\n</div>\n<div class="circle">\n<div class="crosshair-area">\n<div class="crosshair-v"></div>\n<div class="crosshair-h"></div>\n</div>\n</div>\n<div class="layout-ver">\n<div class="edgemark-area"><div class="edgemark"></div></div>\n</div>\n</div>\n<div class="layout-hor">\n<div class="edgemark-area"><div class="edgemark"></div></div>\n</div>\n</div>';
Teratek.Viewing.Extensions.FusionOrbit.FusionOrbitTool = function() {
    var f = ["fusion orbit", "fusion orbit constrained"], h, g, d, c, a, b, k = isTouchDevice(), l = !1, n = {
        buttons: [],
        src: void 0,
        x: 0,
        y: 0,
        dx: 0,
        dy: 0,
        firstMove: !0,
        mode: void 0
    }, m = this;
    this.setViewer = function(a) {
        this.navapi = (this.viewer = a) ? a.navigation : null 
    }
    ;
    var q = function(a) {
        n.buttons[a.touches ? 0 : a.button] = !0;
        n.src = a.target.className;
        n.x = 0;
        n.y = 0;
        n.dx = 0;
        n.dy = 0;
        n.firstMove = !0;
        n.mode = void 0;
        "ring" === n.src ? n.mode = 2 : "edgemark-area" === n.src && ("layout-ver" === a.target.parentNode.className ? 
        n.mode = 0 : "layout-hor" === a.target.parentNode.className && (n.mode = 1));
        E();
        a.stopPropagation()
    }
      , r = function(a) {
        n.buttons[a.touches ? 0 : a.button] = !1;
        n.src = void 0
    }
      , t = function(c) {
        if (n.buttons[0]) {
            var d = c.touches ? c.touches[0].pageX : c.pageX;
            c = c.touches ? c.touches[0].pageY : c.pageY;
            n.firstMove || (n.dx = d - n.x,
            n.dy = c - n.y);
            n.x = d;
            n.y = c;
            d = b.target.clone().sub(b.position).normalize();
            c = d.clone().cross(b.up).normalize();
            var f = c.clone().cross(d).normalize();
            b.up.copy(f);
            if (2 === n.mode) {
                var h = new THREE.Vector3(n.x - g.center.x,
                n.y - g.center.y,0)
                  , k = (new THREE.Vector3(n.dx,n.dy,0)).add(h);
                h.normalize();
                k.normalize();
                h = h.clone().cross(k);
                h = Math.asin(h.z);
                b.up.applyAxisAngle(d, 1 * -h)
            } else
                0 === n.mode ? (k = .005 * -n.dx,
                a && (b.up = Teratek.Viewing.Navigation.snapToAxis(b.up.clone())),
                h = b.up) : 1 === n.mode && (k = .005 * -n.dy,
                a ? (n.firstMove && (b.up = Teratek.Viewing.Navigation.snapToAxis(b.up.clone())),
                h = d.clone().cross(b.up).normalize()) : h = c,
                b.up.applyAxisAngle(h, k)),
                d = m.navapi.getPivotPoint(),
                c = b.position.clone().sub(d),
                c.applyAxisAngle(h, k),
                b.position.addVectors(d, c),
                c = b.target.clone().sub(d),
                c.applyAxisAngle(h, k),
                b.target.addVectors(d, c);
            b.dirty = !0;
            n.firstMove = !1
        }
    }
      , w = function() {
        var a = b.target.clone().sub(b.position).normalize();
        return (a = m.viewer.impl.rayIntersect(new THREE.Ray(b.position,a))) && a.intersectPoint ? a.intersectPoint : b.target
    }
      , C = function(a, c) {
        var d = c || a.clone().sub(b.position).normalize();
        return new THREE.Plane(d,-d.x * a.x - d.y * a.y - d.z * a.z)
    }
      , E = function() {
        var a = b.target.clone().sub(b.position).normalize()
          , c = C(b.position, a).distanceToPoint(b.pivot);
        b.pivot.copy(a).multiplyScalar(c).add(b.position)
    }
      , G = function(a) {
        a.touches || 0 !== a.button || E()
    }
      , B = function(a) {
        l && m.viewer.setActiveNavigationTool()
    }
      , v = function(a, c) {
        var d = m.viewer.impl.hitTest(a, c)
          , d = d && d.intersectPoint ? d.intersectPoint : m.viewer.impl.viewportToRay(m.viewer.impl.clientToViewport(a, c)).intersectPlane(C(b.target))
          , f = b.position.clone().sub(w()).add(d);
        m.navapi.setRequestTransition(!0, f, d, b.fov)
    }
    ;
    this.register = function() {
        h = stringToDOM(Teratek.Viewing.Extensions.FusionOrbit.html);
        h.style.display = 
        "none";
        this.viewer.canvasWrap.insertBefore(h, this.viewer.canvasWrap.firstChild);
        d = h.querySelector(".ring");
        d.addEventListener("mousedown", q);
        Array.prototype.forEach.call(h.querySelectorAll(".edgemark-area"), function(a, b) {
            a.addEventListener("mousedown", q);
            k && a.addEventListener("touchstart", q)
        }
        );
        window.addEventListener("mouseup", r);
        window.addEventListener("mousemove", t);
        c = h.querySelector(".outside");
        c.addEventListener("mousedown", B);
        var a = h.querySelector(".circle");
        a.addEventListener("mousedown", G);
        k && (d.addEventListener("touchstart", q),
        window.addEventListener("touchend", r),
        window.addEventListener("touchmove", t),
        c.addEventListener("touchstart", B),
        a.addEventListener("touchstart", G));
        b = this.viewer.impl.camera
    }
    ;
    this.deregister = function() {
        window.removeEventListener("mouseup", r);
        window.removeEventListener("mousemove", t);
        c.removeEventListener("mousedown", B);
        k && (window.removeEventListener("touchend", r),
        window.removeEventListener("touchmove", t),
        c.removeEventListener("touchstart", B));
        this.viewer.canvasWrap.removeChild(h);
        c = d = h = void 0
    }
    ;
    this.activate = function(b) {
        h.style.display = "";
        this.handleResize();
        (a = "fusion orbit constrained" === b) ? (this.viewer.setDefaultNavigationTool("orbit"),
        this.viewer.prefs.set("fusionOrbitConstrained", !0)) : (this.viewer.setDefaultNavigationTool("freeorbit"),
        this.viewer.prefs.set("fusionOrbitConstrained", !1));
        this.viewer.navigation.setZoomTowardsPivot(!0)
    }
    ;
    this.deactivate = function(a) {
        h.style.display = "none";
        this.viewer.navigation.setZoomTowardsPivot(this.viewer.prefs.zoomTowardsPivot)
    }
    ;
    this.getNames = 
    function() {
        return f
    }
    ;
    this.getName = function() {
        return f[0]
    }
    ;
    this.update = function() {
        return !1
    }
    ;
    this.handleSingleClick = function(a, b) {
        v(a.canvasX, a.canvasY);
        return !0
    }
    ;
    this.handleDoubleClick = function(a, b) {
        return !0
    }
    ;
    this.handleSingleTap = function(a) {
        v(a.canvasX, a.canvasY);
        return !0
    }
    ;
    this.handleDoubleTap = function(a) {
        return !1
    }
    ;
    this.handleKeyDown = function(a, b) {
        return !1
    }
    ;
    this.handleKeyUp = function(a, b) {
        return !1
    }
    ;
    this.handleWheelInput = function(a) {
        return !1
    }
    ;
    this.handleButtonDown = function(a, b) {
        return !1
    }
    ;
    this.handleButtonUp = 
    function(a, b) {
        return !1
    }
    ;
    this.handleMouseMove = function(a) {
        var b = this.viewer.impl.canvas.getBoundingClientRect();
        a = 1.2 < (b.width > b.height ? new THREE.Vector2(((a.canvasX + .5) / b.width * 2 - 1) * b.width / b.height,2 * -((a.canvasY + .5) / b.height) + 1) : new THREE.Vector2((a.canvasX + .5) / b.width * 2 - 1,(2 * -((a.canvasY + .5) / b.height) + 1) * b.height / b.width)).length();
        l !== a && (c.style.cursor = a ? "" : "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAt1BMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8AAAAzMzP6+vri4uISEhKKioqtra2dnZ2EhIR9fX10dHRkZGQdHR3t7e3Hx8e5ubm1tbWoqKhWVlZKSko4ODgICAjv7+/o6OjMzMyxsbFOTk4pKSkXFxcEBAT29vbW1tZ6enpISEgLCwvhzeX+AAAAGXRSTlMANRO0nHRJHfnskIxQRKh89syDVwTWZjEJxPFEswAAAOFJREFUKM+1j+lygkAQhIflEAJe0Rw9u4CCeKKoSTTX+z9XoMJWWeX+ssrvZ3f19DQ5zOw/0DUMQPlmQ72bE2adBp8/Rp3CQUi3ILx+bxj4fjDs9T1Bmo6bbPPN8aDU4bjJt4nb+de789kSFyxn826jW3ICLNZZKU8nWWbrBTCRVm04U8TpjquRFf1Go0d7l8aYOrUR7FGEFr1S9LGymwthgX2gE/Kl0cHPOtF2xOWZ5QpIC93RflW4InkDoPRXesd5LJIMQPzV7tCMa7f6BvhJL79AVDmYTNQ1NhnxbI/uwB8H5Bjd4zQPBAAAAABJRU5ErkJggg==), auto",
        l = a);
        return !1
    }
    ;
    this.handleGesture = function(a) {
        E();
        return !1
    }
    ;
    this.handleBlur = function(a) {
        return !1
    }
    ;
    this.handleResize = function() {
        g = h.getBoundingClientRect();
        g.center = {};
        g.center.x = g.left + g.width / 2;
        g.center.y = g.top + g.height / 2;
        var a = .8 * (window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth);
        h.style.width = h.style.height = "" + a + "px";
        h.style.top = h.style.left = "calc(50% - " + a / 2 + "px)";
        d.style.borderWidth = "" + .1 * a + "px"
    }
}
;
TeratekNamespace("Teratek.Viewing.Private.Collaboration");
(function() {
    function f(a, b, c) {
        function f(b) {
            b = b.data.msg;
            g.x = b.x1;
            g.y = b.y1;
            h.x = b.x2;
            h.y = b.y2;
            q = b.explode;
            b.command && ("gohome" == b.command ? (g.x = g.y = 0,
            h.x = h.y = 0,
            a.navigation.setRequestHomeView(!0),
            a.showAll(),
            a.impl.selector.clearSelection(),
            a.explode(0),
            r = null ) : "select" == b.command ? (b = a.impl.hitTestViewport(new THREE.Vector3(0,0,0))) ? a.impl.selector.toggleSelection(b.dbId, b.model) : a.impl.selector.clearSelection() : "hide" == b.command ? (b = a.impl.hitTestViewport(new THREE.Vector3(0,0,0))) && a.hide(b.dbId) : 
            "fly" == b.command ? r = r ? null  : t.target.clone().sub(t.position).normalize() : "savepoint" == b.command ? (b = E.getState(v),
            G.push(b),
            alertify.success("Savepoint created.")) : "nextsavepoint" == b.command && G.length && (B >= G.length && (B = 0),
            E.restoreState(G[B++])))
        }
        var g = new THREE.Vector2, h = new THREE.Vector2, q = 0, r = null , t, w = .02, C = .002, E, G = [], B = 0, v = {
            seedURN: !1,
            objectSet: !0,
            viewport: !0,
            renderOptions: {
                environment: !1,
                ambientOcclusion: !1,
                toneMap: {
                    exposure: !1
                },
                appearance: !1
            }
        }, D = function() {
            if (!a.impl.model.is2d()) {
                var b = a.impl.model.getData().bbox.size().length();
                w *= b;
                C *= b;
                a.removeEventListener(Teratek.Viewing.PROGRESS_UPDATE_EVENT, D)
            }
        }
        ;
        a.addEventListener(Teratek.Viewing.MODEL_ROOT_LOADED_EVENT, D);
        this.getNames = function() {
            return ["joystick"]
        }
        ;
        this.getName = function() {
            return "joystick"
        }
        ;
        this.activate = function(g) {
            b.addEventListener("joystick", f);
            c.addEventListener("joystick", f);
            t = a.navigation.getCamera();
            a.model && (a.model.getBoundingBox().size().length(),
            E = new d.ViewerState(a))
        }
        ;
        this.deactivate = function(a) {
            b.removeEventListener("joystick", f);
            c.removeEventListener("joystick", 
            f);
            E = t = null ;
            G.length = 0
        }
        ;
        this.update = function(b) {
            t.isPerspective || a.navigation.toPerspective();
            r && (b = r.clone().multiplyScalar(C),
            t.position.add(b),
            t.target.add(b));
            0 != q && (b = a.getExplodeScale() + .01 * q,
            1 < b && (b = 1),
            0 > b && (b = 0),
            a.explode(b));
            if (0 == g.x && 0 == g.y && 0 == h.x && 0 == h.y)
                return !(!r && !q);
            var c = t.target.clone().sub(t.position);
            b = c.length();
            c.multiplyScalar(1 / b);
            var d = c.clone().cross(t.up).normalize()
              , f = c.clone().multiplyScalar(g.y * w);
            t.position.add(f);
            t.target.add(f);
            f = d.clone().multiplyScalar(g.x * w);
            t.position.add(f);
            t.target.add(f);
            f = new THREE.Quaternion;
            f.setFromAxisAngle(d, .05 * h.y);
            c = c.clone().applyQuaternion(f);
            t.up.applyQuaternion(f);
            d = new THREE.Quaternion;
            d.setFromAxisAngle(t.worldup, .05 * -h.x);
            c.applyQuaternion(d);
            t.up.applyQuaternion(d);
            c.multiplyScalar(b);
            t.target.copy(t.position).add(c);
            r && r.copy(t.target).sub(t.position).normalize();
            return !0
        }
        ;
        this.handleSingleClick = function(a, b) {
            return !1
        }
        ;
        this.handleDoubleClick = function(a, b) {
            return !1
        }
        ;
        this.handleSingleTap = function(a) {
            return !1
        }
        ;
        this.handleDoubleTap = function(a, 
        b) {
            return !1
        }
        ;
        this.handleKeyDown = function(a, b) {
            return !1
        }
        ;
        this.handleKeyUp = function(a, b) {
            return !1
        }
        ;
        this.handleWheelInput = function(a) {
            return !1
        }
        ;
        this.handleButtonDown = function(a, b) {
            return !1
        }
        ;
        this.handleButtonUp = function(a, b) {
            return !1
        }
        ;
        this.handleMouseMove = function(a) {
            return !1
        }
        ;
        this.handleGesture = function(a, b) {
            return !1
        }
        ;
        this.handleTouchChange = function(a, b) {
            return !1
        }
        ;
        this.handleBlur = function(a) {
            return !1
        }
        ;
        this.handleResize = function() {}
    }
    var h = Teratek.Viewing
      , g = h.Extensions
      , d = h.Private
      , c = h.UI;
    g.RemoteControl = 
    function(a, b) {
        h.Extension.call(this, a, b);
        this.viewer = a;
        this.client = d.MessageClient.GetInstance();
        this.p2p = new d.P2PClient(this.client);
        this.controllerTool = new f(a,this.client,this.p2p);
        a.toolController.registerTool(this.controllerTool)
    }
    ;
    g.RemoteControl.prototype = Object.create(h.Extension.prototype);
    g.RemoteControl.prototype.constructor = g.RemoteControl;
    g.RemoteControl.prototype.createUI = function() {
        var a = this
          , b = this.viewer;
        this.controlButton = new c.Button("toolbar-remoteControlTool");
        this.controlButton.setToolTip("Pair with controller device");
        this.controlButton.onClick = function() {
            this.getState() === c.Button.State.INACTIVE ? (a.connect(),
            this.setState(c.Button.State.ACTIVE)) : (a.disconnect(),
            this.setState(c.Button.State.INACTIVE))
        }
        ;
        this.controlButton.setIcon("teratek-icon-game-controller");
        b.modelTools.addControl(this.controlButton);
        this.panel = new Teratek.Viewing.UI.DockingPanel(b.container,"remote-panel","Remote Control");
        this.panel.width = 300;
        this.panel.height = 375;
        this.panel.container.style.width = this.panel.width + "px";
        this.panel.container.style.height = 
        this.panel.height + "px";
        this.panel.container.style.top = (window.innerHeight - this.panel.height) / 2 + "px";
        this.panel.container.style.left = (window.innerWidth - this.panel.width) / 2 + "px";
        this.panel.body = document.createElement("div");
        this.panel.body.classList.add("body");
        this.panel.container.appendChild(this.panel.body);
        var b = Teratek.Viewing.i18n.translate("Go to this link")
          , d = Teratek.Viewing.i18n.translate("Scan the QR code with your device");
        this.panel.body.innerHTML = ["<p>" + b + "</p>", '<p><a class="url" target="_blank" href="#">Link</a></p>\n<p>or</p>', 
        "<p>" + d + "</p>", '<img class="qr-img" src="">'].join("\n");
        this.panel.link = this.panel.container.querySelector(".url");
        this.panel.code = this.panel.container.querySelector(".code");
        this.panel.qrImg = this.panel.container.querySelector(".qr-img")
    }
    ;
    g.RemoteControl.prototype.load = function() {
        function a(d) {
            b.removeEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, a);
            c.createUI()
        }
        var b = this.viewer
          , c = this;
        b.modelTools && 0 < b.modelTools.getNumberOfControls() ? c.createUI() : b.addEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, 
        a);
        return !0
    }
    ;
    g.RemoteControl.prototype.unload = function() {
        var a = this.viewer;
        this.p2p.hangup();
        this.client.disconnect();
        a.toolController.deactivateTool(this.controllerTool.getName());
        this.panel && (this.panel.setVisible(!1),
        this.panel = null );
        if (this.controlButton)
            try {
                a.modelTools.removeControl(this.controlButton),
                this.controlButton = null 
            } catch (b) {
                stderr("RemoteControlReceiver - Failed to remove controlButton"),
                this.controlButton = null 
            }
        return !0
    }
    ;
    g.RemoteControl.prototype.addCrosshair = function() {
        this.crosshair = 
        stringToDOM('<div id="remote-crosshair"><div class="crosshair-v"></div><div class="crosshair-h"></div></div>');
        this.viewer.canvasWrap.appendChild(this.crosshair)
    }
    ;
    g.RemoteControl.prototype.removeCrosshair = function() {
        this.crosshair && this.crosshair.remove()
    }
    ;
    g.RemoteControl.prototype.connect = function(a) {
        if (this.client.isConnected())
            console.log("RemoteControl already connected");
        else {
            var b = this
              , c = this.viewer;
            b.client.addEventListener("connectSucceeded", function(c) {
                function f() {
                    h && h.setVisible(!1);
                    b.p2p.removeEventListener(f);
                    b.addCrosshair()
                }
                stderr("connect succeeded");
                c = c.data.id + "rc";
                b.client.join(c);
                c = (LMV_RESOURCE_ROOT.length ? LMV_RESOURCE_ROOT : window.location.origin + "/") + "rc.html?sessionId=" + c + "&env=" + d.env;
                var g = "http://chart.googleapis.com/chart?cht=qr&chs=200x200&choe=UTF-8&chld=H|0&chl=" + escape(c)
                  , h = b.panel;
                h && (h.link.href = c,
                h.link.innerHTML = (LMV_RESOURCE_ROOT.length ? LMV_RESOURCE_ROOT : window.location.origin + "/") + "rc.html",
                h.qrImg.src = g,
                h.setVisible(!0));
                b.p2p.addEventListener("dataChannelAdded", f);
                a && a instanceof 
                Function && a(c)
            }
            );
            c.navigation.toPerspective();
            b.client.connect();
            c.toolController.activateTool(b.controllerTool.getName())
        }
    }
    ;
    g.RemoteControl.prototype.disconnect = function() {
        this.p2p.hangup();
        this.client.disconnect();
        this.viewer.toolController.deactivateTool(this.controllerTool.getName());
        this.removeCrosshair()
    }
    ;
    h.theExtensionManager.registerExtension("Teratek.Viewing.RemoteControl", g.RemoteControl)
}
)();
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.Section");
Teratek.Viewing.Extensions.Section.SectionExtension = function(f, h) {
    Teratek.Viewing.Extension.call(this, f, h);
    this.viewer = f
}
;
Teratek.Viewing.Extensions.Section.SectionExtension.prototype = Object.create(Teratek.Viewing.Extension.prototype);
Teratek.Viewing.Extensions.Section.SectionExtension.prototype.constructor = Teratek.Viewing.Extensions.Section.SectionExtension;
Teratek.Viewing.Extensions.Section.SectionExtension.prototype.load = function() {
    function f() {
        g.removeEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, f);
        h.createUI()
    }
    var h = this
      , g = this.viewer;
    this.tool = new Teratek.Viewing.Extensions.Section.SectionTool(g);
    g.toolController.registerTool(this.tool);
    var d = g.getToolbar ? g.getToolbar(!0) : void 0;
    d ? (d = d.getControl(Teratek.Viewing.TOOLBAR.MODELTOOLSID)) && 0 < d.getNumberOfControls() ? f() : g.addEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, f) : g.addEventListener(Teratek.Viewing.TOOLBAR_CREATED_EVENT, 
    f);
    g.addEventListener(Teratek.Viewing.RESET_EVENT, function() {
        h.tool && h.tool.resetSection()
    }
    );
    this.HOTKEYS_ID = "Teratek.Section.Hotkeys";
    Teratek.Viewing.theHotkeyManager.pushHotkeys(this.HOTKEYS_ID, [{
        keycodes: [Teratek.Viewing.theHotkeyManager.KEYCODES.ESCAPE],
        onRelease: function() {
            return h.enableSectionTool(!1)
        }
    }]);
    return !0
}
;
Teratek.Viewing.Extensions.Section.SectionExtension.prototype.enableSectionTool = function(f) {
    if (this.tool) {
        var h = this.viewer.toolController
          , g = this.tool.isActive();
        if (f && !g)
            return h.activateTool("section"),
            this.sectionToolButton.setState(Teratek.Viewing.UI.Button.State.ACTIVE),
            !0;
        if (!f && g)
            return h.deactivateTool("section"),
            this.sectionToolButton.setState(Teratek.Viewing.UI.Button.State.INACTIVE),
            !0
    }
    return !1
}
;
Teratek.Viewing.Extensions.Section.SectionExtension.prototype.createUI = function() {
    var f = this.viewer;
    this.sectionToolButton = new Teratek.Viewing.UI.ComboButton("toolbar-sectionTool");
    this.sectionToolButton.setToolTip("Section analysis");
    this.sectionToolButton.setIcon("teratek-icon-section-analysis");
    this.createSubmenu(this.sectionToolButton);
    var f = f.getToolbar(!1).getControl(Teratek.Viewing.TOOLBAR.MODELTOOLSID)
      , h = f.getControl("toolbar-resetTool");
    h ? f.addControl(this.sectionToolButton, {
        index: f.indexOf(h.getId())
    }) : 
    f.addControl(this.sectionToolButton, {
        index: 0
    })
}
;
Teratek.Viewing.Extensions.Section.SectionExtension.prototype.createSubmenu = function(f) {
    function h(b, c) {
        return function() {
            var f = b.getState();
            f === a.Button.State.INACTIVE ? (b.setState(a.Button.State.ACTIVE),
            d.enableSectionTool(!0),
            !1 === this instanceof a.ComboButton ? d.tool.setSection(c) : d.tool.attachControl(!0)) : f === a.Button.State.ACTIVE && (b.setState(a.Button.State.INACTIVE),
            d.enableSectionTool(!1))
        }
    }
    function g() {
        var a = function() {
            var a = new THREE.Vector3;
            return function(b, c, d) {
                a.subVectors(b, c);
                return a.lengthSq() < 
                d
            }
        }
        ()
          , b = new THREE.Vector3(1,0,0)
          , f = new THREE.Vector3(0,1,0)
          , h = new THREE.Vector3(0,0,1)
          , q = c.autocam.getWorldRightVector()
          , r = c.autocam.getWorldUpVector()
          , t = c.autocam.getWorldFrontVector();
        a(r, b, 1E-4) ? d.sectionYButton.setIcon("teratek-icon-plane-x") : a(r, h, 1E-4) ? d.sectionYButton.setIcon("teratek-icon-plane-z") : d.sectionYButton.setIcon("teratek-icon-plane-y");
        a(q, f, 1E-4) ? d.sectionXButton.setIcon("teratek-icon-plane-y") : a(q, h, 1E-4) ? d.sectionXButton.setIcon("teratek-icon-plane-z") : d.sectionXButton.setIcon("teratek-icon-plane-x");
        a(t, b, 1E-4) ? d.sectionZButton.setIcon("teratek-icon-plane-x") : a(t, f, 1E-4) ? d.sectionZButton.setIcon("teratek-icon-plane-y") : d.sectionZButton.setIcon("teratek-icon-plane-z");
        c.removeEventListener(Teratek.Viewing.GEOMETRY_LOADED_EVENT, g)
    }
    var d = this
      , c = this.viewer
      , a = Teratek.Viewing.UI
      , b = this.sectionXButton = new a.Button("toolbar-sectionTool-x");
    b.setToolTip("Add X plane");
    b.setIcon("teratek-icon-plane-x");
    b.onClick = h(b, "X");
    f.addControl(b);
    b = this.sectionYButton = new a.Button("toolbar-sectionTool-y");
    b.setToolTip("Add Y plane");
    b.setIcon("teratek-icon-plane-y");
    b.onClick = h(b, "Y");
    f.addControl(b);
    b = this.sectionZButton = new a.Button("toolbar-sectionTool-z");
    b.setToolTip("Add Z plane");
    b.setIcon("teratek-icon-plane-z");
    b.onClick = h(b, "Z");
    f.addControl(b);
    b = this.sectionBoxButton = new a.Button("toolbar-sectionTool-box");
    b.setToolTip("Add box");
    b.setIcon("teratek-icon-box");
    b.onClick = h(b, "BOX");
    f.addControl(b);
    c.addEventListener(Teratek.Viewing.GEOMETRY_LOADED_EVENT, g)
}
;
Teratek.Viewing.Extensions.Section.SectionExtension.prototype.destroyUI = function() {
    var f = this.viewer.getToolbar(!1);
    if (f && (f = f.getControl(Teratek.Viewing.TOOLBAR.MODELTOOLSID)) && this.sectionToolButton) {
        var h = f.getControl("toolbar-inspectSubMenu");
        h ? h.removeControl(this.sectionToolButton.getId()) : f.removeControl(this.sectionToolButton.getId());
        this.sectionToolButton = null 
    }
}
;
Teratek.Viewing.Extensions.Section.SectionExtension.prototype.unload = function() {
    var f = this.viewer;
    Teratek.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);
    this.destroyUI();
    f.toolController.deregisterTool(this.tool);
    this.tool = null ;
    return !0
}
;
Teratek.Viewing.theExtensionManager.registerExtension("Teratek.Section", Teratek.Viewing.Extensions.Section.SectionExtension);
TeratekNamespace("Teratek.Viewing.Extensions.Section");
Teratek.Viewing.Extensions.Section.tintColor = {
    r: 1,
    g: 1,
    b: 0
};
Teratek.Viewing.Extensions.Section.tintIntensity = .2;
Teratek.Viewing.Extensions.Section.SectionTool = function(f, h) {
    function g() {
        C.invalidate(!1, !1, !0)
    }
    function d() {
        D && D.update();
        z && z.update()
    }
    function c() {
        1 === I.length && b((new THREE.Plane).setComponents(I[0].x, I[0].y, I[0].z, I[0].w))
    }
    function a(a) {
        var b = Teratek.Viewing.Extensions.Section.tintIntensity
          , c = Teratek.Viewing.Extensions.Section.tintColor;
        a.r = a.r * (1 - b) + c.r * b;
        a.g = a.g * (1 - b) + c.g * b;
        a.b = a.b * (1 - b) + c.b * b
    }
    function b(b) {
        init_three_triangulator();
        init_three_intersector();
        var c = C.model.getData().instanceTree;
        if (c) {
            var d = C.model.getFragmentList()
              , f = C.sceneAfter.getObjectByName("section");
            f && C.sceneAfter.remove(f);
            f = new THREE.Object3D;
            f.name = "section";
            C.sceneAfter.add(f);
            var g = new THREE.Object3D;
            f.add(g);
            var h = new THREE.Object3D;
            f.add(h);
            var k = Teratek.Viewing.Private
              , l = k.Intersector.makePlaneBasis(b)
              , m = (new THREE.Matrix4).getInverse(l)
              , f = C.matman().create2DMaterial(null , {
                skipCircles: !0,
                skipEllipticals: !0
            }, !1, !1)
              , n = C.matman().findMaterial(null , f);
            n.transparent = !0;
            n.depthTest = !0;
            n.polygonOffset = !0;
            n.polygonOffsetFactor = 
            -1;
            n.polygonOffsetUnits = 1;
            var q = new THREE.Box3;
            C.getVisibleBounds(!0).size().length();
            c.enumNodeChildren(C.model.getRootId(), function(f) {
                if (!c.isNodeHidden(f) && !c.isNodeOff(f)) {
                    var r = [], t;
                    c.enumNodeFragments(f, function(a) {
                        d.getWorldBounds(a, q);
                        k.Intersector.intersectBoxPlane(b, q) && (t = d.getVizmesh(a),
                        t.geometry && (t.geometry.is2d || t.geometry.isLines || k.Intersector.intersectMeshPlane(b, t, r)))
                    }
                    , !1);
                    if (r.length) {
                        var v = new THREE.Box3;
                        k.Intersector.convertToPlaneCoords(l, r, v);
                        var B = new k.VertexBufferBuilder(!1,
                        8 * r.length)
                          , w = t.material.color || new THREE.Color(16777215)
                          , z = 0 | 63.875 * w.r
                          , D = 0 | 63.875 * w.g
                          , E = 0 | 63.875 * w.b
                          , F = 4278190080 | E << 16 | D << 8 | z
                          , w = new k.Triangulator.ContourSet(r,v);
                        w.snapEdges();
                        w.stitchContours();
                        for (v = 0; v < w.contours.length; v++)
                            for (var H = w.contours[v], z = 0 | 255.5 * Math.random(), D = 0 | 255.5 * Math.random(), E = 0 | 255.5 * Math.random(), z = 1; z < H.length; z++)
                                D = w.pts[H[z - 1]],
                                E = w.pts[H[z]],
                                B.addSegment(D.x, D.y, E.x, E.y, 0, .01, F, f, 0);
                        v = {
                            mesh: B.toMesh()
                        };
                        BufferGeometryUtils.meshToGeometry(v);
                        v = v.geometry;
                        v.streamingDraw = 
                        !0;
                        v.streamingIndex = !0;
                        v = new THREE.Mesh(v,n);
                        v.matrix.copy(m);
                        v.matrixAutoUpdate = !1;
                        v.frustumCulled = !1;
                        h.add(v);
                        B = new k.Triangulator.TriangulatedSurface(w);
                        if (B.indices.length) {
                            w = new THREE.BufferGeometry;
                            F = new Float32Array(3 * B.pts.length);
                            for (v = 0; v < B.pts.length; v++)
                                F[3 * v] = B.pts[v].x,
                                F[3 * v + 1] = B.pts[v].y,
                                F[3 * v + 2] = 0;
                            w.addAttribute("position", new THREE.BufferAttribute(F,3));
                            H = (F = t.material.packedNormals) ? new Uint16Array(2 * B.pts.length) : new Float32Array(3 * B.pts.length);
                            for (v = 0; v < B.pts.length; v++)
                                F ? (H[2 * 
                                v] = 32767.5 * (0 / Math.PI + 1) | 0,
                                H[2 * v + 1] = 65535) : (H[3 * v] = 0,
                                H[3 * v + 1] = 0,
                                H[3 * v + 2] = 1);
                            w.addAttribute("normal", new THREE.BufferAttribute(H,F ? 2 : 3));
                            F && (w.attributes.normal.bytesPerItem = 2,
                            w.attributes.normal.normalize = !0);
                            v = new Uint16Array(B.indices.length);
                            v.set(B.indices);
                            w.addAttribute("index", new THREE.BufferAttribute(v,1));
                            w.streamingDraw = !0;
                            w.streamingIndex = !0;
                            v = C.matman().cloneMaterial(t.material);
                            a(v.color || new THREE.Color(16777215));
                            a(v.specular || new THREE.Color(16777215));
                            v.packedNormals = F;
                            v.cutplanes = 
                            null ;
                            v.side = THREE.FrontSide;
                            v.depthTest = !0;
                            v.map = null ;
                            v.bumpMap = null ;
                            v.specularMap = null ;
                            v.transparent = !1;
                            v.depthWrite = !0;
                            v.hatchPattern = !0;
                            v.needsUpdate = !0;
                            B = Math.tan((t.material.id + 2) * Math.PI * .125);
                            v.hatchParams = new THREE.Vector2(B,10);
                            v = new THREE.Mesh(w,v);
                            v.matrix.copy(m);
                            v.matrixAutoUpdate = !1;
                            v.dbId = f;
                            v.fragId = r.fragId;
                            g.add(v)
                        }
                    }
                }
            }
            , !0)
        }
    }
    function k(a, b, c) {
        b = b || C.getVisibleBounds();
        c = c || 0;
        var d = new THREE.Vector3(0,0,1)
          , d = (new THREE.Quaternion).setFromUnitVectors(d, a.normal)
          , f = a.projectPoint(b.max)
          , 
        g = a.projectPoint(b.min)
          , h = d.clone().inverse();
        f.applyQuaternion(h);
        g.applyQuaternion(h);
        f = (new THREE.Vector3).subVectors(f, g);
        f = new THREE.PlaneBufferGeometry(f.x * (1 + c),f.y * (1 + c));
        c = new THREE.MeshBasicMaterial({
            opacity: 0,
            color: 16777215,
            side: THREE.DoubleSide,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        c = new S.SectionMesh(f,c,a);
        a = a.projectPoint(b.center());
        c.position.copy(a);
        c.quaternion.multiply(d);
        a = Teratek.Viewing.Private.LightPresets[C.currentLightPreset()].bgColorGradient;
        a = new THREE.LineBasicMaterial({
            color: "rgb(" + 
            (255 - a[0]) + "," + (255 - a[1]) + "," + (255 - a[2]) + ")",
            linewidth: 1,
            depthTest: !1
        });
        b = c.geometry.getAttribute("position");
        for (d = 0; d < M.length; d++)
            f = new THREE.Geometry,
            f.vertices.push((new THREE.Vector3).fromArray(b.array, M[d][0] * b.itemSize), (new THREE.Vector3).fromArray(b.array, M[d][1] * b.itemSize)),
            f = new THREE.Line(f,a),
            c.add(f),
            c.outlines.push(f);
        return c
    }
    function l() {
        n(function(a) {
            if (a instanceof S.SectionMesh && 0 < a.connectivity.length) {
                for (var b = (new THREE.Matrix4).getInverse(a.matrixWorld), c = new THREE.Vector3, 
                d = a.geometry.getAttribute("position"), f = 0; f < d.length / d.itemSize; f++) {
                    var g = a.connectivity[f];
                    null  !== ba(a.plane, g[0], g[1], c) && (c.applyMatrix4(b),
                    d.setXYZ(f, c.x, c.y, c.z))
                }
                d.needsUpdate = !0;
                a.geometry.computeBoundingBox();
                a.geometry.computeBoundingSphere();
                for (f = 0; f < a.outlines.length; f++)
                    b = a.outlines[f],
                    b.geometry.vertices[0].fromArray(d.array, M[f][0] * d.itemSize),
                    b.geometry.vertices[1].fromArray(d.array, M[f][1] * d.itemSize),
                    b.geometry.verticesNeedUpdate = !0
            }
        }
        )
    }
    function n(a) {
        for (var b = 0; b < H.length; b++)
            H[b].traverse(a)
    }
    function m() {
        n(function(a) {
            a instanceof S.SectionMesh && a.update()
        }
        );
        1 === I.length && b((new THREE.Plane).setComponents(I[0].x, I[0].y, I[0].z, I[0].w));
        C.setCutPlanes(I)
    }
    function q(a) {
        for (var b = 0; b < H.length; b++)
            H[b].visible = a;
        v !== a && g();
        v = a
    }
    function r(a) {
        a && 0 < I.length && (1 === I.length && b((new THREE.Plane).setComponents(I[0].x, I[0].y, I[0].z, I[0].w)),
        f.setCutPlanes(I));
        q(a)
    }
    function t(a, b) {
        a.attach(b);
        a.setPosition(b.position);
        a.visible = !0
    }
    function w(a) {
        0 < C.api.navigation.getEyeVector().dot(a) && a.negate();
        var b = new THREE.Group;
        a = new THREE.Plane(a,0);
        a = k(a, null , .05);
        b.add(a);
        I.push(a.planeVec);
        H.push(b);
        C.addOverlay("gizmo", b);
        t(D, a);
        D.showRotationGizmos(!0);
        J = D.getPicker();
        m()
    }
    var C = f.impl, E = ["section"], G = !1, B = !1, v = !0, D, z, H = [], I = [], J = [], L = "", F = null , N = !1, K = !0, M = [[0, 1], [1, 3], [3, 2], [2, 0]], S = Teratek.Viewing.Extensions.Section;
    init_TransformGizmos();
    init_SectionMesh();
    var ba = function() {
        var a = new THREE.Matrix3
          , b = new THREE.Vector3
          , c = new THREE.Vector3
          , d = new THREE.Vector3;
        return function(f, g, h, k) {
            a.set(f.normal.x, 
            f.normal.y, f.normal.z, g.normal.x, g.normal.y, g.normal.z, h.normal.x, h.normal.y, h.normal.z);
            var l = a.determinant();
            if (0 === l)
                return null ;
            b.crossVectors(g.normal, h.normal).multiplyScalar(-f.constant);
            c.crossVectors(h.normal, f.normal).multiplyScalar(-g.constant);
            d.crossVectors(f.normal, g.normal).multiplyScalar(-h.constant);
            return (k || new THREE.Vector3).copy(b).add(c).add(d).divideScalar(l)
        }
    }
    ()
      , P = function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3
          , c = new THREE.Raycaster
          , d = C.camera;
        return function(f, g, h) {
            var k = 
            C.canvas.getBoundingClientRect()
              , l = (f.clientX - k.left) / k.width * 2 - 1;
            f = 2 * -((f.clientY - k.top) / k.height) + 1;
            d.isPerspective ? (a.set(l, f, .5),
            a.unproject(d),
            c.set(d.position, a.sub(d.position).normalize())) : (a.set(l, f, -1),
            a.unproject(d),
            b.set(0, 0, -1),
            c.set(a, b.transformDirection(d.matrixWorld)));
            g = c.intersectObjects(g, h);
            return g[0] ? g[0] : null 
        }
    }
    ();
    this.isActive = function() {
        return G
    }
    ;
    this.setSection = function(a) {
        this.clearSection();
        switch (a) {
        case "X":
            var b = new THREE.Vector3(1,0,0);
            w(b);
            break;
        case "Y":
            b = new THREE.Vector3(0,
            1,0);
            w(b);
            break;
        case "Z":
            b = new THREE.Vector3(0,0,1);
            w(b);
            break;
        case "BOX":
            for (var c = [new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,-1,0), new THREE.Vector3(0,0,-1)], b = [[[1, 2], [1, 5], [2, 4], [4, 5]], [[3, 5], [0, 5], [2, 3], [0, 2]], [[1, 3], [0, 1], [3, 4], [0, 4]], [[1, 5], [1, 2], [4, 5], [2, 4]], [[2, 3], [0, 2], [3, 5], [0, 5]], [[0, 1], [3, 1], [0, 4], [3, 4]]], d = new THREE.Group, f = C.getVisibleBounds(), g = f.center(), h = new THREE.Box3(f.min,g), f = [], l = [], n = 0; n < c.length; n++) {
                var q = 
                new THREE.Plane(c[n],-1 * g.dot(c[n]));
                f.push(q);
                if (2 < n) {
                    var r = q.orthoPoint(h.max)
                      , v = q.orthoPoint(h.min)
                      , r = (new THREE.Vector3).subVectors(r, v);
                    q.constant -= r.length()
                }
                q = k(q, h);
                d.add(q);
                l.push(q);
                I.push(q.planeVec)
            }
            for (n = 0; n < l.length; n++)
                for (q = l[n],
                c = b[n],
                g = 0; g < c.length; g++) {
                    h = [];
                    r = c[g];
                    for (v = 0; v < r.length; v++)
                        h.push(f[r[v]]);
                    q.connectivity.push(h)
                }
            H.push(d);
            C.addOverlay("gizmo", d);
            t(D, H[0].children[0]);
            t(z, H[0]);
            D.showRotationGizmos(!1);
            J = D.getPicker().concat(z.getPicker());
            m()
        }
        L = a
    }
    ;
    this.clearSection = 
    function() {
        D && D.detach();
        for (z && z.detach(); 0 < I.length; )
            I.pop();
        for (; 0 < H.length; ) {
            var a = H.pop();
            C.removeOverlay("gizmo", a)
        }
        (a = C.sceneAfter.getObjectByName("section")) && C.sceneAfter.remove(a);
        C.setCutPlanes()
    }
    ;
    this.isPlaneOn = function() {
        return v
    }
    ;
    this.showPlane = function(a) {
        q(a)
    }
    ;
    this.attachControl = function(a) {
        a ? (t(D, H[0].children[0]),
        D.highlight(),
        "BOX" === L && t(z, H[0])) : (D.detach(),
        z.detach())
    }
    ;
    this.setOutlineColor = function(a) {
        C.setCutPlanesOutlineColor(a)
    }
    ;
    this.resetSection = function() {
        this.setSection(L)
    }
    ;
    this.getNames = function() {
        return E
    }
    ;
    this.getName = function() {
        return E[0]
    }
    ;
    this.register = function() {}
    ;
    this.deregister = function() {
        this.clearSection();
        N && (C.removeOverlay("gizmo", D),
        D.removeEventListener("change", g),
        D = null ,
        C.removeOverlay("gizmo", z),
        z.removeEventListener("change", g),
        z = null ,
        C.removeOverlayScene("gizmo"),
        f.removeEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, d),
        f.removeEventListener(Teratek.Viewing.ISOLATE_EVENT, c),
        f.removeEventListener(Teratek.Viewing.HIDE_EVENT, c),
        f.removeEventListener(Teratek.Viewing.SHOW_EVENT, 
        c),
        N = !1)
    }
    ;
    this.activate = function(a) {
        N || (D = new THREE.TransformControls(C.camera,C.canvas,"transrotate"),
        D.addEventListener("change", g),
        D.setSnap(Math.PI / 2, Math.PI / 36),
        z = new THREE.TransformControls(C.camera,C.canvas,"translate"),
        z.addEventListener("change", g),
        void 0 === C.overlayScenes.gizmo && C.createOverlayScene("gizmo"),
        C.addOverlay("gizmo", D),
        C.addOverlay("gizmo", z),
        f.addEventListener(Teratek.Viewing.CAMERA_CHANGE_EVENT, d),
        f.addEventListener(Teratek.Viewing.ISOLATE_EVENT, c),
        f.addEventListener(Teratek.Viewing.HIDE_EVENT, 
        c),
        f.addEventListener(Teratek.Viewing.SHOW_EVENT, c),
        N = !0);
        G = !0;
        B = !1;
        K = !0;
        I = I || [];
        r(!0)
    }
    ;
    this.deactivate = function(a) {
        B = G = !1;
        (a = C.sceneAfter.getObjectByName("section")) && C.sceneAfter.remove(a);
        r(!1);
        C.setCutPlanes();
        D.detach();
        z.detach()
    }
    ;
    this.update = function(a) {
        return !1
    }
    ;
    this.handleSingleClick = function(a, b) {
        var c = P(a.pointers ? a.pointers[0] : a, H[0].children);
        c && (t(D, c.object),
        D.highlight(),
        g());
        return !1
    }
    ;
    this.handleDoubleClick = function(a, b) {
        return !1
    }
    ;
    this.handleSingleTap = function(a) {
        return this.handleSingleClick(a, 
        0)
    }
    ;
    this.handleDoubleTap = function(a) {
        return !1
    }
    ;
    this.handleKeyDown = function(a, b) {
        return !1
    }
    ;
    this.handleKeyUp = function(a, b) {
        return !1
    }
    ;
    this.handleWheelInput = function(a) {
        return !1
    }
    ;
    this.handleButtonDown = function(a, b) {
        B = !0;
        return z.onPointerDown(a) ? !0 : D.onPointerDown(a)
    }
    ;
    this.handleButtonUp = function(a, b) {
        B = !1;
        return z.onPointerUp(a) ? !0 : D.onPointerUp(a)
    }
    ;
    this.handleMouseMove = function(a) {
        if (B) {
            if (z.onPointerMove(a))
                return m(),
                D.update(),
                !0;
            if (D.onPointerMove(a))
                return m(),
                l(),
                !0
        }
        if ("touch" !== a.pointerType) {
            var b = 
            a.pointers ? a.pointers[0] : a
              , c = P(b, H[0].children);
            c && (K = !1);
            b = K || c || P(b, J, !0) ? !0 : !1;
            D.visible = b;
            z.visible = void 0 !== z.object && b;
            q(b)
        }
        return z.onPointerHover(a) ? !0 : D.onPointerHover(a)
    }
    ;
    this.handleGesture = function(a) {
        switch (a.type) {
        case "dragstart":
            return F = "drag",
            this.handleButtonDown(a, 0);
        case "dragmove":
            return "drag" === F ? this.handleMouseMove(a) : !1;
        case "dragend":
            if ("drag" === F)
                return F = null ,
                this.handleButtonUp(a, 0)
        }
        return !1
    }
    ;
    this.handleBlur = function(a) {
        return !1
    }
    ;
    this.handleResize = function() {}
    ;
    this.handlePressHold = 
    function(a) {
        return !0
    }
}
;
function init_SectionMesh() {
    Teratek.Viewing.Extensions.Section.SectionMesh || (Teratek.Viewing.Extensions.Section.SectionMesh = function(f, h, g) {
        THREE.Mesh.call(this, f, h, !1);
        this.plane = g;
        this.planeVec = new THREE.Vector4(g.normal.x,g.normal.y,g.normal.z,g.constant);
        this.connectivity = [];
        this.outlines = []
    }
    ,
    Teratek.Viewing.Extensions.Section.SectionMesh.prototype = Object.create(THREE.Mesh.prototype),
    Teratek.Viewing.Extensions.Section.SectionMesh.prototype.constructor = Teratek.Viewing.Extensions.Section.SectionMesh,
    Teratek.Viewing.Extensions.Section.SectionMesh.prototype.update = 
    function() {
        this.plane.normal.set(0, 0, 1);
        this.plane.normal.applyQuaternion(this.quaternion);
        var f = this.plane.normal
          , h = -1 * this.getWorldPosition().dot(f);
        this.planeVec.set(f.x, f.y, f.z, h);
        this.plane.constant = h
    }
    )
}
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.Fusion360Sim");
Teratek.Viewing.Extensions.Fusion360Sim.SimulationDef = function() {
    this.studyNode;
    this.constraintsNode = -1;
    this.constraintNodes = [];
    this.loadsNode = -1;
    this.loadNodes = [];
    this.bodyNode = this.resultsNode = -1;
    this.resultTypes = {};
    this.resultGroups = {};
    this.simNodes = [];
    this.modelNodes = [];
    this.modalAnalysis = !1;
    this.modalResults = {};
    this.simExt = this.modelStructurePanel = null 
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimulationDef.prototype.associateResult = function(f, h) {
    this.resultTypes[h] = f
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimulationDef.prototype.associateResultGroup = function(f, h) {
    this.resultGroups[h] = f
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimulationDef.prototype.associateModalResult = function(f, h) {
    var g = []
      , g = this.modalResults[f];
    null  == g && (g = []);
    g.push(h);
    this.modalResults[f] = g
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimulationDef.prototype.reset = function() {
    this.constraintsNode = this.studyNode = -1;
    this.constraintNodes = [];
    this.loadsNode = -1;
    this.loadNodes = [];
    this.bodyNode = this.resultsNode = -1;
    this.resultTypes = {};
    this.resultGroups = {};
    this.simNodes = [];
    this.modelNodes = [];
    this.modalAnalysis = !1;
    this.modalResults = {};
    this.modelStructurePanel = null 
}
;
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.Fusion360Sim");
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel = function(f) {
    this.viewer = f;
    this.simDef = null ;
    Teratek.Viewing.UI.DockingPanel.call(this, f.container, "Simulation-Panel", "Simulation Results")
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype = Object.create(Teratek.Viewing.UI.DockingPanel.prototype);
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.constructor = Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.initialize = function() {
    Teratek.Viewing.UI.DockingPanel.prototype.initialize.call(this);
    var f = this;
    this.kPanelExpandedHeight = 420;
    this.kPanelCollapsedHeight = 35;
    this.container.classList.add("measurePanel");
    this.container.dockRight = !0;
    this.container.style.minWidth = "380px";
    this.container.style.width = "380px";
    this.container.style.minHeight = this.kPanelCollapsedHeight + "px";
    this.container.style.height = this.kPanelExpandedHeight + "px";
    this.container.style.maxHeight = 
    this.kPanelExpandedHeight + "px";
    this.container.style.top = "150px";
    this.container.style.left = "220px";
    this.container.style.position = "absolute";
    this.legend = document.createElement("div");
    this.container.appendChild(this.legend);
    this.resultsGroup = document.createElement("select");
    this.resultsGroup.classList.add("simulation-resultGroup");
    this.resultsGroup.style.position = "absolute";
    this.resultsGroup.style.top = "42px";
    this.resultsGroup.style.width = "180px";
    this.resultsGroup.style.left = "5px";
    this.resultsGroup.style.color = 
    "black";
    this.resultsGroup.style.height = "22px";
    this.resultsGroup.style.border = "1px";
    this.resultsGroup.addEventListener("change", function(h) {
        f.viewer.hide(f.simDef.resultsNode);
        0 == f.simDef.modalAnalysis ? f.fillResultTypes(f.resultsGroup.value) : f.fillModalResultTypes(f.resultsGroup.value);
        setTimeout(function() {
            f.setSimObjectsVisibility()
        }
        , 100)
    }
    );
    this.legend.appendChild(this.resultsGroup);
    this.resultTypes = document.createElement("select");
    this.resultTypes.classList.add("simulation-resultTypes");
    this.resultTypes.style.position = 
    "absolute";
    this.resultTypes.style.top = "42px";
    this.resultTypes.style.width = "180px";
    this.resultTypes.style.left = "190px";
    this.resultTypes.style.color = "black";
    this.resultTypes.style.height = "22px";
    this.resultTypes.style.border = "1px";
    this.resultTypes.addEventListener("change", function(h) {
        f.viewer.hide(f.simDef.resultsNode);
        f.setSimObjectsVisibility()
    }
    );
    this.legend.appendChild(this.resultTypes);
    this.colorScale = document.createElement("div");
    this.colorScale.classList.add("simulation-colorscale");
    this.colorScale.style.width = 
    "210px";
    this.colorScale.style.height = "20px";
    this.colorScale.style.margin = "5px";
    this.colorScale.style.position = "absolute";
    this.colorScale.style.left = "-70px";
    this.colorScale.style.top = "170px";
    this.colorScale.style.backgroundRepeat = "repeat";
    this.legend.appendChild(this.colorScale);
    this.colorScaleTopText = document.createElement("div");
    this.colorScaleTopText.style.position = "absolute";
    this.colorScaleTopText.style.left = "52px";
    this.colorScaleTopText.style.top = "73px";
    this.colorScaleTopText.innerHTML = "- 3333";
    this.legend.appendChild(this.colorScaleTopText);
    this.colorScaleBottomText = document.createElement("div");
    this.colorScaleBottomText.style.position = "absolute";
    this.colorScaleBottomText.style.left = "52px";
    this.colorScaleBottomText.style.top = "281px";
    this.colorScaleBottomText.innerHTML = "- 3333";
    this.legend.appendChild(this.colorScaleBottomText);
    this.line = document.createElement("hr");
    this.line.style.position = "absolute";
    this.line.style.top = "300px";
    this.line.style.width = "100%";
    this.line.style.borderTop = "1px solid black";
    this.legend.appendChild(this.line);
    this.tbl = document.createElement("table");
    this.tblBody = document.createElement("tbody");
    this.tbl.appendChild(this.tblBody);
    this.legend.appendChild(this.tbl);
    this.tbl.style.position = "absolute";
    this.tbl.style.top = "310px";
    this.tbl.style.margin = "5px"
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setSimulationDef = function(f) {
    function h(a, b) {
        for (var c = 0; c < a.length; ++c) {
            var d = a[c];
            if (d.displayName === b)
                return d.displayValue
        }
        return null 
    }
    function g(a, b, c) {}
    this.simDef = f;
    var d = this;
    this.viewer.getProperties(Number(this.simDef.studyNode), function(a) {
        a = h(a.properties, "Name");
        d.setTitle(a)
    }
    , g);
    var c;
    c = 1 == this.simDef.modalAnalysis ? Teratek.Viewing.i18n.translate("Modal Frequencies") : Teratek.Viewing.i18n.translate("Static Stress");
    this.rowType ? 
    this.cellTextType2.nodeValue = c : (this.rowType = document.createElement("tr"),
    this.cellType1 = document.createElement("td"),
    this.cellTextType1 = document.createTextNode(Teratek.Viewing.i18n.translate("Analysis Type")),
    this.cellType1.appendChild(this.cellTextType1),
    this.cellType1.style.width = "180px",
    this.cellType2 = document.createElement("td"),
    this.cellTextType2 = document.createTextNode(c),
    this.cellType2.appendChild(this.cellTextType2),
    this.rowType.appendChild(this.cellType1),
    this.rowType.appendChild(this.cellType2),
    this.tblBody.appendChild(this.rowType),
    this.rowNodes = document.createElement("tr"),
    this.cellNodes1 = document.createElement("td"),
    this.cellTextNodes1 = document.createTextNode(Teratek.Viewing.i18n.translate("Nodes")),
    this.cellNodes1.appendChild(this.cellTextNodes1),
    this.cellNodes2 = document.createElement("td"),
    this.cellTextNodes2 = document.createTextNode("1872"),
    this.cellNodes2.appendChild(this.cellTextNodes2),
    this.rowNodes.appendChild(this.cellNodes1),
    this.rowNodes.appendChild(this.cellNodes2),
    this.tblBody.appendChild(this.rowNodes),
    this.rowElements = document.createElement("tr"),
    this.cellElements1 = document.createElement("td"),
    this.cellTextElements1 = document.createTextNode(Teratek.Viewing.i18n.translate("Elements")),
    this.cellElements1.appendChild(this.cellTextElements1),
    this.cellElements2 = document.createElement("td"),
    this.cellTextElements2 = document.createTextNode("1084"),
    this.cellElements2.appendChild(this.cellTextElements2),
    this.rowElements.appendChild(this.cellElements1),
    this.rowElements.appendChild(this.cellElements2),
    this.tblBody.appendChild(this.rowElements),
    this.rowMin = document.createElement("tr"),
    this.cellMin1 = document.createElement("td"),
    this.cellTextMin1 = document.createTextNode(Teratek.Viewing.i18n.translate("Min")),
    this.cellMin1.appendChild(this.cellTextMin1),
    this.cellMin2 = document.createElement("td"),
    this.cellTextMin2 = document.createTextNode("0.000E+02 MPa"),
    this.cellMin2.appendChild(this.cellTextMin2),
    this.rowMin.appendChild(this.cellMin1),
    this.rowMin.appendChild(this.cellMin2),
    this.tblBody.appendChild(this.rowMin),
    this.rowMax = document.createElement("tr"),
    this.cellMax1 = document.createElement("td"),
    this.cellTextMax1 = document.createTextNode(Teratek.Viewing.i18n.translate("Max")),
    this.cellMax1.appendChild(this.cellTextMax1),
    this.cellMax2 = document.createElement("td"),
    this.cellTextMax2 = document.createTextNode("5.117E+02 MPa"),
    this.cellMax2.appendChild(this.cellTextMax2),
    this.rowMax.appendChild(this.cellMax1),
    this.rowMax.appendChild(this.cellMax2),
    this.tblBody.appendChild(this.rowMax));
    this.resultsGroup.options.length = 0;
    if (0 == this.simDef.modalAnalysis) {
        c = 
        Object.keys(f.resultGroups);
        for (var a = 0; a < c.length; a++) {
            var b = document.createElement("option");
            b.value = c[a];
            var k = f.resultGroups[c[a]];
            b.setAttribute("data-i18n", k);
            b.textContent = Teratek.Viewing.i18n.translate(k);
            this.resultsGroup.add(b)
        }
    } else
        for (c = Object.keys(f.modalResults),
        a = 0; a < c.length; a++)
            b = document.createElement("option"),
            b.value = c[a],
            k = c[a],
            b.setAttribute("data-i18n", k),
            b.textContent = Teratek.Viewing.i18n.translate(k),
            this.resultsGroup.add(b);
    1 >= this.resultsGroup.options.length ? (this.resultsGroup.disabled = 
    !0,
    this.resultsGroup.style.webkitAppearance = "none",
    this.resultsGroup.style.mozappearance = "none",
    this.resultsGroup.style.appearance = "none") : (this.resultsGroup.disabled = !1,
    this.resultsGroup.style.webkitAppearance = "",
    this.resultsGroup.style.mozappearance = "",
    this.resultsGroup.style.appearance = "");
    d = this;
    d.viewer.model.getObjectTree(function(a) {
        d.instanceTree = a;
        0 == d.simDef.modalAnalysis ? d.fillResultTypes(d.resultsGroup.value) : d.fillModalResultTypes(d.resultsGroup.value);
        setTimeout(function() {
            f.simExt.showResultsDlg(!0);
            f.simExt.applySettings();
            d.setSimObjectsVisibility()
        }
        , 500)
    }
    );
    this.viewer.getProperties(Number(this.simDef.resultsNode), function(a) {
        var b = h(a.properties, "Elements");
        a = h(a.properties, "Nodes");
        d.cellTextElements2.nodeValue = b;
        d.cellTextNodes2.nodeValue = a
    }
    , g)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.processNodes = function(f, h) {
    function g(a, b) {
        for (var c = 0; c < a.length; ++c) {
            var d = a[c];
            if (d.displayName === b)
                return d.displayValue
        }
        return null 
    }
    function d(b, c) {
        function d(f) {
            var h = f.properties
              , m = g(f.properties, "A1C6011B-E1A6-4ADF-975D-A0003C592F87");
            m ? ("SIM_CONSTRAINTS" == m ? k.constraintsNode = b : "SIM_CONSTRAINT" == m ? k.constraintNodes.push(b) : "SIM_LOADS" == m ? k.loadsNode = b : "SIM_LOAD" == m ? k.loadNodes.push(b) : "SIM_RESULTS_SCALAR_PLOT" == m ? 0 == k.modalAnalysis ? 
            k.associateResult(g(h, "Name"), b) : k.associateModalResult(g(h, "Name"), b) : "SIM_RESULTS_GROUP" == m ? 0 == k.modalAnalysis && k.associateResultGroup(g(h, "Name"), b) : "SIM_RESULTS" == m ? (k.resultsNode = b,
            a.viewer.hide(b)) : "SIM_STUDY" == m && (k.studyNode = b,
            "SimCaseModalFrequencies" == g(f.properties, "Study Type") && (k.modalAnalysis = !0)),
            k.simNodes.push(b)) : k.modelNodes.push(b);
            c()
        }
        function f(a, b, d) {
            c()
        }
        b && a.viewer && a.viewer.getProperties(b, d, f)
    }
    function c() {
        0 < b.length ? d(b.shift(), c) : (Teratek.Viewing.Extensions.Fusion360Sim.$getObjectTree = 
        function() {
            return k
        }
        ,
        h(k))
    }
    var a = this
      , b = []
      , k = this.simDef;
    k ? k.reset() : k = new Teratek.Viewing.Extensions.Fusion360Sim.SimulationDef;
    f.enumNodeChildren(f.getRootId(), function(a) {
        b.push(a)
    }
    , !0);
    c()
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.initModel = function(f, h) {
    if (this.viewer) {
        var g = this;
        g.processNodes(f, function(d) {
            d.simExt = h;
            g.setSimulationDef(d)
        }
        );
        g.addEventListener(g.viewer, Teratek.Viewing.ISOLATE_EVENT, function(d) {
            -1 != g.simDef.loadsNode && g.hightlightNode(g.simDef.loadsNode, !1);
            -1 != g.simDef.constraintsNode && g.hightlightNode(g.simDef.constraintsNode, !1);
            if (g.simDef.modelNodes && 0 < g.simDef.modelNodes.length)
                for (var c = 0; c < g.simDef.modelNodes.length; ++c)
                    g.hightlightNode(g.simDef.modelNodes[c], 
                    !1);
            if (d = d.nodeIdArray)
                0 == d.length ? g.setSimObjectsVisibility() : 1 == d.length && g.isModelNode(d[0]) && (g.simDef.loadsNode && g.viewer.hide(g.simDef.loadsNode),
                g.simDef.constraintsNode && g.viewer.hide(g.simDef.constraintsNode),
                g.simDef.resultsNode && g.viewer.hide(g.simDef.resultsNode))
        }
        )
    }
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.hightlightNode = function(f, h) {
    var g = this.viewer.impl
      , d = this
      , c = !1
      , a = this.viewer.model.getData().instanceTree;
    a && (c = a.getRootId(),
    c = "number" == typeof f && f === c);
    c && h || d.instanceTree.enumNodeFragments(f, function(a) {
        g.highlightFragment(d.viewer.model, a, h, !0)
    }
    , !0)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.fillResultTypes = function(f) {
    function h(c, a) {
        for (var b = 0; b < c.length; ++b) {
            var d = c[b];
            if (d.displayName === a)
                return d.displayValue
        }
        return null 
    }
    function g(c, a, b) {}
    var d = this;
    d.resultTypes.options.length = 0;
    d.viewer.getProperties(Number(f), function(c) {
        function a(a) {
            if (h(a.properties, "Result group") === b) {
                var c = document.createElement("option");
                c.value = a.dbId;
                a = d.simDef.resultTypes[a.dbId];
                c.setAttribute("data-i18n", a);
                c.textContent = Teratek.Viewing.i18n.translate(a);
                d.resultTypes.add(c);
                1 >= d.resultTypes.options.length ? (d.resultTypes.disabled = !0,
                d.resultTypes.style.webkitAppearance = "none",
                d.resultTypes.style.mozappearance = "none",
                d.resultTypes.style.appearance = "none") : (d.resultTypes.disabled = !1,
                d.resultTypes.style.webkitAppearance = "",
                d.resultTypes.style.mozappearance = "",
                d.resultTypes.style.appearance = "")
            }
        }
        var b = h(c.properties, "Result group");
        c = Object.keys(d.simDef.resultTypes);
        for (var f = 0; f < c.length; f++)
            d.viewer.getProperties(Number(c[f]), a, g)
    }
    , g)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.fillModalResultTypes = function(f) {
    function h(a, b) {
        for (var c = 0; c < a.length; ++c) {
            var d = a[c];
            if (d.displayName === b)
                return d.displayValue
        }
        return null 
    }
    function g(b) {
        if (h(b.properties, "Result type") === a) {
            var d = document.createElement("option");
            d.value = b.dbId;
            var f = h(b.properties, "Mode");
            d.setAttribute("data-i18n", f);
            d.textContent = f;
            c.resultTypes.add(d);
            c.simDef.associateResult(f, b.dbId);
            1 >= c.resultTypes.options.length ? (c.resultTypes.disabled = !0,
            c.resultTypes.style.webkitAppearance = "none",
            c.resultTypes.style.mozappearance = "none",
            c.resultTypes.style.appearance = "none") : (c.resultTypes.disabled = !1,
            c.resultTypes.style.webkitAppearance = "",
            c.resultTypes.style.mozappearance = "",
            c.resultTypes.style.appearance = "")
        }
    }
    function d(a, b, c) {}
    var c = this;
    c.resultTypes.options.length = 0;
    var a = f;
    f = c.simDef.modalResults[a];
    for (var b = 0; b < f.length; b++)
        c.viewer.getProperties(Number(f[b]), g, d)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.uninitialize = function() {
    Teratek.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);
    this.viewer = null 
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setTitle = function(f, h) {
    f || (f = "Simulations",
    h = h || {},
    h.localizeTitle = !0);
    Teratek.Viewing.UI.DockingPanel.prototype.setTitle.call(this, f, h)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setModelNodesVisible = function(f) {
    if (this.simDef.modelNodes && 0 < this.simDef.modelNodes.length)
        for (var h = 0; h < this.simDef.modelNodes.length; h++) {
            var g = this.simDef.modelNodes[h]
              , d = !1
              , c = this.viewer.model.getData().instanceTree;
            c && (d = c.getRootId(),
            d = "number" == typeof g && g === d);
            d || (f ? this.viewer.show(g) : this.viewer.hide(g))
        }
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isModelNode = function(f) {
    return this.simDef.modelNodes && 0 != this.simDef.modelNodes.length ? -1 !== this.simDef.modelNodes.indexOf(f) : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setNodeVisibility = function(f, h) {
    h ? this.viewer.show(f) : this.viewer.hide(f)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimLoadNode = function(f) {
    return this.simDef.loadNodes ? -1 !== this.simDef.loadNodes.indexOf(f) : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimConstraintNode = function(f) {
    return this.simDef.constraintNodes ? -1 !== this.simDef.constraintNodes.indexOf(f) : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimLoadsNode = function(f) {
    return -1 == this.simDef.loadsNode ? !1 : this.simDef.loadsNode == f
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimConstraintsNode = function(f) {
    return -1 == this.simDef.constraintsNode ? !1 : this.simDef.constraintsNode == f
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimStudyNode = function(f) {
    return this.simDef.studyNode ? this.simDef.studyNode == f : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.isSimResultsNode = function(f) {
    return this.simDef.resultsNode ? this.simDef.resultsNode == f : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel.prototype.setSimObjectsVisibility = function(f) {
    function h(a, b) {
        for (var c = 0; c < a.length; ++c) {
            var d = a[c];
            if (d.displayName === b)
                return d.displayValue
        }
        return null 
    }
    function g(a) {
        var b = h(a.properties, "Minimal value")
          , d = h(a.properties, "Maximal value")
          , f = h(a.properties, "Scale reversed")
          , g = h(a.properties, "Unit");
        c.cellTextMin2.nodeValue = b + " " + g;
        c.cellTextMax2.nodeValue = d + " " + g;
        b = h(a.properties, "Lower referential value");
        a = h(a.properties, "Upper referential value");
        c.colorScale.style.transform = "True" == f ? "rotate(90deg)" : "rotate(-90deg)";
        c.colorScaleTopText.innerHTML = "- " + a + " " + g;
        c.colorScaleBottomText.innerHTML = "- " + b + " " + g
    }
    function d(a, b, c) {}
    if (this.resultTypes && 0 != this.resultTypes.options.length) {
        var c = this;
        this.viewer.hide(this.simDef.resultsNode);
        var a = Number(this.resultTypes.value);
        if (f) {
            var b = !1
              , k = this.viewer.model.getData().instanceTree;
            k && (b = k.getRootId(),
            b = "number" == typeof f && f === b);
            this.setModelNodesVisible(!1);
            this.isSimLoadNode(f);
            this.isSimLoadsNode(f);
            this.isSimConstraintNode(f);
            this.isSimConstraintsNode(f);
            var l = this.isSimStudyNode(f);
            this.viewer.hide(this.simDef.resultsNode);
            this.viewer.show(a);
            this.simDef.loadsNode && this.viewer.show(this.simDef.loadsNode);
            this.simDef.constraintsNode && this.viewer.show(this.simDef.constraintsNode);
            b || l || k.enumNodeFragments(f, function(a) {
                c.viewer.impl.highlightFragment(c.viewer.model, a, !0, !0)
            }
            , !0)
        } else
            this.setModelNodesVisible(!1),
            this.viewer.show(a),
            -1 != this.simDef.loadsNode && this.viewer.show(this.simDef.loadsNode),
            -1 != this.simDef.constraintsNode && this.viewer.show(this.simDef.constraintsNode);
        c = this;
        c.viewer.getProperties(a, g, d)
    } else
        this.setModelNodesVisible(!0),
        this.simDef.simExt.showResultsDlg(!1)
}
;
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.Fusion360Sim");
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel = function(f, h, g) {
    Teratek.Viewing.Extensions.ViewerModelStructurePanel.call(this, f.viewer, h, g);
    this.viewer = f.viewer;
    this.ext = f
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype = Object.create(Teratek.Viewing.Extensions.ViewerModelStructurePanel.prototype);
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.constructor = Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.setGallery = function(f) {
    this.simGalleryPanel = f
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.initialize = function() {
    Teratek.Viewing.Extensions.ViewerModelStructurePanel.prototype.initialize.call(this)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.isSimResultsNode = function(f) {
    return this.simGalleryPanel && this.simGalleryPanel.simDef && this.simGalleryPanel.simDef.resultsNode ? this.simGalleryPanel.simDef.resultsNode == f : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.isSimStudyNode = function(f) {
    return this.simGalleryPanel && this.simGalleryPanel.simDef && this.simGalleryPanel.simDef.studyNode ? this.simGalleryPanel.simDef.studyNode == f : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.isModelNode = function(f) {
    return this.simGalleryPanel && this.simGalleryPanel.simDef && this.simGalleryPanel.simDef.modelNodes && 0 != this.simGalleryPanel.simDef.modelNodes.length ? -1 !== this.simGalleryPanel.simDef.modelNodes.indexOf(f) : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.shouldInclude = function(f) {
    return this.isSimStudyNode(f) ? !1 : !0
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.onClick = function(f, h) {
    Teratek.Viewing.Extensions.ViewerModelStructurePanel.prototype.onClick.call(this, f, h);
    this.simGalleryPanel.setModelNodesVisible(!0);
    this.simGalleryPanel.hightlightNode(f, !0);
    this.simGalleryPanel.simDef.loadsNode && this.viewer.hide(this.simGalleryPanel.simDef.loadsNode);
    this.simGalleryPanel.simDef.constraintsNode && this.viewer.hide(this.simGalleryPanel.simDef.constraintsNode);
    this.simGalleryPanel.simDef.resultsNode && 
    this.viewer.hide(this.simGalleryPanel.simDef.resultsNode)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel.prototype.expandStudyNode = function() {
    this.simGalleryPanel.simDef.studyNode && this.tree.setCollapsed(this.simGalleryPanel.simDef.studyNode, !1)
}
;
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.Fusion360Sim");
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel = function(f, h, g) {
    Teratek.Viewing.Extensions.ViewerModelStructurePanel.call(this, f.viewer, h, g);
    this.viewer = f.viewer;
    this.ext = f;
    this.container.style.left = "350px"
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype = Object.create(Teratek.Viewing.Extensions.ViewerModelStructurePanel.prototype);
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.constructor = Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel;
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.setGallery = function(f) {
    this.simGalleryPanel = f
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.isSimResultsNode = function(f) {
    return this.simGalleryPanel && this.simGalleryPanel.simDef && this.simGalleryPanel.simDef.resultsNode ? this.simGalleryPanel.simDef.resultsNode == f : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.isModelNode = function(f) {
    return this.simGalleryPanel && this.simGalleryPanel.simDef && this.simGalleryPanel.simDef.modelNodes && 0 != this.simGalleryPanel.simDef.modelNodes.length ? 1 == this.simGalleryPanel.simDef.modelNodes.indexOf(f) : !1
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.shouldInclude = function(f) {
    return this.isSimResultsNode(f) || this.isModelNode(f) ? !1 : !0
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.onClick = function(f, h) {
    Teratek.Viewing.Extensions.ViewerModelStructurePanel.prototype.onClick.call(this, f, h);
    this.simGalleryPanel.setSimObjectsVisibility(f)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel.prototype.expandStudyNode = function() {
    this.simGalleryPanel.simDef.studyNode && this.tree.setCollapsed(this.simGalleryPanel.simDef.studyNode, !1)
}
;
"use strict";
TeratekNamespace("Teratek.Viewing.Extensions.Fusion360Sim");
Teratek.Viewing.Extensions.Fusion360Sim.Simulation = function(f, h) {
    Teratek.Viewing.Extension.call(this, f, h);
    this.viewer = f;
    this.simButton = null ;
    this.useModelPanel = this.useSetupPanel = !0;
    h && (void 0 !== h.useSetupPanel && (this.useSetupPanel = h.useSetupPanel),
    void 0 !== h.useModelPanel && (this.useModelPanel = h.useModelPanel))
}
;
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype = Object.create(Teratek.Viewing.Extension.prototype);
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype.constructor = Teratek.Viewing.Extensions.Fusion360Sim.Simulation;
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype.load = function() {
    var f = this
      , h = this.viewer;
    f.galleryPanel = new Teratek.Viewing.Extensions.Fusion360Sim.GalleryPanel(f.viewer);
    f.viewer.addPanel(f.galleryPanel);
    f.simButton = new Teratek.Viewing.UI.Button("toolbar-simulation");
    f.simButton.setToolTip("Simulation Results");
    f.simButton.onClick = function(c) {
        c = f.galleryPanel.isVisible();
        f.galleryPanel.setVisible(!c);
        f.simButton.setState(c ? Teratek.Viewing.UI.Button.State.INACTIVE : Teratek.Viewing.UI.Button.State.ACTIVE)
    }
    ;
    f.simButton.setIcon("toolbar-simulationIcon");
    h.settingsTools.addControl(f.simButton, {
        index: 1
    });
    this.hideLines = h.prefs.get("lineRendering");
    this.ghosting = h.prefs.get("ghosting");
    this.ambientShadow = h.prefs.get("ambientShadows");
    this.antialiazing = h.prefs.get("antialiasing");
    this.lightPreset = h.prefs.get("lightPreset");
    var g = function() {
        h.removeEventListener(Teratek.Viewing.GEOMETRY_LOADED_EVENT, g);
        f.viewer.model.getObjectTree(function(c) {
            f.galleryPanel.initModel(c, f);
            f.useModelPanel && f.initModelBrowser();
            f.useSetupPanel && f.initSetupPanel()
        }
        )
    }
    ;
    this.initIfLoaded = function() {
        var c = f.viewer.model;
        c && c.isLoadDone && c.getObjectTree(function(a) {
            setTimeout(function() {
                f.galleryPanel.initModel(a, f);
                f.useModelPanel && f.initModelBrowser();
                f.useSetupPanel && f.initSetupPanel()
            }
            , 100)
        }
        )
    }
    ;
    var d = f.viewer.model;
    d && d.isLoadDone ? (h.addEventListener(Teratek.Viewing.MODEL_ROOT_LOADED_EVENT, this.initIfLoaded),
    d.getObjectTree(function(c) {
        setTimeout(function() {
            f.galleryPanel.initModel(c, f);
            f.useModelPanel && f.initModelBrowser();
            f.useSetupPanel && f.initSetupPanel()
        }
        , 100)
    }
    )) : h.addEventListener(Teratek.Viewing.GEOMETRY_LOADED_EVENT, g);
    return !0
}
;
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype.unload = function() {
    this.viewer.removeEventListener(Teratek.Viewing.MODEL_ROOT_LOADED_EVENT, this.initIfLoaded);
    this.showResultsDlg(!1);
    this.viewer.settingsTools.removeControl(this.simButton);
    this.viewer.removePanel(this.galleryPanel);
    this.galleryPanel.uninitialize();
    this.viewer.hideLines(!this.hideLines);
    this.viewer.setGhosting(this.ghosting);
    this.viewer.setQualityLevel(this.ambientShadow, this.antialiazing);
    this.viewer.setLightPreset(this.lightPreset);
    this.modelStructurePanel && this.viewer.setModelStructurePanel(null );
    this.simSetupPanel && (this.simSetupPanel.setVisible(!1),
    this.viewer.removePanel(this.simSetupPanel),
    this.simSetupPanel.uninitialize());
    return !0
}
;
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype.initSetupPanel = function() {
    var f = this;
    setTimeout(function() {
        f.simSetupButton = new Teratek.Viewing.UI.Button("toolbar-simulation-setup");
        f.simSetupButton.setToolTip("Simulation Setup");
        f.simSetupButton.onClick = function(h) {
            h = f.simSetupPanel.isVisible();
            f.simSetupPanel.setVisible(!h);
            f.simSetupButton.setState(h ? Teratek.Viewing.UI.Button.State.INACTIVE : Teratek.Viewing.UI.Button.State.ACTIVE)
        }
        ;
        f.simSetupButton.setIcon("toolbar-simulationSetupIcon");
        f.viewer.settingsTools.addControl(f.simSetupButton, {
            index: 0
        });
        f.simSetupPanel = new Teratek.Viewing.Extensions.Fusion360Sim.SimSetupPanel(f,"Simulation Setup Loading",f.options);
        f.simSetupPanel.setGallery(f.galleryPanel);
        f.viewer.addPanel(f.simSetupPanel);
        f.viewer.model && f.viewer.model.getObjectTree(function(h) {
            f.simSetupPanel.setModel(h, "Simulation Setup")
        }
        )
    }
    , 100)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype.initModelBrowser = function() {
    var f = this;
    setTimeout(function() {
        f.modelStructurePanel = new Teratek.Viewing.Extensions.Fusion360Sim.SimModelStructurePanel(f,"Simulation Model Structure Loading",f.options);
        f.viewer.setModelStructurePanel(f.modelStructurePanel);
        f.modelStructurePanel.setGallery(f.galleryPanel)
    }
    , 100)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype.showResultsDlg = function(f) {
    this.simButton.setState(f ? Teratek.Viewing.UI.Button.State.ACTIVE : Teratek.Viewing.UI.Button.State.INACTIVE);
    this.simButton.setVisible(f);
    this.galleryPanel.setVisible(f)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype.applySettings = function(f) {
    this.viewer.hideLines(!1);
    this.viewer.setGhosting(!1);
    this.viewer.setQualityLevel(!1, !0);
    this.viewer.setLightPreset(4)
}
;
Teratek.Viewing.Extensions.Fusion360Sim.Simulation.prototype.simData = function() {
    return this.galleryPanel.simDef
}
;
Teratek.Viewing.theExtensionManager.registerExtension("Teratek.Fusion360.Simulation", Teratek.Viewing.Extensions.Fusion360Sim.Simulation);
function init_TransformGizmos() {
    var f = function(a) {
        THREE.MeshBasicMaterial.call(this);
        this.depthWrite = this.depthTest = !1;
        this.side = THREE.FrontSide;
        this.transparent = !0;
        this.setValues(a);
        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;
        this.highlight = function(a) {
            a ? (this.color.setRGB(1, 230 / 255, 3 / 255),
            this.opacity = 1) : (this.color.copy(this.oldColor),
            this.opacity = this.oldOpacity)
        }
    }
    ;
    f.prototype = Object.create(THREE.MeshBasicMaterial.prototype);
    var h = function(a) {
        THREE.LineBasicMaterial.call(this);
        this.depthWrite = this.depthTest = !1;
        this.transparent = !0;
        this.linewidth = 1;
        this.setValues(a);
        this.oldColor = this.color.clone();
        this.oldOpacity = this.opacity;
        this.highlight = function(a) {
            a ? (this.color.setRGB(1, 230 / 255, 3 / 255),
            this.opacity = 1) : (this.color.copy(this.oldColor),
            this.opacity = this.oldOpacity)
        }
    }
    ;
    h.prototype = Object.create(THREE.LineBasicMaterial.prototype);
    void 0 === THREE.PolyhedronGeometry && (THREE.PolyhedronGeometry = function(a, b, c, d) {
        function f(a) {
            var b = a.normalize().clone();
            b.index = t.vertices.push(b) - 
            1;
            var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;
            a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5;
            b.uv = new THREE.Vector2(c,1 - a);
            return b
        }
        function g(a, b, c) {
            var d = new THREE.Face3(a.index,b.index,c.index,[a.clone(), b.clone(), c.clone()]);
            t.faces.push(d);
            z.copy(a).add(b).add(c).divideScalar(3);
            d = Math.atan2(z.z, -z.x);
            t.faceVertexUvs[0].push([r(a.uv, a, d), r(b.uv, b, d), r(c.uv, c, d)])
        }
        function h(a, b) {
            var c = Math.pow(2, b);
            Math.pow(4, b);
            for (var d = f(t.vertices[a.a]), k = f(t.vertices[a.b]), l = f(t.vertices[a.c]), q = [], 
            r = 0; r <= c; r++) {
                q[r] = [];
                for (var v = f(d.clone().lerp(l, r / c)), B = f(k.clone().lerp(l, r / c)), w = c - r, z = 0; z <= w; z++)
                    q[r][z] = 0 == z && r == c ? v : f(v.clone().lerp(B, z / w))
            }
            for (r = 0; r < c; r++)
                for (z = 0; z < 2 * (c - r) - 1; z++)
                    d = Math.floor(z / 2),
                    0 == z % 2 ? g(q[r][d + 1], q[r + 1][d], q[r][d]) : g(q[r][d + 1], q[r + 1][d + 1], q[r + 1][d])
        }
        function r(a, b, c) {
            0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1,a.y));
            0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5,a.y));
            return a.clone()
        }
        THREE.Geometry.call(this);
        this.type = "PolyhedronGeometry";
        this.parameters = {
            vertices: a,
            indices: b,
            radius: c,
            detail: d
        };
        c = c || 1;
        d = d || 0;
        for (var t = this, w = 0, C = a.length; w < C; w += 3)
            f(new THREE.Vector3(a[w],a[w + 1],a[w + 2]));
        a = this.vertices;
        for (var E = [], G = w = 0, C = b.length; w < C; w += 3,
        G++) {
            var B = a[b[w]]
              , v = a[b[w + 1]]
              , D = a[b[w + 2]];
            E[G] = new THREE.Face3(B.index,v.index,D.index,[B.clone(), v.clone(), D.clone()])
        }
        for (var z = new THREE.Vector3, w = 0, C = E.length; w < C; w++)
            h(E[w], d);
        w = 0;
        for (C = this.faceVertexUvs[0].length; w < C; w++)
            b = this.faceVertexUvs[0][w],
            d = b[0].x,
            a = b[1].x,
            E = b[2].x,
            G = Math.max(d, Math.max(a, E)),
            B = Math.min(d, 
            Math.min(a, E)),
            .9 < G && .1 > B && (.2 > d && (b[0].x += 1),
            .2 > a && (b[1].x += 1),
            .2 > E && (b[2].x += 1));
        w = 0;
        for (C = this.vertices.length; w < C; w++)
            this.vertices[w].multiplyScalar(c);
        this.mergeVertices();
        this.computeFaceNormals();
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3,c)
    }
    ,
    THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype));
    void 0 === THREE.OctahedronGeometry && (THREE.OctahedronGeometry = function(a, b) {
        this.parameters = {
            radius: a,
            detail: b
        };
        THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 
        1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
        this.type = "OctahedronGeometry";
        this.parameters = {
            radius: a,
            detail: b
        }
    }
    ,
    THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype));
    void 0 === THREE.TorusGeometry && (THREE.TorusGeometry = function(a, b, c, d, f) {
        THREE.Geometry.call(this);
        this.type = "TorusGeometry";
        this.parameters = {
            radius: a,
            tube: b,
            radialSegments: c,
            tubularSegments: d,
            arc: f
        };
        a = a || 100;
        b = b || 40;
        c = c || 8;
        d = d || 6;
        f = f || 2 * Math.PI;
        for (var g = new THREE.Vector3, h = [], 
        r = [], t = 0; t <= c; t++)
            for (var w = 0; w <= d; w++) {
                var C = w / d * f
                  , E = t / c * Math.PI * 2;
                g.x = a * Math.cos(C);
                g.y = a * Math.sin(C);
                var G = new THREE.Vector3;
                G.x = (a + b * Math.cos(E)) * Math.cos(C);
                G.y = (a + b * Math.cos(E)) * Math.sin(C);
                G.z = b * Math.sin(E);
                this.vertices.push(G);
                h.push(new THREE.Vector2(w / d,t / c));
                r.push(G.clone().sub(g).normalize())
            }
        for (t = 1; t <= c; t++)
            for (w = 1; w <= d; w++)
                a = (d + 1) * t + w - 1,
                b = (d + 1) * (t - 1) + w - 1,
                f = (d + 1) * (t - 1) + w,
                g = (d + 1) * t + w,
                C = new THREE.Face3(a,b,g,[r[a].clone(), r[b].clone(), r[g].clone()]),
                this.faces.push(C),
                this.faceVertexUvs[0].push([h[a].clone(), 
                h[b].clone(), h[g].clone()]),
                C = new THREE.Face3(b,f,g,[r[b].clone(), r[f].clone(), r[g].clone()]),
                this.faces.push(C),
                this.faceVertexUvs[0].push([h[b].clone(), h[f].clone(), h[g].clone()]);
        this.computeFaceNormals()
    }
    ,
    THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype));
    var g = function(a, b, c) {
        var d = new THREE.Geometry;
        c = c ? c : 1;
        for (var f = 0; f <= 64 * c; ++f)
            "x" == b && d.vertices.push((new THREE.Vector3(0,Math.cos(f / 32 * Math.PI),Math.sin(f / 32 * Math.PI))).multiplyScalar(a)),
            "y" == b && d.vertices.push((new THREE.Vector3(Math.cos(f / 
            32 * Math.PI),0,Math.sin(f / 32 * Math.PI))).multiplyScalar(a)),
            "z" == b && d.vertices.push((new THREE.Vector3(Math.sin(f / 32 * Math.PI),Math.cos(f / 32 * Math.PI),0)).multiplyScalar(a));
        return d
    }
      , d = function(a, b, c, d, f, g) {
        var h = new THREE.Geometry;
        a = new THREE.Mesh(new THREE.CylinderGeometry(a,b,c,d,f,g));
        a.position.y = .5;
        a.updateMatrix();
        h.merge(a.geometry, a.matrix);
        return h
    }
      , c = function(a) {
        var b = new THREE.Geometry;
        "X" === a ? b.vertices.push(new THREE.Vector3(0,0,0), new THREE.Vector3(1,0,0)) : "Y" === a ? b.vertices.push(new THREE.Vector3(0,
        0,0), new THREE.Vector3(0,1,0)) : "Z" === a && b.vertices.push(new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,1));
        return b
    }
    ;
    THREE.TransformGizmo = function() {
        var a = this;
        this.init = function() {
            THREE.Object3D.call(this);
            this.handles = new THREE.Object3D;
            this.pickers = new THREE.Object3D;
            this.planes = new THREE.Object3D;
            this.highlights = new THREE.Object3D;
            this.hemiPicker = new THREE.Object3D;
            this.subPickers = new THREE.Object3D;
            this.add(this.handles);
            this.add(this.pickers);
            this.add(this.planes);
            this.add(this.highlights);
            this.add(this.hemiPicker);
            this.add(this.subPickers);
            var a = new THREE.PlaneBufferGeometry(50,50,2,2)
              , c = new THREE.MeshBasicMaterial({
                wireframe: !0
            });
            c.side = THREE.DoubleSide;
            a = {
                XY: new THREE.Mesh(a,c),
                YZ: new THREE.Mesh(a,c),
                XZ: new THREE.Mesh(a,c),
                XYZE: new THREE.Mesh(a,c)
            };
            this.activePlane = a.XYZE;
            a.YZ.rotation.set(0, Math.PI / 2, 0);
            a.XZ.rotation.set(-Math.PI / 2, 0, 0);
            for (var d in a)
                a[d].name = d,
                this.planes.add(a[d]),
                this.planes[d] = a[d],
                a[d].visible = !1;
            this.setupGizmos();
            this.activeMode = "";
            this.traverse(function(a) {
                if (a instanceof 
                THREE.Mesh) {
                    a.updateMatrix();
                    var b = new THREE.Geometry;
                    a.geometry instanceof THREE.BufferGeometry && (a.geometry = (new THREE.Geometry).fromBufferGeometry(a.geometry));
                    b.merge(a.geometry, a.matrix);
                    a.geometry = b;
                    a.position.set(0, 0, 0);
                    a.rotation.set(0, 0, 0);
                    a.scale.set(1, 1, 1)
                }
            }
            )
        }
        ;
        this.hide = function() {
            this.traverse(function(a) {
                a.visible = !1
            }
            )
        }
        ;
        this.show = function() {
            this.traverse(function(b) {
                b.visible = !0;
                if (b.parent == a.pickers || b.parent == a.hemiPicker)
                    b.visible = !1;
                b.parent == a.planes && (b.visible = !1)
            }
            );
            this.activePlane.visible = 
            !1
        }
        ;
        this.highlight = function(a) {
            this.traverse(function(c) {
                c.material && c.material.highlight && (c.name == a ? c.material.highlight(!0) : c.material.highlight(!1))
            }
            )
        }
        ;
        this.setupGizmos = function() {
            var a = function(a, b) {
                for (var c in a)
                    for (var d = a[c].length; d--; ) {
                        var f = a[c][d][0]
                          , g = a[c][d][1]
                          , h = a[c][d][2]
                          , w = a[c][d][3];
                        f.name = c;
                        g && f.position.set(g[0], g[1], g[2]);
                        h && f.rotation.set(h[0], h[1], h[2]);
                        w && (f.visble = w);
                        b.add(f)
                    }
            }
            ;
            this.setHandlePickerGizmos();
            a(this.handleGizmos, this.handles);
            a(this.pickerGizmos, this.pickers);
            a(this.highlightGizmos, this.highlights);
            a(this.hemiPickerGizmos, this.hemiPicker);
            a(this.subPickerGizmos, this.subPickers);
            this.hide();
            this.show()
        }
    }
    ;
    THREE.TransformGizmo.prototype = Object.create(THREE.Object3D.prototype);
    THREE.TransformGizmo.prototype.update = function(a, b) {
        var c = new THREE.Vector3(0,0,0)
          , d = new THREE.Vector3(0,1,0)
          , f = new THREE.Matrix4;
        this.traverse(function(g) {
            g.name && (-1 != g.name.search("E") ? g.quaternion.setFromRotationMatrix(f.lookAt(b, c, d)) : -1 == g.name.search("X") && -1 == g.name.search("Y") && 
            -1 == g.name.search("Z") || g.quaternion.setFromEuler(a))
        }
        )
    }
    ;
    THREE.TransformGizmoTranslate = function() {
        THREE.TransformGizmo.call(this);
        this.setHandlePickerGizmos = function() {
            var a = d(0, .05, .2, 12, 1, !1)
              , b = c("X")
              , g = c("Y")
              , l = c("Z");
            this.handleGizmos = {
                X: [[new THREE.Mesh(a,new f({
                    color: 15805484
                })), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(b,new h({
                    color: 15805484
                }))]],
                Y: [[new THREE.Mesh(a,new f({
                    color: 768011
                })), [0, .5, 0]], [new THREE.Line(g,new h({
                    color: 768011
                }))]],
                Z: [[new THREE.Mesh(a,new f({
                    color: 2895089
                })), [0, 
                0, .5], [Math.PI / 2, 0, 0]], [new THREE.Line(l,new h({
                    color: 2895089
                }))]],
                XYZ: [[new THREE.Mesh(new THREE.OctahedronGeometry(.1,0),new f({
                    color: 16777215,
                    opacity: .25
                })), [0, 0, 0], [0, 0, 0]]],
                XY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(.29,.29),new f({
                    color: 16776960,
                    opacity: .25
                })), [.15, .15, 0]]],
                YZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(.29,.29),new f({
                    color: 65535,
                    opacity: .25
                })), [0, .15, .15], [0, Math.PI / 2, 0]]],
                XZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(.29,.29),new f({
                    color: 16711935,
                    opacity: .25
                })), 
                [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
            };
            this.pickerGizmos = {
                X: [[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),new f({
                    color: 16711680,
                    opacity: .25
                })), [.6, 0, 0], [0, 0, -Math.PI / 2]]],
                Y: [[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),new f({
                    color: 65280,
                    opacity: .25
                })), [0, .6, 0]]],
                Z: [[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),new f({
                    color: 255,
                    opacity: .25
                })), [0, 0, .6], [Math.PI / 2, 0, 0]]],
                XYZ: [[new THREE.Mesh(new THREE.OctahedronGeometry(.2,0),new f({
                    color: 16777215,
                    opacity: .25
                }))]],
                XY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(.4,
                .4),new f({
                    color: 16776960,
                    opacity: .25
                })), [.2, .2, 0]]],
                YZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(.4,.4),new f({
                    color: 65535,
                    opacity: .25
                })), [0, .2, .2], [0, Math.PI / 2, 0]]],
                XZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(.4,.4),new f({
                    color: 16711935,
                    opacity: .25
                })), [.2, 0, .2], [-Math.PI / 2, 0, 0]]]
            };
            this.hemiPickerGizmos = {
                XYZ: [[new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2),new f({
                    color: 255
                })), [.5, .5, .5], null , !1]]
            }
        }
        ;
        this.setActivePlane = function(a, b) {
            var c = new THREE.Matrix4;
            b.applyMatrix4(c.getInverse(c.extractRotation(this.planes.XY.matrixWorld)));
            "X" == a && (this.activePlane = this.planes.XY,
            Math.abs(b.y) > Math.abs(b.z) && (this.activePlane = this.planes.XZ));
            "Y" == a && (this.activePlane = this.planes.XY,
            Math.abs(b.x) > Math.abs(b.z) && (this.activePlane = this.planes.YZ));
            "Z" == a && (this.activePlane = this.planes.XZ,
            Math.abs(b.x) > Math.abs(b.y) && (this.activePlane = this.planes.YZ));
            "XYZ" == a && (this.activePlane = this.planes.XYZE);
            "XY" == a && (this.activePlane = this.planes.XY);
            "YZ" == a && (this.activePlane = this.planes.YZ);
            "XZ" == a && (this.activePlane = this.planes.XZ);
            this.hide();
            this.show()
        }
        ;
        this.init()
    }
    ;
    THREE.TransformGizmoTranslate.prototype = Object.create(THREE.TransformGizmo.prototype);
    THREE.TransformGizmoRotate = function() {
        THREE.TransformGizmo.call(this);
        this.setHandlePickerGizmos = function() {
            this.handleGizmos = {
                RX: [[new THREE.Line(g(1, "x", .5),new h({
                    color: 16711680
                }))]],
                RY: [[new THREE.Line(g(1, "y", .5),new h({
                    color: 65280
                }))]],
                RZ: [[new THREE.Line(g(1, "z", .5),new h({
                    color: 255
                }))]],
                RE: [[new THREE.Line(g(1.25, "z", 1),new h({
                    color: 65535
                }))]],
                RXYZE: [[new THREE.Line(g(1, "z", 1),new h({
                    color: 16711935
                }))]]
            };
            this.pickerGizmos = {
                RX: [[new THREE.Mesh(new THREE.TorusGeometry(1,.12,4,12,Math.PI),new f({
                    color: 16711680,
                    opacity: .25
                })), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
                RY: [[new THREE.Mesh(new THREE.TorusGeometry(1,.12,4,12,Math.PI),new f({
                    color: 65280,
                    opacity: .25
                })), [0, 0, 0], [Math.PI / 2, 0, 0]]],
                RZ: [[new THREE.Mesh(new THREE.TorusGeometry(1,.12,4,12,Math.PI),new f({
                    color: 255,
                    opacity: .25
                })), [0, 0, 0], [0, 0, -Math.PI / 2]]],
                RE: [[new THREE.Mesh(new THREE.TorusGeometry(1.25,.12,2,24),new f({
                    color: 65535,
                    opacity: .25
                }))]],
                RXYZE: [[new THREE.Mesh(new THREE.TorusGeometry(1,
                .12,2,24),new f({
                    color: 16711935,
                    opacity: .25
                }))]]
            }
        }
        ;
        this.setActivePlane = function(a) {
            "RE" == a && (this.activePlane = this.planes.XYZE);
            "RX" == a && (this.activePlane = this.planes.YZ);
            "RY" == a && (this.activePlane = this.planes.XZ);
            "RZ" == a && (this.activePlane = this.planes.XY);
            this.hide();
            this.show()
        }
        ;
        this.update = function(a, b) {
            THREE.TransformGizmo.prototype.update.apply(this, arguments);
            var c = new THREE.Matrix4
              , d = new THREE.Euler(0,0,1)
              , f = new THREE.Quaternion
              , g = new THREE.Vector3(1,0,0)
              , h = new THREE.Vector3(0,1,0)
              , r = new THREE.Vector3(0,
            0,1)
              , t = new THREE.Quaternion
              , w = new THREE.Quaternion
              , C = new THREE.Quaternion
              , E = b.clone();
            d.copy(this.planes.XY.rotation);
            f.setFromEuler(d);
            c.makeRotationFromQuaternion(f).getInverse(c);
            E.applyMatrix4(c);
            this.traverse(function(a) {
                f.setFromEuler(d);
                "RX" == a.name && (t.setFromAxisAngle(g, Math.atan2(-E.y, E.z)),
                f.multiplyQuaternions(f, t),
                a.quaternion.copy(f));
                "RY" == a.name && (w.setFromAxisAngle(h, Math.atan2(E.x, E.z)),
                f.multiplyQuaternions(f, w),
                a.quaternion.copy(f));
                "RZ" == a.name && (C.setFromAxisAngle(r, Math.atan2(E.y, 
                E.x)),
                f.multiplyQuaternions(f, C),
                a.quaternion.copy(f))
            }
            )
        }
        ;
        this.init()
    }
    ;
    THREE.TransformGizmoRotate.prototype = Object.create(THREE.TransformGizmo.prototype);
    THREE.TransformGizmoTranslateRotate = function() {
        THREE.TransformGizmo.call(this);
        var a = this;
        this.setHandlePickerGizmos = function() {
            var a = d(0, .05, .2, 12, 1, !1);
            (new THREE.Geometry).vertices.push(new THREE.Vector3(0,0,-.1), new THREE.Vector3(0,0,.1), new THREE.Vector3(-.1,0,0), new THREE.Vector3(.1,0,0));
            this.handleGizmos = {
                Z: [[new THREE.Mesh(a,new f({
                    color: 16777215
                })), 
                [0, 0, .25], [Math.PI / 2, 0, 0]], [new THREE.Mesh(new THREE.CylinderGeometry(.015,.015,.6,4,1,!1),new f({
                    color: 16777215
                })), [0, 0, .5], [Math.PI / 2, 0, 0]]],
                RX: [[new THREE.Mesh(new THREE.TorusGeometry(1,.015,12,60,.3 * Math.PI),new f({
                    color: 16711680
                })), [0, 0, 0], [.15 * Math.PI, -Math.PI / 2, 0]], [new THREE.Mesh(new THREE.CylinderGeometry(.05,.05,.015,60,1,!1),new f({
                    color: 16711680
                })), [0, 0, 1], [Math.PI / 2, 0, 0]]],
                RY: [[new THREE.Mesh(new THREE.TorusGeometry(1,.015,12,60,.3 * Math.PI),new f({
                    color: 255
                })), [0, 0, 0], [Math.PI / 2, 0, .35 * 
                Math.PI]], [new THREE.Mesh(new THREE.CylinderGeometry(.05,.05,.01,60,1,!1),new f({
                    color: 255
                })), [0, 0, 1]]]
            };
            this.pickerGizmos = {
                Z: [[new THREE.Mesh(new THREE.CylinderGeometry(.12,.12,.65,4,1,!1),new f({
                    color: 255,
                    opacity: .25
                })), [0, 0, .5], [Math.PI / 2, 0, 0]]],
                RX: [[new THREE.Mesh(new THREE.TorusGeometry(1,.12,4,12,.3 * Math.PI),new f({
                    color: 16711680,
                    opacity: .25
                })), [0, 0, 0], [.15 * Math.PI, -Math.PI / 2, 0]]],
                RY: [[new THREE.Mesh(new THREE.TorusGeometry(1,.12,4,12,.3 * Math.PI),new f({
                    color: 255,
                    opacity: .25
                })), [0, 0, 0], [Math.PI / 
                2, 0, .35 * Math.PI]]]
            };
            this.subPickerGizmos = {
                Z: [[new THREE.Mesh(new THREE.CylinderGeometry(.12,.12,.65,4,1,!1),new f({
                    color: 255,
                    opacity: .25
                })), [0, 0, .5], [Math.PI / 2, 0, 0]]]
            };
            this.highlightGizmos = {
                Z: [],
                RX: [[new THREE.Mesh(new THREE.TorusGeometry(1,.02,12,60,2 * Math.PI),new f({
                    color: 16711680,
                    opacity: 1
                })), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2], !1]],
                RY: [[new THREE.Mesh(new THREE.TorusGeometry(1,.02,12,60,2 * Math.PI),new f({
                    color: 255,
                    opacity: 1
                })), [0, 0, 0], [Math.PI / 2, 0, 0], !1]]
            };
            this.hemiPickerGizmos = {
                XYZ: [[new THREE.Mesh(new THREE.SphereGeometry(1.2,
                8,8,0,Math.PI),new f({
                    color: 255
                })), null , null , !1]]
            }
        }
        ;
        this.setActivePlane = function(a, c) {
            if ("translate" == this.activeMode) {
                var d = new THREE.Matrix4;
                c.applyMatrix4(d.getInverse(d.extractRotation(this.planes.XY.matrixWorld)));
                "X" == a && (this.activePlane = this.planes.XY,
                Math.abs(c.y) > Math.abs(c.z) && (this.activePlane = this.planes.XZ));
                "Y" == a && (this.activePlane = this.planes.XY,
                Math.abs(c.x) > Math.abs(c.z) && (this.activePlane = this.planes.YZ));
                "Z" == a && (this.activePlane = this.planes.XZ,
                Math.abs(c.x) > Math.abs(c.y) && (this.activePlane = 
                this.planes.YZ))
            } else
                "rotate" == this.activeMode && ("RX" == a && (this.activePlane = this.planes.YZ),
                "RY" == a && (this.activePlane = this.planes.XZ),
                "RZ" == a && (this.activePlane = this.planes.XY));
            this.hide();
            this.show()
        }
        ;
        this.update = function(a, c) {
            if ("translate" == this.activeMode)
                THREE.TransformGizmo.prototype.update.apply(this, arguments);
            else if ("rotate" == this.activeMode) {
                THREE.TransformGizmo.prototype.update.apply(this, arguments);
                var d = new THREE.Matrix4
                  , f = new THREE.Euler(0,0,1)
                  , g = new THREE.Quaternion
                  , h = new THREE.Vector3(1,
                0,0)
                  , r = new THREE.Vector3(0,1,0)
                  , t = new THREE.Vector3(0,0,1)
                  , w = new THREE.Quaternion
                  , C = new THREE.Quaternion
                  , E = new THREE.Quaternion
                  , G = c.clone();
                f.copy(this.planes.XY.rotation);
                g.setFromEuler(f);
                d.makeRotationFromQuaternion(g).getInverse(d);
                G.applyMatrix4(d);
                this.traverse(function(a) {
                    g.setFromEuler(f);
                    "RX" == a.name && (w.setFromAxisAngle(h, Math.atan2(-G.y, G.z)),
                    g.multiplyQuaternions(g, w),
                    a.quaternion.copy(g));
                    "RY" == a.name && (C.setFromAxisAngle(r, Math.atan2(G.x, G.z)),
                    g.multiplyQuaternions(g, C),
                    a.quaternion.copy(g));
                    "RZ" == a.name && (E.setFromAxisAngle(t, Math.atan2(G.y, G.x)),
                    g.multiplyQuaternions(g, E),
                    a.quaternion.copy(g))
                }
                )
            }
        }
        ;
        this.show = function() {
            this.traverse(function(b) {
                if (null  == a.parent || a.parent.useAllPickers || b.parent != a.handles)
                    b.visible = !0;
                b.material && (b.material.opacity = b.material.oldOpacity);
                if (b.parent == a.pickers || b.parent == a.hemiPicker || b.parent == a.subPickers)
                    b.visible = !1;
                if (b.parent == a.planes || b.parent == a.highlights)
                    b.visible = !1
            }
            );
            this.activePlane.visible = !1
        }
        ;
        this.highlight = function(b) {
            this.traverse(function(c) {
                if (c.material && 
                c.material.highlight)
                    if (c.name == b) {
                        if (c.parent == a.highlights || c.parent == a.handles)
                            c.visible = !0;
                        c.material.highlight(!0)
                    } else
                        c.material.highlight(!1),
                        c.material.opacity = .1
            }
            )
        }
        ;
        this.init()
    }
    ;
    THREE.TransformGizmoTranslateRotate.prototype = Object.create(THREE.TransformGizmo.prototype);
    THREE.TransformGizmoScale = function() {
        THREE.TransformGizmo.call(this);
        this.setHandlePickerGizmos = function() {
            var a = d(.125, .125, .125)
              , b = c("X")
              , g = c("Y")
              , l = c("Z");
            this.handleGizmos = {
                X: [[new THREE.Mesh(a,new f({
                    color: 16711680
                })), 
                [.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(b,new h({
                    color: 16711680
                }))]],
                Y: [[new THREE.Mesh(a,new f({
                    color: 65280
                })), [0, .5, 0]], [new THREE.Line(g,new h({
                    color: 65280
                }))]],
                Z: [[new THREE.Mesh(a,new f({
                    color: 255
                })), [0, 0, .5], [Math.PI / 2, 0, 0]], [new THREE.Line(l,new h({
                    color: 255
                }))]],
                XYZ: [[new THREE.Mesh(new THREE.BoxGeometry(.125,.125,.125),new f({
                    color: 16777215,
                    opacity: .25
                }))]]
            };
            this.pickerGizmos = {
                X: [[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),new f({
                    color: 16711680,
                    opacity: .25
                })), [.6, 0, 0], [0, 
                0, -Math.PI / 2]]],
                Y: [[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),new f({
                    color: 65280,
                    opacity: .25
                })), [0, .6, 0]]],
                Z: [[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),new f({
                    color: 255,
                    opacity: .25
                })), [0, 0, .6], [Math.PI / 2, 0, 0]]],
                XYZ: [[new THREE.Mesh(new THREE.BoxGeometry(.4,.4,.4),new f({
                    color: 16777215,
                    opacity: .25
                }))]]
            }
        }
        ;
        this.setActivePlane = function(a, b) {
            var c = new THREE.Matrix4;
            b.applyMatrix4(c.getInverse(c.extractRotation(this.planes.XY.matrixWorld)));
            "X" == a && (this.activePlane = this.planes.XY,
            Math.abs(b.y) > Math.abs(b.z) && (this.activePlane = this.planes.XZ));
            "Y" == a && (this.activePlane = this.planes.XY,
            Math.abs(b.x) > Math.abs(b.z) && (this.activePlane = this.planes.YZ));
            "Z" == a && (this.activePlane = this.planes.XZ,
            Math.abs(b.x) > Math.abs(b.y) && (this.activePlane = this.planes.YZ));
            "XYZ" == a && (this.activePlane = this.planes.XYZE);
            this.hide();
            this.show()
        }
        ;
        this.init()
    }
    ;
    THREE.TransformGizmoScale.prototype = Object.create(THREE.TransformGizmo.prototype);
    THREE.TransformControls = function(a, b, c) {
        function d(c, f) {
            var g = 
            b.getBoundingClientRect()
              , h = (c.clientX - g.left) / g.width * 2 - 1
              , g = 2 * -((c.clientY - g.top) / g.height) + 1;
            a.isPerspective ? (v.set(h, g, .5),
            v.unproject(a),
            B.set(a.position, v.sub(a.position).normalize())) : (v.set(h, g, -1),
            v.unproject(a),
            D.set(0, 0, -1),
            B.set(v, D.transformDirection(a.matrixWorld)));
            h = B.intersectObjects(f, !0);
            return h[0] ? h[0] : !1
        }
        THREE.Object3D.call(this);
        b = void 0 !== b ? b : document;
        this.gizmo = {};
        switch (c) {
        case "translate":
            this.gizmo[c] = new THREE.TransformGizmoTranslate;
            break;
        case "rotate":
            this.gizmo[c] = new THREE.TransformGizmoRotate;
            break;
        case "transrotate":
            this.gizmo[c] = new THREE.TransformGizmoTranslateRotate;
            break;
        case "scale":
            this.gizmo[c] = new THREE.TransformGizmoScale
        }
        this.add(this.gizmo[c]);
        this.gizmo[c].hide();
        this.object = void 0;
        this.snap = null ;
        this.snapDelta = 0;
        this.space = "world";
        this.size = 1;
        this.axis = null ;
        this.useAllPickers = !0;
        this.unitX = new THREE.Vector3(1,0,0);
        this.unitY = new THREE.Vector3(0,1,0);
        this.unitZ = new THREE.Vector3(0,0,1);
        this.normal = new THREE.Vector3(0,0,1);
        if ("transrotate" === c) {
            var f = new THREE.Geometry;
            f.vertices.push(new THREE.Vector3(0,
            0,0), new THREE.Vector3(0,0,1));
            var g = new THREE.LineBasicMaterial({
                color: 0,
                linewidth: 2,
                depthTest: !1
            });
            this.startLine = new THREE.Line(f,g);
            f = new THREE.Geometry;
            g = new THREE.LineBasicMaterial({
                color: 16770563,
                linewidth: 2,
                depthTest: !1
            });
            f.vertices.push(new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,1));
            this.endLine = new THREE.Line(f,g);
            f = new THREE.Geometry;
            g = new THREE.LineDashedMaterial({
                color: 0,
                linewidth: 1,
                depthTest: !1
            });
            f.vertices.push(new THREE.Vector3(0,-1,0), new THREE.Vector3(0,1,0));
            this.centerLine = 
            new THREE.Line(f,g);
            g = THREE.ImageUtils.loadTexture(Teratek.Viewing.Private.getResourceUrl("res/textures/centerMarker_X.png"));
            g.magFilter = g.minFilter = THREE.NearestFilter;
            f = new THREE.CircleGeometry(.1,32);
            g = new THREE.MeshBasicMaterial({
                opacity: 1,
                side: THREE.DoubleSide,
                transparent: !0,
                map: g
            });
            this.centerMark = new THREE.Mesh(f,g);
            this.centerMark.rotation.set(Math.PI / 2, 0, 0);
            this.ticks = {};
            g = THREE.ImageUtils.loadTexture(Teratek.Viewing.Private.getResourceUrl("res/textures/cardinalPoint.png"));
            g.magFilter = 
            g.minFilter = THREE.NearestFilter;
            g = new THREE.MeshBasicMaterial({
                depthTest: !1,
                opacity: 1,
                transparent: !0,
                side: THREE.DoubleSide,
                map: g
            });
            this.ticks.RX = new THREE.Object3D;
            f = new THREE.PlaneBufferGeometry(.12,.25);
            f = new THREE.Mesh(f,g);
            f.position.set(0, 0, -1.275);
            f.rotation.set(Math.PI / 2, Math.PI / 2, 0);
            this.ticks.RX.add(f);
            f = f.clone();
            f.position.set(0, 1.275, 0);
            f.rotation.set(0, Math.PI / 2, 0);
            this.ticks.RX.add(f);
            f = f.clone();
            f.position.set(0, 0, 1.275);
            f.rotation.set(0, Math.PI / 2, Math.PI / 2);
            this.ticks.RX.add(f);
            f = 
            f.clone();
            f.position.set(0, -1.275, 0);
            f.rotation.set(0, Math.PI / 2, 0);
            this.ticks.RX.add(f);
            this.ticks.RY = new THREE.Object3D;
            f = f.clone();
            f.position.set(0, 0, -1.275);
            f.rotation.set(Math.PI / 2, 0, 0);
            this.ticks.RY.add(f);
            f = f.clone();
            f.position.set(-1.275, 0, 0);
            f.rotation.set(Math.PI / 2, 0, Math.PI / 2);
            this.ticks.RY.add(f);
            f = f.clone();
            f.position.set(0, 0, 1.275);
            f.rotation.set(Math.PI / 2, 0, 0);
            this.ticks.RY.add(f);
            f = f.clone();
            f.position.set(1.275, 0, 0);
            f.rotation.set(Math.PI / 2, 0, Math.PI / 2);
            this.ticks.RY.add(f)
        }
        var h = 
        this
          , r = !1
          , t = c
          , w = {
            type: "change"
        }
          , C = {
            type: "mouseDown"
        }
          , E = {
            type: "mouseUp",
            mode: t
        }
          , G = {
            type: "objectChange"
        }
          , B = new THREE.Raycaster
          , v = new THREE.Vector3
          , D = new THREE.Vector3
          , z = new THREE.Vector3
          , H = new THREE.Vector3
          , I = new THREE.Vector3
          , J = new THREE.Vector3
          , L = 1
          , F = new THREE.Matrix4
          , N = new THREE.Vector3
          , K = new THREE.Matrix4
          , M = new THREE.Vector3
          , S = new THREE.Quaternion
          , ba = new THREE.Vector3
          , P = new THREE.Vector3
          , aa = new THREE.Vector3
          , Z = new THREE.Quaternion
          , V = new THREE.Quaternion
          , ea = new THREE.Quaternion
          , X = new THREE.Quaternion
          , 
        R = new THREE.Quaternion
          , T = new THREE.Vector3
          , O = new THREE.Vector3
          , ca = new THREE.Matrix4
          , ia = new THREE.Matrix4
          , fa = new THREE.Vector3
          , W = new THREE.Vector3
          , ga = new THREE.Euler
          , da = new THREE.Matrix4
          , na = new THREE.Vector3;
        new THREE.Euler;
        this.attach = function(a) {
            h.object = a;
            this.gizmo[t].show();
            h.update();
            h.updateUnitVectors()
        }
        ;
        this.detach = function(a) {
            h.object = void 0;
            this.axis = null ;
            this.gizmo[t].hide()
        }
        ;
        this.setMode = function(a) {
            t = a ? a : t;
            "scale" == t && (h.space = "local");
            this.gizmo[t].show();
            this.update();
            h.dispatchEvent(w)
        }
        ;
        this.getPicker = function() {
            return h.gizmo[t].hemiPicker.children
        }
        ;
        this.setPosition = function(a) {
            this.object.position.copy(a);
            this.update()
        }
        ;
        this.setNormal = function(a) {
            S.setFromUnitVectors(this.normal, a);
            this.unitX.applyQuaternion(S);
            this.unitY.applyQuaternion(S);
            this.unitZ.applyQuaternion(S);
            this.normal.copy(a);
            this.object && this.object.quaternion.multiply(S);
            this.update()
        }
        ;
        this.setSnap = function(a, b) {
            h.snap = a;
            h.snapDelta = b
        }
        ;
        this.setSize = function(a) {
            h.size = a;
            this.update();
            h.dispatchEvent(w)
        }
        ;
        this.setSpace = 
        function(a) {
            h.space = a;
            this.update();
            h.dispatchEvent(w)
        }
        ;
        this.update = function(c) {
            if (void 0 !== h.object) {
                h.object.updateMatrixWorld();
                W.setFromMatrixPosition(h.object.matrixWorld);
                ga.setFromRotationMatrix(K.extractRotation(h.object.matrixWorld));
                a.updateMatrixWorld();
                na.setFromMatrixPosition(a.matrixWorld);
                this.position.copy(W);
                this.quaternion.setFromEuler(ga);
                this.normal.set(0, 0, 1);
                this.normal.applyEuler(ga);
                var d = W.distanceTo(na)
                  , d = a.isPerspective ? 2 * Math.tan(a.fov * Math.PI / 360) * d : d
                  , f = b.getBoundingClientRect();
                L = 100 * d / f.height;
                this.scale.set(L, L, L);
                c && this.gizmo[t].highlight(h.axis)
            }
        }
        ;
        this.updateUnitVectors = function() {
            this.unitX.set(1, 0, 0);
            this.unitY.set(0, 1, 0);
            this.unitZ.set(0, 0, 1);
            this.unitX.applyEuler(ga);
            this.unitY.applyEuler(ga);
            this.unitZ.applyEuler(ga)
        }
        ;
        this.showRotationGizmos = function(a) {
            for (var b = this.gizmo[t].handles.children, c = 0; c < b.length; c++) {
                var d = b[c];
                d.visible = !0;
                -1 !== d.name.search("R") && (d.visible = a)
            }
            this.useAllPickers = a
        }
        ;
        this.highlight = function() {
            this.gizmo[t].highlight(this.axis || "Z")
        }
        ;
        this.onPointerHover = function(a) {
            if (void 0 === h.object || !0 === r)
                return !1;
            a = d(a.pointers ? a.pointers[0] : a, h.useAllPickers ? h.gizmo[t].pickers.children : h.gizmo[t].subPickers.children);
            var b = null 
              , c = "";
            a && (b = a.object.name,
            c = -1 != b.search("R") ? "rotate" : "translate");
            h.axis !== b && (h.axis = b,
            h.gizmo[t].activeMode = c,
            h.update(!0),
            h.dispatchEvent(w));
            null  === h.axis && h.gizmo[t].show();
            return a ? !0 : !1
        }
        ;
        this.onPointerDown = function(b) {
            if (void 0 === h.object || !0 === r)
                return !1;
            var c = b.pointers ? b.pointers[0] : b;
            if ("touch" === b.pointerType) {
                b = 
                d(c, h.useAllPickers ? h.gizmo[t].pickers.children : h.gizmo[t].subPickers.children);
                var f = null 
                  , g = "";
                b && (f = b.object.name,
                g = -1 != f.search("R") ? "rotate" : "translate");
                h.axis !== f && (h.axis = f,
                h.gizmo[t].activeMode = g)
            }
            b = null ;
            if (0 === c.button || void 0 === c.button)
                if (b = d(c, h.useAllPickers ? h.gizmo[t].pickers.children : h.gizmo[t].subPickers.children))
                    if (h.dispatchEvent(C),
                    h.axis = b.object.name,
                    h.update(),
                    N.copy(a.position).sub(W).normalize(),
                    h.gizmo[t].setActivePlane(h.axis, N),
                    (c = d(c, [h.gizmo[t].activePlane])) && H.copy(c.point),
                    T.copy(h.object.position),
                    O.copy(h.object.scale),
                    ca.extractRotation(h.object.matrix),
                    da.extractRotation(h.object.matrixWorld),
                    h.object.parent ? (ia.extractRotation(h.object.parent.matrixWorld),
                    fa.setFromMatrixScale(K.getInverse(h.object.parent.matrixWorld))) : (ia.extractRotation(h.object.matrixWorld),
                    fa.setFromMatrixScale(K.getInverse(h.object.matrixWorld))),
                    "transrotate" === t && "rotate" === h.gizmo[t].activeMode) {
                        h.startLine.geometry.vertices[0].set(0, 0, 0).applyMatrix4(h.matrixWorld);
                        h.startLine.geometry.vertices[1].set(0, 
                        0, 1).applyMatrix4(h.matrixWorld);
                        h.startLine.geometry.verticesNeedUpdate = !0;
                        h.parent.add(h.startLine);
                        var k = h.object.geometry.getAttribute("position")
                          , c = (new THREE.Vector3).fromAttribute(k, 0).applyMatrix4(h.object.matrixWorld)
                          , f = (new THREE.Vector3).fromAttribute(k, 1).applyMatrix4(h.object.matrixWorld)
                          , g = (new THREE.Vector3).fromAttribute(k, 2).applyMatrix4(h.object.matrixWorld)
                          , k = (new THREE.Vector3).fromAttribute(k, 3).applyMatrix4(h.object.matrixWorld);
                        "RX" === h.axis ? (c.lerp(g, .5),
                        f.lerp(k, .5),
                        k = c.distanceTo(f),
                        h.centerLine.material.dashSize = k / 15,
                        h.centerLine.material.gapSize = k / 30,
                        h.centerLine.geometry.vertices[0].copy(c),
                        h.centerLine.geometry.vertices[1].copy(f)) : (c.lerp(f, .5),
                        g.lerp(k, .5),
                        k = c.distanceTo(g),
                        h.centerLine.material.dashSize = k / 15,
                        h.centerLine.material.gapSize = k / 30,
                        h.centerLine.geometry.vertices[0].copy(c),
                        h.centerLine.geometry.vertices[1].copy(g));
                        h.centerLine.geometry.computeLineDistances();
                        h.centerLine.geometry.verticesNeedUpdate = !0;
                        h.parent.add(h.centerLine);
                        h.ticks[h.axis].position.copy(h.position);
                        h.ticks[h.axis].quaternion.copy(h.quaternion);
                        h.ticks[h.axis].scale.copy(h.scale);
                        h.parent.add(h.ticks[h.axis])
                    }
            r = !0;
            return b ? !0 : !1
        }
        ;
        this.onPointerMove = function(a) {
            if (void 0 === h.object || null  === h.axis || !1 === r)
                return !1;
            (a = d(a.pointers ? a.pointers[0] : a, [h.gizmo[t].activePlane])) && z.copy(a.point);
            var b = h.gizmo[t].activeMode;
            if ("translate" == b) {
                if (z.sub(H),
                z.multiply(fa),
                "local" == h.space && (z.applyMatrix4(K.getInverse(da)),
                ba.copy(this.unitX),
                P.copy(this.unitY),
                aa.copy(this.unitZ),
                M.set(0, 0, 0),
                -1 != h.axis.search("X") && 
                (ba.multiplyScalar(z.dot(this.unitX)),
                M.add(ba)),
                -1 != h.axis.search("Y") && (P.multiplyScalar(z.dot(this.unitY)),
                M.add(P)),
                -1 != h.axis.search("Z") && (aa.multiplyScalar(z.dot(this.unitZ)),
                M.add(aa)),
                z.copy(M),
                z.applyMatrix4(ca),
                h.object.position.copy(T),
                h.object.position.add(z)),
                "world" == h.space || -1 != h.axis.search("XYZ"))
                    ba.copy(this.unitX),
                    P.copy(this.unitY),
                    aa.copy(this.unitZ),
                    M.set(0, 0, 0),
                    -1 != h.axis.search("X") && (ba.multiplyScalar(z.dot(this.unitX)),
                    M.add(ba)),
                    -1 != h.axis.search("Y") && (P.multiplyScalar(z.dot(this.unitY)),
                    M.add(P)),
                    -1 != h.axis.search("Z") && (aa.multiplyScalar(z.dot(this.unitZ)),
                    M.add(aa)),
                    z.copy(M),
                    z.applyMatrix4(K.getInverse(ia)),
                    h.object.position.copy(T),
                    h.object.position.add(z)
            } else if ("scale" == b)
                z.sub(H),
                z.multiply(fa),
                "local" == h.space && ("XYZ" == h.axis ? (L = 1 + z.y / 50,
                h.object.scale.x = O.x * L,
                h.object.scale.y = O.y * L,
                h.object.scale.z = O.z * L) : (z.applyMatrix4(K.getInverse(da)),
                "X" == h.axis && (h.object.scale.x = O.x * (1 + z.x / 50)),
                "Y" == h.axis && (h.object.scale.y = O.y * (1 + z.y / 50)),
                "Z" == h.axis && (h.object.scale.z = O.z * (1 + 
                z.z / 50))));
            else if ("rotate" == b) {
                z.sub(W);
                z.multiply(fa);
                M.copy(H).sub(W);
                M.multiply(fa);
                if ("RE" == h.axis) {
                    z.applyMatrix4(K.getInverse(F));
                    M.applyMatrix4(K.getInverse(F));
                    I.set(Math.atan2(z.z, z.y), Math.atan2(z.x, z.z), Math.atan2(z.y, z.x));
                    J.set(Math.atan2(M.z, M.y), Math.atan2(M.x, M.z), Math.atan2(M.y, M.x));
                    S.setFromRotationMatrix(K.getInverse(ia));
                    var c = I.z - J.z;
                    null  !== h.snap && (b = Math.round(c / h.snap) * h.snap,
                    Math.abs(b - c) < h.snapDelta && (c = b));
                    R.setFromAxisAngle(N, c);
                    Z.setFromRotationMatrix(da);
                    S.multiplyQuaternions(S, 
                    R);
                    S.multiplyQuaternions(S, Z);
                    h.object.quaternion.copy(S)
                } else if ("RXYZE" == h.axis) {
                    c = z.clone().cross(M).normalize();
                    S.setFromRotationMatrix(K.getInverse(ia));
                    var f = -z.clone().angleTo(M);
                    null  !== h.snap && (b = Math.round(f / h.snap) * h.snap,
                    Math.abs(b - f) < h.snapDelta && (f = b));
                    V.setFromAxisAngle(c, f);
                    Z.setFromRotationMatrix(da);
                    S.multiplyQuaternions(S, V);
                    S.multiplyQuaternions(S, Z);
                    h.object.quaternion.copy(S)
                } else if ("local" == h.space) {
                    z.applyMatrix4(K.getInverse(da));
                    M.applyMatrix4(K.getInverse(da));
                    var b = z.dot(this.unitX)
                      , 
                    c = z.dot(this.unitY)
                      , f = z.dot(this.unitZ)
                      , g = M.dot(this.unitX)
                      , k = M.dot(this.unitY)
                      , m = M.dot(this.unitZ);
                    I.set(Math.atan2(f, c), Math.atan2(b, f), Math.atan2(c, b));
                    J.set(Math.atan2(m, k), Math.atan2(g, m), Math.atan2(k, g));
                    f = I.x - J.x;
                    g = I.y - J.y;
                    c = I.z - J.z;
                    null  !== h.snap && (-1 != h.axis.search("X") && (b = Math.round(f / h.snap) * h.snap,
                    Math.abs(b - f) < h.snapDelta && (f = b)),
                    -1 != h.axis.search("Y") && (b = Math.round(g / h.snap) * h.snap,
                    Math.abs(b - g) < h.snapDelta && (g = b)),
                    -1 != h.axis.search("Z") && (b = Math.round(c / h.snap) * h.snap,
                    Math.abs(b - c) < 
                    h.snapDelta && (c = b)));
                    V.setFromAxisAngle(this.unitX, f);
                    ea.setFromAxisAngle(this.unitY, g);
                    X.setFromAxisAngle(this.unitZ, c);
                    Z.setFromRotationMatrix(ca);
                    "RX" == h.axis && Z.multiplyQuaternions(Z, V);
                    "RY" == h.axis && Z.multiplyQuaternions(Z, ea);
                    "RZ" == h.axis && Z.multiplyQuaternions(Z, X);
                    h.object.quaternion.copy(Z)
                } else
                    "world" == h.space && (b = z.dot(this.unitX),
                    c = z.dot(this.unitY),
                    f = z.dot(this.unitZ),
                    g = M.dot(this.unitX),
                    k = M.dot(this.unitY),
                    m = M.dot(this.unitZ),
                    I.set(Math.atan2(f, c), Math.atan2(b, f), Math.atan2(c, b)),
                    J.set(Math.atan2(m, 
                    k), Math.atan2(g, m), Math.atan2(k, g)),
                    S.setFromRotationMatrix(K.getInverse(ia)),
                    f = I.x - J.x,
                    g = I.y - J.y,
                    c = I.z - J.z,
                    null  !== h.snap && (-1 != h.axis.search("X") && (b = Math.round(f / h.snap) * h.snap,
                    Math.abs(b - f) < h.snapDelta && (f = b)),
                    -1 != h.axis.search("Y") && (b = Math.round(g / h.snap) * h.snap,
                    Math.abs(b - g) < h.snapDelta && (g = b)),
                    -1 != h.axis.search("Z") && (b = Math.round(c / h.snap) * h.snap,
                    Math.abs(b - c) < h.snapDelta && (c = b))),
                    V.setFromAxisAngle(this.unitX, f),
                    ea.setFromAxisAngle(this.unitY, g),
                    X.setFromAxisAngle(this.unitZ, c),
                    Z.setFromRotationMatrix(da),
                    "RX" == h.axis && S.multiplyQuaternions(S, V),
                    "RY" == h.axis && S.multiplyQuaternions(S, ea),
                    "RZ" == h.axis && S.multiplyQuaternions(S, X),
                    S.multiplyQuaternions(S, Z),
                    h.object.quaternion.copy(S));
                "transrotate" === t && (h.add(h.endLine),
                h.add(h.centerMark))
            }
            h.object.matrixAutoUpdate = !0;
            h.update(!0);
            h.dispatchEvent(w);
            h.dispatchEvent(G);
            return a ? !0 : !1
        }
        ;
        this.onPointerUp = function(a) {
            r && null  !== h.axis && (E.mode = t,
            h.dispatchEvent(E));
            r = !1;
            this.gizmo[t].show();
            this.updateUnitVectors();
            "transrotate" === t && "rotate" === this.gizmo[t].activeMode && 
            (this.remove(this.endLine),
            this.remove(this.centerMark),
            this.parent.remove(this.centerLine),
            this.parent.remove(this.startLine),
            this.parent.remove(this.ticks[this.axis]));
            return !1
        }
    }
    ;
    THREE.TransformControls.prototype = Object.create(THREE.Object3D.prototype)
}
(function(f, h) {
    var g = f.document;
    "undefined" === typeof f.alertify && (f.alertify = new function() {
        var d = {}, c = !1, a = [], b, k, l, n, m, q, r, t, w, C, E, G;
        G = function() {
            var a, b, c = !1, d = g.createElement("fakeelement"), f = {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "otransitionend",
                transition: "transitionend"
            };
            for (a in f)
                if (d.style[a] !== h) {
                    b = f[a];
                    c = !0;
                    break
                }
            return {
                type: b,
                supported: c
            }
        }
        ;
        b = function(a) {
            return g.getElementById(a)
        }
        ;
        d = {
            labels: {
                ok: "OK",
                cancel: "Cancel"
            },
            delay: 5E3,
            buttonReverse: !1,
            buttonFocus: "ok",
            transition: h,
            addListeners: function(a) {
                var b = "undefined" !== typeof l, c = "undefined" !== typeof k, d = "undefined" !== typeof E, f = "", h = this, q, r, t, w, C;
                q = function(b) {
                    "undefined" !== typeof b.preventDefault && b.preventDefault();
                    t(b);
                    "undefined" !== typeof E && (f = E.value);
                    "function" === typeof a && ("undefined" !== typeof E ? a(!0, f) : a(!0));
                    return !1
                }
                ;
                r = function(b) {
                    "undefined" !== typeof b.preventDefault && b.preventDefault();
                    t(b);
                    "function" === typeof a && a(!1);
                    return !1
                }
                ;
                t = function(a) {
                    h.hide();
                    h.unbind(g.body, "keyup", 
                    w);
                    h.unbind(n, "focus", C);
                    b && h.unbind(l, "click", q);
                    c && h.unbind(k, "click", r)
                }
                ;
                w = function(a) {
                    var b = a.keyCode;
                    (32 === b && !d || d && 13 === b) && q(a);
                    27 === b && c && r(a)
                }
                ;
                C = function(a) {
                    d ? E.focus() : !c || h.buttonReverse ? l.focus() : k.focus()
                }
                ;
                this.bind(n, "focus", C);
                this.bind(m, "focus", C);
                b && this.bind(l, "click", q);
                c && this.bind(k, "click", r);
                this.bind(g.body, "keyup", w);
                this.transition.supported || this.setFocus()
            },
            bind: function(a, b, c) {
                "function" === typeof a.addEventListener ? a.addEventListener(b, c, !1) : a.attachEvent && a.attachEvent("on" + 
                b, c)
            },
            handleErrors: function() {
                if ("undefined" !== typeof f.onerror) {
                    var a = this;
                    f.onerror = function(b, c, d) {
                        a.error("[" + b + " on line " + d + " of " + c + "]", 0)
                    }
                    ;
                    return !0
                }
                return !1
            },
            appendButtons: function(a, b) {
                return this.buttonReverse ? b + a : a + b
            },
            build: function(a) {
                var b = a.type
                  , c = a.message
                  , f = a.cssClass || "";
                a = '<div class="alertify-dialog"><a id="alertify-resetFocusBack" class="alertify-resetFocus" href="#">Reset Focus</a>';
                "none" === d.buttonFocus && (a += '<a href="#" id="alertify-noneFocus" class="alertify-hidden"></a>');
                "prompt" === b && (a += '<div id="alertify-form">');
                a += '<article class="alertify-inner">';
                a += '<p class="alertify-message">{{message}}</p>'.replace("{{message}}", c);
                "prompt" === b && (a += '<div class="alertify-text-wrapper"><input type="text" class="alertify-text" id="alertify-text"></div>');
                a += '<nav class="alertify-buttons">{{buttons}}</nav>';
                a += "</article>";
                "prompt" === b && (a += "</div>");
                a += '<a id="alertify-resetFocus" class="alertify-resetFocus" href="#">Reset Focus</a>';
                a += "</div>";
                switch (b) {
                case "confirm":
                    a = 
                    a.replace("{{buttons}}", this.appendButtons('<button class="alertify-button alertify-button-cancel" id="alertify-cancel">{{cancel}}</button>', '<button class="alertify-button alertify-button-ok" id="alertify-ok">{{ok}}</button>'));
                    a = a.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);
                    break;
                case "prompt":
                    a = a.replace("{{buttons}}", this.appendButtons('<button class="alertify-button alertify-button-cancel" id="alertify-cancel">{{cancel}}</button>', '<button type="submit" class="alertify-button alertify-button-ok" id="alertify-ok">{{ok}}</button>'));
                    a = a.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);
                    break;
                case "alert":
                    a = a.replace("{{buttons}}", '<button class="alertify-button alertify-button-ok" id="alertify-ok">{{ok}}</button>'),
                    a = a.replace("{{ok}}", this.labels.ok)
                }
                w.className = "alertify alertify-" + b + " " + f;
                t.className = "alertify-cover";
                return a
            },
            close: function(a, b) {
                var c = b && !isNaN(b) ? +b : this.delay, d = this, f, g;
                this.bind(a, "click", function() {
                    f(a)
                }
                );
                g = function(a) {
                    a.stopPropagation();
                    d.unbind(this, d.transition.type, g);
                    C.removeChild(this);
                    C.hasChildNodes() || (C.className += " alertify-logs-hidden")
                }
                ;
                f = function(a) {
                    "undefined" !== typeof a && a.parentNode === C && (d.transition.supported ? (d.bind(a, d.transition.type, g),
                    a.className += " alertify-log-hide") : (C.removeChild(a),
                    C.hasChildNodes() || (C.className += " alertify-logs-hidden")))
                }
                ;
                0 !== b && setTimeout(function() {
                    f(a)
                }
                , c)
            },
            dialog: function(b, d, f, h, k) {
                r = g.activeElement;
                var l = function() {
                    C && null  !== C.scrollTop && t && null  !== t.scrollTop || l()
                }
                ;
                if ("string" !== typeof b)
                    throw Error("message must be a string");
                if ("string" !== 
                typeof d)
                    throw Error("type must be a string");
                if ("undefined" !== typeof f && "function" !== typeof f)
                    throw Error("fn must be a function");
                this.init();
                l();
                a.push({
                    type: d,
                    message: b,
                    callback: f,
                    placeholder: h,
                    cssClass: k
                });
                c || this.setup();
                return this
            },
            extend: function(a) {
                if ("string" !== typeof a)
                    throw Error("extend method must have exactly one paramter");
                return function(b, c) {
                    this.log(b, a, c);
                    return this
                }
            },
            hide: function() {
                var b, d = this;
                a.splice(0, 1);
                0 < a.length ? this.setup(!0) : (c = !1,
                b = function(a) {
                    a.stopPropagation();
                    d.unbind(w, d.transition.type, b)
                }
                ,
                this.transition.supported ? (this.bind(w, this.transition.type, b),
                w.className = "alertify alertify-hide alertify-hidden") : w.className = "alertify alertify-hide alertify-hidden alertify-isHidden",
                t.className = "alertify-cover alertify-cover-hidden",
                r.focus())
            },
            init: function() {
                g.createElement("nav");
                g.createElement("article");
                g.createElement("section");
                null  == b("alertify-cover") && (t = g.createElement("div"),
                t.setAttribute("id", "alertify-cover"),
                t.className = "alertify-cover alertify-cover-hidden",
                g.body.appendChild(t));
                null  == b("alertify") && (c = !1,
                a = [],
                w = g.createElement("section"),
                w.setAttribute("id", "alertify"),
                w.setAttribute("style", "z-index : 999999999"),
                w.className = "alertify alertify-hidden",
                g.body.appendChild(w));
                null  == b("alertify-logs") && (C = g.createElement("section"),
                C.setAttribute("id", "alertify-logs"),
                C.className = "alertify-logs alertify-logs-hidden",
                g.body.appendChild(C));
                g.body.setAttribute("tabindex", "0");
                this.transition = G()
            },
            log: function(a, b, c) {
                var d = function() {
                    C && null  !== C.scrollTop || 
                    d()
                }
                ;
                this.init();
                d();
                C.className = "alertify-logs";
                this.notify(a, b, c);
                return this
            },
            notify: function(a, b, c) {
                var d = g.createElement("article");
                d.className = "alertify-log" + ("string" === typeof b && "" !== b ? " alertify-log-" + b : "");
                d.innerHTML = a;
                C.appendChild(d);
                setTimeout(function() {
                    d.className += " alertify-log-show"
                }
                , 50);
                this.close(d, c)
            },
            set: function(a) {
                var b;
                if ("object" !== typeof a && a instanceof Array)
                    throw Error("args must be an object");
                for (b in a)
                    a.hasOwnProperty(b) && (this[b] = a[b])
            },
            setFocus: function() {
                E ? (E.focus(),
                E.select()) : q.focus()
            },
            setup: function(f) {
                var g = a[0], r = this, t;
                c = !0;
                t = function(a) {
                    a.stopPropagation();
                    r.setFocus();
                    r.unbind(w, r.transition.type, t)
                }
                ;
                this.transition.supported && !f && this.bind(w, this.transition.type, t);
                w.innerHTML = this.build(g);
                n = b("alertify-resetFocus");
                m = b("alertify-resetFocusBack");
                l = b("alertify-ok") || h;
                k = b("alertify-cancel") || h;
                q = "cancel" === d.buttonFocus ? k : "none" === d.buttonFocus ? b("alertify-noneFocus") : l;
                E = b("alertify-text") || h;
                b("alertify-form");
                "string" === typeof g.placeholder && "" !== 
                g.placeholder && (E.value = g.placeholder);
                f && this.setFocus();
                this.addListeners(g.callback)
            },
            unbind: function(a, b, c) {
                "function" === typeof a.removeEventListener ? a.removeEventListener(b, c, !1) : a.detachEvent && a.detachEvent("on" + b, c)
            }
        };
        return {
            alert: function(a, b, c) {
                d.dialog(a, "alert", b, "", c);
                return this
            },
            confirm: function(a, b, c) {
                d.dialog(a, "confirm", b, "", c);
                return this
            },
            extend: d.extend,
            init: d.init,
            log: function(a, b, c) {
                d.log(a, b, c);
                return this
            },
            prompt: function(a, b, c, f) {
                d.dialog(a, "prompt", b, c, f);
                return this
            },
            success: function(a, 
            b) {
                d.log(a, "success", b);
                return this
            },
            error: function(a, b) {
                d.log(a, "error", b);
                return this
            },
            set: function(a) {
                d.set(a)
            },
            hide: function(a) {
                d.hide(a)
            },
            labels: d.labels,
            debug: d.handleErrors
        }
    }
    )
}
)(this);
TeratekNamespace("Teratek.Viewing");
TeratekNamespace("Teratek.Viewing.Private");
var auth = null , VIEWING_URL, ACM_SESSION_URL, OSS_URL, PROTEIN_ROOT = null , PRISM_ROOT = null , LOCALIZATION_REL_PATH = "", LMV_VIEWER_VERSION = "1.2.18", LMV_RESOURCE_VERSION = null , LMV_RESOURCE_ROOT = "";
function stderr() {
    ENABLE_TRACE && console.log.apply(console, arguments)
}
(function() {
    var f = Teratek.Viewing.Private;
    f.env = null ;
    f.logger = null ;
    f.refreshToken = null ;
    f.docItemId = null ;
    f.token = {
        getAccessToken: null ,
        tokenRefreshInterval: null 
    };
    f.memoryOptimizedLoading = !0;
    f.GPU_MEMORY_LIMIT = 268435456;
    f.GPU_OBJECT_LIMIT = 1E4;
    isAndroidDevice() || isIOSDevice() ? (f.FRAGS_PERSISTENT_COUNT = 2E3,
    f.FRAGS_PERSISTENT_MAX_COUNT = 15E4,
    f.GEOMS_COUNT_LIMIT = 8E3) : (f.FRAGS_PERSISTENT_COUNT = 1E4,
    f.FRAGS_PERSISTENT_MAX_COUNT = 8E5,
    f.GEOMS_COUNT_LIMIT = 3E5);
    f.onDemandLoading = !1;
    f.cullGeometryOnLoading = f.onDemandLoading;
    f.pageOutGeometryEnabled = f.onDemandLoading;
    f.PAGEOUT_SUCCESS = 0;
    f.PAGEOUT_FAIL = 1;
    f.PAGEOUT_NONE = 2;
    f.PAGEOUT_PERCENTAGE = .35;
    f.GEOMS_PAGEOUT_COUNT = f.GEOMS_COUNT_LIMIT * f.PAGEOUT_PERCENTAGE;
    f.assets = [];
    f.offline = !1;
    f.offlineResourcePrefix = null ;
    var h = {
        local: {
            LOGGING: "",
            RTC: ["", ""]
        }
    }
      , g = {
        local: ""
    }
      , d = {
        local: ""
    };
    f.EnvironmentConfigurations = 
    {
        Local: {
            VIEWING: "",
            ACM: "",
            OSS: "",
            LMV: h.local
        }
    };
    f.initializeEnvironmentVariable = 
    function(c) {
        f.env = "Local"
    }
    ;
    f.initializeServiceEndPoints = function(c) {
        var a = f.EnvironmentConfigurations[f.env];
        VIEWING_URL = a.VIEWING;
        ACM_SESSION_URL = a.ACM;
        OSS_URL = a.OSS;
        a = ["viewer3D.js", "viewer3D.min.js", 
        "firefly.js", "firefly.min.js"];
        c && c.hasOwnProperty("libraryName") && a.push(c.libraryName);
        var b, d;
        for (c = 0; c < a.length; c++) {
            d = (d = f.getScript(a[c])) ? d.src : "";
            var g = d.indexOf(a[c]);
            if (0 <= g) {
                b = d.substr(0, g);
                break
            }
        }
        LMV_RESOURCE_VERSION = "v" + LMV_VIEWER_VERSION;
        (a = f.getParameterByNameFromPath("v", d)) && a.length && a != LMV_RESOURCE_VERSION ? (console.warn("Version string mismatch between requested and actual version: " + a + " vs. " + LMV_RESOURCE_VERSION + ". Using " + a),
        LMV_RESOURCE_VERSION = a) : a && a.length || (LMV_RESOURCE_VERSION = 
        null ,
        console.info("No viewer version specified, will implicitly use " + LMV_VIEWER_VERSION));
        LMV_RESOURCE_ROOT = b || LMV_RESOURCE_ROOT
    }
    ;
    f.refreshCookie = function(c, a, b) {
        // load svf here
		a();
/*         var d = new XMLHttpRequest;
        d.onload = a;
        d.onerror = b;
        d.ontimeout = b;
        0 === f.env.indexOf("Teratek") ? (a = VIEWING_URL.substring(0, VIEWING_URL.indexOf("/viewingservice")),
        d.open("POST", a + "/utility/v1/settoken", !0),
        d.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
        d.withCredentials = !0,
        d.send("access-token=" + c),
        _isIE11 && (f.accessToken = 
        c)) : (c = {
            oauth: {
                token: c
            }
        },
        d.open("POST", VIEWING_URL + "/token", !0),
        d.setRequestHeader("Content-Type", "application/json"),
        d.withCredentials = !0,
        d.send(JSON.stringify(c)))
 */    }
    ;
    f.initializeAuth = function(c, a) {
        var b = a ? a.shouldInitializeAuth : null ;
        b || (b = f.getParameterByName("auth"));
        if ("Local" == f.env && !b)
            return setTimeout(c, 0),
            auth = !1;
        auth = !0;
        var d;
        if (a && a.accessToken)
            d = a.accessToken,
            f.refreshCookie(d, c);
        else if (a && a.getAccessToken) {
            var g = function(b, h) {
                d = b;
                f.refreshCookie(d, f.token.tokenRefreshInterval ? null  : c);
                var q = h - 60;
                0 >= q && (q = h);
                f.token.tokenRefreshInterval = 1E3 * q;
                setTimeout(function() {
                    a.getAccessToken(g)
                }
                , f.token.tokenRefreshInterval)
            }
            ;
            f.token.getAccessToken = a.getAccessToken;
            d = a.getAccessToken(g);
            "string" == typeof d && d && f.refreshCookie(d, c)
        } else
            d = f.getParameterByName("accessToken"),
            d || (d = "QYNrnn1T44Jy3wWMKJaT6RHmMgg=",
            console.log("Warning : no access token is provided. Use built in token : " + d)),
            f.refreshCookie(d, c);
        return auth
    }
    ;
    f.refreshTokenAndCookie = function(c, a) {
        var b = null ;
        f.refreshToken && (b = f.refreshToken());
        b ? f.refreshCookie(b, c, a) : a && a(null )
    }
    ;
    f.initializeLogger = function(c) {
        f.logger = new f.Logger({
            endpoint: f.EnvironmentConfigurations[f.env].LMV.LOGGING,
            eventCallback: c ? c.eventCallback : void 0
        })
    }
    ;
    f.initializeProtein = function() {
        if ((!ENABLE_DEBUG || "Local" != f.env || auth) && !f.offline) {
			PROTEIN_ROOT = "";
			PRISM_ROOT = "";
        }
    }
    ;
    f.getAuthObject = function() {
        return auth
    }
    ;
    f.getParameterByName = function(c) {
        return f.getParameterByNameFromPath(c, window.location.href)
    }
    ;
    f.getParameterByNameFromPath = 
    function(c, a) {
        c = c.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        var b = (new RegExp("[\\?&]" + c + "=([^&#]*)")).exec(a);
        return null  == b ? "" : decodeURIComponent(b[1].replace(/\+/g, " "))
    }
    ;
    f.getDemoDocumentURN = function() {
        var c;
        switch (f.env) {
        case "Development":
            c = "urn:dXJuOmFkc2suYTM2MGJldGFkZXY6ZnMuZmlsZTplbnRlcnByaXNlLmxtdnRlc3QuRFM1YTczMFFUYmYwMDIyZDA3NTFhYmE5MjZlZDZkMjJlZDY0P3ZlcnNpb249MQ==";
            break;
        case "Staging":
            c = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbicvTU0zNTAwQXNzZW1ibHkuZHdm";
            break;
        case "Production":
            c = "FIXME";
            break;
        default:
            c = "https://lmv.rocks/viewer/data/gears/output/bubble.json"
        }
        return c
    }
    ;
    f.setLanguage = function(c, a) {
        var b = {
            lng: c,
            resGetPath: "res/locales/__lng__/__ns__.json",
            ns: {
                namespaces: ["allstrings"],
                defaultNs: "allstrings"
            },
            fallbackLng: "en",
            debug: !1
        };
        LOCALIZATION_REL_PATH = "res/locales/" + c + "/";
        Teratek.Viewing.i18n.init(b, function(b) {
            Teratek.Viewing.i18n.localize();
            a && a()
        }
        )
    }
    ;
    f.initializeLocalization = function(c) {
        c = c && c.language || navigator.language;
        var a = c.split("-");
        c = 1 < a.length ? a[0].toLowerCase() + "-" + a[1].toUpperCase() : a[0].toLowerCase();
        var b = "cs de en es fr it ja ko pl pt-BR ru tr zh-HANS zh-HANT".split(" ");
        -1 !== b.indexOf(c) || -1 < c.indexOf("zh-CN") || -1 < c.indexOf("zh-TW") || 1 < a.length && b.indexOf(a[0]);
        f.setLanguage("zh-HANS")
    }
    ;
    f.initializeUserInfo = function(c) {
        c && c.userInfo && (f.setUserName(c.userInfo.name),
        c.comment2Token && (f.comment2Token = c.comment2Token))
    }
    ;
    f.getScript = function(c) {
        c = c.toLowerCase();
        var a = document.getElementsByTagName("SCRIPT");
        if (a && 0 < a.length)
            for (var b = 
            0; b < a.length; ++b)
                if (a[b].src && -1 !== a[b].src.toLowerCase().indexOf(c))
                    return a[b];
        return null 
    }
    ;
    f.getResourceUrl = function(c) {
        var a = LMV_RESOURCE_VERSION;
        return LMV_RESOURCE_ROOT + c + (a ? "?v=" + a : "")
    }
    ;
    f.loadDependency = function(c, a, b) {
        "undefined" == typeof window[c] ? (c = document.createElement("SCRIPT"),
        c.src = f.getResourceUrl(a),
        document.head.appendChild(c),
        b && (c.onload = b)) : b && b()
    }
    ;
    Teratek.Viewing.Initializer = function(c, a) {
        f.WEBGL_HELP_LINK = c ? c.webGLHelpLink : null ;
        f.initializeEnvironmentVariable(c);
        f.initializeServiceEndPoints(c);
        f.initializeProtein();
        f.initWorkerScript();
        f.loadDependency("THREE", "three.min.js", function() {
            THREE.warn = function() {
                stderr.apply(stderr, arguments)
            }
            ;
            init_three_dds_loader();
            f.initializeLogger(c);
            f.initializeAuth(a, c);
            f.initializeLocalization(c);
            f.initializeUserInfo(c)
        }
        )
    }
}
)();
